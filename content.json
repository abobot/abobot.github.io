{"meta":{"title":"阿波bot Blog","subtitle":"record life","description":"认真生活，记录自己","author":"阿波bot","url":"http://19999997.xyz","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2023-09-26T09:45:16.000Z","updated":"2023-09-26T09:45:47.133Z","comments":false,"path":"/404.html","permalink":"http://19999997.xyz/404.html","excerpt":"","text":""},{"title":"books","date":"2023-09-26T09:32:29.000Z","updated":"2023-09-26T09:39:02.452Z","comments":true,"path":"books/index.html","permalink":"http://19999997.xyz/books/index.html","excerpt":"","text":""},{"title":"about","date":"2023-09-26T09:32:45.000Z","updated":"2023-09-26T09:38:50.801Z","comments":true,"path":"about/index.html","permalink":"http://19999997.xyz/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2023-09-26T09:17:40.000Z","updated":"2023-09-26T09:38:01.171Z","comments":true,"path":"categories/index.html","permalink":"http://19999997.xyz/categories/index.html","excerpt":"","text":""},{"title":"gallery","date":"2023-09-26T09:31:32.000Z","updated":"2023-09-26T09:39:15.755Z","comments":true,"path":"gallery/index.html","permalink":"http://19999997.xyz/gallery/index.html","excerpt":"","text":""},{"title":"links","date":"2023-09-26T09:32:37.000Z","updated":"2023-09-27T12:53:11.070Z","comments":true,"path":"links/index.html","permalink":"http://19999997.xyz/links/index.html","excerpt":"","text":""},{"title":"repository","date":"2023-09-26T09:31:01.000Z","updated":"2023-09-26T09:39:31.314Z","comments":true,"path":"repository/index.html","permalink":"http://19999997.xyz/repository/index.html","excerpt":"","text":""},{"title":"tags","date":"2023-09-26T09:25:39.000Z","updated":"2023-09-26T09:39:33.282Z","comments":true,"path":"tags/index.html","permalink":"http://19999997.xyz/tags/index.html","excerpt":"","text":""},{"title":"","date":"2023-10-14T08:36:18.919Z","updated":"2023-10-14T08:36:18.919Z","comments":true,"path":"js/modelJS/001.js","permalink":"http://19999997.xyz/js/modelJS/001.js","excerpt":"","text":"import * as THREE from \"three\" import { OrbitControls } from 'three/addons/controls/OrbitControls.js'; import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js'; import { OBJLoader } from 'three/addons/loaders/OBJLoader.js'; import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js' // https://codesandbox.io/s/three-jsjia-zai-3dmo-xing-forked-v6yjgy?file=/src/Scene.js const path = \"../js/models/001/\" const DecoderPath = '../js/three/jsm/libs/draco/' let renderer, scene, camera, controls, material; // let width = window.innerWidth; // let height = window.innerHeight; let width = 800; let height = 500; init(); function init(){ setScene(); setCamera(); setRender(); setModel(); setLight() // setMaterial(); setControls(); animate(); } function setScene(){ scene = new THREE.Scene() scene.background = new THREE.Color(0xffffff) } function setCamera(){ camera = new THREE.PerspectiveCamera( 50, width / height, 0.1, 10000 ) camera.position.z = 8 scene.add(camera) } function setRender(){ renderer = new THREE.WebGLRenderer( { antialias: true } ); renderer.setPixelRatio( window.devicePixelRatio ); renderer.setSize( width, height ); document.getElementById(\"webgl\").appendChild( renderer.domElement ); } function setModel() { const gltfLoader = new GLTFLoader() const objLoader = new OBJLoader(); var dracoLoader = new DRACOLoader(); dracoLoader.setDecoderPath( DecoderPath ); dracoLoader.setDecoderConfig({type: 'js'}); gltfLoader.setDRACOLoader(dracoLoader); let flag = 0; if(flag){ objLoader .setPath(path) .load(\"001.obj\", (obj) => { const s = 0.01 obj.scale.set(s, s, s) scene.add(obj) }) }else{ gltfLoader .setPath(path) .load(\"001.gltf\", (gltf) => { const s = 50 gltf.scene.scale.set(s, s, s) scene.add(gltf.scene) console.log(\"加载完成\"); }) } } function setControls() { controls = new OrbitControls(camera, renderer.domElement) controls.autoRotate = true } function setMaterial(){ } function animate(){ renderer.render(scene, camera) window.requestAnimationFrame(animate) // console.log(camera.position) } function setLight() { let light = 1; switch(light){ case 0: const spotLight = new THREE.SpotLight() spotLight.position.set(10, 10, 10) spotLight.intensity = 1000 scene.add(spotLight) break; case 1: const ambientLight = new THREE.AmbientLight( 0x404040 ); // soft white light ambientLight.intensity = 150; scene.add( ambientLight ); break; case 2: const hemiLight = new THREE.HemisphereLight( 0xffffff, 0x8d8d8d, 3 ); hemiLight.position.set( 0, 20, 0 ); hemiLight.intensity = 10; scene.add( hemiLight ); break; } }"},{"title":"","date":"2023-10-12T14:08:40.246Z","updated":"2023-10-12T14:08:40.246Z","comments":true,"path":"js/three/jsm/controls/DragControls.js","permalink":"http://19999997.xyz/js/three/jsm/controls/DragControls.js","excerpt":"","text":"import { EventDispatcher, Matrix4, Plane, Raycaster, Vector2, Vector3 } from 'three'; const _plane = new Plane(); const _raycaster = new Raycaster(); const _pointer = new Vector2(); const _offset = new Vector3(); const _intersection = new Vector3(); const _worldPosition = new Vector3(); const _inverseMatrix = new Matrix4(); class DragControls extends EventDispatcher { constructor( _objects, _camera, _domElement ) { super(); _domElement.style.touchAction = 'none'; // disable touch scroll let _selected = null, _hovered = null; const _intersections = []; // const scope = this; function activate() { _domElement.addEventListener( 'pointermove', onPointerMove ); _domElement.addEventListener( 'pointerdown', onPointerDown ); _domElement.addEventListener( 'pointerup', onPointerCancel ); _domElement.addEventListener( 'pointerleave', onPointerCancel ); } function deactivate() { _domElement.removeEventListener( 'pointermove', onPointerMove ); _domElement.removeEventListener( 'pointerdown', onPointerDown ); _domElement.removeEventListener( 'pointerup', onPointerCancel ); _domElement.removeEventListener( 'pointerleave', onPointerCancel ); _domElement.style.cursor = ''; } function dispose() { deactivate(); } function getObjects() { return _objects; } function getRaycaster() { return _raycaster; } function onPointerMove( event ) { if ( scope.enabled === false ) return; updatePointer( event ); _raycaster.setFromCamera( _pointer, _camera ); if ( _selected ) { if ( _raycaster.ray.intersectPlane( _plane, _intersection ) ) { _selected.position.copy( _intersection.sub( _offset ).applyMatrix4( _inverseMatrix ) ); } scope.dispatchEvent( { type: 'drag', object: _selected } ); return; } // hover support if ( event.pointerType === 'mouse' || event.pointerType === 'pen' ) { _intersections.length = 0; _raycaster.setFromCamera( _pointer, _camera ); _raycaster.intersectObjects( _objects, scope.recursive, _intersections ); if ( _intersections.length > 0 ) { const object = _intersections[ 0 ].object; _plane.setFromNormalAndCoplanarPoint( _camera.getWorldDirection( _plane.normal ), _worldPosition.setFromMatrixPosition( object.matrixWorld ) ); if ( _hovered !== object && _hovered !== null ) { scope.dispatchEvent( { type: 'hoveroff', object: _hovered } ); _domElement.style.cursor = 'auto'; _hovered = null; } if ( _hovered !== object ) { scope.dispatchEvent( { type: 'hoveron', object: object } ); _domElement.style.cursor = 'pointer'; _hovered = object; } } else { if ( _hovered !== null ) { scope.dispatchEvent( { type: 'hoveroff', object: _hovered } ); _domElement.style.cursor = 'auto'; _hovered = null; } } } } function onPointerDown( event ) { if ( scope.enabled === false ) return; updatePointer( event ); _intersections.length = 0; _raycaster.setFromCamera( _pointer, _camera ); _raycaster.intersectObjects( _objects, scope.recursive, _intersections ); if ( _intersections.length > 0 ) { _selected = ( scope.transformGroup === true ) ? _objects[ 0 ] : _intersections[ 0 ].object; _plane.setFromNormalAndCoplanarPoint( _camera.getWorldDirection( _plane.normal ), _worldPosition.setFromMatrixPosition( _selected.matrixWorld ) ); if ( _raycaster.ray.intersectPlane( _plane, _intersection ) ) { _inverseMatrix.copy( _selected.parent.matrixWorld ).invert(); _offset.copy( _intersection ).sub( _worldPosition.setFromMatrixPosition( _selected.matrixWorld ) ); } _domElement.style.cursor = 'move'; scope.dispatchEvent( { type: 'dragstart', object: _selected } ); } } function onPointerCancel() { if ( scope.enabled === false ) return; if ( _selected ) { scope.dispatchEvent( { type: 'dragend', object: _selected } ); _selected = null; } _domElement.style.cursor = _hovered ? 'pointer' : 'auto'; } function updatePointer( event ) { const rect = _domElement.getBoundingClientRect(); _pointer.x = ( event.clientX - rect.left ) / rect.width * 2 - 1; _pointer.y = - ( event.clientY - rect.top ) / rect.height * 2 + 1; } activate(); // API this.enabled = true; this.recursive = true; this.transformGroup = false; this.activate = activate; this.deactivate = deactivate; this.dispose = dispose; this.getObjects = getObjects; this.getRaycaster = getRaycaster; } } export { DragControls };"},{"title":"","date":"2023-10-12T14:08:40.251Z","updated":"2023-10-12T14:08:40.251Z","comments":true,"path":"js/three/jsm/controls/FlyControls.js","permalink":"http://19999997.xyz/js/three/jsm/controls/FlyControls.js","excerpt":"","text":"import { EventDispatcher, Quaternion, Vector3 } from 'three'; const _changeEvent = { type: 'change' }; class FlyControls extends EventDispatcher { constructor( object, domElement ) { super(); this.object = object; this.domElement = domElement; // API // Set to false to disable this control this.enabled = true; this.movementSpeed = 1.0; this.rollSpeed = 0.005; this.dragToLook = false; this.autoForward = false; // disable default target object behavior // internals const scope = this; const EPS = 0.000001; const lastQuaternion = new Quaternion(); const lastPosition = new Vector3(); this.tmpQuaternion = new Quaternion(); this.status = 0; this.moveState = { up: 0, down: 0, left: 0, right: 0, forward: 0, back: 0, pitchUp: 0, pitchDown: 0, yawLeft: 0, yawRight: 0, rollLeft: 0, rollRight: 0 }; this.moveVector = new Vector3( 0, 0, 0 ); this.rotationVector = new Vector3( 0, 0, 0 ); this.keydown = function ( event ) { if ( event.altKey || this.enabled === false ) { return; } switch ( event.code ) { case 'ShiftLeft': case 'ShiftRight': this.movementSpeedMultiplier = .1; break; case 'KeyW': this.moveState.forward = 1; break; case 'KeyS': this.moveState.back = 1; break; case 'KeyA': this.moveState.left = 1; break; case 'KeyD': this.moveState.right = 1; break; case 'KeyR': this.moveState.up = 1; break; case 'KeyF': this.moveState.down = 1; break; case 'ArrowUp': this.moveState.pitchUp = 1; break; case 'ArrowDown': this.moveState.pitchDown = 1; break; case 'ArrowLeft': this.moveState.yawLeft = 1; break; case 'ArrowRight': this.moveState.yawRight = 1; break; case 'KeyQ': this.moveState.rollLeft = 1; break; case 'KeyE': this.moveState.rollRight = 1; break; } this.updateMovementVector(); this.updateRotationVector(); }; this.keyup = function ( event ) { if ( this.enabled === false ) return; switch ( event.code ) { case 'ShiftLeft': case 'ShiftRight': this.movementSpeedMultiplier = 1; break; case 'KeyW': this.moveState.forward = 0; break; case 'KeyS': this.moveState.back = 0; break; case 'KeyA': this.moveState.left = 0; break; case 'KeyD': this.moveState.right = 0; break; case 'KeyR': this.moveState.up = 0; break; case 'KeyF': this.moveState.down = 0; break; case 'ArrowUp': this.moveState.pitchUp = 0; break; case 'ArrowDown': this.moveState.pitchDown = 0; break; case 'ArrowLeft': this.moveState.yawLeft = 0; break; case 'ArrowRight': this.moveState.yawRight = 0; break; case 'KeyQ': this.moveState.rollLeft = 0; break; case 'KeyE': this.moveState.rollRight = 0; break; } this.updateMovementVector(); this.updateRotationVector(); }; this.pointerdown = function ( event ) { if ( this.enabled === false ) return; if ( this.dragToLook ) { this.status ++; } else { switch ( event.button ) { case 0: this.moveState.forward = 1; break; case 2: this.moveState.back = 1; break; } this.updateMovementVector(); } }; this.pointermove = function ( event ) { if ( this.enabled === false ) return; if ( ! this.dragToLook || this.status > 0 ) { const container = this.getContainerDimensions(); const halfWidth = container.size[ 0 ] / 2; const halfHeight = container.size[ 1 ] / 2; this.moveState.yawLeft = - ( ( event.pageX - container.offset[ 0 ] ) - halfWidth ) / halfWidth; this.moveState.pitchDown = ( ( event.pageY - container.offset[ 1 ] ) - halfHeight ) / halfHeight; this.updateRotationVector(); } }; this.pointerup = function ( event ) { if ( this.enabled === false ) return; if ( this.dragToLook ) { this.status --; this.moveState.yawLeft = this.moveState.pitchDown = 0; } else { switch ( event.button ) { case 0: this.moveState.forward = 0; break; case 2: this.moveState.back = 0; break; } this.updateMovementVector(); } this.updateRotationVector(); }; this.contextMenu = function ( event ) { if ( this.enabled === false ) return; event.preventDefault(); }; this.update = function ( delta ) { if ( this.enabled === false ) return; const moveMult = delta * scope.movementSpeed; const rotMult = delta * scope.rollSpeed; scope.object.translateX( scope.moveVector.x * moveMult ); scope.object.translateY( scope.moveVector.y * moveMult ); scope.object.translateZ( scope.moveVector.z * moveMult ); scope.tmpQuaternion.set( scope.rotationVector.x * rotMult, scope.rotationVector.y * rotMult, scope.rotationVector.z * rotMult, 1 ).normalize(); scope.object.quaternion.multiply( scope.tmpQuaternion ); if ( lastPosition.distanceToSquared( scope.object.position ) > EPS || 8 * ( 1 - lastQuaternion.dot( scope.object.quaternion ) ) > EPS ) { scope.dispatchEvent( _changeEvent ); lastQuaternion.copy( scope.object.quaternion ); lastPosition.copy( scope.object.position ); } }; this.updateMovementVector = function () { const forward = ( this.moveState.forward || ( this.autoForward && ! this.moveState.back ) ) ? 1 : 0; this.moveVector.x = ( - this.moveState.left + this.moveState.right ); this.moveVector.y = ( - this.moveState.down + this.moveState.up ); this.moveVector.z = ( - forward + this.moveState.back ); //console.log( 'move:', [ this.moveVector.x, this.moveVector.y, this.moveVector.z ] ); }; this.updateRotationVector = function () { this.rotationVector.x = ( - this.moveState.pitchDown + this.moveState.pitchUp ); this.rotationVector.y = ( - this.moveState.yawRight + this.moveState.yawLeft ); this.rotationVector.z = ( - this.moveState.rollRight + this.moveState.rollLeft ); //console.log( 'rotate:', [ this.rotationVector.x, this.rotationVector.y, this.rotationVector.z ] ); }; this.getContainerDimensions = function () { if ( this.domElement != document ) { return { size: [ this.domElement.offsetWidth, this.domElement.offsetHeight ], offset: [ this.domElement.offsetLeft, this.domElement.offsetTop ] }; } else { return { size: [ window.innerWidth, window.innerHeight ], offset: [ 0, 0 ] }; } }; this.dispose = function () { this.domElement.removeEventListener( 'contextmenu', _contextmenu ); this.domElement.removeEventListener( 'pointerdown', _pointerdown ); this.domElement.removeEventListener( 'pointermove', _pointermove ); this.domElement.removeEventListener( 'pointerup', _pointerup ); window.removeEventListener( 'keydown', _keydown ); window.removeEventListener( 'keyup', _keyup ); }; const _contextmenu = this.contextMenu.bind( this ); const _pointermove = this.pointermove.bind( this ); const _pointerdown = this.pointerdown.bind( this ); const _pointerup = this.pointerup.bind( this ); const _keydown = this.keydown.bind( this ); const _keyup = this.keyup.bind( this ); this.domElement.addEventListener( 'contextmenu', _contextmenu ); this.domElement.addEventListener( 'pointerdown', _pointerdown ); this.domElement.addEventListener( 'pointermove', _pointermove ); this.domElement.addEventListener( 'pointerup', _pointerup ); window.addEventListener( 'keydown', _keydown ); window.addEventListener( 'keyup', _keyup ); this.updateMovementVector(); this.updateRotationVector(); } } export { FlyControls };"},{"title":"","date":"2023-10-12T14:08:40.244Z","updated":"2023-10-12T14:08:40.244Z","comments":true,"path":"js/three/jsm/controls/ArcballControls.js","permalink":"http://19999997.xyz/js/three/jsm/controls/ArcballControls.js","excerpt":"","text":"import { GridHelper, EllipseCurve, BufferGeometry, Line, LineBasicMaterial, Raycaster, Group, Box3, Sphere, Quaternion, Vector2, Vector3, Matrix4, MathUtils, EventDispatcher } from 'three'; //trackball state const STATE = { IDLE: Symbol(), ROTATE: Symbol(), PAN: Symbol(), SCALE: Symbol(), FOV: Symbol(), FOCUS: Symbol(), ZROTATE: Symbol(), TOUCH_MULTI: Symbol(), ANIMATION_FOCUS: Symbol(), ANIMATION_ROTATE: Symbol() }; const INPUT = { NONE: Symbol(), ONE_FINGER: Symbol(), ONE_FINGER_SWITCHED: Symbol(), TWO_FINGER: Symbol(), MULT_FINGER: Symbol(), CURSOR: Symbol() }; //cursor center coordinates const _center = { x: 0, y: 0 }; //transformation matrices for gizmos and camera const _transformation = { camera: new Matrix4(), gizmos: new Matrix4() }; //events const _changeEvent = { type: 'change' }; const _startEvent = { type: 'start' }; const _endEvent = { type: 'end' }; const _raycaster = new Raycaster(); const _offset = new Vector3(); const _gizmoMatrixStateTemp = new Matrix4(); const _cameraMatrixStateTemp = new Matrix4(); const _scalePointTemp = new Vector3(); /** * * @param {Camera} camera Virtual camera used in the scene * @param {HTMLElement} domElement Renderer's dom element * @param {Scene} scene The scene to be rendered */ class ArcballControls extends EventDispatcher { constructor( camera, domElement, scene = null ) { super(); this.camera = null; this.domElement = domElement; this.scene = scene; this.target = new Vector3(); this._currentTarget = new Vector3(); this.radiusFactor = 0.67; this.mouseActions = []; this._mouseOp = null; //global vectors and matrices that are used in some operations to avoid creating new objects every time (e.g. every time cursor moves) this._v2_1 = new Vector2(); this._v3_1 = new Vector3(); this._v3_2 = new Vector3(); this._m4_1 = new Matrix4(); this._m4_2 = new Matrix4(); this._quat = new Quaternion(); //transformation matrices this._translationMatrix = new Matrix4(); //matrix for translation operation this._rotationMatrix = new Matrix4(); //matrix for rotation operation this._scaleMatrix = new Matrix4(); //matrix for scaling operation this._rotationAxis = new Vector3(); //axis for rotate operation //camera state this._cameraMatrixState = new Matrix4(); this._cameraProjectionState = new Matrix4(); this._fovState = 1; this._upState = new Vector3(); this._zoomState = 1; this._nearPos = 0; this._farPos = 0; this._gizmoMatrixState = new Matrix4(); //initial values this._up0 = new Vector3(); this._zoom0 = 1; this._fov0 = 0; this._initialNear = 0; this._nearPos0 = 0; this._initialFar = 0; this._farPos0 = 0; this._cameraMatrixState0 = new Matrix4(); this._gizmoMatrixState0 = new Matrix4(); //pointers array this._button = - 1; this._touchStart = []; this._touchCurrent = []; this._input = INPUT.NONE; //two fingers touch interaction this._switchSensibility = 32; //minimum movement to be performed to fire single pan start after the second finger has been released this._startFingerDistance = 0; //distance between two fingers this._currentFingerDistance = 0; this._startFingerRotation = 0; //amount of rotation performed with two fingers this._currentFingerRotation = 0; //double tap this._devPxRatio = 0; this._downValid = true; this._nclicks = 0; this._downEvents = []; this._downStart = 0; //pointerDown time this._clickStart = 0; //first click time this._maxDownTime = 250; this._maxInterval = 300; this._posThreshold = 24; this._movementThreshold = 24; //cursor positions this._currentCursorPosition = new Vector3(); this._startCursorPosition = new Vector3(); //grid this._grid = null; //grid to be visualized during pan operation this._gridPosition = new Vector3(); //gizmos this._gizmos = new Group(); this._curvePts = 128; //animations this._timeStart = - 1; //initial time this._animationId = - 1; //focus animation this.focusAnimationTime = 500; //duration of focus animation in ms //rotate animation this._timePrev = 0; //time at which previous rotate operation has been detected this._timeCurrent = 0; //time at which current rotate operation has been detected this._anglePrev = 0; //angle of previous rotation this._angleCurrent = 0; //angle of current rotation this._cursorPosPrev = new Vector3(); //cursor position when previous rotate operation has been detected this._cursorPosCurr = new Vector3();//cursor position when current rotate operation has been detected this._wPrev = 0; //angular velocity of the previous rotate operation this._wCurr = 0; //angular velocity of the current rotate operation //parameters this.adjustNearFar = false; this.scaleFactor = 1.1; //zoom/distance multiplier this.dampingFactor = 25; this.wMax = 20; //maximum angular velocity allowed this.enableAnimations = true; //if animations should be performed this.enableGrid = false; //if grid should be showed during pan operation this.cursorZoom = false; //if wheel zoom should be cursor centered this.minFov = 5; this.maxFov = 90; this.rotateSpeed = 1; this.enabled = true; this.enablePan = true; this.enableRotate = true; this.enableZoom = true; this.enableGizmos = true; this.minDistance = 0; this.maxDistance = Infinity; this.minZoom = 0; this.maxZoom = Infinity; //trackball parameters this._tbRadius = 1; //FSA this._state = STATE.IDLE; this.setCamera( camera ); if ( this.scene != null ) { this.scene.add( this._gizmos ); } this.domElement.style.touchAction = 'none'; this._devPxRatio = window.devicePixelRatio; this.initializeMouseActions(); this._onContextMenu = onContextMenu.bind( this ); this._onWheel = onWheel.bind( this ); this._onPointerUp = onPointerUp.bind( this ); this._onPointerMove = onPointerMove.bind( this ); this._onPointerDown = onPointerDown.bind( this ); this._onPointerCancel = onPointerCancel.bind( this ); this._onWindowResize = onWindowResize.bind( this ); this.domElement.addEventListener( 'contextmenu', this._onContextMenu ); this.domElement.addEventListener( 'wheel', this._onWheel ); this.domElement.addEventListener( 'pointerdown', this._onPointerDown ); this.domElement.addEventListener( 'pointercancel', this._onPointerCancel ); window.addEventListener( 'resize', this._onWindowResize ); } onSinglePanStart( event, operation ) { if ( this.enabled ) { this.dispatchEvent( _startEvent ); this.setCenter( event.clientX, event.clientY ); switch ( operation ) { case 'PAN': if ( ! this.enablePan ) { return; } if ( this._animationId != - 1 ) { cancelAnimationFrame( this._animationId ); this._animationId = - 1; this._timeStart = - 1; this.activateGizmos( false ); this.dispatchEvent( _changeEvent ); } this.updateTbState( STATE.PAN, true ); this._startCursorPosition.copy( this.unprojectOnTbPlane( this.camera, _center.x, _center.y, this.domElement ) ); if ( this.enableGrid ) { this.drawGrid(); this.dispatchEvent( _changeEvent ); } break; case 'ROTATE': if ( ! this.enableRotate ) { return; } if ( this._animationId != - 1 ) { cancelAnimationFrame( this._animationId ); this._animationId = - 1; this._timeStart = - 1; } this.updateTbState( STATE.ROTATE, true ); this._startCursorPosition.copy( this.unprojectOnTbSurface( this.camera, _center.x, _center.y, this.domElement, this._tbRadius ) ); this.activateGizmos( true ); if ( this.enableAnimations ) { this._timePrev = this._timeCurrent = performance.now(); this._angleCurrent = this._anglePrev = 0; this._cursorPosPrev.copy( this._startCursorPosition ); this._cursorPosCurr.copy( this._cursorPosPrev ); this._wCurr = 0; this._wPrev = this._wCurr; } this.dispatchEvent( _changeEvent ); break; case 'FOV': if ( ! this.camera.isPerspectiveCamera || ! this.enableZoom ) { return; } if ( this._animationId != - 1 ) { cancelAnimationFrame( this._animationId ); this._animationId = - 1; this._timeStart = - 1; this.activateGizmos( false ); this.dispatchEvent( _changeEvent ); } this.updateTbState( STATE.FOV, true ); this._startCursorPosition.setY( this.getCursorNDC( _center.x, _center.y, this.domElement ).y * 0.5 ); this._currentCursorPosition.copy( this._startCursorPosition ); break; case 'ZOOM': if ( ! this.enableZoom ) { return; } if ( this._animationId != - 1 ) { cancelAnimationFrame( this._animationId ); this._animationId = - 1; this._timeStart = - 1; this.activateGizmos( false ); this.dispatchEvent( _changeEvent ); } this.updateTbState( STATE.SCALE, true ); this._startCursorPosition.setY( this.getCursorNDC( _center.x, _center.y, this.domElement ).y * 0.5 ); this._currentCursorPosition.copy( this._startCursorPosition ); break; } } } onSinglePanMove( event, opState ) { if ( this.enabled ) { const restart = opState != this._state; this.setCenter( event.clientX, event.clientY ); switch ( opState ) { case STATE.PAN: if ( this.enablePan ) { if ( restart ) { //switch to pan operation this.dispatchEvent( _endEvent ); this.dispatchEvent( _startEvent ); this.updateTbState( opState, true ); this._startCursorPosition.copy( this.unprojectOnTbPlane( this.camera, _center.x, _center.y, this.domElement ) ); if ( this.enableGrid ) { this.drawGrid(); } this.activateGizmos( false ); } else { //continue with pan operation this._currentCursorPosition.copy( this.unprojectOnTbPlane( this.camera, _center.x, _center.y, this.domElement ) ); this.applyTransformMatrix( this.pan( this._startCursorPosition, this._currentCursorPosition ) ); } } break; case STATE.ROTATE: if ( this.enableRotate ) { if ( restart ) { //switch to rotate operation this.dispatchEvent( _endEvent ); this.dispatchEvent( _startEvent ); this.updateTbState( opState, true ); this._startCursorPosition.copy( this.unprojectOnTbSurface( this.camera, _center.x, _center.y, this.domElement, this._tbRadius ) ); if ( this.enableGrid ) { this.disposeGrid(); } this.activateGizmos( true ); } else { //continue with rotate operation this._currentCursorPosition.copy( this.unprojectOnTbSurface( this.camera, _center.x, _center.y, this.domElement, this._tbRadius ) ); const distance = this._startCursorPosition.distanceTo( this._currentCursorPosition ); const angle = this._startCursorPosition.angleTo( this._currentCursorPosition ); const amount = Math.max( distance / this._tbRadius, angle ) * this.rotateSpeed; //effective rotation angle this.applyTransformMatrix( this.rotate( this.calculateRotationAxis( this._startCursorPosition, this._currentCursorPosition ), amount ) ); if ( this.enableAnimations ) { this._timePrev = this._timeCurrent; this._timeCurrent = performance.now(); this._anglePrev = this._angleCurrent; this._angleCurrent = amount; this._cursorPosPrev.copy( this._cursorPosCurr ); this._cursorPosCurr.copy( this._currentCursorPosition ); this._wPrev = this._wCurr; this._wCurr = this.calculateAngularSpeed( this._anglePrev, this._angleCurrent, this._timePrev, this._timeCurrent ); } } } break; case STATE.SCALE: if ( this.enableZoom ) { if ( restart ) { //switch to zoom operation this.dispatchEvent( _endEvent ); this.dispatchEvent( _startEvent ); this.updateTbState( opState, true ); this._startCursorPosition.setY( this.getCursorNDC( _center.x, _center.y, this.domElement ).y * 0.5 ); this._currentCursorPosition.copy( this._startCursorPosition ); if ( this.enableGrid ) { this.disposeGrid(); } this.activateGizmos( false ); } else { //continue with zoom operation const screenNotches = 8; //how many wheel notches corresponds to a full screen pan this._currentCursorPosition.setY( this.getCursorNDC( _center.x, _center.y, this.domElement ).y * 0.5 ); const movement = this._currentCursorPosition.y - this._startCursorPosition.y; let size = 1; if ( movement < 0 ) { size = 1 / ( Math.pow( this.scaleFactor, - movement * screenNotches ) ); } else if ( movement > 0 ) { size = Math.pow( this.scaleFactor, movement * screenNotches ); } this._v3_1.setFromMatrixPosition( this._gizmoMatrixState ); this.applyTransformMatrix( this.scale( size, this._v3_1 ) ); } } break; case STATE.FOV: if ( this.enableZoom && this.camera.isPerspectiveCamera ) { if ( restart ) { //switch to fov operation this.dispatchEvent( _endEvent ); this.dispatchEvent( _startEvent ); this.updateTbState( opState, true ); this._startCursorPosition.setY( this.getCursorNDC( _center.x, _center.y, this.domElement ).y * 0.5 ); this._currentCursorPosition.copy( this._startCursorPosition ); if ( this.enableGrid ) { this.disposeGrid(); } this.activateGizmos( false ); } else { //continue with fov operation const screenNotches = 8; //how many wheel notches corresponds to a full screen pan this._currentCursorPosition.setY( this.getCursorNDC( _center.x, _center.y, this.domElement ).y * 0.5 ); const movement = this._currentCursorPosition.y - this._startCursorPosition.y; let size = 1; if ( movement < 0 ) { size = 1 / ( Math.pow( this.scaleFactor, - movement * screenNotches ) ); } else if ( movement > 0 ) { size = Math.pow( this.scaleFactor, movement * screenNotches ); } this._v3_1.setFromMatrixPosition( this._cameraMatrixState ); const x = this._v3_1.distanceTo( this._gizmos.position ); let xNew = x / size; //distance between camera and gizmos if scale(size, scalepoint) would be performed //check min and max distance xNew = MathUtils.clamp( xNew, this.minDistance, this.maxDistance ); const y = x * Math.tan( MathUtils.DEG2RAD * this._fovState * 0.5 ); //calculate new fov let newFov = MathUtils.RAD2DEG * ( Math.atan( y / xNew ) * 2 ); //check min and max fov newFov = MathUtils.clamp( newFov, this.minFov, this.maxFov ); const newDistance = y / Math.tan( MathUtils.DEG2RAD * ( newFov / 2 ) ); size = x / newDistance; this._v3_2.setFromMatrixPosition( this._gizmoMatrixState ); this.setFov( newFov ); this.applyTransformMatrix( this.scale( size, this._v3_2, false ) ); //adjusting distance _offset.copy( this._gizmos.position ).sub( this.camera.position ).normalize().multiplyScalar( newDistance / x ); this._m4_1.makeTranslation( _offset.x, _offset.y, _offset.z ); } } break; } this.dispatchEvent( _changeEvent ); } } onSinglePanEnd() { if ( this._state == STATE.ROTATE ) { if ( ! this.enableRotate ) { return; } if ( this.enableAnimations ) { //perform rotation animation const deltaTime = ( performance.now() - this._timeCurrent ); if ( deltaTime < 120 ) { const w = Math.abs( ( this._wPrev + this._wCurr ) / 2 ); const self = this; this._animationId = window.requestAnimationFrame( function ( t ) { self.updateTbState( STATE.ANIMATION_ROTATE, true ); const rotationAxis = self.calculateRotationAxis( self._cursorPosPrev, self._cursorPosCurr ); self.onRotationAnim( t, rotationAxis, Math.min( w, self.wMax ) ); } ); } else { //cursor has been standing still for over 120 ms since last movement this.updateTbState( STATE.IDLE, false ); this.activateGizmos( false ); this.dispatchEvent( _changeEvent ); } } else { this.updateTbState( STATE.IDLE, false ); this.activateGizmos( false ); this.dispatchEvent( _changeEvent ); } } else if ( this._state == STATE.PAN || this._state == STATE.IDLE ) { this.updateTbState( STATE.IDLE, false ); if ( this.enableGrid ) { this.disposeGrid(); } this.activateGizmos( false ); this.dispatchEvent( _changeEvent ); } this.dispatchEvent( _endEvent ); } onDoubleTap( event ) { if ( this.enabled && this.enablePan && this.scene != null ) { this.dispatchEvent( _startEvent ); this.setCenter( event.clientX, event.clientY ); const hitP = this.unprojectOnObj( this.getCursorNDC( _center.x, _center.y, this.domElement ), this.camera ); if ( hitP != null && this.enableAnimations ) { const self = this; if ( this._animationId != - 1 ) { window.cancelAnimationFrame( this._animationId ); } this._timeStart = - 1; this._animationId = window.requestAnimationFrame( function ( t ) { self.updateTbState( STATE.ANIMATION_FOCUS, true ); self.onFocusAnim( t, hitP, self._cameraMatrixState, self._gizmoMatrixState ); } ); } else if ( hitP != null && ! this.enableAnimations ) { this.updateTbState( STATE.FOCUS, true ); this.focus( hitP, this.scaleFactor ); this.updateTbState( STATE.IDLE, false ); this.dispatchEvent( _changeEvent ); } } this.dispatchEvent( _endEvent ); } onDoublePanStart() { if ( this.enabled && this.enablePan ) { this.dispatchEvent( _startEvent ); this.updateTbState( STATE.PAN, true ); this.setCenter( ( this._touchCurrent[ 0 ].clientX + this._touchCurrent[ 1 ].clientX ) / 2, ( this._touchCurrent[ 0 ].clientY + this._touchCurrent[ 1 ].clientY ) / 2 ); this._startCursorPosition.copy( this.unprojectOnTbPlane( this.camera, _center.x, _center.y, this.domElement, true ) ); this._currentCursorPosition.copy( this._startCursorPosition ); this.activateGizmos( false ); } } onDoublePanMove() { if ( this.enabled && this.enablePan ) { this.setCenter( ( this._touchCurrent[ 0 ].clientX + this._touchCurrent[ 1 ].clientX ) / 2, ( this._touchCurrent[ 0 ].clientY + this._touchCurrent[ 1 ].clientY ) / 2 ); if ( this._state != STATE.PAN ) { this.updateTbState( STATE.PAN, true ); this._startCursorPosition.copy( this._currentCursorPosition ); } this._currentCursorPosition.copy( this.unprojectOnTbPlane( this.camera, _center.x, _center.y, this.domElement, true ) ); this.applyTransformMatrix( this.pan( this._startCursorPosition, this._currentCursorPosition, true ) ); this.dispatchEvent( _changeEvent ); } } onDoublePanEnd() { this.updateTbState( STATE.IDLE, false ); this.dispatchEvent( _endEvent ); } onRotateStart() { if ( this.enabled && this.enableRotate ) { this.dispatchEvent( _startEvent ); this.updateTbState( STATE.ZROTATE, true ); //this._startFingerRotation = event.rotation; this._startFingerRotation = this.getAngle( this._touchCurrent[ 1 ], this._touchCurrent[ 0 ] ) + this.getAngle( this._touchStart[ 1 ], this._touchStart[ 0 ] ); this._currentFingerRotation = this._startFingerRotation; this.camera.getWorldDirection( this._rotationAxis ); //rotation axis if ( ! this.enablePan && ! this.enableZoom ) { this.activateGizmos( true ); } } } onRotateMove() { if ( this.enabled && this.enableRotate ) { this.setCenter( ( this._touchCurrent[ 0 ].clientX + this._touchCurrent[ 1 ].clientX ) / 2, ( this._touchCurrent[ 0 ].clientY + this._touchCurrent[ 1 ].clientY ) / 2 ); let rotationPoint; if ( this._state != STATE.ZROTATE ) { this.updateTbState( STATE.ZROTATE, true ); this._startFingerRotation = this._currentFingerRotation; } //this._currentFingerRotation = event.rotation; this._currentFingerRotation = this.getAngle( this._touchCurrent[ 1 ], this._touchCurrent[ 0 ] ) + this.getAngle( this._touchStart[ 1 ], this._touchStart[ 0 ] ); if ( ! this.enablePan ) { rotationPoint = new Vector3().setFromMatrixPosition( this._gizmoMatrixState ); } else { this._v3_2.setFromMatrixPosition( this._gizmoMatrixState ); rotationPoint = this.unprojectOnTbPlane( this.camera, _center.x, _center.y, this.domElement ).applyQuaternion( this.camera.quaternion ).multiplyScalar( 1 / this.camera.zoom ).add( this._v3_2 ); } const amount = MathUtils.DEG2RAD * ( this._startFingerRotation - this._currentFingerRotation ); this.applyTransformMatrix( this.zRotate( rotationPoint, amount ) ); this.dispatchEvent( _changeEvent ); } } onRotateEnd() { this.updateTbState( STATE.IDLE, false ); this.activateGizmos( false ); this.dispatchEvent( _endEvent ); } onPinchStart() { if ( this.enabled && this.enableZoom ) { this.dispatchEvent( _startEvent ); this.updateTbState( STATE.SCALE, true ); this._startFingerDistance = this.calculatePointersDistance( this._touchCurrent[ 0 ], this._touchCurrent[ 1 ] ); this._currentFingerDistance = this._startFingerDistance; this.activateGizmos( false ); } } onPinchMove() { if ( this.enabled && this.enableZoom ) { this.setCenter( ( this._touchCurrent[ 0 ].clientX + this._touchCurrent[ 1 ].clientX ) / 2, ( this._touchCurrent[ 0 ].clientY + this._touchCurrent[ 1 ].clientY ) / 2 ); const minDistance = 12; //minimum distance between fingers (in css pixels) if ( this._state != STATE.SCALE ) { this._startFingerDistance = this._currentFingerDistance; this.updateTbState( STATE.SCALE, true ); } this._currentFingerDistance = Math.max( this.calculatePointersDistance( this._touchCurrent[ 0 ], this._touchCurrent[ 1 ] ), minDistance * this._devPxRatio ); const amount = this._currentFingerDistance / this._startFingerDistance; let scalePoint; if ( ! this.enablePan ) { scalePoint = this._gizmos.position; } else { if ( this.camera.isOrthographicCamera ) { scalePoint = this.unprojectOnTbPlane( this.camera, _center.x, _center.y, this.domElement ) .applyQuaternion( this.camera.quaternion ) .multiplyScalar( 1 / this.camera.zoom ) .add( this._gizmos.position ); } else if ( this.camera.isPerspectiveCamera ) { scalePoint = this.unprojectOnTbPlane( this.camera, _center.x, _center.y, this.domElement ) .applyQuaternion( this.camera.quaternion ) .add( this._gizmos.position ); } } this.applyTransformMatrix( this.scale( amount, scalePoint ) ); this.dispatchEvent( _changeEvent ); } } onPinchEnd() { this.updateTbState( STATE.IDLE, false ); this.dispatchEvent( _endEvent ); } onTriplePanStart() { if ( this.enabled && this.enableZoom ) { this.dispatchEvent( _startEvent ); this.updateTbState( STATE.SCALE, true ); //const center = event.center; let clientX = 0; let clientY = 0; const nFingers = this._touchCurrent.length; for ( let i = 0; i < nFingers; i ++ ) { clientX += this._touchCurrent[ i ].clientX; clientY += this._touchCurrent[ i ].clientY; } this.setCenter( clientX / nFingers, clientY / nFingers ); this._startCursorPosition.setY( this.getCursorNDC( _center.x, _center.y, this.domElement ).y * 0.5 ); this._currentCursorPosition.copy( this._startCursorPosition ); } } onTriplePanMove() { if ( this.enabled && this.enableZoom ) { // fov / 2 // |\\ // | \\ // | \\ // x | \\ // | \\ // | \\ // | _ _ _\\ // y //const center = event.center; let clientX = 0; let clientY = 0; const nFingers = this._touchCurrent.length; for ( let i = 0; i < nFingers; i ++ ) { clientX += this._touchCurrent[ i ].clientX; clientY += this._touchCurrent[ i ].clientY; } this.setCenter( clientX / nFingers, clientY / nFingers ); const screenNotches = 8; //how many wheel notches corresponds to a full screen pan this._currentCursorPosition.setY( this.getCursorNDC( _center.x, _center.y, this.domElement ).y * 0.5 ); const movement = this._currentCursorPosition.y - this._startCursorPosition.y; let size = 1; if ( movement < 0 ) { size = 1 / ( Math.pow( this.scaleFactor, - movement * screenNotches ) ); } else if ( movement > 0 ) { size = Math.pow( this.scaleFactor, movement * screenNotches ); } this._v3_1.setFromMatrixPosition( this._cameraMatrixState ); const x = this._v3_1.distanceTo( this._gizmos.position ); let xNew = x / size; //distance between camera and gizmos if scale(size, scalepoint) would be performed //check min and max distance xNew = MathUtils.clamp( xNew, this.minDistance, this.maxDistance ); const y = x * Math.tan( MathUtils.DEG2RAD * this._fovState * 0.5 ); //calculate new fov let newFov = MathUtils.RAD2DEG * ( Math.atan( y / xNew ) * 2 ); //check min and max fov newFov = MathUtils.clamp( newFov, this.minFov, this.maxFov ); const newDistance = y / Math.tan( MathUtils.DEG2RAD * ( newFov / 2 ) ); size = x / newDistance; this._v3_2.setFromMatrixPosition( this._gizmoMatrixState ); this.setFov( newFov ); this.applyTransformMatrix( this.scale( size, this._v3_2, false ) ); //adjusting distance _offset.copy( this._gizmos.position ).sub( this.camera.position ).normalize().multiplyScalar( newDistance / x ); this._m4_1.makeTranslation( _offset.x, _offset.y, _offset.z ); this.dispatchEvent( _changeEvent ); } } onTriplePanEnd() { this.updateTbState( STATE.IDLE, false ); this.dispatchEvent( _endEvent ); //this.dispatchEvent( _changeEvent ); } /** * Set _center's x/y coordinates * @param {Number} clientX * @param {Number} clientY */ setCenter( clientX, clientY ) { _center.x = clientX; _center.y = clientY; } /** * Set default mouse actions */ initializeMouseActions() { this.setMouseAction( 'PAN', 0, 'CTRL' ); this.setMouseAction( 'PAN', 2 ); this.setMouseAction( 'ROTATE', 0 ); this.setMouseAction( 'ZOOM', 'WHEEL' ); this.setMouseAction( 'ZOOM', 1 ); this.setMouseAction( 'FOV', 'WHEEL', 'SHIFT' ); this.setMouseAction( 'FOV', 1, 'SHIFT' ); } /** * Compare two mouse actions * @param {Object} action1 * @param {Object} action2 * @returns {Boolean} True if action1 and action 2 are the same mouse action, false otherwise */ compareMouseAction( action1, action2 ) { if ( action1.operation == action2.operation ) { if ( action1.mouse == action2.mouse && action1.key == action2.key ) { return true; } else { return false; } } else { return false; } } /** * Set a new mouse action by specifying the operation to be performed and a mouse/key combination. In case of conflict, replaces the existing one * @param {String} operation The operation to be performed ('PAN', 'ROTATE', 'ZOOM', 'FOV) * @param {*} mouse A mouse button (0, 1, 2) or 'WHEEL' for wheel notches * @param {*} key The keyboard modifier ('CTRL', 'SHIFT') or null if key is not needed * @returns {Boolean} True if the mouse action has been successfully added, false otherwise */ setMouseAction( operation, mouse, key = null ) { const operationInput = [ 'PAN', 'ROTATE', 'ZOOM', 'FOV' ]; const mouseInput = [ 0, 1, 2, 'WHEEL' ]; const keyInput = [ 'CTRL', 'SHIFT', null ]; let state; if ( ! operationInput.includes( operation ) || ! mouseInput.includes( mouse ) || ! keyInput.includes( key ) ) { //invalid parameters return false; } if ( mouse == 'WHEEL' ) { if ( operation != 'ZOOM' && operation != 'FOV' ) { //cannot associate 2D operation to 1D input return false; } } switch ( operation ) { case 'PAN': state = STATE.PAN; break; case 'ROTATE': state = STATE.ROTATE; break; case 'ZOOM': state = STATE.SCALE; break; case 'FOV': state = STATE.FOV; break; } const action = { operation: operation, mouse: mouse, key: key, state: state }; for ( let i = 0; i < this.mouseActions.length; i ++ ) { if ( this.mouseActions[ i ].mouse == action.mouse && this.mouseActions[ i ].key == action.key ) { this.mouseActions.splice( i, 1, action ); return true; } } this.mouseActions.push( action ); return true; } /** * Remove a mouse action by specifying its mouse/key combination * @param {*} mouse A mouse button (0, 1, 2) or 'WHEEL' for wheel notches * @param {*} key The keyboard modifier ('CTRL', 'SHIFT') or null if key is not needed * @returns {Boolean} True if the operation has been succesfully removed, false otherwise */ unsetMouseAction( mouse, key = null ) { for ( let i = 0; i < this.mouseActions.length; i ++ ) { if ( this.mouseActions[ i ].mouse == mouse && this.mouseActions[ i ].key == key ) { this.mouseActions.splice( i, 1 ); return true; } } return false; } /** * Return the operation associated to a mouse/keyboard combination * @param {*} mouse A mouse button (0, 1, 2) or 'WHEEL' for wheel notches * @param {*} key The keyboard modifier ('CTRL', 'SHIFT') or null if key is not needed * @returns The operation if it has been found, null otherwise */ getOpFromAction( mouse, key ) { let action; for ( let i = 0; i < this.mouseActions.length; i ++ ) { action = this.mouseActions[ i ]; if ( action.mouse == mouse && action.key == key ) { return action.operation; } } if ( key != null ) { for ( let i = 0; i < this.mouseActions.length; i ++ ) { action = this.mouseActions[ i ]; if ( action.mouse == mouse && action.key == null ) { return action.operation; } } } return null; } /** * Get the operation associated to mouse and key combination and returns the corresponding FSA state * @param {Number} mouse Mouse button * @param {String} key Keyboard modifier * @returns The FSA state obtained from the operation associated to mouse/keyboard combination */ getOpStateFromAction( mouse, key ) { let action; for ( let i = 0; i < this.mouseActions.length; i ++ ) { action = this.mouseActions[ i ]; if ( action.mouse == mouse && action.key == key ) { return action.state; } } if ( key != null ) { for ( let i = 0; i < this.mouseActions.length; i ++ ) { action = this.mouseActions[ i ]; if ( action.mouse == mouse && action.key == null ) { return action.state; } } } return null; } /** * Calculate the angle between two pointers * @param {PointerEvent} p1 * @param {PointerEvent} p2 * @returns {Number} The angle between two pointers in degrees */ getAngle( p1, p2 ) { return Math.atan2( p2.clientY - p1.clientY, p2.clientX - p1.clientX ) * 180 / Math.PI; } /** * Update a PointerEvent inside current pointerevents array * @param {PointerEvent} event */ updateTouchEvent( event ) { for ( let i = 0; i < this._touchCurrent.length; i ++ ) { if ( this._touchCurrent[ i ].pointerId == event.pointerId ) { this._touchCurrent.splice( i, 1, event ); break; } } } /** * Apply a transformation matrix, to the camera and gizmos * @param {Object} transformation Object containing matrices to apply to camera and gizmos */ applyTransformMatrix( transformation ) { if ( transformation.camera != null ) { this._m4_1.copy( this._cameraMatrixState ).premultiply( transformation.camera ); this._m4_1.decompose( this.camera.position, this.camera.quaternion, this.camera.scale ); this.camera.updateMatrix(); //update camera up vector if ( this._state == STATE.ROTATE || this._state == STATE.ZROTATE || this._state == STATE.ANIMATION_ROTATE ) { this.camera.up.copy( this._upState ).applyQuaternion( this.camera.quaternion ); } } if ( transformation.gizmos != null ) { this._m4_1.copy( this._gizmoMatrixState ).premultiply( transformation.gizmos ); this._m4_1.decompose( this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale ); this._gizmos.updateMatrix(); } if ( this._state == STATE.SCALE || this._state == STATE.FOCUS || this._state == STATE.ANIMATION_FOCUS ) { this._tbRadius = this.calculateTbRadius( this.camera ); if ( this.adjustNearFar ) { const cameraDistance = this.camera.position.distanceTo( this._gizmos.position ); const bb = new Box3(); bb.setFromObject( this._gizmos ); const sphere = new Sphere(); bb.getBoundingSphere( sphere ); const adjustedNearPosition = Math.max( this._nearPos0, sphere.radius + sphere.center.length() ); const regularNearPosition = cameraDistance - this._initialNear; const minNearPos = Math.min( adjustedNearPosition, regularNearPosition ); this.camera.near = cameraDistance - minNearPos; const adjustedFarPosition = Math.min( this._farPos0, - sphere.radius + sphere.center.length() ); const regularFarPosition = cameraDistance - this._initialFar; const minFarPos = Math.min( adjustedFarPosition, regularFarPosition ); this.camera.far = cameraDistance - minFarPos; this.camera.updateProjectionMatrix(); } else { let update = false; if ( this.camera.near != this._initialNear ) { this.camera.near = this._initialNear; update = true; } if ( this.camera.far != this._initialFar ) { this.camera.far = this._initialFar; update = true; } if ( update ) { this.camera.updateProjectionMatrix(); } } } } /** * Calculate the angular speed * @param {Number} p0 Position at t0 * @param {Number} p1 Position at t1 * @param {Number} t0 Initial time in milliseconds * @param {Number} t1 Ending time in milliseconds */ calculateAngularSpeed( p0, p1, t0, t1 ) { const s = p1 - p0; const t = ( t1 - t0 ) / 1000; if ( t == 0 ) { return 0; } return s / t; } /** * Calculate the distance between two pointers * @param {PointerEvent} p0 The first pointer * @param {PointerEvent} p1 The second pointer * @returns {number} The distance between the two pointers */ calculatePointersDistance( p0, p1 ) { return Math.sqrt( Math.pow( p1.clientX - p0.clientX, 2 ) + Math.pow( p1.clientY - p0.clientY, 2 ) ); } /** * Calculate the rotation axis as the vector perpendicular between two vectors * @param {Vector3} vec1 The first vector * @param {Vector3} vec2 The second vector * @returns {Vector3} The normalized rotation axis */ calculateRotationAxis( vec1, vec2 ) { this._rotationMatrix.extractRotation( this._cameraMatrixState ); this._quat.setFromRotationMatrix( this._rotationMatrix ); this._rotationAxis.crossVectors( vec1, vec2 ).applyQuaternion( this._quat ); return this._rotationAxis.normalize().clone(); } /** * Calculate the trackball radius so that gizmo's diamater will be 2/3 of the minimum side of the camera frustum * @param {Camera} camera * @returns {Number} The trackball radius */ calculateTbRadius( camera ) { const distance = camera.position.distanceTo( this._gizmos.position ); if ( camera.type == 'PerspectiveCamera' ) { const halfFovV = MathUtils.DEG2RAD * camera.fov * 0.5; //vertical fov/2 in radians const halfFovH = Math.atan( ( camera.aspect ) * Math.tan( halfFovV ) ); //horizontal fov/2 in radians return Math.tan( Math.min( halfFovV, halfFovH ) ) * distance * this.radiusFactor; } else if ( camera.type == 'OrthographicCamera' ) { return Math.min( camera.top, camera.right ) * this.radiusFactor; } } /** * Focus operation consist of positioning the point of interest in front of the camera and a slightly zoom in * @param {Vector3} point The point of interest * @param {Number} size Scale factor * @param {Number} amount Amount of operation to be completed (used for focus animations, default is complete full operation) */ focus( point, size, amount = 1 ) { //move center of camera (along with gizmos) towards point of interest _offset.copy( point ).sub( this._gizmos.position ).multiplyScalar( amount ); this._translationMatrix.makeTranslation( _offset.x, _offset.y, _offset.z ); _gizmoMatrixStateTemp.copy( this._gizmoMatrixState ); this._gizmoMatrixState.premultiply( this._translationMatrix ); this._gizmoMatrixState.decompose( this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale ); _cameraMatrixStateTemp.copy( this._cameraMatrixState ); this._cameraMatrixState.premultiply( this._translationMatrix ); this._cameraMatrixState.decompose( this.camera.position, this.camera.quaternion, this.camera.scale ); //apply zoom if ( this.enableZoom ) { this.applyTransformMatrix( this.scale( size, this._gizmos.position ) ); } this._gizmoMatrixState.copy( _gizmoMatrixStateTemp ); this._cameraMatrixState.copy( _cameraMatrixStateTemp ); } /** * Draw a grid and add it to the scene */ drawGrid() { if ( this.scene != null ) { const color = 0x888888; const multiplier = 3; let size, divisions, maxLength, tick; if ( this.camera.isOrthographicCamera ) { const width = this.camera.right - this.camera.left; const height = this.camera.bottom - this.camera.top; maxLength = Math.max( width, height ); tick = maxLength / 20; size = maxLength / this.camera.zoom * multiplier; divisions = size / tick * this.camera.zoom; } else if ( this.camera.isPerspectiveCamera ) { const distance = this.camera.position.distanceTo( this._gizmos.position ); const halfFovV = MathUtils.DEG2RAD * this.camera.fov * 0.5; const halfFovH = Math.atan( ( this.camera.aspect ) * Math.tan( halfFovV ) ); maxLength = Math.tan( Math.max( halfFovV, halfFovH ) ) * distance * 2; tick = maxLength / 20; size = maxLength * multiplier; divisions = size / tick; } if ( this._grid == null ) { this._grid = new GridHelper( size, divisions, color, color ); this._grid.position.copy( this._gizmos.position ); this._gridPosition.copy( this._grid.position ); this._grid.quaternion.copy( this.camera.quaternion ); this._grid.rotateX( Math.PI * 0.5 ); this.scene.add( this._grid ); } } } /** * Remove all listeners, stop animations and clean scene */ dispose() { if ( this._animationId != - 1 ) { window.cancelAnimationFrame( this._animationId ); } this.domElement.removeEventListener( 'pointerdown', this._onPointerDown ); this.domElement.removeEventListener( 'pointercancel', this._onPointerCancel ); this.domElement.removeEventListener( 'wheel', this._onWheel ); this.domElement.removeEventListener( 'contextmenu', this._onContextMenu ); window.removeEventListener( 'pointermove', this._onPointerMove ); window.removeEventListener( 'pointerup', this._onPointerUp ); window.removeEventListener( 'resize', this._onWindowResize ); if ( this.scene !== null ) this.scene.remove( this._gizmos ); this.disposeGrid(); } /** * remove the grid from the scene */ disposeGrid() { if ( this._grid != null && this.scene != null ) { this.scene.remove( this._grid ); this._grid = null; } } /** * Compute the easing out cubic function for ease out effect in animation * @param {Number} t The absolute progress of the animation in the bound of 0 (beginning of the) and 1 (ending of animation) * @returns {Number} Result of easing out cubic at time t */ easeOutCubic( t ) { return 1 - Math.pow( 1 - t, 3 ); } /** * Make rotation gizmos more or less visible * @param {Boolean} isActive If true, make gizmos more visible */ activateGizmos( isActive ) { const gizmoX = this._gizmos.children[ 0 ]; const gizmoY = this._gizmos.children[ 1 ]; const gizmoZ = this._gizmos.children[ 2 ]; if ( isActive ) { gizmoX.material.setValues( { opacity: 1 } ); gizmoY.material.setValues( { opacity: 1 } ); gizmoZ.material.setValues( { opacity: 1 } ); } else { gizmoX.material.setValues( { opacity: 0.6 } ); gizmoY.material.setValues( { opacity: 0.6 } ); gizmoZ.material.setValues( { opacity: 0.6 } ); } } /** * Calculate the cursor position in NDC * @param {number} x Cursor horizontal coordinate within the canvas * @param {number} y Cursor vertical coordinate within the canvas * @param {HTMLElement} canvas The canvas where the renderer draws its output * @returns {Vector2} Cursor normalized position inside the canvas */ getCursorNDC( cursorX, cursorY, canvas ) { const canvasRect = canvas.getBoundingClientRect(); this._v2_1.setX( ( ( cursorX - canvasRect.left ) / canvasRect.width ) * 2 - 1 ); this._v2_1.setY( ( ( canvasRect.bottom - cursorY ) / canvasRect.height ) * 2 - 1 ); return this._v2_1.clone(); } /** * Calculate the cursor position inside the canvas x/y coordinates with the origin being in the center of the canvas * @param {Number} x Cursor horizontal coordinate within the canvas * @param {Number} y Cursor vertical coordinate within the canvas * @param {HTMLElement} canvas The canvas where the renderer draws its output * @returns {Vector2} Cursor position inside the canvas */ getCursorPosition( cursorX, cursorY, canvas ) { this._v2_1.copy( this.getCursorNDC( cursorX, cursorY, canvas ) ); this._v2_1.x *= ( this.camera.right - this.camera.left ) * 0.5; this._v2_1.y *= ( this.camera.top - this.camera.bottom ) * 0.5; return this._v2_1.clone(); } /** * Set the camera to be controlled * @param {Camera} camera The virtual camera to be controlled */ setCamera( camera ) { camera.lookAt( this.target ); camera.updateMatrix(); //setting state if ( camera.type == 'PerspectiveCamera' ) { this._fov0 = camera.fov; this._fovState = camera.fov; } this._cameraMatrixState0.copy( camera.matrix ); this._cameraMatrixState.copy( this._cameraMatrixState0 ); this._cameraProjectionState.copy( camera.projectionMatrix ); this._zoom0 = camera.zoom; this._zoomState = this._zoom0; this._initialNear = camera.near; this._nearPos0 = camera.position.distanceTo( this.target ) - camera.near; this._nearPos = this._initialNear; this._initialFar = camera.far; this._farPos0 = camera.position.distanceTo( this.target ) - camera.far; this._farPos = this._initialFar; this._up0.copy( camera.up ); this._upState.copy( camera.up ); this.camera = camera; this.camera.updateProjectionMatrix(); //making gizmos this._tbRadius = this.calculateTbRadius( camera ); this.makeGizmos( this.target, this._tbRadius ); } /** * Set gizmos visibility * @param {Boolean} value Value of gizmos visibility */ setGizmosVisible( value ) { this._gizmos.visible = value; this.dispatchEvent( _changeEvent ); } /** * Set gizmos radius factor and redraws gizmos * @param {Float} value Value of radius factor */ setTbRadius( value ) { this.radiusFactor = value; this._tbRadius = this.calculateTbRadius( this.camera ); const curve = new EllipseCurve( 0, 0, this._tbRadius, this._tbRadius ); const points = curve.getPoints( this._curvePts ); const curveGeometry = new BufferGeometry().setFromPoints( points ); for ( const gizmo in this._gizmos.children ) { this._gizmos.children[ gizmo ].geometry = curveGeometry; } this.dispatchEvent( _changeEvent ); } /** * Creates the rotation gizmos matching trackball center and radius * @param {Vector3} tbCenter The trackball center * @param {number} tbRadius The trackball radius */ makeGizmos( tbCenter, tbRadius ) { const curve = new EllipseCurve( 0, 0, tbRadius, tbRadius ); const points = curve.getPoints( this._curvePts ); //geometry const curveGeometry = new BufferGeometry().setFromPoints( points ); //material const curveMaterialX = new LineBasicMaterial( { color: 0xff8080, fog: false, transparent: true, opacity: 0.6 } ); const curveMaterialY = new LineBasicMaterial( { color: 0x80ff80, fog: false, transparent: true, opacity: 0.6 } ); const curveMaterialZ = new LineBasicMaterial( { color: 0x8080ff, fog: false, transparent: true, opacity: 0.6 } ); //line const gizmoX = new Line( curveGeometry, curveMaterialX ); const gizmoY = new Line( curveGeometry, curveMaterialY ); const gizmoZ = new Line( curveGeometry, curveMaterialZ ); const rotation = Math.PI * 0.5; gizmoX.rotation.x = rotation; gizmoY.rotation.y = rotation; //setting state this._gizmoMatrixState0.identity().setPosition( tbCenter ); this._gizmoMatrixState.copy( this._gizmoMatrixState0 ); if ( this.camera.zoom !== 1 ) { //adapt gizmos size to camera zoom const size = 1 / this.camera.zoom; this._scaleMatrix.makeScale( size, size, size ); this._translationMatrix.makeTranslation( - tbCenter.x, - tbCenter.y, - tbCenter.z ); this._gizmoMatrixState.premultiply( this._translationMatrix ).premultiply( this._scaleMatrix ); this._translationMatrix.makeTranslation( tbCenter.x, tbCenter.y, tbCenter.z ); this._gizmoMatrixState.premultiply( this._translationMatrix ); } this._gizmoMatrixState.decompose( this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale ); // this._gizmos.traverse( function ( object ) { if ( object.isLine ) { object.geometry.dispose(); object.material.dispose(); } } ); this._gizmos.clear(); // this._gizmos.add( gizmoX ); this._gizmos.add( gizmoY ); this._gizmos.add( gizmoZ ); } /** * Perform animation for focus operation * @param {Number} time Instant in which this function is called as performance.now() * @param {Vector3} point Point of interest for focus operation * @param {Matrix4} cameraMatrix Camera matrix * @param {Matrix4} gizmoMatrix Gizmos matrix */ onFocusAnim( time, point, cameraMatrix, gizmoMatrix ) { if ( this._timeStart == - 1 ) { //animation start this._timeStart = time; } if ( this._state == STATE.ANIMATION_FOCUS ) { const deltaTime = time - this._timeStart; const animTime = deltaTime / this.focusAnimationTime; this._gizmoMatrixState.copy( gizmoMatrix ); if ( animTime >= 1 ) { //animation end this._gizmoMatrixState.decompose( this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale ); this.focus( point, this.scaleFactor ); this._timeStart = - 1; this.updateTbState( STATE.IDLE, false ); this.activateGizmos( false ); this.dispatchEvent( _changeEvent ); } else { const amount = this.easeOutCubic( animTime ); const size = ( ( 1 - amount ) + ( this.scaleFactor * amount ) ); this._gizmoMatrixState.decompose( this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale ); this.focus( point, size, amount ); this.dispatchEvent( _changeEvent ); const self = this; this._animationId = window.requestAnimationFrame( function ( t ) { self.onFocusAnim( t, point, cameraMatrix, gizmoMatrix.clone() ); } ); } } else { //interrupt animation this._animationId = - 1; this._timeStart = - 1; } } /** * Perform animation for rotation operation * @param {Number} time Instant in which this function is called as performance.now() * @param {Vector3} rotationAxis Rotation axis * @param {number} w0 Initial angular velocity */ onRotationAnim( time, rotationAxis, w0 ) { if ( this._timeStart == - 1 ) { //animation start this._anglePrev = 0; this._angleCurrent = 0; this._timeStart = time; } if ( this._state == STATE.ANIMATION_ROTATE ) { //w = w0 + alpha * t const deltaTime = ( time - this._timeStart ) / 1000; const w = w0 + ( ( - this.dampingFactor ) * deltaTime ); if ( w > 0 ) { //tetha = 0.5 * alpha * t^2 + w0 * t + tetha0 this._angleCurrent = 0.5 * ( - this.dampingFactor ) * Math.pow( deltaTime, 2 ) + w0 * deltaTime + 0; this.applyTransformMatrix( this.rotate( rotationAxis, this._angleCurrent ) ); this.dispatchEvent( _changeEvent ); const self = this; this._animationId = window.requestAnimationFrame( function ( t ) { self.onRotationAnim( t, rotationAxis, w0 ); } ); } else { this._animationId = - 1; this._timeStart = - 1; this.updateTbState( STATE.IDLE, false ); this.activateGizmos( false ); this.dispatchEvent( _changeEvent ); } } else { //interrupt animation this._animationId = - 1; this._timeStart = - 1; if ( this._state != STATE.ROTATE ) { this.activateGizmos( false ); this.dispatchEvent( _changeEvent ); } } } /** * Perform pan operation moving camera between two points * @param {Vector3} p0 Initial point * @param {Vector3} p1 Ending point * @param {Boolean} adjust If movement should be adjusted considering camera distance (Perspective only) */ pan( p0, p1, adjust = false ) { const movement = p0.clone().sub( p1 ); if ( this.camera.isOrthographicCamera ) { //adjust movement amount movement.multiplyScalar( 1 / this.camera.zoom ); } else if ( this.camera.isPerspectiveCamera && adjust ) { //adjust movement amount this._v3_1.setFromMatrixPosition( this._cameraMatrixState0 ); //camera's initial position this._v3_2.setFromMatrixPosition( this._gizmoMatrixState0 ); //gizmo's initial position const distanceFactor = this._v3_1.distanceTo( this._v3_2 ) / this.camera.position.distanceTo( this._gizmos.position ); movement.multiplyScalar( 1 / distanceFactor ); } this._v3_1.set( movement.x, movement.y, 0 ).applyQuaternion( this.camera.quaternion ); this._m4_1.makeTranslation( this._v3_1.x, this._v3_1.y, this._v3_1.z ); this.setTransformationMatrices( this._m4_1, this._m4_1 ); return _transformation; } /** * Reset trackball */ reset() { this.camera.zoom = this._zoom0; if ( this.camera.isPerspectiveCamera ) { this.camera.fov = this._fov0; } this.camera.near = this._nearPos; this.camera.far = this._farPos; this._cameraMatrixState.copy( this._cameraMatrixState0 ); this._cameraMatrixState.decompose( this.camera.position, this.camera.quaternion, this.camera.scale ); this.camera.up.copy( this._up0 ); this.camera.updateMatrix(); this.camera.updateProjectionMatrix(); this._gizmoMatrixState.copy( this._gizmoMatrixState0 ); this._gizmoMatrixState0.decompose( this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale ); this._gizmos.updateMatrix(); this._tbRadius = this.calculateTbRadius( this.camera ); this.makeGizmos( this._gizmos.position, this._tbRadius ); this.camera.lookAt( this._gizmos.position ); this.updateTbState( STATE.IDLE, false ); this.dispatchEvent( _changeEvent ); } /** * Rotate the camera around an axis passing by trackball's center * @param {Vector3} axis Rotation axis * @param {number} angle Angle in radians * @returns {Object} Object with 'camera' field containing transformation matrix resulting from the operation to be applied to the camera */ rotate( axis, angle ) { const point = this._gizmos.position; //rotation center this._translationMatrix.makeTranslation( - point.x, - point.y, - point.z ); this._rotationMatrix.makeRotationAxis( axis, - angle ); //rotate camera this._m4_1.makeTranslation( point.x, point.y, point.z ); this._m4_1.multiply( this._rotationMatrix ); this._m4_1.multiply( this._translationMatrix ); this.setTransformationMatrices( this._m4_1 ); return _transformation; } copyState() { let state; if ( this.camera.isOrthographicCamera ) { state = JSON.stringify( { arcballState: { cameraFar: this.camera.far, cameraMatrix: this.camera.matrix, cameraNear: this.camera.near, cameraUp: this.camera.up, cameraZoom: this.camera.zoom, gizmoMatrix: this._gizmos.matrix } } ); } else if ( this.camera.isPerspectiveCamera ) { state = JSON.stringify( { arcballState: { cameraFar: this.camera.far, cameraFov: this.camera.fov, cameraMatrix: this.camera.matrix, cameraNear: this.camera.near, cameraUp: this.camera.up, cameraZoom: this.camera.zoom, gizmoMatrix: this._gizmos.matrix } } ); } navigator.clipboard.writeText( state ); } pasteState() { const self = this; navigator.clipboard.readText().then( function resolved( value ) { self.setStateFromJSON( value ); } ); } /** * Save the current state of the control. This can later be recover with .reset */ saveState() { this._cameraMatrixState0.copy( this.camera.matrix ); this._gizmoMatrixState0.copy( this._gizmos.matrix ); this._nearPos = this.camera.near; this._farPos = this.camera.far; this._zoom0 = this.camera.zoom; this._up0.copy( this.camera.up ); if ( this.camera.isPerspectiveCamera ) { this._fov0 = this.camera.fov; } } /** * Perform uniform scale operation around a given point * @param {Number} size Scale factor * @param {Vector3} point Point around which scale * @param {Boolean} scaleGizmos If gizmos should be scaled (Perspective only) * @returns {Object} Object with 'camera' and 'gizmo' fields containing transformation matrices resulting from the operation to be applied to the camera and gizmos */ scale( size, point, scaleGizmos = true ) { _scalePointTemp.copy( point ); let sizeInverse = 1 / size; if ( this.camera.isOrthographicCamera ) { //camera zoom this.camera.zoom = this._zoomState; this.camera.zoom *= size; //check min and max zoom if ( this.camera.zoom > this.maxZoom ) { this.camera.zoom = this.maxZoom; sizeInverse = this._zoomState / this.maxZoom; } else if ( this.camera.zoom < this.minZoom ) { this.camera.zoom = this.minZoom; sizeInverse = this._zoomState / this.minZoom; } this.camera.updateProjectionMatrix(); this._v3_1.setFromMatrixPosition( this._gizmoMatrixState ); //gizmos position //scale gizmos so they appear in the same spot having the same dimension this._scaleMatrix.makeScale( sizeInverse, sizeInverse, sizeInverse ); this._translationMatrix.makeTranslation( - this._v3_1.x, - this._v3_1.y, - this._v3_1.z ); this._m4_2.makeTranslation( this._v3_1.x, this._v3_1.y, this._v3_1.z ).multiply( this._scaleMatrix ); this._m4_2.multiply( this._translationMatrix ); //move camera and gizmos to obtain pinch effect _scalePointTemp.sub( this._v3_1 ); const amount = _scalePointTemp.clone().multiplyScalar( sizeInverse ); _scalePointTemp.sub( amount ); this._m4_1.makeTranslation( _scalePointTemp.x, _scalePointTemp.y, _scalePointTemp.z ); this._m4_2.premultiply( this._m4_1 ); this.setTransformationMatrices( this._m4_1, this._m4_2 ); return _transformation; } else if ( this.camera.isPerspectiveCamera ) { this._v3_1.setFromMatrixPosition( this._cameraMatrixState ); this._v3_2.setFromMatrixPosition( this._gizmoMatrixState ); //move camera let distance = this._v3_1.distanceTo( _scalePointTemp ); let amount = distance - ( distance * sizeInverse ); //check min and max distance const newDistance = distance - amount; if ( newDistance < this.minDistance ) { sizeInverse = this.minDistance / distance; amount = distance - ( distance * sizeInverse ); } else if ( newDistance > this.maxDistance ) { sizeInverse = this.maxDistance / distance; amount = distance - ( distance * sizeInverse ); } _offset.copy( _scalePointTemp ).sub( this._v3_1 ).normalize().multiplyScalar( amount ); this._m4_1.makeTranslation( _offset.x, _offset.y, _offset.z ); if ( scaleGizmos ) { //scale gizmos so they appear in the same spot having the same dimension const pos = this._v3_2; distance = pos.distanceTo( _scalePointTemp ); amount = distance - ( distance * sizeInverse ); _offset.copy( _scalePointTemp ).sub( this._v3_2 ).normalize().multiplyScalar( amount ); this._translationMatrix.makeTranslation( pos.x, pos.y, pos.z ); this._scaleMatrix.makeScale( sizeInverse, sizeInverse, sizeInverse ); this._m4_2.makeTranslation( _offset.x, _offset.y, _offset.z ).multiply( this._translationMatrix ); this._m4_2.multiply( this._scaleMatrix ); this._translationMatrix.makeTranslation( - pos.x, - pos.y, - pos.z ); this._m4_2.multiply( this._translationMatrix ); this.setTransformationMatrices( this._m4_1, this._m4_2 ); } else { this.setTransformationMatrices( this._m4_1 ); } return _transformation; } } /** * Set camera fov * @param {Number} value fov to be setted */ setFov( value ) { if ( this.camera.isPerspectiveCamera ) { this.camera.fov = MathUtils.clamp( value, this.minFov, this.maxFov ); this.camera.updateProjectionMatrix(); } } /** * Set values in transformation object * @param {Matrix4} camera Transformation to be applied to the camera * @param {Matrix4} gizmos Transformation to be applied to gizmos */ setTransformationMatrices( camera = null, gizmos = null ) { if ( camera != null ) { if ( _transformation.camera != null ) { _transformation.camera.copy( camera ); } else { _transformation.camera = camera.clone(); } } else { _transformation.camera = null; } if ( gizmos != null ) { if ( _transformation.gizmos != null ) { _transformation.gizmos.copy( gizmos ); } else { _transformation.gizmos = gizmos.clone(); } } else { _transformation.gizmos = null; } } /** * Rotate camera around its direction axis passing by a given point by a given angle * @param {Vector3} point The point where the rotation axis is passing trough * @param {Number} angle Angle in radians * @returns The computed transormation matix */ zRotate( point, angle ) { this._rotationMatrix.makeRotationAxis( this._rotationAxis, angle ); this._translationMatrix.makeTranslation( - point.x, - point.y, - point.z ); this._m4_1.makeTranslation( point.x, point.y, point.z ); this._m4_1.multiply( this._rotationMatrix ); this._m4_1.multiply( this._translationMatrix ); this._v3_1.setFromMatrixPosition( this._gizmoMatrixState ).sub( point ); //vector from rotation center to gizmos position this._v3_2.copy( this._v3_1 ).applyAxisAngle( this._rotationAxis, angle ); //apply rotation this._v3_2.sub( this._v3_1 ); this._m4_2.makeTranslation( this._v3_2.x, this._v3_2.y, this._v3_2.z ); this.setTransformationMatrices( this._m4_1, this._m4_2 ); return _transformation; } getRaycaster() { return _raycaster; } /** * Unproject the cursor on the 3D object surface * @param {Vector2} cursor Cursor coordinates in NDC * @param {Camera} camera Virtual camera * @returns {Vector3} The point of intersection with the model, if exist, null otherwise */ unprojectOnObj( cursor, camera ) { const raycaster = this.getRaycaster(); raycaster.near = camera.near; raycaster.far = camera.far; raycaster.setFromCamera( cursor, camera ); const intersect = raycaster.intersectObjects( this.scene.children, true ); for ( let i = 0; i < intersect.length; i ++ ) { if ( intersect[ i ].object.uuid != this._gizmos.uuid && intersect[ i ].face != null ) { return intersect[ i ].point.clone(); } } return null; } /** * Unproject the cursor on the trackball surface * @param {Camera} camera The virtual camera * @param {Number} cursorX Cursor horizontal coordinate on screen * @param {Number} cursorY Cursor vertical coordinate on screen * @param {HTMLElement} canvas The canvas where the renderer draws its output * @param {number} tbRadius The trackball radius * @returns {Vector3} The unprojected point on the trackball surface */ unprojectOnTbSurface( camera, cursorX, cursorY, canvas, tbRadius ) { if ( camera.type == 'OrthographicCamera' ) { this._v2_1.copy( this.getCursorPosition( cursorX, cursorY, canvas ) ); this._v3_1.set( this._v2_1.x, this._v2_1.y, 0 ); const x2 = Math.pow( this._v2_1.x, 2 ); const y2 = Math.pow( this._v2_1.y, 2 ); const r2 = Math.pow( this._tbRadius, 2 ); if ( x2 + y2 = 0 ) { //intersection with sphere this._v2_1.setX( ( - b - Math.sqrt( delta ) ) / ( 2 * a ) ); this._v2_1.setY( m * this._v2_1.x + q ); const angle = MathUtils.RAD2DEG * this._v2_1.angle(); if ( angle >= 45 ) { //if angle between intersection point and X' axis is >= 45°, return that point //otherwise, calculate intersection point with hyperboloid const rayLength = Math.sqrt( Math.pow( this._v2_1.x, 2 ) + Math.pow( ( cameraGizmoDistance - this._v2_1.y ), 2 ) ); rayDir.multiplyScalar( rayLength ); rayDir.z += cameraGizmoDistance; return rayDir; } } //intersection with hyperboloid /* *|y = m * x + q *|y = (1 / x) * (r^2 / 2) * * m * x^2 + q * x - r^2 / 2 = 0 */ a = m; b = q; c = - radius2 * 0.5; delta = Math.pow( b, 2 ) - ( 4 * a * c ); this._v2_1.setX( ( - b - Math.sqrt( delta ) ) / ( 2 * a ) ); this._v2_1.setY( m * this._v2_1.x + q ); const rayLength = Math.sqrt( Math.pow( this._v2_1.x, 2 ) + Math.pow( ( cameraGizmoDistance - this._v2_1.y ), 2 ) ); rayDir.multiplyScalar( rayLength ); rayDir.z += cameraGizmoDistance; return rayDir; } } /** * Unproject the cursor on the plane passing through the center of the trackball orthogonal to the camera * @param {Camera} camera The virtual camera * @param {Number} cursorX Cursor horizontal coordinate on screen * @param {Number} cursorY Cursor vertical coordinate on screen * @param {HTMLElement} canvas The canvas where the renderer draws its output * @param {Boolean} initialDistance If initial distance between camera and gizmos should be used for calculations instead of current (Perspective only) * @returns {Vector3} The unprojected point on the trackball plane */ unprojectOnTbPlane( camera, cursorX, cursorY, canvas, initialDistance = false ) { if ( camera.type == 'OrthographicCamera' ) { this._v2_1.copy( this.getCursorPosition( cursorX, cursorY, canvas ) ); this._v3_1.set( this._v2_1.x, this._v2_1.y, 0 ); return this._v3_1.clone(); } else if ( camera.type == 'PerspectiveCamera' ) { this._v2_1.copy( this.getCursorNDC( cursorX, cursorY, canvas ) ); //unproject cursor on the near plane this._v3_1.set( this._v2_1.x, this._v2_1.y, - 1 ); this._v3_1.applyMatrix4( camera.projectionMatrixInverse ); const rayDir = this._v3_1.clone().normalize(); //unprojected ray direction // camera // |\\ // | \\ // | \\ // h | \\ // | \\ // | \\ // _ _ | _ _ _\\ _ _ near plane // l const h = this._v3_1.z; const l = Math.sqrt( Math.pow( this._v3_1.x, 2 ) + Math.pow( this._v3_1.y, 2 ) ); let cameraGizmoDistance; if ( initialDistance ) { cameraGizmoDistance = this._v3_1.setFromMatrixPosition( this._cameraMatrixState0 ).distanceTo( this._v3_2.setFromMatrixPosition( this._gizmoMatrixState0 ) ); } else { cameraGizmoDistance = camera.position.distanceTo( this._gizmos.position ); } /* * calculate intersection point between unprojected ray and the plane *|y = mx + q *|y = 0 * * x = -q/m */ if ( l == 0 ) { //ray aligned with camera rayDir.set( 0, 0, 0 ); return rayDir; } const m = h / l; const q = cameraGizmoDistance; const x = - q / m; const rayLength = Math.sqrt( Math.pow( q, 2 ) + Math.pow( x, 2 ) ); rayDir.multiplyScalar( rayLength ); rayDir.z = 0; return rayDir; } } /** * Update camera and gizmos state */ updateMatrixState() { //update camera and gizmos state this._cameraMatrixState.copy( this.camera.matrix ); this._gizmoMatrixState.copy( this._gizmos.matrix ); if ( this.camera.isOrthographicCamera ) { this._cameraProjectionState.copy( this.camera.projectionMatrix ); this.camera.updateProjectionMatrix(); this._zoomState = this.camera.zoom; } else if ( this.camera.isPerspectiveCamera ) { this._fovState = this.camera.fov; } } /** * Update the trackball FSA * @param {STATE} newState New state of the FSA * @param {Boolean} updateMatrices If matriices state should be updated */ updateTbState( newState, updateMatrices ) { this._state = newState; if ( updateMatrices ) { this.updateMatrixState(); } } update() { const EPS = 0.000001; if ( this.target.equals( this._currentTarget ) === false ) { this._gizmos.position.copy( this.target ); //for correct radius calculation this._tbRadius = this.calculateTbRadius( this.camera ); this.makeGizmos( this.target, this._tbRadius ); this._currentTarget.copy( this.target ); } //check min/max parameters if ( this.camera.isOrthographicCamera ) { //check zoom if ( this.camera.zoom > this.maxZoom || this.camera.zoom < this.minZoom ) { const newZoom = MathUtils.clamp( this.camera.zoom, this.minZoom, this.maxZoom ); this.applyTransformMatrix( this.scale( newZoom / this.camera.zoom, this._gizmos.position, true ) ); } } else if ( this.camera.isPerspectiveCamera ) { //check distance const distance = this.camera.position.distanceTo( this._gizmos.position ); if ( distance > this.maxDistance + EPS || distance < this.minDistance - EPS ) { const newDistance = MathUtils.clamp( distance, this.minDistance, this.maxDistance ); this.applyTransformMatrix( this.scale( newDistance / distance, this._gizmos.position ) ); this.updateMatrixState(); } //check fov if ( this.camera.fov < this.minFov || this.camera.fov > this.maxFov ) { this.camera.fov = MathUtils.clamp( this.camera.fov, this.minFov, this.maxFov ); this.camera.updateProjectionMatrix(); } const oldRadius = this._tbRadius; this._tbRadius = this.calculateTbRadius( this.camera ); if ( oldRadius < this._tbRadius - EPS || oldRadius > this._tbRadius + EPS ) { const scale = ( this._gizmos.scale.x + this._gizmos.scale.y + this._gizmos.scale.z ) / 3; const newRadius = this._tbRadius / scale; const curve = new EllipseCurve( 0, 0, newRadius, newRadius ); const points = curve.getPoints( this._curvePts ); const curveGeometry = new BufferGeometry().setFromPoints( points ); for ( const gizmo in this._gizmos.children ) { this._gizmos.children[ gizmo ].geometry = curveGeometry; } } } this.camera.lookAt( this._gizmos.position ); } setStateFromJSON( json ) { const state = JSON.parse( json ); if ( state.arcballState != undefined ) { this._cameraMatrixState.fromArray( state.arcballState.cameraMatrix.elements ); this._cameraMatrixState.decompose( this.camera.position, this.camera.quaternion, this.camera.scale ); this.camera.up.copy( state.arcballState.cameraUp ); this.camera.near = state.arcballState.cameraNear; this.camera.far = state.arcballState.cameraFar; this.camera.zoom = state.arcballState.cameraZoom; if ( this.camera.isPerspectiveCamera ) { this.camera.fov = state.arcballState.cameraFov; } this._gizmoMatrixState.fromArray( state.arcballState.gizmoMatrix.elements ); this._gizmoMatrixState.decompose( this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale ); this.camera.updateMatrix(); this.camera.updateProjectionMatrix(); this._gizmos.updateMatrix(); this._tbRadius = this.calculateTbRadius( this.camera ); const gizmoTmp = new Matrix4().copy( this._gizmoMatrixState0 ); this.makeGizmos( this._gizmos.position, this._tbRadius ); this._gizmoMatrixState0.copy( gizmoTmp ); this.camera.lookAt( this._gizmos.position ); this.updateTbState( STATE.IDLE, false ); this.dispatchEvent( _changeEvent ); } } } //listeners function onWindowResize() { const scale = ( this._gizmos.scale.x + this._gizmos.scale.y + this._gizmos.scale.z ) / 3; this._tbRadius = this.calculateTbRadius( this.camera ); const newRadius = this._tbRadius / scale; const curve = new EllipseCurve( 0, 0, newRadius, newRadius ); const points = curve.getPoints( this._curvePts ); const curveGeometry = new BufferGeometry().setFromPoints( points ); for ( const gizmo in this._gizmos.children ) { this._gizmos.children[ gizmo ].geometry = curveGeometry; } this.dispatchEvent( _changeEvent ); } function onContextMenu( event ) { if ( ! this.enabled ) { return; } for ( let i = 0; i < this.mouseActions.length; i ++ ) { if ( this.mouseActions[ i ].mouse == 2 ) { //prevent only if button 2 is actually used event.preventDefault(); break; } } } function onPointerCancel() { this._touchStart.splice( 0, this._touchStart.length ); this._touchCurrent.splice( 0, this._touchCurrent.length ); this._input = INPUT.NONE; } function onPointerDown( event ) { if ( event.button == 0 && event.isPrimary ) { this._downValid = true; this._downEvents.push( event ); this._downStart = performance.now(); } else { this._downValid = false; } if ( event.pointerType == 'touch' && this._input != INPUT.CURSOR ) { this._touchStart.push( event ); this._touchCurrent.push( event ); switch ( this._input ) { case INPUT.NONE: //singleStart this._input = INPUT.ONE_FINGER; this.onSinglePanStart( event, 'ROTATE' ); window.addEventListener( 'pointermove', this._onPointerMove ); window.addEventListener( 'pointerup', this._onPointerUp ); break; case INPUT.ONE_FINGER: case INPUT.ONE_FINGER_SWITCHED: //doubleStart this._input = INPUT.TWO_FINGER; this.onRotateStart(); this.onPinchStart(); this.onDoublePanStart(); break; case INPUT.TWO_FINGER: //multipleStart this._input = INPUT.MULT_FINGER; this.onTriplePanStart( event ); break; } } else if ( event.pointerType != 'touch' && this._input == INPUT.NONE ) { let modifier = null; if ( event.ctrlKey || event.metaKey ) { modifier = 'CTRL'; } else if ( event.shiftKey ) { modifier = 'SHIFT'; } this._mouseOp = this.getOpFromAction( event.button, modifier ); if ( this._mouseOp != null ) { window.addEventListener( 'pointermove', this._onPointerMove ); window.addEventListener( 'pointerup', this._onPointerUp ); //singleStart this._input = INPUT.CURSOR; this._button = event.button; this.onSinglePanStart( event, this._mouseOp ); } } } function onPointerMove( event ) { if ( event.pointerType == 'touch' && this._input != INPUT.CURSOR ) { switch ( this._input ) { case INPUT.ONE_FINGER: //singleMove this.updateTouchEvent( event ); this.onSinglePanMove( event, STATE.ROTATE ); break; case INPUT.ONE_FINGER_SWITCHED: const movement = this.calculatePointersDistance( this._touchCurrent[ 0 ], event ) * this._devPxRatio; if ( movement >= this._switchSensibility ) { //singleMove this._input = INPUT.ONE_FINGER; this.updateTouchEvent( event ); this.onSinglePanStart( event, 'ROTATE' ); break; } break; case INPUT.TWO_FINGER: //rotate/pan/pinchMove this.updateTouchEvent( event ); this.onRotateMove(); this.onPinchMove(); this.onDoublePanMove(); break; case INPUT.MULT_FINGER: //multMove this.updateTouchEvent( event ); this.onTriplePanMove( event ); break; } } else if ( event.pointerType != 'touch' && this._input == INPUT.CURSOR ) { let modifier = null; if ( event.ctrlKey || event.metaKey ) { modifier = 'CTRL'; } else if ( event.shiftKey ) { modifier = 'SHIFT'; } const mouseOpState = this.getOpStateFromAction( this._button, modifier ); if ( mouseOpState != null ) { this.onSinglePanMove( event, mouseOpState ); } } //checkDistance if ( this._downValid ) { const movement = this.calculatePointersDistance( this._downEvents[ this._downEvents.length - 1 ], event ) * this._devPxRatio; if ( movement > this._movementThreshold ) { this._downValid = false; } } } function onPointerUp( event ) { if ( event.pointerType == 'touch' && this._input != INPUT.CURSOR ) { const nTouch = this._touchCurrent.length; for ( let i = 0; i < nTouch; i ++ ) { if ( this._touchCurrent[ i ].pointerId == event.pointerId ) { this._touchCurrent.splice( i, 1 ); this._touchStart.splice( i, 1 ); break; } } switch ( this._input ) { case INPUT.ONE_FINGER: case INPUT.ONE_FINGER_SWITCHED: //singleEnd window.removeEventListener( 'pointermove', this._onPointerMove ); window.removeEventListener( 'pointerup', this._onPointerUp ); this._input = INPUT.NONE; this.onSinglePanEnd(); break; case INPUT.TWO_FINGER: //doubleEnd this.onDoublePanEnd( event ); this.onPinchEnd( event ); this.onRotateEnd( event ); //switching to singleStart this._input = INPUT.ONE_FINGER_SWITCHED; break; case INPUT.MULT_FINGER: if ( this._touchCurrent.length == 0 ) { window.removeEventListener( 'pointermove', this._onPointerMove ); window.removeEventListener( 'pointerup', this._onPointerUp ); //multCancel this._input = INPUT.NONE; this.onTriplePanEnd(); } break; } } else if ( event.pointerType != 'touch' && this._input == INPUT.CURSOR ) { window.removeEventListener( 'pointermove', this._onPointerMove ); window.removeEventListener( 'pointerup', this._onPointerUp ); this._input = INPUT.NONE; this.onSinglePanEnd(); this._button = - 1; } if ( event.isPrimary ) { if ( this._downValid ) { const downTime = event.timeStamp - this._downEvents[ this._downEvents.length - 1 ].timeStamp; if ( downTime"},{"title":"","date":"2023-10-12T14:08:40.249Z","updated":"2023-10-12T14:08:40.249Z","comments":true,"path":"js/three/jsm/controls/FirstPersonControls.js","permalink":"http://19999997.xyz/js/three/jsm/controls/FirstPersonControls.js","excerpt":"","text":"import { MathUtils, Spherical, Vector3 } from 'three'; const _lookDirection = new Vector3(); const _spherical = new Spherical(); const _target = new Vector3(); class FirstPersonControls { constructor( object, domElement ) { this.object = object; this.domElement = domElement; // API this.enabled = true; this.movementSpeed = 1.0; this.lookSpeed = 0.005; this.lookVertical = true; this.autoForward = false; this.activeLook = true; this.heightSpeed = false; this.heightCoef = 1.0; this.heightMin = 0.0; this.heightMax = 1.0; this.constrainVertical = false; this.verticalMin = 0; this.verticalMax = Math.PI; this.mouseDragOn = false; // internals this.autoSpeedFactor = 0.0; this.pointerX = 0; this.pointerY = 0; this.moveForward = false; this.moveBackward = false; this.moveLeft = false; this.moveRight = false; this.viewHalfX = 0; this.viewHalfY = 0; // private variables let lat = 0; let lon = 0; // this.handleResize = function () { if ( this.domElement === document ) { this.viewHalfX = window.innerWidth / 2; this.viewHalfY = window.innerHeight / 2; } else { this.viewHalfX = this.domElement.offsetWidth / 2; this.viewHalfY = this.domElement.offsetHeight / 2; } }; this.onPointerDown = function ( event ) { if ( this.domElement !== document ) { this.domElement.focus(); } if ( this.activeLook ) { switch ( event.button ) { case 0: this.moveForward = true; break; case 2: this.moveBackward = true; break; } } this.mouseDragOn = true; }; this.onPointerUp = function ( event ) { if ( this.activeLook ) { switch ( event.button ) { case 0: this.moveForward = false; break; case 2: this.moveBackward = false; break; } } this.mouseDragOn = false; }; this.onPointerMove = function ( event ) { if ( this.domElement === document ) { this.pointerX = event.pageX - this.viewHalfX; this.pointerY = event.pageY - this.viewHalfY; } else { this.pointerX = event.pageX - this.domElement.offsetLeft - this.viewHalfX; this.pointerY = event.pageY - this.domElement.offsetTop - this.viewHalfY; } }; this.onKeyDown = function ( event ) { switch ( event.code ) { case 'ArrowUp': case 'KeyW': this.moveForward = true; break; case 'ArrowLeft': case 'KeyA': this.moveLeft = true; break; case 'ArrowDown': case 'KeyS': this.moveBackward = true; break; case 'ArrowRight': case 'KeyD': this.moveRight = true; break; case 'KeyR': this.moveUp = true; break; case 'KeyF': this.moveDown = true; break; } }; this.onKeyUp = function ( event ) { switch ( event.code ) { case 'ArrowUp': case 'KeyW': this.moveForward = false; break; case 'ArrowLeft': case 'KeyA': this.moveLeft = false; break; case 'ArrowDown': case 'KeyS': this.moveBackward = false; break; case 'ArrowRight': case 'KeyD': this.moveRight = false; break; case 'KeyR': this.moveUp = false; break; case 'KeyF': this.moveDown = false; break; } }; this.lookAt = function ( x, y, z ) { if ( x.isVector3 ) { _target.copy( x ); } else { _target.set( x, y, z ); } this.object.lookAt( _target ); setOrientation( this ); return this; }; this.update = function () { const targetPosition = new Vector3(); return function update( delta ) { if ( this.enabled === false ) return; if ( this.heightSpeed ) { const y = MathUtils.clamp( this.object.position.y, this.heightMin, this.heightMax ); const heightDelta = y - this.heightMin; this.autoSpeedFactor = delta * ( heightDelta * this.heightCoef ); } else { this.autoSpeedFactor = 0.0; } const actualMoveSpeed = delta * this.movementSpeed; if ( this.moveForward || ( this.autoForward && ! this.moveBackward ) ) this.object.translateZ( - ( actualMoveSpeed + this.autoSpeedFactor ) ); if ( this.moveBackward ) this.object.translateZ( actualMoveSpeed ); if ( this.moveLeft ) this.object.translateX( - actualMoveSpeed ); if ( this.moveRight ) this.object.translateX( actualMoveSpeed ); if ( this.moveUp ) this.object.translateY( actualMoveSpeed ); if ( this.moveDown ) this.object.translateY( - actualMoveSpeed ); let actualLookSpeed = delta * this.lookSpeed; if ( ! this.activeLook ) { actualLookSpeed = 0; } let verticalLookRatio = 1; if ( this.constrainVertical ) { verticalLookRatio = Math.PI / ( this.verticalMax - this.verticalMin ); } lon -= this.pointerX * actualLookSpeed; if ( this.lookVertical ) lat -= this.pointerY * actualLookSpeed * verticalLookRatio; lat = Math.max( - 85, Math.min( 85, lat ) ); let phi = MathUtils.degToRad( 90 - lat ); const theta = MathUtils.degToRad( lon ); if ( this.constrainVertical ) { phi = MathUtils.mapLinear( phi, 0, Math.PI, this.verticalMin, this.verticalMax ); } const position = this.object.position; targetPosition.setFromSphericalCoords( 1, phi, theta ).add( position ); this.object.lookAt( targetPosition ); }; }(); this.dispose = function () { this.domElement.removeEventListener( 'contextmenu', contextmenu ); this.domElement.removeEventListener( 'pointerdown', _onPointerDown ); this.domElement.removeEventListener( 'pointermove', _onPointerMove ); this.domElement.removeEventListener( 'pointerup', _onPointerUp ); window.removeEventListener( 'keydown', _onKeyDown ); window.removeEventListener( 'keyup', _onKeyUp ); }; const _onPointerMove = this.onPointerMove.bind( this ); const _onPointerDown = this.onPointerDown.bind( this ); const _onPointerUp = this.onPointerUp.bind( this ); const _onKeyDown = this.onKeyDown.bind( this ); const _onKeyUp = this.onKeyUp.bind( this ); this.domElement.addEventListener( 'contextmenu', contextmenu ); this.domElement.addEventListener( 'pointerdown', _onPointerDown ); this.domElement.addEventListener( 'pointermove', _onPointerMove ); this.domElement.addEventListener( 'pointerup', _onPointerUp ); window.addEventListener( 'keydown', _onKeyDown ); window.addEventListener( 'keyup', _onKeyUp ); function setOrientation( controls ) { const quaternion = controls.object.quaternion; _lookDirection.set( 0, 0, - 1 ).applyQuaternion( quaternion ); _spherical.setFromVector3( _lookDirection ); lat = 90 - MathUtils.radToDeg( _spherical.phi ); lon = MathUtils.radToDeg( _spherical.theta ); } this.handleResize(); setOrientation( this ); } } function contextmenu( event ) { event.preventDefault(); } export { FirstPersonControls };"},{"title":"","date":"2023-10-12T14:08:40.254Z","updated":"2023-10-12T14:08:40.254Z","comments":true,"path":"js/three/jsm/controls/MapControls.js","permalink":"http://19999997.xyz/js/three/jsm/controls/MapControls.js","excerpt":"","text":"import { MOUSE, TOUCH } from 'three'; import { OrbitControls } from './OrbitControls.js'; // MapControls performs orbiting, dollying (zooming), and panning. // Unlike TrackballControls, it maintains the \"up\" direction object.up (+Y by default). // // Orbit - right mouse, or left mouse + ctrl/meta/shiftKey / touch: two-finger rotate // Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish // Pan - left mouse, or arrow keys / touch: one-finger move class MapControls extends OrbitControls { constructor( object, domElement ) { super( object, domElement ); this.screenSpacePanning = false; // pan orthogonal to world-space direction camera.up this.mouseButtons = { LEFT: MOUSE.PAN, MIDDLE: MOUSE.DOLLY, RIGHT: MOUSE.ROTATE }; this.touches = { ONE: TOUCH.PAN, TWO: TOUCH.DOLLY_ROTATE }; } } export { MapControls };"},{"title":"","date":"2023-10-12T14:08:40.257Z","updated":"2023-10-12T14:08:40.257Z","comments":true,"path":"js/three/jsm/controls/OrbitControls.js","permalink":"http://19999997.xyz/js/three/jsm/controls/OrbitControls.js","excerpt":"","text":"import { EventDispatcher, MOUSE, Quaternion, Spherical, TOUCH, Vector2, Vector3, Plane, Ray, MathUtils } from 'three'; // OrbitControls performs orbiting, dollying (zooming), and panning. // Unlike TrackballControls, it maintains the \"up\" direction object.up (+Y by default). // // Orbit - left mouse / touch: one-finger move // Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish // Pan - right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move const _changeEvent = { type: 'change' }; const _startEvent = { type: 'start' }; const _endEvent = { type: 'end' }; const _ray = new Ray(); const _plane = new Plane(); const TILT_LIMIT = Math.cos( 70 * MathUtils.DEG2RAD ); class OrbitControls extends EventDispatcher { constructor( object, domElement ) { super(); this.object = object; this.domElement = domElement; this.domElement.style.touchAction = 'none'; // disable touch scroll // Set to false to disable this control this.enabled = true; // \"target\" sets the location of focus, where the object orbits around this.target = new Vector3(); // How far you can dolly in and out ( PerspectiveCamera only ) this.minDistance = 0; this.maxDistance = Infinity; // How far you can zoom in and out ( OrthographicCamera only ) this.minZoom = 0; this.maxZoom = Infinity; // How far you can orbit vertically, upper and lower limits. // Range is 0 to Math.PI radians. this.minPolarAngle = 0; // radians this.maxPolarAngle = Math.PI; // radians // How far you can orbit horizontally, upper and lower limits. // If set, the interval [ min, max ] must be a sub-interval of [ - 2 PI, 2 PI ], with ( max - min < 2 PI ) this.minAzimuthAngle = - Infinity; // radians this.maxAzimuthAngle = Infinity; // radians // Set to true to enable damping (inertia) // If damping is enabled, you must call controls.update() in your animation loop this.enableDamping = false; this.dampingFactor = 0.05; // This option actually enables dollying in and out; left as \"zoom\" for backwards compatibility. // Set to false to disable zooming this.enableZoom = true; this.zoomSpeed = 1.0; // Set to false to disable rotating this.enableRotate = true; this.rotateSpeed = 1.0; // Set to false to disable panning this.enablePan = true; this.panSpeed = 1.0; this.screenSpacePanning = true; // if false, pan orthogonal to world-space direction camera.up this.keyPanSpeed = 7.0; // pixels moved per arrow key push this.zoomToCursor = false; // Set to true to automatically rotate around the target // If auto-rotate is enabled, you must call controls.update() in your animation loop this.autoRotate = false; this.autoRotateSpeed = 2.0; // 30 seconds per orbit when fps is 60 // The four arrow keys this.keys = { LEFT: 'ArrowLeft', UP: 'ArrowUp', RIGHT: 'ArrowRight', BOTTOM: 'ArrowDown' }; // Mouse buttons this.mouseButtons = { LEFT: MOUSE.ROTATE, MIDDLE: MOUSE.DOLLY, RIGHT: MOUSE.PAN }; // Touch fingers this.touches = { ONE: TOUCH.ROTATE, TWO: TOUCH.DOLLY_PAN }; // for reset this.target0 = this.target.clone(); this.position0 = this.object.position.clone(); this.zoom0 = this.object.zoom; // the target DOM element for key events this._domElementKeyEvents = null; // // public methods // this.getPolarAngle = function () { return spherical.phi; }; this.getAzimuthalAngle = function () { return spherical.theta; }; this.getDistance = function () { return this.object.position.distanceTo( this.target ); }; this.listenToKeyEvents = function ( domElement ) { domElement.addEventListener( 'keydown', onKeyDown ); this._domElementKeyEvents = domElement; }; this.stopListenToKeyEvents = function () { this._domElementKeyEvents.removeEventListener( 'keydown', onKeyDown ); this._domElementKeyEvents = null; }; this.saveState = function () { scope.target0.copy( scope.target ); scope.position0.copy( scope.object.position ); scope.zoom0 = scope.object.zoom; }; this.reset = function () { scope.target.copy( scope.target0 ); scope.object.position.copy( scope.position0 ); scope.object.zoom = scope.zoom0; scope.object.updateProjectionMatrix(); scope.dispatchEvent( _changeEvent ); scope.update(); state = STATE.NONE; }; // this method is exposed, but perhaps it would be better if we can make it private... this.update = function () { const offset = new Vector3(); // so camera.up is the orbit axis const quat = new Quaternion().setFromUnitVectors( object.up, new Vector3( 0, 1, 0 ) ); const quatInverse = quat.clone().invert(); const lastPosition = new Vector3(); const lastQuaternion = new Quaternion(); const lastTargetPosition = new Vector3(); const twoPI = 2 * Math.PI; return function update( deltaTime = null ) { const position = scope.object.position; offset.copy( position ).sub( scope.target ); // rotate offset to \"y-axis-is-up\" space offset.applyQuaternion( quat ); // angle from z-axis around y-axis spherical.setFromVector3( offset ); if ( scope.autoRotate && state === STATE.NONE ) { rotateLeft( getAutoRotationAngle( deltaTime ) ); } if ( scope.enableDamping ) { spherical.theta += sphericalDelta.theta * scope.dampingFactor; spherical.phi += sphericalDelta.phi * scope.dampingFactor; } else { spherical.theta += sphericalDelta.theta; spherical.phi += sphericalDelta.phi; } // restrict theta to be between desired limits let min = scope.minAzimuthAngle; let max = scope.maxAzimuthAngle; if ( isFinite( min ) && isFinite( max ) ) { if ( min < - Math.PI ) min += twoPI; else if ( min > Math.PI ) min -= twoPI; if ( max < - Math.PI ) max += twoPI; else if ( max > Math.PI ) max -= twoPI; if ( min ( min + max ) / 2 ) ? Math.max( min, spherical.theta ) : Math.min( max, spherical.theta ); } } // restrict phi to be between desired limits spherical.phi = Math.max( scope.minPolarAngle, Math.min( scope.maxPolarAngle, spherical.phi ) ); spherical.makeSafe(); // move target to panned location if ( scope.enableDamping === true ) { scope.target.addScaledVector( panOffset, scope.dampingFactor ); } else { scope.target.add( panOffset ); } // adjust the camera position based on zoom only if we're not zooming to the cursor or if it's an ortho camera // we adjust zoom later in these cases if ( scope.zoomToCursor && performCursorZoom || scope.object.isOrthographicCamera ) { spherical.radius = clampDistance( spherical.radius ); } else { spherical.radius = clampDistance( spherical.radius * scale ); } offset.setFromSpherical( spherical ); // rotate offset back to \"camera-up-vector-is-up\" space offset.applyQuaternion( quatInverse ); position.copy( scope.target ).add( offset ); scope.object.lookAt( scope.target ); if ( scope.enableDamping === true ) { sphericalDelta.theta *= ( 1 - scope.dampingFactor ); sphericalDelta.phi *= ( 1 - scope.dampingFactor ); panOffset.multiplyScalar( 1 - scope.dampingFactor ); } else { sphericalDelta.set( 0, 0, 0 ); panOffset.set( 0, 0, 0 ); } // adjust camera position let zoomChanged = false; if ( scope.zoomToCursor && performCursorZoom ) { let newRadius = null; if ( scope.object.isPerspectiveCamera ) { // move the camera down the pointer ray // this method avoids floating point error const prevRadius = offset.length(); newRadius = clampDistance( prevRadius * scale ); const radiusDelta = prevRadius - newRadius; scope.object.position.addScaledVector( dollyDirection, radiusDelta ); scope.object.updateMatrixWorld(); } else if ( scope.object.isOrthographicCamera ) { // adjust the ortho camera position based on zoom changes const mouseBefore = new Vector3( mouse.x, mouse.y, 0 ); mouseBefore.unproject( scope.object ); scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / scale ) ); scope.object.updateProjectionMatrix(); zoomChanged = true; const mouseAfter = new Vector3( mouse.x, mouse.y, 0 ); mouseAfter.unproject( scope.object ); scope.object.position.sub( mouseAfter ).add( mouseBefore ); scope.object.updateMatrixWorld(); newRadius = offset.length(); } else { console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled.' ); scope.zoomToCursor = false; } // handle the placement of the target if ( newRadius !== null ) { if ( this.screenSpacePanning ) { // position the orbit target in front of the new camera position scope.target.set( 0, 0, - 1 ) .transformDirection( scope.object.matrix ) .multiplyScalar( newRadius ) .add( scope.object.position ); } else { // get the ray and translation plane to compute target _ray.origin.copy( scope.object.position ); _ray.direction.set( 0, 0, - 1 ).transformDirection( scope.object.matrix ); // if the camera is 20 degrees above the horizon then don't adjust the focus target to avoid // extremely large values if ( Math.abs( scope.object.up.dot( _ray.direction ) ) < TILT_LIMIT ) { object.lookAt( scope.target ); } else { _plane.setFromNormalAndCoplanarPoint( scope.object.up, scope.target ); _ray.intersectPlane( _plane, scope.target ); } } } } else if ( scope.object.isOrthographicCamera ) { scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / scale ) ); scope.object.updateProjectionMatrix(); zoomChanged = true; } scale = 1; performCursorZoom = false; // update condition is: // min(camera displacement, camera rotation in radians)^2 > EPS // using small-angle approximation cos(x/2) = 1 - x^2 / 8 if ( zoomChanged || lastPosition.distanceToSquared( scope.object.position ) > EPS || 8 * ( 1 - lastQuaternion.dot( scope.object.quaternion ) ) > EPS || lastTargetPosition.distanceToSquared( scope.target ) > 0 ) { scope.dispatchEvent( _changeEvent ); lastPosition.copy( scope.object.position ); lastQuaternion.copy( scope.object.quaternion ); lastTargetPosition.copy( scope.target ); zoomChanged = false; return true; } return false; }; }(); this.dispose = function () { scope.domElement.removeEventListener( 'contextmenu', onContextMenu ); scope.domElement.removeEventListener( 'pointerdown', onPointerDown ); scope.domElement.removeEventListener( 'pointercancel', onPointerUp ); scope.domElement.removeEventListener( 'wheel', onMouseWheel ); scope.domElement.removeEventListener( 'pointermove', onPointerMove ); scope.domElement.removeEventListener( 'pointerup', onPointerUp ); if ( scope._domElementKeyEvents !== null ) { scope._domElementKeyEvents.removeEventListener( 'keydown', onKeyDown ); scope._domElementKeyEvents = null; } //scope.dispatchEvent( { type: 'dispose' } ); // should this be added here? }; // // internals // const scope = this; const STATE = { NONE: - 1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_PAN: 4, TOUCH_DOLLY_PAN: 5, TOUCH_DOLLY_ROTATE: 6 }; let state = STATE.NONE; const EPS = 0.000001; // current position in spherical coordinates const spherical = new Spherical(); const sphericalDelta = new Spherical(); let scale = 1; const panOffset = new Vector3(); const rotateStart = new Vector2(); const rotateEnd = new Vector2(); const rotateDelta = new Vector2(); const panStart = new Vector2(); const panEnd = new Vector2(); const panDelta = new Vector2(); const dollyStart = new Vector2(); const dollyEnd = new Vector2(); const dollyDelta = new Vector2(); const dollyDirection = new Vector3(); const mouse = new Vector2(); let performCursorZoom = false; const pointers = []; const pointerPositions = {}; function getAutoRotationAngle( deltaTime ) { if ( deltaTime !== null ) { return ( 2 * Math.PI / 60 * scope.autoRotateSpeed ) * deltaTime; } else { return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed; } } function getZoomScale() { return Math.pow( 0.95, scope.zoomSpeed ); } function rotateLeft( angle ) { sphericalDelta.theta -= angle; } function rotateUp( angle ) { sphericalDelta.phi -= angle; } const panLeft = function () { const v = new Vector3(); return function panLeft( distance, objectMatrix ) { v.setFromMatrixColumn( objectMatrix, 0 ); // get X column of objectMatrix v.multiplyScalar( - distance ); panOffset.add( v ); }; }(); const panUp = function () { const v = new Vector3(); return function panUp( distance, objectMatrix ) { if ( scope.screenSpacePanning === true ) { v.setFromMatrixColumn( objectMatrix, 1 ); } else { v.setFromMatrixColumn( objectMatrix, 0 ); v.crossVectors( scope.object.up, v ); } v.multiplyScalar( distance ); panOffset.add( v ); }; }(); // deltaX and deltaY are in pixels; right and down are positive const pan = function () { const offset = new Vector3(); return function pan( deltaX, deltaY ) { const element = scope.domElement; if ( scope.object.isPerspectiveCamera ) { // perspective const position = scope.object.position; offset.copy( position ).sub( scope.target ); let targetDistance = offset.length(); // half of the fov is center to top of screen targetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 ); // we use only clientHeight here so aspect ratio does not distort speed panLeft( 2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix ); panUp( 2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix ); } else if ( scope.object.isOrthographicCamera ) { // orthographic panLeft( deltaX * ( scope.object.right - scope.object.left ) / scope.object.zoom / element.clientWidth, scope.object.matrix ); panUp( deltaY * ( scope.object.top - scope.object.bottom ) / scope.object.zoom / element.clientHeight, scope.object.matrix ); } else { // camera neither orthographic nor perspective console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' ); scope.enablePan = false; } }; }(); function dollyOut( dollyScale ) { if ( scope.object.isPerspectiveCamera || scope.object.isOrthographicCamera ) { scale /= dollyScale; } else { console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' ); scope.enableZoom = false; } } function dollyIn( dollyScale ) { if ( scope.object.isPerspectiveCamera || scope.object.isOrthographicCamera ) { scale *= dollyScale; } else { console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' ); scope.enableZoom = false; } } function updateMouseParameters( event ) { if ( ! scope.zoomToCursor ) { return; } performCursorZoom = true; const rect = scope.domElement.getBoundingClientRect(); const x = event.clientX - rect.left; const y = event.clientY - rect.top; const w = rect.width; const h = rect.height; mouse.x = ( x / w ) * 2 - 1; mouse.y = - ( y / h ) * 2 + 1; dollyDirection.set( mouse.x, mouse.y, 1 ).unproject( scope.object ).sub( scope.object.position ).normalize(); } function clampDistance( dist ) { return Math.max( scope.minDistance, Math.min( scope.maxDistance, dist ) ); } // // event callbacks - update the object state // function handleMouseDownRotate( event ) { rotateStart.set( event.clientX, event.clientY ); } function handleMouseDownDolly( event ) { updateMouseParameters( event ); dollyStart.set( event.clientX, event.clientY ); } function handleMouseDownPan( event ) { panStart.set( event.clientX, event.clientY ); } function handleMouseMoveRotate( event ) { rotateEnd.set( event.clientX, event.clientY ); rotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed ); const element = scope.domElement; rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight ); // yes, height rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight ); rotateStart.copy( rotateEnd ); scope.update(); } function handleMouseMoveDolly( event ) { dollyEnd.set( event.clientX, event.clientY ); dollyDelta.subVectors( dollyEnd, dollyStart ); if ( dollyDelta.y > 0 ) { dollyOut( getZoomScale() ); } else if ( dollyDelta.y < 0 ) { dollyIn( getZoomScale() ); } dollyStart.copy( dollyEnd ); scope.update(); } function handleMouseMovePan( event ) { panEnd.set( event.clientX, event.clientY ); panDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed ); pan( panDelta.x, panDelta.y ); panStart.copy( panEnd ); scope.update(); } function handleMouseWheel( event ) { updateMouseParameters( event ); if ( event.deltaY < 0 ) { dollyIn( getZoomScale() ); } else if ( event.deltaY > 0 ) { dollyOut( getZoomScale() ); } scope.update(); } function handleKeyDown( event ) { let needsUpdate = false; switch ( event.code ) { case scope.keys.UP: if ( event.ctrlKey || event.metaKey || event.shiftKey ) { rotateUp( 2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight ); } else { pan( 0, scope.keyPanSpeed ); } needsUpdate = true; break; case scope.keys.BOTTOM: if ( event.ctrlKey || event.metaKey || event.shiftKey ) { rotateUp( - 2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight ); } else { pan( 0, - scope.keyPanSpeed ); } needsUpdate = true; break; case scope.keys.LEFT: if ( event.ctrlKey || event.metaKey || event.shiftKey ) { rotateLeft( 2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight ); } else { pan( scope.keyPanSpeed, 0 ); } needsUpdate = true; break; case scope.keys.RIGHT: if ( event.ctrlKey || event.metaKey || event.shiftKey ) { rotateLeft( - 2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight ); } else { pan( - scope.keyPanSpeed, 0 ); } needsUpdate = true; break; } if ( needsUpdate ) { // prevent the browser from scrolling on cursor keys event.preventDefault(); scope.update(); } } function handleTouchStartRotate() { if ( pointers.length === 1 ) { rotateStart.set( pointers[ 0 ].pageX, pointers[ 0 ].pageY ); } else { const x = 0.5 * ( pointers[ 0 ].pageX + pointers[ 1 ].pageX ); const y = 0.5 * ( pointers[ 0 ].pageY + pointers[ 1 ].pageY ); rotateStart.set( x, y ); } } function handleTouchStartPan() { if ( pointers.length === 1 ) { panStart.set( pointers[ 0 ].pageX, pointers[ 0 ].pageY ); } else { const x = 0.5 * ( pointers[ 0 ].pageX + pointers[ 1 ].pageX ); const y = 0.5 * ( pointers[ 0 ].pageY + pointers[ 1 ].pageY ); panStart.set( x, y ); } } function handleTouchStartDolly() { const dx = pointers[ 0 ].pageX - pointers[ 1 ].pageX; const dy = pointers[ 0 ].pageY - pointers[ 1 ].pageY; const distance = Math.sqrt( dx * dx + dy * dy ); dollyStart.set( 0, distance ); } function handleTouchStartDollyPan() { if ( scope.enableZoom ) handleTouchStartDolly(); if ( scope.enablePan ) handleTouchStartPan(); } function handleTouchStartDollyRotate() { if ( scope.enableZoom ) handleTouchStartDolly(); if ( scope.enableRotate ) handleTouchStartRotate(); } function handleTouchMoveRotate( event ) { if ( pointers.length == 1 ) { rotateEnd.set( event.pageX, event.pageY ); } else { const position = getSecondPointerPosition( event ); const x = 0.5 * ( event.pageX + position.x ); const y = 0.5 * ( event.pageY + position.y ); rotateEnd.set( x, y ); } rotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed ); const element = scope.domElement; rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight ); // yes, height rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight ); rotateStart.copy( rotateEnd ); } function handleTouchMovePan( event ) { if ( pointers.length === 1 ) { panEnd.set( event.pageX, event.pageY ); } else { const position = getSecondPointerPosition( event ); const x = 0.5 * ( event.pageX + position.x ); const y = 0.5 * ( event.pageY + position.y ); panEnd.set( x, y ); } panDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed ); pan( panDelta.x, panDelta.y ); panStart.copy( panEnd ); } function handleTouchMoveDolly( event ) { const position = getSecondPointerPosition( event ); const dx = event.pageX - position.x; const dy = event.pageY - position.y; const distance = Math.sqrt( dx * dx + dy * dy ); dollyEnd.set( 0, distance ); dollyDelta.set( 0, Math.pow( dollyEnd.y / dollyStart.y, scope.zoomSpeed ) ); dollyOut( dollyDelta.y ); dollyStart.copy( dollyEnd ); } function handleTouchMoveDollyPan( event ) { if ( scope.enableZoom ) handleTouchMoveDolly( event ); if ( scope.enablePan ) handleTouchMovePan( event ); } function handleTouchMoveDollyRotate( event ) { if ( scope.enableZoom ) handleTouchMoveDolly( event ); if ( scope.enableRotate ) handleTouchMoveRotate( event ); } // // event handlers - FSM: listen for events and reset state // function onPointerDown( event ) { if ( scope.enabled === false ) return; if ( pointers.length === 0 ) { scope.domElement.setPointerCapture( event.pointerId ); scope.domElement.addEventListener( 'pointermove', onPointerMove ); scope.domElement.addEventListener( 'pointerup', onPointerUp ); } // addPointer( event ); if ( event.pointerType === 'touch' ) { onTouchStart( event ); } else { onMouseDown( event ); } } function onPointerMove( event ) { if ( scope.enabled === false ) return; if ( event.pointerType === 'touch' ) { onTouchMove( event ); } else { onMouseMove( event ); } } function onPointerUp( event ) { removePointer( event ); if ( pointers.length === 0 ) { scope.domElement.releasePointerCapture( event.pointerId ); scope.domElement.removeEventListener( 'pointermove', onPointerMove ); scope.domElement.removeEventListener( 'pointerup', onPointerUp ); } scope.dispatchEvent( _endEvent ); state = STATE.NONE; } function onMouseDown( event ) { let mouseAction; switch ( event.button ) { case 0: mouseAction = scope.mouseButtons.LEFT; break; case 1: mouseAction = scope.mouseButtons.MIDDLE; break; case 2: mouseAction = scope.mouseButtons.RIGHT; break; default: mouseAction = - 1; } switch ( mouseAction ) { case MOUSE.DOLLY: if ( scope.enableZoom === false ) return; handleMouseDownDolly( event ); state = STATE.DOLLY; break; case MOUSE.ROTATE: if ( event.ctrlKey || event.metaKey || event.shiftKey ) { if ( scope.enablePan === false ) return; handleMouseDownPan( event ); state = STATE.PAN; } else { if ( scope.enableRotate === false ) return; handleMouseDownRotate( event ); state = STATE.ROTATE; } break; case MOUSE.PAN: if ( event.ctrlKey || event.metaKey || event.shiftKey ) { if ( scope.enableRotate === false ) return; handleMouseDownRotate( event ); state = STATE.ROTATE; } else { if ( scope.enablePan === false ) return; handleMouseDownPan( event ); state = STATE.PAN; } break; default: state = STATE.NONE; } if ( state !== STATE.NONE ) { scope.dispatchEvent( _startEvent ); } } function onMouseMove( event ) { switch ( state ) { case STATE.ROTATE: if ( scope.enableRotate === false ) return; handleMouseMoveRotate( event ); break; case STATE.DOLLY: if ( scope.enableZoom === false ) return; handleMouseMoveDolly( event ); break; case STATE.PAN: if ( scope.enablePan === false ) return; handleMouseMovePan( event ); break; } } function onMouseWheel( event ) { if ( scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE ) return; event.preventDefault(); scope.dispatchEvent( _startEvent ); handleMouseWheel( event ); scope.dispatchEvent( _endEvent ); } function onKeyDown( event ) { if ( scope.enabled === false || scope.enablePan === false ) return; handleKeyDown( event ); } function onTouchStart( event ) { trackPointer( event ); switch ( pointers.length ) { case 1: switch ( scope.touches.ONE ) { case TOUCH.ROTATE: if ( scope.enableRotate === false ) return; handleTouchStartRotate(); state = STATE.TOUCH_ROTATE; break; case TOUCH.PAN: if ( scope.enablePan === false ) return; handleTouchStartPan(); state = STATE.TOUCH_PAN; break; default: state = STATE.NONE; } break; case 2: switch ( scope.touches.TWO ) { case TOUCH.DOLLY_PAN: if ( scope.enableZoom === false && scope.enablePan === false ) return; handleTouchStartDollyPan(); state = STATE.TOUCH_DOLLY_PAN; break; case TOUCH.DOLLY_ROTATE: if ( scope.enableZoom === false && scope.enableRotate === false ) return; handleTouchStartDollyRotate(); state = STATE.TOUCH_DOLLY_ROTATE; break; default: state = STATE.NONE; } break; default: state = STATE.NONE; } if ( state !== STATE.NONE ) { scope.dispatchEvent( _startEvent ); } } function onTouchMove( event ) { trackPointer( event ); switch ( state ) { case STATE.TOUCH_ROTATE: if ( scope.enableRotate === false ) return; handleTouchMoveRotate( event ); scope.update(); break; case STATE.TOUCH_PAN: if ( scope.enablePan === false ) return; handleTouchMovePan( event ); scope.update(); break; case STATE.TOUCH_DOLLY_PAN: if ( scope.enableZoom === false && scope.enablePan === false ) return; handleTouchMoveDollyPan( event ); scope.update(); break; case STATE.TOUCH_DOLLY_ROTATE: if ( scope.enableZoom === false && scope.enableRotate === false ) return; handleTouchMoveDollyRotate( event ); scope.update(); break; default: state = STATE.NONE; } } function onContextMenu( event ) { if ( scope.enabled === false ) return; event.preventDefault(); } function addPointer( event ) { pointers.push( event ); } function removePointer( event ) { delete pointerPositions[ event.pointerId ]; for ( let i = 0; i < pointers.length; i ++ ) { if ( pointers[ i ].pointerId == event.pointerId ) { pointers.splice( i, 1 ); return; } } } function trackPointer( event ) { let position = pointerPositions[ event.pointerId ]; if ( position === undefined ) { position = new Vector2(); pointerPositions[ event.pointerId ] = position; } position.set( event.pageX, event.pageY ); } function getSecondPointerPosition( event ) { const pointer = ( event.pointerId === pointers[ 0 ].pointerId ) ? pointers[ 1 ] : pointers[ 0 ]; return pointerPositions[ pointer.pointerId ]; } // scope.domElement.addEventListener( 'contextmenu', onContextMenu ); scope.domElement.addEventListener( 'pointerdown', onPointerDown ); scope.domElement.addEventListener( 'pointercancel', onPointerUp ); scope.domElement.addEventListener( 'wheel', onMouseWheel, { passive: false } ); // force an update at start this.update(); } } export { OrbitControls };"},{"title":"","date":"2023-10-12T14:08:40.260Z","updated":"2023-10-12T14:08:40.260Z","comments":true,"path":"js/three/jsm/controls/PointerLockControls.js","permalink":"http://19999997.xyz/js/three/jsm/controls/PointerLockControls.js","excerpt":"","text":"import { Euler, EventDispatcher, Vector3 } from 'three'; const _euler = new Euler( 0, 0, 0, 'YXZ' ); const _vector = new Vector3(); const _changeEvent = { type: 'change' }; const _lockEvent = { type: 'lock' }; const _unlockEvent = { type: 'unlock' }; const _PI_2 = Math.PI / 2; class PointerLockControls extends EventDispatcher { constructor( camera, domElement ) { super(); this.camera = camera; this.domElement = domElement; this.isLocked = false; // Set to constrain the pitch of the camera // Range is 0 to Math.PI radians this.minPolarAngle = 0; // radians this.maxPolarAngle = Math.PI; // radians this.pointerSpeed = 1.0; this._onMouseMove = onMouseMove.bind( this ); this._onPointerlockChange = onPointerlockChange.bind( this ); this._onPointerlockError = onPointerlockError.bind( this ); this.connect(); } connect() { this.domElement.ownerDocument.addEventListener( 'mousemove', this._onMouseMove ); this.domElement.ownerDocument.addEventListener( 'pointerlockchange', this._onPointerlockChange ); this.domElement.ownerDocument.addEventListener( 'pointerlockerror', this._onPointerlockError ); } disconnect() { this.domElement.ownerDocument.removeEventListener( 'mousemove', this._onMouseMove ); this.domElement.ownerDocument.removeEventListener( 'pointerlockchange', this._onPointerlockChange ); this.domElement.ownerDocument.removeEventListener( 'pointerlockerror', this._onPointerlockError ); } dispose() { this.disconnect(); } getObject() { // retaining this method for backward compatibility return this.camera; } getDirection( v ) { return v.set( 0, 0, - 1 ).applyQuaternion( this.camera.quaternion ); } moveForward( distance ) { // move forward parallel to the xz-plane // assumes camera.up is y-up const camera = this.camera; _vector.setFromMatrixColumn( camera.matrix, 0 ); _vector.crossVectors( camera.up, _vector ); camera.position.addScaledVector( _vector, distance ); } moveRight( distance ) { const camera = this.camera; _vector.setFromMatrixColumn( camera.matrix, 0 ); camera.position.addScaledVector( _vector, distance ); } lock() { this.domElement.requestPointerLock(); } unlock() { this.domElement.ownerDocument.exitPointerLock(); } } // event listeners function onMouseMove( event ) { if ( this.isLocked === false ) return; const movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0; const movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0; const camera = this.camera; _euler.setFromQuaternion( camera.quaternion ); _euler.y -= movementX * 0.002 * this.pointerSpeed; _euler.x -= movementY * 0.002 * this.pointerSpeed; _euler.x = Math.max( _PI_2 - this.maxPolarAngle, Math.min( _PI_2 - this.minPolarAngle, _euler.x ) ); camera.quaternion.setFromEuler( _euler ); this.dispatchEvent( _changeEvent ); } function onPointerlockChange() { if ( this.domElement.ownerDocument.pointerLockElement === this.domElement ) { this.dispatchEvent( _lockEvent ); this.isLocked = true; } else { this.dispatchEvent( _unlockEvent ); this.isLocked = false; } } function onPointerlockError() { console.error( 'THREE.PointerLockControls: Unable to use Pointer Lock API' ); } export { PointerLockControls };"},{"title":"","date":"2023-10-12T14:08:40.266Z","updated":"2023-10-12T14:08:40.266Z","comments":true,"path":"js/three/jsm/controls/TransformControls.js","permalink":"http://19999997.xyz/js/three/jsm/controls/TransformControls.js","excerpt":"","text":"import { BoxGeometry, BufferGeometry, CylinderGeometry, DoubleSide, Euler, Float32BufferAttribute, Line, LineBasicMaterial, Matrix4, Mesh, MeshBasicMaterial, Object3D, OctahedronGeometry, PlaneGeometry, Quaternion, Raycaster, SphereGeometry, TorusGeometry, Vector3 } from 'three'; const _raycaster = new Raycaster(); const _tempVector = new Vector3(); const _tempVector2 = new Vector3(); const _tempQuaternion = new Quaternion(); const _unit = { X: new Vector3( 1, 0, 0 ), Y: new Vector3( 0, 1, 0 ), Z: new Vector3( 0, 0, 1 ) }; const _changeEvent = { type: 'change' }; const _mouseDownEvent = { type: 'mouseDown' }; const _mouseUpEvent = { type: 'mouseUp', mode: null }; const _objectChangeEvent = { type: 'objectChange' }; class TransformControls extends Object3D { constructor( camera, domElement ) { super(); if ( domElement === undefined ) { console.warn( 'THREE.TransformControls: The second parameter \"domElement\" is now mandatory.' ); domElement = document; } this.isTransformControls = true; this.visible = false; this.domElement = domElement; this.domElement.style.touchAction = 'none'; // disable touch scroll const _gizmo = new TransformControlsGizmo(); this._gizmo = _gizmo; this.add( _gizmo ); const _plane = new TransformControlsPlane(); this._plane = _plane; this.add( _plane ); const scope = this; // Defined getter, setter and store for a property function defineProperty( propName, defaultValue ) { let propValue = defaultValue; Object.defineProperty( scope, propName, { get: function () { return propValue !== undefined ? propValue : defaultValue; }, set: function ( value ) { if ( propValue !== value ) { propValue = value; _plane[ propName ] = value; _gizmo[ propName ] = value; scope.dispatchEvent( { type: propName + '-changed', value: value } ); scope.dispatchEvent( _changeEvent ); } } } ); scope[ propName ] = defaultValue; _plane[ propName ] = defaultValue; _gizmo[ propName ] = defaultValue; } // Define properties with getters/setter // Setting the defined property will automatically trigger change event // Defined properties are passed down to gizmo and plane defineProperty( 'camera', camera ); defineProperty( 'object', undefined ); defineProperty( 'enabled', true ); defineProperty( 'axis', null ); defineProperty( 'mode', 'translate' ); defineProperty( 'translationSnap', null ); defineProperty( 'rotationSnap', null ); defineProperty( 'scaleSnap', null ); defineProperty( 'space', 'world' ); defineProperty( 'size', 1 ); defineProperty( 'dragging', false ); defineProperty( 'showX', true ); defineProperty( 'showY', true ); defineProperty( 'showZ', true ); // Reusable utility variables const worldPosition = new Vector3(); const worldPositionStart = new Vector3(); const worldQuaternion = new Quaternion(); const worldQuaternionStart = new Quaternion(); const cameraPosition = new Vector3(); const cameraQuaternion = new Quaternion(); const pointStart = new Vector3(); const pointEnd = new Vector3(); const rotationAxis = new Vector3(); const rotationAngle = 0; const eye = new Vector3(); // TODO: remove properties unused in plane and gizmo defineProperty( 'worldPosition', worldPosition ); defineProperty( 'worldPositionStart', worldPositionStart ); defineProperty( 'worldQuaternion', worldQuaternion ); defineProperty( 'worldQuaternionStart', worldQuaternionStart ); defineProperty( 'cameraPosition', cameraPosition ); defineProperty( 'cameraQuaternion', cameraQuaternion ); defineProperty( 'pointStart', pointStart ); defineProperty( 'pointEnd', pointEnd ); defineProperty( 'rotationAxis', rotationAxis ); defineProperty( 'rotationAngle', rotationAngle ); defineProperty( 'eye', eye ); this._offset = new Vector3(); this._startNorm = new Vector3(); this._endNorm = new Vector3(); this._cameraScale = new Vector3(); this._parentPosition = new Vector3(); this._parentQuaternion = new Quaternion(); this._parentQuaternionInv = new Quaternion(); this._parentScale = new Vector3(); this._worldScaleStart = new Vector3(); this._worldQuaternionInv = new Quaternion(); this._worldScale = new Vector3(); this._positionStart = new Vector3(); this._quaternionStart = new Quaternion(); this._scaleStart = new Vector3(); this._getPointer = getPointer.bind( this ); this._onPointerDown = onPointerDown.bind( this ); this._onPointerHover = onPointerHover.bind( this ); this._onPointerMove = onPointerMove.bind( this ); this._onPointerUp = onPointerUp.bind( this ); this.domElement.addEventListener( 'pointerdown', this._onPointerDown ); this.domElement.addEventListener( 'pointermove', this._onPointerHover ); this.domElement.addEventListener( 'pointerup', this._onPointerUp ); } // updateMatrixWorld updates key transformation variables updateMatrixWorld() { if ( this.object !== undefined ) { this.object.updateMatrixWorld(); if ( this.object.parent === null ) { console.error( 'TransformControls: The attached 3D object must be a part of the scene graph.' ); } else { this.object.parent.matrixWorld.decompose( this._parentPosition, this._parentQuaternion, this._parentScale ); } this.object.matrixWorld.decompose( this.worldPosition, this.worldQuaternion, this._worldScale ); this._parentQuaternionInv.copy( this._parentQuaternion ).invert(); this._worldQuaternionInv.copy( this.worldQuaternion ).invert(); } this.camera.updateMatrixWorld(); this.camera.matrixWorld.decompose( this.cameraPosition, this.cameraQuaternion, this._cameraScale ); if ( this.camera.isOrthographicCamera ) { this.camera.getWorldDirection( this.eye ).negate(); } else { this.eye.copy( this.cameraPosition ).sub( this.worldPosition ).normalize(); } super.updateMatrixWorld( this ); } pointerHover( pointer ) { if ( this.object === undefined || this.dragging === true ) return; _raycaster.setFromCamera( pointer, this.camera ); const intersect = intersectObjectWithRay( this._gizmo.picker[ this.mode ], _raycaster ); if ( intersect ) { this.axis = intersect.object.name; } else { this.axis = null; } } pointerDown( pointer ) { if ( this.object === undefined || this.dragging === true || pointer.button !== 0 ) return; if ( this.axis !== null ) { _raycaster.setFromCamera( pointer, this.camera ); const planeIntersect = intersectObjectWithRay( this._plane, _raycaster, true ); if ( planeIntersect ) { this.object.updateMatrixWorld(); this.object.parent.updateMatrixWorld(); this._positionStart.copy( this.object.position ); this._quaternionStart.copy( this.object.quaternion ); this._scaleStart.copy( this.object.scale ); this.object.matrixWorld.decompose( this.worldPositionStart, this.worldQuaternionStart, this._worldScaleStart ); this.pointStart.copy( planeIntersect.point ).sub( this.worldPositionStart ); } this.dragging = true; _mouseDownEvent.mode = this.mode; this.dispatchEvent( _mouseDownEvent ); } } pointerMove( pointer ) { const axis = this.axis; const mode = this.mode; const object = this.object; let space = this.space; if ( mode === 'scale' ) { space = 'local'; } else if ( axis === 'E' || axis === 'XYZE' || axis === 'XYZ' ) { space = 'world'; } if ( object === undefined || axis === null || this.dragging === false || pointer.button !== - 1 ) return; _raycaster.setFromCamera( pointer, this.camera ); const planeIntersect = intersectObjectWithRay( this._plane, _raycaster, true ); if ( ! planeIntersect ) return; this.pointEnd.copy( planeIntersect.point ).sub( this.worldPositionStart ); if ( mode === 'translate' ) { // Apply translate this._offset.copy( this.pointEnd ).sub( this.pointStart ); if ( space === 'local' && axis !== 'XYZ' ) { this._offset.applyQuaternion( this._worldQuaternionInv ); } if ( axis.indexOf( 'X' ) === - 1 ) this._offset.x = 0; if ( axis.indexOf( 'Y' ) === - 1 ) this._offset.y = 0; if ( axis.indexOf( 'Z' ) === - 1 ) this._offset.z = 0; if ( space === 'local' && axis !== 'XYZ' ) { this._offset.applyQuaternion( this._quaternionStart ).divide( this._parentScale ); } else { this._offset.applyQuaternion( this._parentQuaternionInv ).divide( this._parentScale ); } object.position.copy( this._offset ).add( this._positionStart ); // Apply translation snap if ( this.translationSnap ) { if ( space === 'local' ) { object.position.applyQuaternion( _tempQuaternion.copy( this._quaternionStart ).invert() ); if ( axis.search( 'X' ) !== - 1 ) { object.position.x = Math.round( object.position.x / this.translationSnap ) * this.translationSnap; } if ( axis.search( 'Y' ) !== - 1 ) { object.position.y = Math.round( object.position.y / this.translationSnap ) * this.translationSnap; } if ( axis.search( 'Z' ) !== - 1 ) { object.position.z = Math.round( object.position.z / this.translationSnap ) * this.translationSnap; } object.position.applyQuaternion( this._quaternionStart ); } if ( space === 'world' ) { if ( object.parent ) { object.position.add( _tempVector.setFromMatrixPosition( object.parent.matrixWorld ) ); } if ( axis.search( 'X' ) !== - 1 ) { object.position.x = Math.round( object.position.x / this.translationSnap ) * this.translationSnap; } if ( axis.search( 'Y' ) !== - 1 ) { object.position.y = Math.round( object.position.y / this.translationSnap ) * this.translationSnap; } if ( axis.search( 'Z' ) !== - 1 ) { object.position.z = Math.round( object.position.z / this.translationSnap ) * this.translationSnap; } if ( object.parent ) { object.position.sub( _tempVector.setFromMatrixPosition( object.parent.matrixWorld ) ); } } } } else if ( mode === 'scale' ) { if ( axis.search( 'XYZ' ) !== - 1 ) { let d = this.pointEnd.length() / this.pointStart.length(); if ( this.pointEnd.dot( this.pointStart ) < 0 ) d *= - 1; _tempVector2.set( d, d, d ); } else { _tempVector.copy( this.pointStart ); _tempVector2.copy( this.pointEnd ); _tempVector.applyQuaternion( this._worldQuaternionInv ); _tempVector2.applyQuaternion( this._worldQuaternionInv ); _tempVector2.divide( _tempVector ); if ( axis.search( 'X' ) === - 1 ) { _tempVector2.x = 1; } if ( axis.search( 'Y' ) === - 1 ) { _tempVector2.y = 1; } if ( axis.search( 'Z' ) === - 1 ) { _tempVector2.z = 1; } } // Apply scale object.scale.copy( this._scaleStart ).multiply( _tempVector2 ); if ( this.scaleSnap ) { if ( axis.search( 'X' ) !== - 1 ) { object.scale.x = Math.round( object.scale.x / this.scaleSnap ) * this.scaleSnap || this.scaleSnap; } if ( axis.search( 'Y' ) !== - 1 ) { object.scale.y = Math.round( object.scale.y / this.scaleSnap ) * this.scaleSnap || this.scaleSnap; } if ( axis.search( 'Z' ) !== - 1 ) { object.scale.z = Math.round( object.scale.z / this.scaleSnap ) * this.scaleSnap || this.scaleSnap; } } } else if ( mode === 'rotate' ) { this._offset.copy( this.pointEnd ).sub( this.pointStart ); const ROTATION_SPEED = 20 / this.worldPosition.distanceTo( _tempVector.setFromMatrixPosition( this.camera.matrixWorld ) ); if ( axis === 'E' ) { this.rotationAxis.copy( this.eye ); this.rotationAngle = this.pointEnd.angleTo( this.pointStart ); this._startNorm.copy( this.pointStart ).normalize(); this._endNorm.copy( this.pointEnd ).normalize(); this.rotationAngle *= ( this._endNorm.cross( this._startNorm ).dot( this.eye ) < 0 ? 1 : - 1 ); } else if ( axis === 'XYZE' ) { this.rotationAxis.copy( this._offset ).cross( this.eye ).normalize(); this.rotationAngle = this._offset.dot( _tempVector.copy( this.rotationAxis ).cross( this.eye ) ) * ROTATION_SPEED; } else if ( axis === 'X' || axis === 'Y' || axis === 'Z' ) { this.rotationAxis.copy( _unit[ axis ] ); _tempVector.copy( _unit[ axis ] ); if ( space === 'local' ) { _tempVector.applyQuaternion( this.worldQuaternion ); } this.rotationAngle = this._offset.dot( _tempVector.cross( this.eye ).normalize() ) * ROTATION_SPEED; } // Apply rotation snap if ( this.rotationSnap ) this.rotationAngle = Math.round( this.rotationAngle / this.rotationSnap ) * this.rotationSnap; // Apply rotate if ( space === 'local' && axis !== 'E' && axis !== 'XYZE' ) { object.quaternion.copy( this._quaternionStart ); object.quaternion.multiply( _tempQuaternion.setFromAxisAngle( this.rotationAxis, this.rotationAngle ) ).normalize(); } else { this.rotationAxis.applyQuaternion( this._parentQuaternionInv ); object.quaternion.copy( _tempQuaternion.setFromAxisAngle( this.rotationAxis, this.rotationAngle ) ); object.quaternion.multiply( this._quaternionStart ).normalize(); } } this.dispatchEvent( _changeEvent ); this.dispatchEvent( _objectChangeEvent ); } pointerUp( pointer ) { if ( pointer.button !== 0 ) return; if ( this.dragging && ( this.axis !== null ) ) { _mouseUpEvent.mode = this.mode; this.dispatchEvent( _mouseUpEvent ); } this.dragging = false; this.axis = null; } dispose() { this.domElement.removeEventListener( 'pointerdown', this._onPointerDown ); this.domElement.removeEventListener( 'pointermove', this._onPointerHover ); this.domElement.removeEventListener( 'pointermove', this._onPointerMove ); this.domElement.removeEventListener( 'pointerup', this._onPointerUp ); this.traverse( function ( child ) { if ( child.geometry ) child.geometry.dispose(); if ( child.material ) child.material.dispose(); } ); } // Set current object attach( object ) { this.object = object; this.visible = true; return this; } // Detach from object detach() { this.object = undefined; this.visible = false; this.axis = null; return this; } reset() { if ( ! this.enabled ) return; if ( this.dragging ) { this.object.position.copy( this._positionStart ); this.object.quaternion.copy( this._quaternionStart ); this.object.scale.copy( this._scaleStart ); this.dispatchEvent( _changeEvent ); this.dispatchEvent( _objectChangeEvent ); this.pointStart.copy( this.pointEnd ); } } getRaycaster() { return _raycaster; } // TODO: deprecate getMode() { return this.mode; } setMode( mode ) { this.mode = mode; } setTranslationSnap( translationSnap ) { this.translationSnap = translationSnap; } setRotationSnap( rotationSnap ) { this.rotationSnap = rotationSnap; } setScaleSnap( scaleSnap ) { this.scaleSnap = scaleSnap; } setSize( size ) { this.size = size; } setSpace( space ) { this.space = space; } } // mouse / touch event handlers function getPointer( event ) { if ( this.domElement.ownerDocument.pointerLockElement ) { return { x: 0, y: 0, button: event.button }; } else { const rect = this.domElement.getBoundingClientRect(); return { x: ( event.clientX - rect.left ) / rect.width * 2 - 1, y: - ( event.clientY - rect.top ) / rect.height * 2 + 1, button: event.button }; } } function onPointerHover( event ) { if ( ! this.enabled ) return; switch ( event.pointerType ) { case 'mouse': case 'pen': this.pointerHover( this._getPointer( event ) ); break; } } function onPointerDown( event ) { if ( ! this.enabled ) return; if ( ! document.pointerLockElement ) { this.domElement.setPointerCapture( event.pointerId ); } this.domElement.addEventListener( 'pointermove', this._onPointerMove ); this.pointerHover( this._getPointer( event ) ); this.pointerDown( this._getPointer( event ) ); } function onPointerMove( event ) { if ( ! this.enabled ) return; this.pointerMove( this._getPointer( event ) ); } function onPointerUp( event ) { if ( ! this.enabled ) return; this.domElement.releasePointerCapture( event.pointerId ); this.domElement.removeEventListener( 'pointermove', this._onPointerMove ); this.pointerUp( this._getPointer( event ) ); } function intersectObjectWithRay( object, raycaster, includeInvisible ) { const allIntersections = raycaster.intersectObject( object, true ); for ( let i = 0; i < allIntersections.length; i ++ ) { if ( allIntersections[ i ].object.visible || includeInvisible ) { return allIntersections[ i ]; } } return false; } // // Reusable utility variables const _tempEuler = new Euler(); const _alignVector = new Vector3( 0, 1, 0 ); const _zeroVector = new Vector3( 0, 0, 0 ); const _lookAtMatrix = new Matrix4(); const _tempQuaternion2 = new Quaternion(); const _identityQuaternion = new Quaternion(); const _dirVector = new Vector3(); const _tempMatrix = new Matrix4(); const _unitX = new Vector3( 1, 0, 0 ); const _unitY = new Vector3( 0, 1, 0 ); const _unitZ = new Vector3( 0, 0, 1 ); const _v1 = new Vector3(); const _v2 = new Vector3(); const _v3 = new Vector3(); class TransformControlsGizmo extends Object3D { constructor() { super(); this.isTransformControlsGizmo = true; this.type = 'TransformControlsGizmo'; // shared materials const gizmoMaterial = new MeshBasicMaterial( { depthTest: false, depthWrite: false, fog: false, toneMapped: false, transparent: true } ); const gizmoLineMaterial = new LineBasicMaterial( { depthTest: false, depthWrite: false, fog: false, toneMapped: false, transparent: true } ); // Make unique material for each axis/color const matInvisible = gizmoMaterial.clone(); matInvisible.opacity = 0.15; const matHelper = gizmoLineMaterial.clone(); matHelper.opacity = 0.5; const matRed = gizmoMaterial.clone(); matRed.color.setHex( 0xff0000 ); const matGreen = gizmoMaterial.clone(); matGreen.color.setHex( 0x00ff00 ); const matBlue = gizmoMaterial.clone(); matBlue.color.setHex( 0x0000ff ); const matRedTransparent = gizmoMaterial.clone(); matRedTransparent.color.setHex( 0xff0000 ); matRedTransparent.opacity = 0.5; const matGreenTransparent = gizmoMaterial.clone(); matGreenTransparent.color.setHex( 0x00ff00 ); matGreenTransparent.opacity = 0.5; const matBlueTransparent = gizmoMaterial.clone(); matBlueTransparent.color.setHex( 0x0000ff ); matBlueTransparent.opacity = 0.5; const matWhiteTransparent = gizmoMaterial.clone(); matWhiteTransparent.opacity = 0.25; const matYellowTransparent = gizmoMaterial.clone(); matYellowTransparent.color.setHex( 0xffff00 ); matYellowTransparent.opacity = 0.25; const matYellow = gizmoMaterial.clone(); matYellow.color.setHex( 0xffff00 ); const matGray = gizmoMaterial.clone(); matGray.color.setHex( 0x787878 ); // reusable geometry const arrowGeometry = new CylinderGeometry( 0, 0.04, 0.1, 12 ); arrowGeometry.translate( 0, 0.05, 0 ); const scaleHandleGeometry = new BoxGeometry( 0.08, 0.08, 0.08 ); scaleHandleGeometry.translate( 0, 0.04, 0 ); const lineGeometry = new BufferGeometry(); lineGeometry.setAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 1, 0, 0 ], 3 ) ); const lineGeometry2 = new CylinderGeometry( 0.0075, 0.0075, 0.5, 3 ); lineGeometry2.translate( 0, 0.25, 0 ); function CircleGeometry( radius, arc ) { const geometry = new TorusGeometry( radius, 0.0075, 3, 64, arc * Math.PI * 2 ); geometry.rotateY( Math.PI / 2 ); geometry.rotateX( Math.PI / 2 ); return geometry; } // Special geometry for transform helper. If scaled with position vector it spans from [0,0,0] to position function TranslateHelperGeometry() { const geometry = new BufferGeometry(); geometry.setAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 1, 1, 1 ], 3 ) ); return geometry; } // Gizmo definitions - custom hierarchy definitions for setupGizmo() function const gizmoTranslate = { X: [ [ new Mesh( arrowGeometry, matRed ), [ 0.5, 0, 0 ], [ 0, 0, - Math.PI / 2 ]], [ new Mesh( arrowGeometry, matRed ), [ - 0.5, 0, 0 ], [ 0, 0, Math.PI / 2 ]], [ new Mesh( lineGeometry2, matRed ), [ 0, 0, 0 ], [ 0, 0, - Math.PI / 2 ]] ], Y: [ [ new Mesh( arrowGeometry, matGreen ), [ 0, 0.5, 0 ]], [ new Mesh( arrowGeometry, matGreen ), [ 0, - 0.5, 0 ], [ Math.PI, 0, 0 ]], [ new Mesh( lineGeometry2, matGreen ) ] ], Z: [ [ new Mesh( arrowGeometry, matBlue ), [ 0, 0, 0.5 ], [ Math.PI / 2, 0, 0 ]], [ new Mesh( arrowGeometry, matBlue ), [ 0, 0, - 0.5 ], [ - Math.PI / 2, 0, 0 ]], [ new Mesh( lineGeometry2, matBlue ), null, [ Math.PI / 2, 0, 0 ]] ], XYZ: [ [ new Mesh( new OctahedronGeometry( 0.1, 0 ), matWhiteTransparent.clone() ), [ 0, 0, 0 ]] ], XY: [ [ new Mesh( new BoxGeometry( 0.15, 0.15, 0.01 ), matBlueTransparent.clone() ), [ 0.15, 0.15, 0 ]] ], YZ: [ [ new Mesh( new BoxGeometry( 0.15, 0.15, 0.01 ), matRedTransparent.clone() ), [ 0, 0.15, 0.15 ], [ 0, Math.PI / 2, 0 ]] ], XZ: [ [ new Mesh( new BoxGeometry( 0.15, 0.15, 0.01 ), matGreenTransparent.clone() ), [ 0.15, 0, 0.15 ], [ - Math.PI / 2, 0, 0 ]] ] }; const pickerTranslate = { X: [ [ new Mesh( new CylinderGeometry( 0.2, 0, 0.6, 4 ), matInvisible ), [ 0.3, 0, 0 ], [ 0, 0, - Math.PI / 2 ]], [ new Mesh( new CylinderGeometry( 0.2, 0, 0.6, 4 ), matInvisible ), [ - 0.3, 0, 0 ], [ 0, 0, Math.PI / 2 ]] ], Y: [ [ new Mesh( new CylinderGeometry( 0.2, 0, 0.6, 4 ), matInvisible ), [ 0, 0.3, 0 ]], [ new Mesh( new CylinderGeometry( 0.2, 0, 0.6, 4 ), matInvisible ), [ 0, - 0.3, 0 ], [ 0, 0, Math.PI ]] ], Z: [ [ new Mesh( new CylinderGeometry( 0.2, 0, 0.6, 4 ), matInvisible ), [ 0, 0, 0.3 ], [ Math.PI / 2, 0, 0 ]], [ new Mesh( new CylinderGeometry( 0.2, 0, 0.6, 4 ), matInvisible ), [ 0, 0, - 0.3 ], [ - Math.PI / 2, 0, 0 ]] ], XYZ: [ [ new Mesh( new OctahedronGeometry( 0.2, 0 ), matInvisible ) ] ], XY: [ [ new Mesh( new BoxGeometry( 0.2, 0.2, 0.01 ), matInvisible ), [ 0.15, 0.15, 0 ]] ], YZ: [ [ new Mesh( new BoxGeometry( 0.2, 0.2, 0.01 ), matInvisible ), [ 0, 0.15, 0.15 ], [ 0, Math.PI / 2, 0 ]] ], XZ: [ [ new Mesh( new BoxGeometry( 0.2, 0.2, 0.01 ), matInvisible ), [ 0.15, 0, 0.15 ], [ - Math.PI / 2, 0, 0 ]] ] }; const helperTranslate = { START: [ [ new Mesh( new OctahedronGeometry( 0.01, 2 ), matHelper ), null, null, null, 'helper' ] ], END: [ [ new Mesh( new OctahedronGeometry( 0.01, 2 ), matHelper ), null, null, null, 'helper' ] ], DELTA: [ [ new Line( TranslateHelperGeometry(), matHelper ), null, null, null, 'helper' ] ], X: [ [ new Line( lineGeometry, matHelper.clone() ), [ - 1e3, 0, 0 ], null, [ 1e6, 1, 1 ], 'helper' ] ], Y: [ [ new Line( lineGeometry, matHelper.clone() ), [ 0, - 1e3, 0 ], [ 0, 0, Math.PI / 2 ], [ 1e6, 1, 1 ], 'helper' ] ], Z: [ [ new Line( lineGeometry, matHelper.clone() ), [ 0, 0, - 1e3 ], [ 0, - Math.PI / 2, 0 ], [ 1e6, 1, 1 ], 'helper' ] ] }; const gizmoRotate = { XYZE: [ [ new Mesh( CircleGeometry( 0.5, 1 ), matGray ), null, [ 0, Math.PI / 2, 0 ]] ], X: [ [ new Mesh( CircleGeometry( 0.5, 0.5 ), matRed ) ] ], Y: [ [ new Mesh( CircleGeometry( 0.5, 0.5 ), matGreen ), null, [ 0, 0, - Math.PI / 2 ]] ], Z: [ [ new Mesh( CircleGeometry( 0.5, 0.5 ), matBlue ), null, [ 0, Math.PI / 2, 0 ]] ], E: [ [ new Mesh( CircleGeometry( 0.75, 1 ), matYellowTransparent ), null, [ 0, Math.PI / 2, 0 ]] ] }; const helperRotate = { AXIS: [ [ new Line( lineGeometry, matHelper.clone() ), [ - 1e3, 0, 0 ], null, [ 1e6, 1, 1 ], 'helper' ] ] }; const pickerRotate = { XYZE: [ [ new Mesh( new SphereGeometry( 0.25, 10, 8 ), matInvisible ) ] ], X: [ [ new Mesh( new TorusGeometry( 0.5, 0.1, 4, 24 ), matInvisible ), [ 0, 0, 0 ], [ 0, - Math.PI / 2, - Math.PI / 2 ]], ], Y: [ [ new Mesh( new TorusGeometry( 0.5, 0.1, 4, 24 ), matInvisible ), [ 0, 0, 0 ], [ Math.PI / 2, 0, 0 ]], ], Z: [ [ new Mesh( new TorusGeometry( 0.5, 0.1, 4, 24 ), matInvisible ), [ 0, 0, 0 ], [ 0, 0, - Math.PI / 2 ]], ], E: [ [ new Mesh( new TorusGeometry( 0.75, 0.1, 2, 24 ), matInvisible ) ] ] }; const gizmoScale = { X: [ [ new Mesh( scaleHandleGeometry, matRed ), [ 0.5, 0, 0 ], [ 0, 0, - Math.PI / 2 ]], [ new Mesh( lineGeometry2, matRed ), [ 0, 0, 0 ], [ 0, 0, - Math.PI / 2 ]], [ new Mesh( scaleHandleGeometry, matRed ), [ - 0.5, 0, 0 ], [ 0, 0, Math.PI / 2 ]], ], Y: [ [ new Mesh( scaleHandleGeometry, matGreen ), [ 0, 0.5, 0 ]], [ new Mesh( lineGeometry2, matGreen ) ], [ new Mesh( scaleHandleGeometry, matGreen ), [ 0, - 0.5, 0 ], [ 0, 0, Math.PI ]], ], Z: [ [ new Mesh( scaleHandleGeometry, matBlue ), [ 0, 0, 0.5 ], [ Math.PI / 2, 0, 0 ]], [ new Mesh( lineGeometry2, matBlue ), [ 0, 0, 0 ], [ Math.PI / 2, 0, 0 ]], [ new Mesh( scaleHandleGeometry, matBlue ), [ 0, 0, - 0.5 ], [ - Math.PI / 2, 0, 0 ]] ], XY: [ [ new Mesh( new BoxGeometry( 0.15, 0.15, 0.01 ), matBlueTransparent ), [ 0.15, 0.15, 0 ]] ], YZ: [ [ new Mesh( new BoxGeometry( 0.15, 0.15, 0.01 ), matRedTransparent ), [ 0, 0.15, 0.15 ], [ 0, Math.PI / 2, 0 ]] ], XZ: [ [ new Mesh( new BoxGeometry( 0.15, 0.15, 0.01 ), matGreenTransparent ), [ 0.15, 0, 0.15 ], [ - Math.PI / 2, 0, 0 ]] ], XYZ: [ [ new Mesh( new BoxGeometry( 0.1, 0.1, 0.1 ), matWhiteTransparent.clone() ) ], ] }; const pickerScale = { X: [ [ new Mesh( new CylinderGeometry( 0.2, 0, 0.6, 4 ), matInvisible ), [ 0.3, 0, 0 ], [ 0, 0, - Math.PI / 2 ]], [ new Mesh( new CylinderGeometry( 0.2, 0, 0.6, 4 ), matInvisible ), [ - 0.3, 0, 0 ], [ 0, 0, Math.PI / 2 ]] ], Y: [ [ new Mesh( new CylinderGeometry( 0.2, 0, 0.6, 4 ), matInvisible ), [ 0, 0.3, 0 ]], [ new Mesh( new CylinderGeometry( 0.2, 0, 0.6, 4 ), matInvisible ), [ 0, - 0.3, 0 ], [ 0, 0, Math.PI ]] ], Z: [ [ new Mesh( new CylinderGeometry( 0.2, 0, 0.6, 4 ), matInvisible ), [ 0, 0, 0.3 ], [ Math.PI / 2, 0, 0 ]], [ new Mesh( new CylinderGeometry( 0.2, 0, 0.6, 4 ), matInvisible ), [ 0, 0, - 0.3 ], [ - Math.PI / 2, 0, 0 ]] ], XY: [ [ new Mesh( new BoxGeometry( 0.2, 0.2, 0.01 ), matInvisible ), [ 0.15, 0.15, 0 ]], ], YZ: [ [ new Mesh( new BoxGeometry( 0.2, 0.2, 0.01 ), matInvisible ), [ 0, 0.15, 0.15 ], [ 0, Math.PI / 2, 0 ]], ], XZ: [ [ new Mesh( new BoxGeometry( 0.2, 0.2, 0.01 ), matInvisible ), [ 0.15, 0, 0.15 ], [ - Math.PI / 2, 0, 0 ]], ], XYZ: [ [ new Mesh( new BoxGeometry( 0.2, 0.2, 0.2 ), matInvisible ), [ 0, 0, 0 ]], ] }; const helperScale = { X: [ [ new Line( lineGeometry, matHelper.clone() ), [ - 1e3, 0, 0 ], null, [ 1e6, 1, 1 ], 'helper' ] ], Y: [ [ new Line( lineGeometry, matHelper.clone() ), [ 0, - 1e3, 0 ], [ 0, 0, Math.PI / 2 ], [ 1e6, 1, 1 ], 'helper' ] ], Z: [ [ new Line( lineGeometry, matHelper.clone() ), [ 0, 0, - 1e3 ], [ 0, - Math.PI / 2, 0 ], [ 1e6, 1, 1 ], 'helper' ] ] }; // Creates an Object3D with gizmos described in custom hierarchy definition. function setupGizmo( gizmoMap ) { const gizmo = new Object3D(); for ( const name in gizmoMap ) { for ( let i = gizmoMap[ name ].length; i --; ) { const object = gizmoMap[ name ][ i ][ 0 ].clone(); const position = gizmoMap[ name ][ i ][ 1 ]; const rotation = gizmoMap[ name ][ i ][ 2 ]; const scale = gizmoMap[ name ][ i ][ 3 ]; const tag = gizmoMap[ name ][ i ][ 4 ]; // name and tag properties are essential for picking and updating logic. object.name = name; object.tag = tag; if ( position ) { object.position.set( position[ 0 ], position[ 1 ], position[ 2 ] ); } if ( rotation ) { object.rotation.set( rotation[ 0 ], rotation[ 1 ], rotation[ 2 ] ); } if ( scale ) { object.scale.set( scale[ 0 ], scale[ 1 ], scale[ 2 ] ); } object.updateMatrix(); const tempGeometry = object.geometry.clone(); tempGeometry.applyMatrix4( object.matrix ); object.geometry = tempGeometry; object.renderOrder = Infinity; object.position.set( 0, 0, 0 ); object.rotation.set( 0, 0, 0 ); object.scale.set( 1, 1, 1 ); gizmo.add( object ); } } return gizmo; } // Gizmo creation this.gizmo = {}; this.picker = {}; this.helper = {}; this.add( this.gizmo[ 'translate' ] = setupGizmo( gizmoTranslate ) ); this.add( this.gizmo[ 'rotate' ] = setupGizmo( gizmoRotate ) ); this.add( this.gizmo[ 'scale' ] = setupGizmo( gizmoScale ) ); this.add( this.picker[ 'translate' ] = setupGizmo( pickerTranslate ) ); this.add( this.picker[ 'rotate' ] = setupGizmo( pickerRotate ) ); this.add( this.picker[ 'scale' ] = setupGizmo( pickerScale ) ); this.add( this.helper[ 'translate' ] = setupGizmo( helperTranslate ) ); this.add( this.helper[ 'rotate' ] = setupGizmo( helperRotate ) ); this.add( this.helper[ 'scale' ] = setupGizmo( helperScale ) ); // Pickers should be hidden always this.picker[ 'translate' ].visible = false; this.picker[ 'rotate' ].visible = false; this.picker[ 'scale' ].visible = false; } // updateMatrixWorld will update transformations and appearance of individual handles updateMatrixWorld( force ) { const space = ( this.mode === 'scale' ) ? 'local' : this.space; // scale always oriented to local rotation const quaternion = ( space === 'local' ) ? this.worldQuaternion : _identityQuaternion; // Show only gizmos for current transform mode this.gizmo[ 'translate' ].visible = this.mode === 'translate'; this.gizmo[ 'rotate' ].visible = this.mode === 'rotate'; this.gizmo[ 'scale' ].visible = this.mode === 'scale'; this.helper[ 'translate' ].visible = this.mode === 'translate'; this.helper[ 'rotate' ].visible = this.mode === 'rotate'; this.helper[ 'scale' ].visible = this.mode === 'scale'; let handles = []; handles = handles.concat( this.picker[ this.mode ].children ); handles = handles.concat( this.gizmo[ this.mode ].children ); handles = handles.concat( this.helper[ this.mode ].children ); for ( let i = 0; i < handles.length; i ++ ) { const handle = handles[ i ]; // hide aligned to camera handle.visible = true; handle.rotation.set( 0, 0, 0 ); handle.position.copy( this.worldPosition ); let factor; if ( this.camera.isOrthographicCamera ) { factor = ( this.camera.top - this.camera.bottom ) / this.camera.zoom; } else { factor = this.worldPosition.distanceTo( this.cameraPosition ) * Math.min( 1.9 * Math.tan( Math.PI * this.camera.fov / 360 ) / this.camera.zoom, 7 ); } handle.scale.set( 1, 1, 1 ).multiplyScalar( factor * this.size / 4 ); // TODO: simplify helpers and consider decoupling from gizmo if ( handle.tag === 'helper' ) { handle.visible = false; if ( handle.name === 'AXIS' ) { handle.visible = !! this.axis; if ( this.axis === 'X' ) { _tempQuaternion.setFromEuler( _tempEuler.set( 0, 0, 0 ) ); handle.quaternion.copy( quaternion ).multiply( _tempQuaternion ); if ( Math.abs( _alignVector.copy( _unitX ).applyQuaternion( quaternion ).dot( this.eye ) ) > 0.9 ) { handle.visible = false; } } if ( this.axis === 'Y' ) { _tempQuaternion.setFromEuler( _tempEuler.set( 0, 0, Math.PI / 2 ) ); handle.quaternion.copy( quaternion ).multiply( _tempQuaternion ); if ( Math.abs( _alignVector.copy( _unitY ).applyQuaternion( quaternion ).dot( this.eye ) ) > 0.9 ) { handle.visible = false; } } if ( this.axis === 'Z' ) { _tempQuaternion.setFromEuler( _tempEuler.set( 0, Math.PI / 2, 0 ) ); handle.quaternion.copy( quaternion ).multiply( _tempQuaternion ); if ( Math.abs( _alignVector.copy( _unitZ ).applyQuaternion( quaternion ).dot( this.eye ) ) > 0.9 ) { handle.visible = false; } } if ( this.axis === 'XYZE' ) { _tempQuaternion.setFromEuler( _tempEuler.set( 0, Math.PI / 2, 0 ) ); _alignVector.copy( this.rotationAxis ); handle.quaternion.setFromRotationMatrix( _lookAtMatrix.lookAt( _zeroVector, _alignVector, _unitY ) ); handle.quaternion.multiply( _tempQuaternion ); handle.visible = this.dragging; } if ( this.axis === 'E' ) { handle.visible = false; } } else if ( handle.name === 'START' ) { handle.position.copy( this.worldPositionStart ); handle.visible = this.dragging; } else if ( handle.name === 'END' ) { handle.position.copy( this.worldPosition ); handle.visible = this.dragging; } else if ( handle.name === 'DELTA' ) { handle.position.copy( this.worldPositionStart ); handle.quaternion.copy( this.worldQuaternionStart ); _tempVector.set( 1e-10, 1e-10, 1e-10 ).add( this.worldPositionStart ).sub( this.worldPosition ).multiplyScalar( - 1 ); _tempVector.applyQuaternion( this.worldQuaternionStart.clone().invert() ); handle.scale.copy( _tempVector ); handle.visible = this.dragging; } else { handle.quaternion.copy( quaternion ); if ( this.dragging ) { handle.position.copy( this.worldPositionStart ); } else { handle.position.copy( this.worldPosition ); } if ( this.axis ) { handle.visible = this.axis.search( handle.name ) !== - 1; } } // If updating helper, skip rest of the loop continue; } // Align handles to current local or world rotation handle.quaternion.copy( quaternion ); if ( this.mode === 'translate' || this.mode === 'scale' ) { // Hide translate and scale axis facing the camera const AXIS_HIDE_THRESHOLD = 0.99; const PLANE_HIDE_THRESHOLD = 0.2; if ( handle.name === 'X' ) { if ( Math.abs( _alignVector.copy( _unitX ).applyQuaternion( quaternion ).dot( this.eye ) ) > AXIS_HIDE_THRESHOLD ) { handle.scale.set( 1e-10, 1e-10, 1e-10 ); handle.visible = false; } } if ( handle.name === 'Y' ) { if ( Math.abs( _alignVector.copy( _unitY ).applyQuaternion( quaternion ).dot( this.eye ) ) > AXIS_HIDE_THRESHOLD ) { handle.scale.set( 1e-10, 1e-10, 1e-10 ); handle.visible = false; } } if ( handle.name === 'Z' ) { if ( Math.abs( _alignVector.copy( _unitZ ).applyQuaternion( quaternion ).dot( this.eye ) ) > AXIS_HIDE_THRESHOLD ) { handle.scale.set( 1e-10, 1e-10, 1e-10 ); handle.visible = false; } } if ( handle.name === 'XY' ) { if ( Math.abs( _alignVector.copy( _unitZ ).applyQuaternion( quaternion ).dot( this.eye ) ) < PLANE_HIDE_THRESHOLD ) { handle.scale.set( 1e-10, 1e-10, 1e-10 ); handle.visible = false; } } if ( handle.name === 'YZ' ) { if ( Math.abs( _alignVector.copy( _unitX ).applyQuaternion( quaternion ).dot( this.eye ) ) < PLANE_HIDE_THRESHOLD ) { handle.scale.set( 1e-10, 1e-10, 1e-10 ); handle.visible = false; } } if ( handle.name === 'XZ' ) { if ( Math.abs( _alignVector.copy( _unitY ).applyQuaternion( quaternion ).dot( this.eye ) ) < PLANE_HIDE_THRESHOLD ) { handle.scale.set( 1e-10, 1e-10, 1e-10 ); handle.visible = false; } } } else if ( this.mode === 'rotate' ) { // Align handles to current local or world rotation _tempQuaternion2.copy( quaternion ); _alignVector.copy( this.eye ).applyQuaternion( _tempQuaternion.copy( quaternion ).invert() ); if ( handle.name.search( 'E' ) !== - 1 ) { handle.quaternion.setFromRotationMatrix( _lookAtMatrix.lookAt( this.eye, _zeroVector, _unitY ) ); } if ( handle.name === 'X' ) { _tempQuaternion.setFromAxisAngle( _unitX, Math.atan2( - _alignVector.y, _alignVector.z ) ); _tempQuaternion.multiplyQuaternions( _tempQuaternion2, _tempQuaternion ); handle.quaternion.copy( _tempQuaternion ); } if ( handle.name === 'Y' ) { _tempQuaternion.setFromAxisAngle( _unitY, Math.atan2( _alignVector.x, _alignVector.z ) ); _tempQuaternion.multiplyQuaternions( _tempQuaternion2, _tempQuaternion ); handle.quaternion.copy( _tempQuaternion ); } if ( handle.name === 'Z' ) { _tempQuaternion.setFromAxisAngle( _unitZ, Math.atan2( _alignVector.y, _alignVector.x ) ); _tempQuaternion.multiplyQuaternions( _tempQuaternion2, _tempQuaternion ); handle.quaternion.copy( _tempQuaternion ); } } // Hide disabled axes handle.visible = handle.visible && ( handle.name.indexOf( 'X' ) === - 1 || this.showX ); handle.visible = handle.visible && ( handle.name.indexOf( 'Y' ) === - 1 || this.showY ); handle.visible = handle.visible && ( handle.name.indexOf( 'Z' ) === - 1 || this.showZ ); handle.visible = handle.visible && ( handle.name.indexOf( 'E' ) === - 1 || ( this.showX && this.showY && this.showZ ) ); // highlight selected axis handle.material._color = handle.material._color || handle.material.color.clone(); handle.material._opacity = handle.material._opacity || handle.material.opacity; handle.material.color.copy( handle.material._color ); handle.material.opacity = handle.material._opacity; if ( this.enabled && this.axis ) { if ( handle.name === this.axis ) { handle.material.color.setHex( 0xffff00 ); handle.material.opacity = 1.0; } else if ( this.axis.split( '' ).some( function ( a ) { return handle.name === a; } ) ) { handle.material.color.setHex( 0xffff00 ); handle.material.opacity = 1.0; } } } super.updateMatrixWorld( force ); } } // class TransformControlsPlane extends Mesh { constructor() { super( new PlaneGeometry( 100000, 100000, 2, 2 ), new MeshBasicMaterial( { visible: false, wireframe: true, side: DoubleSide, transparent: true, opacity: 0.1, toneMapped: false } ) ); this.isTransformControlsPlane = true; this.type = 'TransformControlsPlane'; } updateMatrixWorld( force ) { let space = this.space; this.position.copy( this.worldPosition ); if ( this.mode === 'scale' ) space = 'local'; // scale always oriented to local rotation _v1.copy( _unitX ).applyQuaternion( space === 'local' ? this.worldQuaternion : _identityQuaternion ); _v2.copy( _unitY ).applyQuaternion( space === 'local' ? this.worldQuaternion : _identityQuaternion ); _v3.copy( _unitZ ).applyQuaternion( space === 'local' ? this.worldQuaternion : _identityQuaternion ); // Align the plane for current transform mode, axis and space. _alignVector.copy( _v2 ); switch ( this.mode ) { case 'translate': case 'scale': switch ( this.axis ) { case 'X': _alignVector.copy( this.eye ).cross( _v1 ); _dirVector.copy( _v1 ).cross( _alignVector ); break; case 'Y': _alignVector.copy( this.eye ).cross( _v2 ); _dirVector.copy( _v2 ).cross( _alignVector ); break; case 'Z': _alignVector.copy( this.eye ).cross( _v3 ); _dirVector.copy( _v3 ).cross( _alignVector ); break; case 'XY': _dirVector.copy( _v3 ); break; case 'YZ': _dirVector.copy( _v1 ); break; case 'XZ': _alignVector.copy( _v3 ); _dirVector.copy( _v2 ); break; case 'XYZ': case 'E': _dirVector.set( 0, 0, 0 ); break; } break; case 'rotate': default: // special case for rotate _dirVector.set( 0, 0, 0 ); } if ( _dirVector.length() === 0 ) { // If in rotate mode, make the plane parallel to camera this.quaternion.copy( this.cameraQuaternion ); } else { _tempMatrix.lookAt( _tempVector.set( 0, 0, 0 ), _dirVector, _alignVector ); this.quaternion.setFromRotationMatrix( _tempMatrix ); } super.updateMatrixWorld( force ); } } export { TransformControls, TransformControlsGizmo, TransformControlsPlane };"},{"title":"","date":"2023-10-12T14:08:40.264Z","updated":"2023-10-12T14:08:40.264Z","comments":true,"path":"js/three/jsm/controls/TrackballControls.js","permalink":"http://19999997.xyz/js/three/jsm/controls/TrackballControls.js","excerpt":"","text":"import { EventDispatcher, MathUtils, MOUSE, Quaternion, Vector2, Vector3 } from 'three'; const _changeEvent = { type: 'change' }; const _startEvent = { type: 'start' }; const _endEvent = { type: 'end' }; class TrackballControls extends EventDispatcher { constructor( object, domElement ) { super(); const scope = this; const STATE = { NONE: - 1, ROTATE: 0, ZOOM: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_ZOOM_PAN: 4 }; this.object = object; this.domElement = domElement; this.domElement.style.touchAction = 'none'; // disable touch scroll // API this.enabled = true; this.screen = { left: 0, top: 0, width: 0, height: 0 }; this.rotateSpeed = 1.0; this.zoomSpeed = 1.2; this.panSpeed = 0.3; this.noRotate = false; this.noZoom = false; this.noPan = false; this.staticMoving = false; this.dynamicDampingFactor = 0.2; this.minDistance = 0; this.maxDistance = Infinity; this.minZoom = 0; this.maxZoom = Infinity; this.keys = [ 'KeyA' /*A*/, 'KeyS' /*S*/, 'KeyD' /*D*/ ]; this.mouseButtons = { LEFT: MOUSE.ROTATE, MIDDLE: MOUSE.DOLLY, RIGHT: MOUSE.PAN }; // internals this.target = new Vector3(); const EPS = 0.000001; const lastPosition = new Vector3(); let lastZoom = 1; let _state = STATE.NONE, _keyState = STATE.NONE, _touchZoomDistanceStart = 0, _touchZoomDistanceEnd = 0, _lastAngle = 0; const _eye = new Vector3(), _movePrev = new Vector2(), _moveCurr = new Vector2(), _lastAxis = new Vector3(), _zoomStart = new Vector2(), _zoomEnd = new Vector2(), _panStart = new Vector2(), _panEnd = new Vector2(), _pointers = [], _pointerPositions = {}; // for reset this.target0 = this.target.clone(); this.position0 = this.object.position.clone(); this.up0 = this.object.up.clone(); this.zoom0 = this.object.zoom; // methods this.handleResize = function () { const box = scope.domElement.getBoundingClientRect(); // adjustments come from similar code in the jquery offset() function const d = scope.domElement.ownerDocument.documentElement; scope.screen.left = box.left + window.pageXOffset - d.clientLeft; scope.screen.top = box.top + window.pageYOffset - d.clientTop; scope.screen.width = box.width; scope.screen.height = box.height; }; const getMouseOnScreen = ( function () { const vector = new Vector2(); return function getMouseOnScreen( pageX, pageY ) { vector.set( ( pageX - scope.screen.left ) / scope.screen.width, ( pageY - scope.screen.top ) / scope.screen.height ); return vector; }; }() ); const getMouseOnCircle = ( function () { const vector = new Vector2(); return function getMouseOnCircle( pageX, pageY ) { vector.set( ( ( pageX - scope.screen.width * 0.5 - scope.screen.left ) / ( scope.screen.width * 0.5 ) ), ( ( scope.screen.height + 2 * ( scope.screen.top - pageY ) ) / scope.screen.width ) // screen.width intentional ); return vector; }; }() ); this.rotateCamera = ( function () { const axis = new Vector3(), quaternion = new Quaternion(), eyeDirection = new Vector3(), objectUpDirection = new Vector3(), objectSidewaysDirection = new Vector3(), moveDirection = new Vector3(); return function rotateCamera() { moveDirection.set( _moveCurr.x - _movePrev.x, _moveCurr.y - _movePrev.y, 0 ); let angle = moveDirection.length(); if ( angle ) { _eye.copy( scope.object.position ).sub( scope.target ); eyeDirection.copy( _eye ).normalize(); objectUpDirection.copy( scope.object.up ).normalize(); objectSidewaysDirection.crossVectors( objectUpDirection, eyeDirection ).normalize(); objectUpDirection.setLength( _moveCurr.y - _movePrev.y ); objectSidewaysDirection.setLength( _moveCurr.x - _movePrev.x ); moveDirection.copy( objectUpDirection.add( objectSidewaysDirection ) ); axis.crossVectors( moveDirection, _eye ).normalize(); angle *= scope.rotateSpeed; quaternion.setFromAxisAngle( axis, angle ); _eye.applyQuaternion( quaternion ); scope.object.up.applyQuaternion( quaternion ); _lastAxis.copy( axis ); _lastAngle = angle; } else if ( ! scope.staticMoving && _lastAngle ) { _lastAngle *= Math.sqrt( 1.0 - scope.dynamicDampingFactor ); _eye.copy( scope.object.position ).sub( scope.target ); quaternion.setFromAxisAngle( _lastAxis, _lastAngle ); _eye.applyQuaternion( quaternion ); scope.object.up.applyQuaternion( quaternion ); } _movePrev.copy( _moveCurr ); }; }() ); this.zoomCamera = function () { let factor; if ( _state === STATE.TOUCH_ZOOM_PAN ) { factor = _touchZoomDistanceStart / _touchZoomDistanceEnd; _touchZoomDistanceStart = _touchZoomDistanceEnd; if ( scope.object.isPerspectiveCamera ) { _eye.multiplyScalar( factor ); } else if ( scope.object.isOrthographicCamera ) { scope.object.zoom = MathUtils.clamp( scope.object.zoom / factor, scope.minZoom, scope.maxZoom ); if ( lastZoom !== scope.object.zoom ) { scope.object.updateProjectionMatrix(); } } else { console.warn( 'THREE.TrackballControls: Unsupported camera type' ); } } else { factor = 1.0 + ( _zoomEnd.y - _zoomStart.y ) * scope.zoomSpeed; if ( factor !== 1.0 && factor > 0.0 ) { if ( scope.object.isPerspectiveCamera ) { _eye.multiplyScalar( factor ); } else if ( scope.object.isOrthographicCamera ) { scope.object.zoom = MathUtils.clamp( scope.object.zoom / factor, scope.minZoom, scope.maxZoom ); if ( lastZoom !== scope.object.zoom ) { scope.object.updateProjectionMatrix(); } } else { console.warn( 'THREE.TrackballControls: Unsupported camera type' ); } } if ( scope.staticMoving ) { _zoomStart.copy( _zoomEnd ); } else { _zoomStart.y += ( _zoomEnd.y - _zoomStart.y ) * this.dynamicDampingFactor; } } }; this.panCamera = ( function () { const mouseChange = new Vector2(), objectUp = new Vector3(), pan = new Vector3(); return function panCamera() { mouseChange.copy( _panEnd ).sub( _panStart ); if ( mouseChange.lengthSq() ) { if ( scope.object.isOrthographicCamera ) { const scale_x = ( scope.object.right - scope.object.left ) / scope.object.zoom / scope.domElement.clientWidth; const scale_y = ( scope.object.top - scope.object.bottom ) / scope.object.zoom / scope.domElement.clientWidth; mouseChange.x *= scale_x; mouseChange.y *= scale_y; } mouseChange.multiplyScalar( _eye.length() * scope.panSpeed ); pan.copy( _eye ).cross( scope.object.up ).setLength( mouseChange.x ); pan.add( objectUp.copy( scope.object.up ).setLength( mouseChange.y ) ); scope.object.position.add( pan ); scope.target.add( pan ); if ( scope.staticMoving ) { _panStart.copy( _panEnd ); } else { _panStart.add( mouseChange.subVectors( _panEnd, _panStart ).multiplyScalar( scope.dynamicDampingFactor ) ); } } }; }() ); this.checkDistances = function () { if ( ! scope.noZoom || ! scope.noPan ) { if ( _eye.lengthSq() > scope.maxDistance * scope.maxDistance ) { scope.object.position.addVectors( scope.target, _eye.setLength( scope.maxDistance ) ); _zoomStart.copy( _zoomEnd ); } if ( _eye.lengthSq() < scope.minDistance * scope.minDistance ) { scope.object.position.addVectors( scope.target, _eye.setLength( scope.minDistance ) ); _zoomStart.copy( _zoomEnd ); } } }; this.update = function () { _eye.subVectors( scope.object.position, scope.target ); if ( ! scope.noRotate ) { scope.rotateCamera(); } if ( ! scope.noZoom ) { scope.zoomCamera(); } if ( ! scope.noPan ) { scope.panCamera(); } scope.object.position.addVectors( scope.target, _eye ); if ( scope.object.isPerspectiveCamera ) { scope.checkDistances(); scope.object.lookAt( scope.target ); if ( lastPosition.distanceToSquared( scope.object.position ) > EPS ) { scope.dispatchEvent( _changeEvent ); lastPosition.copy( scope.object.position ); } } else if ( scope.object.isOrthographicCamera ) { scope.object.lookAt( scope.target ); if ( lastPosition.distanceToSquared( scope.object.position ) > EPS || lastZoom !== scope.object.zoom ) { scope.dispatchEvent( _changeEvent ); lastPosition.copy( scope.object.position ); lastZoom = scope.object.zoom; } } else { console.warn( 'THREE.TrackballControls: Unsupported camera type' ); } }; this.reset = function () { _state = STATE.NONE; _keyState = STATE.NONE; scope.target.copy( scope.target0 ); scope.object.position.copy( scope.position0 ); scope.object.up.copy( scope.up0 ); scope.object.zoom = scope.zoom0; scope.object.updateProjectionMatrix(); _eye.subVectors( scope.object.position, scope.target ); scope.object.lookAt( scope.target ); scope.dispatchEvent( _changeEvent ); lastPosition.copy( scope.object.position ); lastZoom = scope.object.zoom; }; // listeners function onPointerDown( event ) { if ( scope.enabled === false ) return; if ( _pointers.length === 0 ) { scope.domElement.setPointerCapture( event.pointerId ); scope.domElement.addEventListener( 'pointermove', onPointerMove ); scope.domElement.addEventListener( 'pointerup', onPointerUp ); } // addPointer( event ); if ( event.pointerType === 'touch' ) { onTouchStart( event ); } else { onMouseDown( event ); } } function onPointerMove( event ) { if ( scope.enabled === false ) return; if ( event.pointerType === 'touch' ) { onTouchMove( event ); } else { onMouseMove( event ); } } function onPointerUp( event ) { if ( scope.enabled === false ) return; if ( event.pointerType === 'touch' ) { onTouchEnd( event ); } else { onMouseUp(); } // removePointer( event ); if ( _pointers.length === 0 ) { scope.domElement.releasePointerCapture( event.pointerId ); scope.domElement.removeEventListener( 'pointermove', onPointerMove ); scope.domElement.removeEventListener( 'pointerup', onPointerUp ); } } function onPointerCancel( event ) { removePointer( event ); } function keydown( event ) { if ( scope.enabled === false ) return; window.removeEventListener( 'keydown', keydown ); if ( _keyState !== STATE.NONE ) { return; } else if ( event.code === scope.keys[ STATE.ROTATE ] && ! scope.noRotate ) { _keyState = STATE.ROTATE; } else if ( event.code === scope.keys[ STATE.ZOOM ] && ! scope.noZoom ) { _keyState = STATE.ZOOM; } else if ( event.code === scope.keys[ STATE.PAN ] && ! scope.noPan ) { _keyState = STATE.PAN; } } function keyup() { if ( scope.enabled === false ) return; _keyState = STATE.NONE; window.addEventListener( 'keydown', keydown ); } function onMouseDown( event ) { if ( _state === STATE.NONE ) { switch ( event.button ) { case scope.mouseButtons.LEFT: _state = STATE.ROTATE; break; case scope.mouseButtons.MIDDLE: _state = STATE.ZOOM; break; case scope.mouseButtons.RIGHT: _state = STATE.PAN; break; } } const state = ( _keyState !== STATE.NONE ) ? _keyState : _state; if ( state === STATE.ROTATE && ! scope.noRotate ) { _moveCurr.copy( getMouseOnCircle( event.pageX, event.pageY ) ); _movePrev.copy( _moveCurr ); } else if ( state === STATE.ZOOM && ! scope.noZoom ) { _zoomStart.copy( getMouseOnScreen( event.pageX, event.pageY ) ); _zoomEnd.copy( _zoomStart ); } else if ( state === STATE.PAN && ! scope.noPan ) { _panStart.copy( getMouseOnScreen( event.pageX, event.pageY ) ); _panEnd.copy( _panStart ); } scope.dispatchEvent( _startEvent ); } function onMouseMove( event ) { const state = ( _keyState !== STATE.NONE ) ? _keyState : _state; if ( state === STATE.ROTATE && ! scope.noRotate ) { _movePrev.copy( _moveCurr ); _moveCurr.copy( getMouseOnCircle( event.pageX, event.pageY ) ); } else if ( state === STATE.ZOOM && ! scope.noZoom ) { _zoomEnd.copy( getMouseOnScreen( event.pageX, event.pageY ) ); } else if ( state === STATE.PAN && ! scope.noPan ) { _panEnd.copy( getMouseOnScreen( event.pageX, event.pageY ) ); } } function onMouseUp() { _state = STATE.NONE; scope.dispatchEvent( _endEvent ); } function onMouseWheel( event ) { if ( scope.enabled === false ) return; if ( scope.noZoom === true ) return; event.preventDefault(); switch ( event.deltaMode ) { case 2: // Zoom in pages _zoomStart.y -= event.deltaY * 0.025; break; case 1: // Zoom in lines _zoomStart.y -= event.deltaY * 0.01; break; default: // undefined, 0, assume pixels _zoomStart.y -= event.deltaY * 0.00025; break; } scope.dispatchEvent( _startEvent ); scope.dispatchEvent( _endEvent ); } function onTouchStart( event ) { trackPointer( event ); switch ( _pointers.length ) { case 1: _state = STATE.TOUCH_ROTATE; _moveCurr.copy( getMouseOnCircle( _pointers[ 0 ].pageX, _pointers[ 0 ].pageY ) ); _movePrev.copy( _moveCurr ); break; default: // 2 or more _state = STATE.TOUCH_ZOOM_PAN; const dx = _pointers[ 0 ].pageX - _pointers[ 1 ].pageX; const dy = _pointers[ 0 ].pageY - _pointers[ 1 ].pageY; _touchZoomDistanceEnd = _touchZoomDistanceStart = Math.sqrt( dx * dx + dy * dy ); const x = ( _pointers[ 0 ].pageX + _pointers[ 1 ].pageX ) / 2; const y = ( _pointers[ 0 ].pageY + _pointers[ 1 ].pageY ) / 2; _panStart.copy( getMouseOnScreen( x, y ) ); _panEnd.copy( _panStart ); break; } scope.dispatchEvent( _startEvent ); } function onTouchMove( event ) { trackPointer( event ); switch ( _pointers.length ) { case 1: _movePrev.copy( _moveCurr ); _moveCurr.copy( getMouseOnCircle( event.pageX, event.pageY ) ); break; default: // 2 or more const position = getSecondPointerPosition( event ); const dx = event.pageX - position.x; const dy = event.pageY - position.y; _touchZoomDistanceEnd = Math.sqrt( dx * dx + dy * dy ); const x = ( event.pageX + position.x ) / 2; const y = ( event.pageY + position.y ) / 2; _panEnd.copy( getMouseOnScreen( x, y ) ); break; } } function onTouchEnd( event ) { switch ( _pointers.length ) { case 0: _state = STATE.NONE; break; case 1: _state = STATE.TOUCH_ROTATE; _moveCurr.copy( getMouseOnCircle( event.pageX, event.pageY ) ); _movePrev.copy( _moveCurr ); break; case 2: _state = STATE.TOUCH_ZOOM_PAN; for ( let i = 0; i < _pointers.length; i ++ ) { if ( _pointers[ i ].pointerId !== event.pointerId ) { const position = _pointerPositions[ _pointers[ i ].pointerId ]; _moveCurr.copy( getMouseOnCircle( position.x, position.y ) ); _movePrev.copy( _moveCurr ); break; } } break; } scope.dispatchEvent( _endEvent ); } function contextmenu( event ) { if ( scope.enabled === false ) return; event.preventDefault(); } function addPointer( event ) { _pointers.push( event ); } function removePointer( event ) { delete _pointerPositions[ event.pointerId ]; for ( let i = 0; i < _pointers.length; i ++ ) { if ( _pointers[ i ].pointerId == event.pointerId ) { _pointers.splice( i, 1 ); return; } } } function trackPointer( event ) { let position = _pointerPositions[ event.pointerId ]; if ( position === undefined ) { position = new Vector2(); _pointerPositions[ event.pointerId ] = position; } position.set( event.pageX, event.pageY ); } function getSecondPointerPosition( event ) { const pointer = ( event.pointerId === _pointers[ 0 ].pointerId ) ? _pointers[ 1 ] : _pointers[ 0 ]; return _pointerPositions[ pointer.pointerId ]; } this.dispose = function () { scope.domElement.removeEventListener( 'contextmenu', contextmenu ); scope.domElement.removeEventListener( 'pointerdown', onPointerDown ); scope.domElement.removeEventListener( 'pointercancel', onPointerCancel ); scope.domElement.removeEventListener( 'wheel', onMouseWheel ); scope.domElement.removeEventListener( 'pointermove', onPointerMove ); scope.domElement.removeEventListener( 'pointerup', onPointerUp ); window.removeEventListener( 'keydown', keydown ); window.removeEventListener( 'keyup', keyup ); }; this.domElement.addEventListener( 'contextmenu', contextmenu ); this.domElement.addEventListener( 'pointerdown', onPointerDown ); this.domElement.addEventListener( 'pointercancel', onPointerCancel ); this.domElement.addEventListener( 'wheel', onMouseWheel, { passive: false } ); window.addEventListener( 'keydown', keydown ); window.addEventListener( 'keyup', keyup ); this.handleResize(); // force an update at start this.update(); } } export { TrackballControls };"},{"title":"","date":"2023-10-12T14:08:41.746Z","updated":"2023-10-12T14:08:41.746Z","comments":true,"path":"js/three/jsm/utils/BufferGeometryUtils.js","permalink":"http://19999997.xyz/js/three/jsm/utils/BufferGeometryUtils.js","excerpt":"","text":"import { BufferAttribute, BufferGeometry, Float32BufferAttribute, InstancedBufferAttribute, InterleavedBuffer, InterleavedBufferAttribute, TriangleFanDrawMode, TriangleStripDrawMode, TrianglesDrawMode, Vector3, } from 'three'; function computeMikkTSpaceTangents( geometry, MikkTSpace, negateSign = true ) { if ( ! MikkTSpace || ! MikkTSpace.isReady ) { throw new Error( 'BufferGeometryUtils: Initialized MikkTSpace library required.' ); } if ( ! geometry.hasAttribute( 'position' ) || ! geometry.hasAttribute( 'normal' ) || ! geometry.hasAttribute( 'uv' ) ) { throw new Error( 'BufferGeometryUtils: Tangents require \"position\", \"normal\", and \"uv\" attributes.' ); } function getAttributeArray( attribute ) { if ( attribute.normalized || attribute.isInterleavedBufferAttribute ) { const dstArray = new Float32Array( attribute.count * attribute.itemSize ); for ( let i = 0, j = 0; i < attribute.count; i ++ ) { dstArray[ j ++ ] = attribute.getX( i ); dstArray[ j ++ ] = attribute.getY( i ); if ( attribute.itemSize > 2 ) { dstArray[ j ++ ] = attribute.getZ( i ); } } return dstArray; } if ( attribute.array instanceof Float32Array ) { return attribute.array; } return new Float32Array( attribute.array ); } // MikkTSpace algorithm requires non-indexed input. const _geometry = geometry.index ? geometry.toNonIndexed() : geometry; // Compute vertex tangents. const tangents = MikkTSpace.generateTangents( getAttributeArray( _geometry.attributes.position ), getAttributeArray( _geometry.attributes.normal ), getAttributeArray( _geometry.attributes.uv ) ); // Texture coordinate convention of glTF differs from the apparent // default of the MikkTSpace library; .w component must be flipped. if ( negateSign ) { for ( let i = 3; i < tangents.length; i += 4 ) { tangents[ i ] *= - 1; } } // _geometry.setAttribute( 'tangent', new BufferAttribute( tangents, 4 ) ); if ( geometry !== _geometry ) { geometry.copy( _geometry ); } return geometry; } /** * @param {Array} geometries * @param {Boolean} useGroups * @return {BufferGeometry} */ function mergeGeometries( geometries, useGroups = false ) { const isIndexed = geometries[ 0 ].index !== null; const attributesUsed = new Set( Object.keys( geometries[ 0 ].attributes ) ); const morphAttributesUsed = new Set( Object.keys( geometries[ 0 ].morphAttributes ) ); const attributes = {}; const morphAttributes = {}; const morphTargetsRelative = geometries[ 0 ].morphTargetsRelative; const mergedGeometry = new BufferGeometry(); let offset = 0; for ( let i = 0; i < geometries.length; ++ i ) { const geometry = geometries[ i ]; let attributesCount = 0; // ensure that all geometries are indexed, or none if ( isIndexed !== ( geometry.index !== null ) ) { console.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.' ); return null; } // gather attributes, exit early if they're different for ( const name in geometry.attributes ) { if ( ! attributesUsed.has( name ) ) { console.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.' ); return null; } if ( attributes[ name ] === undefined ) attributes[ name ] = []; attributes[ name ].push( geometry.attributes[ name ] ); attributesCount ++; } // ensure geometries have the same number of attributes if ( attributesCount !== attributesUsed.size ) { console.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. Make sure all geometries have the same number of attributes.' ); return null; } // gather morph attributes, exit early if they're different if ( morphTargetsRelative !== geometry.morphTargetsRelative ) { console.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. .morphTargetsRelative must be consistent throughout all geometries.' ); return null; } for ( const name in geometry.morphAttributes ) { if ( ! morphAttributesUsed.has( name ) ) { console.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. .morphAttributes must be consistent throughout all geometries.' ); return null; } if ( morphAttributes[ name ] === undefined ) morphAttributes[ name ] = []; morphAttributes[ name ].push( geometry.morphAttributes[ name ] ); } if ( useGroups ) { let count; if ( isIndexed ) { count = geometry.index.count; } else if ( geometry.attributes.position !== undefined ) { count = geometry.attributes.position.count; } else { console.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. The geometry must have either an index or a position attribute' ); return null; } mergedGeometry.addGroup( offset, count, i ); offset += count; } } // merge indices if ( isIndexed ) { let indexOffset = 0; const mergedIndex = []; for ( let i = 0; i < geometries.length; ++ i ) { const index = geometries[ i ].index; for ( let j = 0; j < index.count; ++ j ) { mergedIndex.push( index.getX( j ) + indexOffset ); } indexOffset += geometries[ i ].attributes.position.count; } mergedGeometry.setIndex( mergedIndex ); } // merge attributes for ( const name in attributes ) { const mergedAttribute = mergeAttributes( attributes[ name ] ); if ( ! mergedAttribute ) { console.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the ' + name + ' attribute.' ); return null; } mergedGeometry.setAttribute( name, mergedAttribute ); } // merge morph attributes for ( const name in morphAttributes ) { const numMorphTargets = morphAttributes[ name ][ 0 ].length; if ( numMorphTargets === 0 ) break; mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {}; mergedGeometry.morphAttributes[ name ] = []; for ( let i = 0; i < numMorphTargets; ++ i ) { const morphAttributesToMerge = []; for ( let j = 0; j < morphAttributes[ name ].length; ++ j ) { morphAttributesToMerge.push( morphAttributes[ name ][ j ][ i ] ); } const mergedMorphAttribute = mergeAttributes( morphAttributesToMerge ); if ( ! mergedMorphAttribute ) { console.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the ' + name + ' morphAttribute.' ); return null; } mergedGeometry.morphAttributes[ name ].push( mergedMorphAttribute ); } } return mergedGeometry; } /** * @param {Array} attributes * @return {BufferAttribute} */ function mergeAttributes( attributes ) { let TypedArray; let itemSize; let normalized; let gpuType = - 1; let arrayLength = 0; for ( let i = 0; i < attributes.length; ++ i ) { const attribute = attributes[ i ]; if ( attribute.isInterleavedBufferAttribute ) { console.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. InterleavedBufferAttributes are not supported.' ); return null; } if ( TypedArray === undefined ) TypedArray = attribute.array.constructor; if ( TypedArray !== attribute.array.constructor ) { console.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.' ); return null; } if ( itemSize === undefined ) itemSize = attribute.itemSize; if ( itemSize !== attribute.itemSize ) { console.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.' ); return null; } if ( normalized === undefined ) normalized = attribute.normalized; if ( normalized !== attribute.normalized ) { console.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.' ); return null; } if ( gpuType === - 1 ) gpuType = attribute.gpuType; if ( gpuType !== attribute.gpuType ) { console.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes.' ); return null; } arrayLength += attribute.array.length; } const array = new TypedArray( arrayLength ); let offset = 0; for ( let i = 0; i < attributes.length; ++ i ) { array.set( attributes[ i ].array, offset ); offset += attributes[ i ].array.length; } const result = new BufferAttribute( array, itemSize, normalized ); if ( gpuType !== undefined ) { result.gpuType = gpuType; } return result; } /** * @param {BufferAttribute} * @return {BufferAttribute} */ export function deepCloneAttribute( attribute ) { if ( attribute.isInstancedInterleavedBufferAttribute || attribute.isInterleavedBufferAttribute ) { return deinterleaveAttribute( attribute ); } if ( attribute.isInstancedBufferAttribute ) { return new InstancedBufferAttribute().copy( attribute ); } return new BufferAttribute().copy( attribute ); } /** * @param {Array} attributes * @return {Array} */ function interleaveAttributes( attributes ) { // Interleaves the provided attributes into an InterleavedBuffer and returns // a set of InterleavedBufferAttributes for each attribute let TypedArray; let arrayLength = 0; let stride = 0; // calculate the length and type of the interleavedBuffer for ( let i = 0, l = attributes.length; i < l; ++ i ) { const attribute = attributes[ i ]; if ( TypedArray === undefined ) TypedArray = attribute.array.constructor; if ( TypedArray !== attribute.array.constructor ) { console.error( 'AttributeBuffers of different types cannot be interleaved' ); return null; } arrayLength += attribute.array.length; stride += attribute.itemSize; } // Create the set of buffer attributes const interleavedBuffer = new InterleavedBuffer( new TypedArray( arrayLength ), stride ); let offset = 0; const res = []; const getters = [ 'getX', 'getY', 'getZ', 'getW' ]; const setters = [ 'setX', 'setY', 'setZ', 'setW' ]; for ( let j = 0, l = attributes.length; j < l; j ++ ) { const attribute = attributes[ j ]; const itemSize = attribute.itemSize; const count = attribute.count; const iba = new InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, attribute.normalized ); res.push( iba ); offset += itemSize; // Move the data for each attribute into the new interleavedBuffer // at the appropriate offset for ( let c = 0; c < count; c ++ ) { for ( let k = 0; k < itemSize; k ++ ) { iba[ setters[ k ] ]( c, attribute[ getters[ k ] ]( c ) ); } } } return res; } // returns a new, non-interleaved version of the provided attribute export function deinterleaveAttribute( attribute ) { const cons = attribute.data.array.constructor; const count = attribute.count; const itemSize = attribute.itemSize; const normalized = attribute.normalized; const array = new cons( count * itemSize ); let newAttribute; if ( attribute.isInstancedInterleavedBufferAttribute ) { newAttribute = new InstancedBufferAttribute( array, itemSize, normalized, attribute.meshPerAttribute ); } else { newAttribute = new BufferAttribute( array, itemSize, normalized ); } for ( let i = 0; i < count; i ++ ) { newAttribute.setX( i, attribute.getX( i ) ); if ( itemSize >= 2 ) { newAttribute.setY( i, attribute.getY( i ) ); } if ( itemSize >= 3 ) { newAttribute.setZ( i, attribute.getZ( i ) ); } if ( itemSize >= 4 ) { newAttribute.setW( i, attribute.getW( i ) ); } } return newAttribute; } // deinterleaves all attributes on the geometry export function deinterleaveGeometry( geometry ) { const attributes = geometry.attributes; const morphTargets = geometry.morphTargets; const attrMap = new Map(); for ( const key in attributes ) { const attr = attributes[ key ]; if ( attr.isInterleavedBufferAttribute ) { if ( ! attrMap.has( attr ) ) { attrMap.set( attr, deinterleaveAttribute( attr ) ); } attributes[ key ] = attrMap.get( attr ); } } for ( const key in morphTargets ) { const attr = morphTargets[ key ]; if ( attr.isInterleavedBufferAttribute ) { if ( ! attrMap.has( attr ) ) { attrMap.set( attr, deinterleaveAttribute( attr ) ); } morphTargets[ key ] = attrMap.get( attr ); } } } /** * @param {BufferGeometry} geometry * @return {number} */ function estimateBytesUsed( geometry ) { // Return the estimated memory used by this geometry in bytes // Calculate using itemSize, count, and BYTES_PER_ELEMENT to account // for InterleavedBufferAttributes. let mem = 0; for ( const name in geometry.attributes ) { const attr = geometry.getAttribute( name ); mem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT; } const indices = geometry.getIndex(); mem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0; return mem; } /** * @param {BufferGeometry} geometry * @param {number} tolerance * @return {BufferGeometry} */ function mergeVertices( geometry, tolerance = 1e-4 ) { tolerance = Math.max( tolerance, Number.EPSILON ); // Generate an index buffer if the geometry doesn't have one, or optimize it // if it's already available. const hashToIndex = {}; const indices = geometry.getIndex(); const positions = geometry.getAttribute( 'position' ); const vertexCount = indices ? indices.count : positions.count; // next value for triangle indices let nextIndex = 0; // attributes and new attribute arrays const attributeNames = Object.keys( geometry.attributes ); const tmpAttributes = {}; const tmpMorphAttributes = {}; const newIndices = []; const getters = [ 'getX', 'getY', 'getZ', 'getW' ]; const setters = [ 'setX', 'setY', 'setZ', 'setW' ]; // Initialize the arrays, allocating space conservatively. Extra // space will be trimmed in the last step. for ( let i = 0, l = attributeNames.length; i < l; i ++ ) { const name = attributeNames[ i ]; const attr = geometry.attributes[ name ]; tmpAttributes[ name ] = new BufferAttribute( new attr.array.constructor( attr.count * attr.itemSize ), attr.itemSize, attr.normalized ); const morphAttr = geometry.morphAttributes[ name ]; if ( morphAttr ) { tmpMorphAttributes[ name ] = new BufferAttribute( new morphAttr.array.constructor( morphAttr.count * morphAttr.itemSize ), morphAttr.itemSize, morphAttr.normalized ); } } // convert the error tolerance to an amount of decimal places to truncate to const halfTolerance = tolerance * 0.5; const exponent = Math.log10( 1 / tolerance ); const hashMultiplier = Math.pow( 10, exponent ); const hashAdditive = halfTolerance * hashMultiplier; for ( let i = 0; i < vertexCount; i ++ ) { const index = indices ? indices.getX( i ) : i; // Generate a hash for the vertex attributes at the current index 'i' let hash = ''; for ( let j = 0, l = attributeNames.length; j < l; j ++ ) { const name = attributeNames[ j ]; const attribute = geometry.getAttribute( name ); const itemSize = attribute.itemSize; for ( let k = 0; k < itemSize; k ++ ) { // double tilde truncates the decimal value hash += `${ ~ ~ ( attribute[ getters[ k ] ]( index ) * hashMultiplier + hashAdditive ) },`; } } // Add another reference to the vertex if it's already // used by another index if ( hash in hashToIndex ) { newIndices.push( hashToIndex[ hash ] ); } else { // copy data to the new index in the temporary attributes for ( let j = 0, l = attributeNames.length; j < l; j ++ ) { const name = attributeNames[ j ]; const attribute = geometry.getAttribute( name ); const morphAttr = geometry.morphAttributes[ name ]; const itemSize = attribute.itemSize; const newarray = tmpAttributes[ name ]; const newMorphArrays = tmpMorphAttributes[ name ]; for ( let k = 0; k < itemSize; k ++ ) { const getterFunc = getters[ k ]; const setterFunc = setters[ k ]; newarray[ setterFunc ]( nextIndex, attribute[ getterFunc ]( index ) ); if ( morphAttr ) { for ( let m = 0, ml = morphAttr.length; m < ml; m ++ ) { newMorphArrays[ m ][ setterFunc ]( nextIndex, morphAttr[ m ][ getterFunc ]( index ) ); } } } } hashToIndex[ hash ] = nextIndex; newIndices.push( nextIndex ); nextIndex ++; } } // generate result BufferGeometry const result = geometry.clone(); for ( const name in geometry.attributes ) { const tmpAttribute = tmpAttributes[ name ]; result.setAttribute( name, new BufferAttribute( tmpAttribute.array.slice( 0, nextIndex * tmpAttribute.itemSize ), tmpAttribute.itemSize, tmpAttribute.normalized, ) ); if ( ! ( name in tmpMorphAttributes ) ) continue; for ( let j = 0; j < tmpMorphAttributes[ name ].length; j ++ ) { const tmpMorphAttribute = tmpMorphAttributes[ name ][ j ]; result.morphAttributes[ name ][ j ] = new BufferAttribute( tmpMorphAttribute.array.slice( 0, nextIndex * tmpMorphAttribute.itemSize ), tmpMorphAttribute.itemSize, tmpMorphAttribute.normalized, ); } } // indices result.setIndex( newIndices ); return result; } /** * @param {BufferGeometry} geometry * @param {number} drawMode * @return {BufferGeometry} */ function toTrianglesDrawMode( geometry, drawMode ) { if ( drawMode === TrianglesDrawMode ) { console.warn( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.' ); return geometry; } if ( drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode ) { let index = geometry.getIndex(); // generate index if not present if ( index === null ) { const indices = []; const position = geometry.getAttribute( 'position' ); if ( position !== undefined ) { for ( let i = 0; i < position.count; i ++ ) { indices.push( i ); } geometry.setIndex( indices ); index = geometry.getIndex(); } else { console.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.' ); return geometry; } } // const numberOfTriangles = index.count - 2; const newIndices = []; if ( drawMode === TriangleFanDrawMode ) { // gl.TRIANGLE_FAN for ( let i = 1; i"},{"title":"","date":"2023-10-12T14:08:40.639Z","updated":"2023-10-12T14:08:40.639Z","comments":true,"path":"js/three/jsm/loaders/3DMLoader.js","permalink":"http://19999997.xyz/js/three/jsm/loaders/3DMLoader.js","excerpt":"","text":"import { BufferGeometryLoader, FileLoader, Loader, Object3D, MeshStandardMaterial, MeshPhysicalMaterial, Mesh, Color, Points, PointsMaterial, Line, LineBasicMaterial, Matrix4, DirectionalLight, PointLight, SpotLight, RectAreaLight, Sprite, SpriteMaterial, CanvasTexture, LinearFilter, ClampToEdgeWrapping, RepeatWrapping, TextureLoader, DoubleSide } from 'three'; import { EXRLoader } from '../loaders/EXRLoader.js'; const _taskCache = new WeakMap(); class Rhino3dmLoader extends Loader { constructor( manager ) { super( manager ); this.libraryPath = ''; this.libraryPending = null; this.libraryBinary = null; this.libraryConfig = {}; this.url = ''; this.workerLimit = 4; this.workerPool = []; this.workerNextTaskID = 1; this.workerSourceURL = ''; this.workerConfig = {}; this.materials = []; this.warnings = []; } setLibraryPath( path ) { this.libraryPath = path; return this; } setWorkerLimit( workerLimit ) { this.workerLimit = workerLimit; return this; } load( url, onLoad, onProgress, onError ) { const loader = new FileLoader( this.manager ); loader.setPath( this.path ); loader.setResponseType( 'arraybuffer' ); loader.setRequestHeader( this.requestHeader ); this.url = url; loader.load( url, ( buffer ) => { // Check for an existing task using this buffer. A transferred buffer cannot be transferred // again from this thread. if ( _taskCache.has( buffer ) ) { const cachedTask = _taskCache.get( buffer ); return cachedTask.promise.then( onLoad ).catch( onError ); } this.decodeObjects( buffer, url ) .then( result => { result.userData.warnings = this.warnings; onLoad( result ); } ) .catch( e => onError( e ) ); }, onProgress, onError ); } debug() { console.log( 'Task load: ', this.workerPool.map( ( worker ) => worker._taskLoad ) ); } decodeObjects( buffer, url ) { let worker; let taskID; const taskCost = buffer.byteLength; const objectPending = this._getWorker( taskCost ) .then( ( _worker ) => { worker = _worker; taskID = this.workerNextTaskID ++; return new Promise( ( resolve, reject ) => { worker._callbacks[ taskID ] = { resolve, reject }; worker.postMessage( { type: 'decode', id: taskID, buffer }, [ buffer ] ); // this.debug(); } ); } ) .then( ( message ) => this._createGeometry( message.data ) ) .catch( e => { throw e; } ); // Remove task from the task list. // Note: replaced '.finally()' with '.catch().then()' block - iOS 11 support (#19416) objectPending .catch( () => true ) .then( () => { if ( worker && taskID ) { this._releaseTask( worker, taskID ); //this.debug(); } } ); // Cache the task result. _taskCache.set( buffer, { url: url, promise: objectPending } ); return objectPending; } parse( data, onLoad, onError ) { this.decodeObjects( data, '' ) .then( result => { result.userData.warnings = this.warnings; onLoad( result ); } ) .catch( e => onError( e ) ); } _compareMaterials( material ) { const mat = {}; mat.name = material.name; mat.color = {}; mat.color.r = material.color.r; mat.color.g = material.color.g; mat.color.b = material.color.b; mat.type = material.type; const json = JSON.stringify( mat ); for ( let i = 0; i < this.materials.length; i ++ ) { const m = this.materials[ i ]; const _mat = {}; _mat.name = m.name; _mat.color = {}; _mat.color.r = m.color.r; _mat.color.g = m.color.g; _mat.color.b = m.color.b; _mat.type = m.type; if ( JSON.stringify( _mat ) === json ) { return m; } } this.materials.push( material ); return material; } _createMaterial( material, renderEnvironment ) { if ( material === undefined ) { return new MeshStandardMaterial( { color: new Color( 1, 1, 1 ), metalness: 0.8, name: Loader.DEFAULT_MATERIAL_NAME, side: DoubleSide } ); } //console.log(material) let mat = new MeshPhysicalMaterial( { color: new Color( material.diffuseColor.r / 255.0, material.diffuseColor.g / 255.0, material.diffuseColor.b / 255.0 ), emissive: new Color( material.emissionColor.r, material.emissionColor.g, material.emissionColor.b ), flatShading: material.disableLighting, ior: material.indexOfRefraction, name: material.name, reflectivity: material.reflectivity, opacity: 1.0 - material.transparency, side: DoubleSide, specularColor: material.specularColor, transparent: material.transparency > 0 ? true : false } ); mat.userData.id = material.id; if ( material.pbrSupported ) { const pbr = material.pbr; mat.anisotropy = pbr.anisotropy; mat.anisotropyRotation = pbr.anisotropicRotation; mat.color = new Color( pbr.baseColor.r, pbr.baseColor.g, pbr.baseColor.b ); mat.clearCoat = pbr.clearCoat; mat.clearCoatRoughness = pbr.clearCoatRoughness; mat.metalness = pbr.metallic; mat.transmission = 1 - pbr.opacity; mat.roughness = pbr.roughness; mat.sheen = pbr.sheen; mat.specularIntensity = pbr.specular; mat.thickness = pbr.subsurface; } if ( material.pbrSupported && material.pbr.opacity === 0 && material.transparency === 1 ) { //some compromises mat.opacity = 0.2; mat.transmission = 1.00; } const textureLoader = new TextureLoader(); for ( let i = 0; i < material.textures.length; i ++ ) { const texture = material.textures[ i ]; if ( texture.image !== null ) { const map = textureLoader.load( texture.image ); //console.log(texture.type ) switch ( texture.type ) { case 'Bump': mat.bumpMap = map; break; case 'Diffuse': mat.map = map; break; case 'Emap': mat.envMap = map; break; case 'Opacity': mat.transmissionMap = map; break; case 'Transparency': mat.alphaMap = map; mat.transparent = true; break; case 'PBR_Alpha': mat.alphaMap = map; mat.transparent = true; break; case 'PBR_AmbientOcclusion': mat.aoMap = map; break; case 'PBR_Anisotropic': mat.anisotropyMap = map; break; case 'PBR_BaseColor': mat.map = map; break; case 'PBR_Clearcoat': mat.clearcoatMap = map; break; case 'PBR_ClearcoatBump': mat.clearcoatNormalMap = map; break; case 'PBR_ClearcoatRoughness': mat.clearcoatRoughnessMap = map; break; case 'PBR_Displacement': mat.displacementMap = map; break; case 'PBR_Emission': mat.emissiveMap = map; break; case 'PBR_Metallic': mat.metalnessMap = map; break; case 'PBR_Roughness': mat.roughnessMap = map; break; case 'PBR_Sheen': mat.sheenColorMap = map; break; case 'PBR_Specular': mat.specularColorMap = map; break; case 'PBR_Subsurface': mat.thicknessMap = map; break; default: this.warnings.push( { message: `THREE.3DMLoader: No conversion exists for 3dm ${texture.type}.`, type: 'no conversion' } ); break; } map.wrapS = texture.wrapU === 0 ? RepeatWrapping : ClampToEdgeWrapping; map.wrapT = texture.wrapV === 0 ? RepeatWrapping : ClampToEdgeWrapping; if ( texture.repeat ) { map.repeat.set( texture.repeat[ 0 ], texture.repeat[ 1 ] ); } } } if ( renderEnvironment ) { new EXRLoader().load( renderEnvironment.image, function ( texture ) { texture.mapping = THREE.EquirectangularReflectionMapping; mat.envMap = texture; } ); } return mat; } _createGeometry( data ) { const object = new Object3D(); const instanceDefinitionObjects = []; const instanceDefinitions = []; const instanceReferences = []; object.userData[ 'layers' ] = data.layers; object.userData[ 'groups' ] = data.groups; object.userData[ 'settings' ] = data.settings; object.userData.settings[ 'renderSettings' ] = data.renderSettings; object.userData[ 'objectType' ] = 'File3dm'; object.userData[ 'materials' ] = null; object.name = this.url; let objects = data.objects; const materials = data.materials; for ( let i = 0; i < objects.length; i ++ ) { const obj = objects[ i ]; const attributes = obj.attributes; switch ( obj.objectType ) { case 'InstanceDefinition': instanceDefinitions.push( obj ); break; case 'InstanceReference': instanceReferences.push( obj ); break; default: let matId; switch( attributes.materialSource.name ) { case 'ObjectMaterialSource_MaterialFromLayer': //check layer index if ( attributes.layerIndex >= 0 ) { matId = data.layers[ attributes.layerIndex ].renderMaterialIndex; } else { matId = null; } break; case 'ObjectMaterialSource_MaterialFromObject': if ( attributes.materialIndex >= 0 ) { matId = attributes.materialIndex; } else { matId = null; } break; } let material; if ( matId >= 0 ) { const rMaterial = materials[ matId ]; material = this._createMaterial( rMaterial, data.renderEnvironment ); } else { material = this._createMaterial(); } material = this._compareMaterials( material ); const _object = this._createObject( obj, material ); if ( _object === undefined ) { continue; } const layer = data.layers[ attributes.layerIndex ]; _object.visible = layer ? data.layers[ attributes.layerIndex ].visible : true; if ( attributes.isInstanceDefinitionObject ) { instanceDefinitionObjects.push( _object ); } else { object.add( _object ); } break; } } for ( let i = 0; i < instanceDefinitions.length; i ++ ) { const iDef = instanceDefinitions[ i ]; objects = []; for ( let j = 0; j < iDef.attributes.objectIds.length; j ++ ) { const objId = iDef.attributes.objectIds[ j ]; for ( let p = 0; p < instanceDefinitionObjects.length; p ++ ) { const idoId = instanceDefinitionObjects[ p ].userData.attributes.id; if ( objId === idoId ) { objects.push( instanceDefinitionObjects[ p ] ); } } } // Currently clones geometry and does not take advantage of instancing for ( let j = 0; j < instanceReferences.length; j ++ ) { const iRef = instanceReferences[ j ]; if ( iRef.geometry.parentIdefId === iDef.attributes.id ) { const iRefObject = new Object3D(); const xf = iRef.geometry.xform.array; const matrix = new Matrix4(); matrix.set( ...xf ); iRefObject.applyMatrix4( matrix ); for ( let p = 0; p < objects.length; p ++ ) { iRefObject.add( objects[ p ].clone( true ) ); } object.add( iRefObject ); } } } object.userData[ 'materials' ] = this.materials; object.name = ''; return object; } _createObject( obj, mat ) { const loader = new BufferGeometryLoader(); const attributes = obj.attributes; let geometry, material, _color, color; switch ( obj.objectType ) { case 'Point': case 'PointSet': geometry = loader.parse( obj.geometry ); if ( geometry.attributes.hasOwnProperty( 'color' ) ) { material = new PointsMaterial( { vertexColors: true, sizeAttenuation: false, size: 2 } ); } else { _color = attributes.drawColor; color = new Color( _color.r / 255.0, _color.g / 255.0, _color.b / 255.0 ); material = new PointsMaterial( { color: color, sizeAttenuation: false, size: 2 } ); } material = this._compareMaterials( material ); const points = new Points( geometry, material ); points.userData[ 'attributes' ] = attributes; points.userData[ 'objectType' ] = obj.objectType; if ( attributes.name ) { points.name = attributes.name; } return points; case 'Mesh': case 'Extrusion': case 'SubD': case 'Brep': if ( obj.geometry === null ) return; geometry = loader.parse( obj.geometry ); if ( geometry.attributes.hasOwnProperty( 'color' ) ) { mat.vertexColors = true; } if ( mat === null ) { mat = this._createMaterial(); mat = this._compareMaterials( mat ); } const mesh = new Mesh( geometry, mat ); mesh.castShadow = attributes.castsShadows; mesh.receiveShadow = attributes.receivesShadows; mesh.userData[ 'attributes' ] = attributes; mesh.userData[ 'objectType' ] = obj.objectType; if ( attributes.name ) { mesh.name = attributes.name; } return mesh; case 'Curve': geometry = loader.parse( obj.geometry ); _color = attributes.drawColor; color = new Color( _color.r / 255.0, _color.g / 255.0, _color.b / 255.0 ); material = new LineBasicMaterial( { color: color } ); material = this._compareMaterials( material ); const lines = new Line( geometry, material ); lines.userData[ 'attributes' ] = attributes; lines.userData[ 'objectType' ] = obj.objectType; if ( attributes.name ) { lines.name = attributes.name; } return lines; case 'TextDot': geometry = obj.geometry; const ctx = document.createElement( 'canvas' ).getContext( '2d' ); const font = `${geometry.fontHeight}px ${geometry.fontFace}`; ctx.font = font; const width = ctx.measureText( geometry.text ).width + 10; const height = geometry.fontHeight + 10; const r = window.devicePixelRatio; ctx.canvas.width = width * r; ctx.canvas.height = height * r; ctx.canvas.style.width = width + 'px'; ctx.canvas.style.height = height + 'px'; ctx.setTransform( r, 0, 0, r, 0, 0 ); ctx.font = font; ctx.textBaseline = 'middle'; ctx.textAlign = 'center'; color = attributes.drawColor; ctx.fillStyle = `rgba(${color.r},${color.g},${color.b},${color.a})`; ctx.fillRect( 0, 0, width, height ); ctx.fillStyle = 'white'; ctx.fillText( geometry.text, width / 2, height / 2 ); const texture = new CanvasTexture( ctx.canvas ); texture.minFilter = LinearFilter; texture.wrapS = ClampToEdgeWrapping; texture.wrapT = ClampToEdgeWrapping; material = new SpriteMaterial( { map: texture, depthTest: false } ); const sprite = new Sprite( material ); sprite.position.set( geometry.point[ 0 ], geometry.point[ 1 ], geometry.point[ 2 ] ); sprite.scale.set( width / 10, height / 10, 1.0 ); sprite.userData[ 'attributes' ] = attributes; sprite.userData[ 'objectType' ] = obj.objectType; if ( attributes.name ) { sprite.name = attributes.name; } return sprite; case 'Light': geometry = obj.geometry; let light; switch ( geometry.lightStyle.name ) { case 'LightStyle_WorldPoint': light = new PointLight(); light.castShadow = attributes.castsShadows; light.position.set( geometry.location[ 0 ], geometry.location[ 1 ], geometry.location[ 2 ] ); light.shadow.normalBias = 0.1; break; case 'LightStyle_WorldSpot': light = new SpotLight(); light.castShadow = attributes.castsShadows; light.position.set( geometry.location[ 0 ], geometry.location[ 1 ], geometry.location[ 2 ] ); light.target.position.set( geometry.direction[ 0 ], geometry.direction[ 1 ], geometry.direction[ 2 ] ); light.angle = geometry.spotAngleRadians; light.shadow.normalBias = 0.1; break; case 'LightStyle_WorldRectangular': light = new RectAreaLight(); const width = Math.abs( geometry.width[ 2 ] ); const height = Math.abs( geometry.length[ 0 ] ); light.position.set( geometry.location[ 0 ] - ( height / 2 ), geometry.location[ 1 ], geometry.location[ 2 ] - ( width / 2 ) ); light.height = height; light.width = width; light.lookAt( geometry.direction[ 0 ], geometry.direction[ 1 ], geometry.direction[ 2 ] ); break; case 'LightStyle_WorldDirectional': light = new DirectionalLight(); light.castShadow = attributes.castsShadows; light.position.set( geometry.location[ 0 ], geometry.location[ 1 ], geometry.location[ 2 ] ); light.target.position.set( geometry.direction[ 0 ], geometry.direction[ 1 ], geometry.direction[ 2 ] ); light.shadow.normalBias = 0.1; break; case 'LightStyle_WorldLinear': // no conversion exists, warning has already been printed to the console break; default: break; } if ( light ) { light.intensity = geometry.intensity; _color = geometry.diffuse; color = new Color( _color.r / 255.0, _color.g / 255.0, _color.b / 255.0 ); light.color = color; light.userData[ 'attributes' ] = attributes; light.userData[ 'objectType' ] = obj.objectType; } return light; } } _initLibrary() { if ( ! this.libraryPending ) { // Load rhino3dm wrapper. const jsLoader = new FileLoader( this.manager ); jsLoader.setPath( this.libraryPath ); const jsContent = new Promise( ( resolve, reject ) => { jsLoader.load( 'rhino3dm.js', resolve, undefined, reject ); } ); // Load rhino3dm WASM binary. const binaryLoader = new FileLoader( this.manager ); binaryLoader.setPath( this.libraryPath ); binaryLoader.setResponseType( 'arraybuffer' ); const binaryContent = new Promise( ( resolve, reject ) => { binaryLoader.load( 'rhino3dm.wasm', resolve, undefined, reject ); } ); this.libraryPending = Promise.all( [ jsContent, binaryContent ] ) .then( ( [ jsContent, binaryContent ] ) => { //this.libraryBinary = binaryContent; this.libraryConfig.wasmBinary = binaryContent; const fn = Rhino3dmWorker.toString(); const body = [ '/* rhino3dm.js */', jsContent, '/* worker */', fn.substring( fn.indexOf( '{' ) + 1, fn.lastIndexOf( '}' ) ) ].join( '\\n' ); this.workerSourceURL = URL.createObjectURL( new Blob( [ body ] ) ); } ); } return this.libraryPending; } _getWorker( taskCost ) { return this._initLibrary().then( () => { if ( this.workerPool.length < this.workerLimit ) { const worker = new Worker( this.workerSourceURL ); worker._callbacks = {}; worker._taskCosts = {}; worker._taskLoad = 0; worker.postMessage( { type: 'init', libraryConfig: this.libraryConfig } ); worker.onmessage = e => { const message = e.data; switch ( message.type ) { case 'warning': this.warnings.push( message.data ); console.warn( message.data ); break; case 'decode': worker._callbacks[ message.id ].resolve( message ); break; case 'error': worker._callbacks[ message.id ].reject( message ); break; default: console.error( 'THREE.Rhino3dmLoader: Unexpected message, \"' + message.type + '\"' ); } }; this.workerPool.push( worker ); } else { this.workerPool.sort( function ( a, b ) { return a._taskLoad > b._taskLoad ? - 1 : 1; } ); } const worker = this.workerPool[ this.workerPool.length - 1 ]; worker._taskLoad += taskCost; return worker; } ); } _releaseTask( worker, taskID ) { worker._taskLoad -= worker._taskCosts[ taskID ]; delete worker._callbacks[ taskID ]; delete worker._taskCosts[ taskID ]; } dispose() { for ( let i = 0; i < this.workerPool.length; ++ i ) { this.workerPool[ i ].terminate(); } this.workerPool.length = 0; return this; } } /* WEB WORKER */ function Rhino3dmWorker() { let libraryPending; let libraryConfig; let rhino; let taskID; onmessage = function ( e ) { const message = e.data; switch ( message.type ) { case 'init': libraryConfig = message.libraryConfig; const wasmBinary = libraryConfig.wasmBinary; let RhinoModule; libraryPending = new Promise( function ( resolve ) { /* Like Basis Loader */ RhinoModule = { wasmBinary, onRuntimeInitialized: resolve }; rhino3dm( RhinoModule ); // eslint-disable-line no-undef } ).then( () => { rhino = RhinoModule; } ); break; case 'decode': taskID = message.id; const buffer = message.buffer; libraryPending.then( () => { try { const data = decodeObjects( rhino, buffer ); self.postMessage( { type: 'decode', id: message.id, data } ); } catch ( error ) { self.postMessage( { type: 'error', id: message.id, error } ); } } ); break; } }; function decodeObjects( rhino, buffer ) { const arr = new Uint8Array( buffer ); const doc = rhino.File3dm.fromByteArray( arr ); const objects = []; const materials = []; const layers = []; const views = []; const namedViews = []; const groups = []; const strings = []; //Handle objects const objs = doc.objects(); const cnt = objs.count; for ( let i = 0; i < cnt; i ++ ) { const _object = objs.get( i ); const object = extractObjectData( _object, doc ); _object.delete(); if ( object ) { objects.push( object ); } } // Handle instance definitions // console.log( `Instance Definitions Count: ${doc.instanceDefinitions().count()}` ); for ( let i = 0; i < doc.instanceDefinitions().count; i ++ ) { const idef = doc.instanceDefinitions().get( i ); const idefAttributes = extractProperties( idef ); idefAttributes.objectIds = idef.getObjectIds(); objects.push( { geometry: null, attributes: idefAttributes, objectType: 'InstanceDefinition' } ); } // Handle materials const textureTypes = [ // rhino.TextureType.Bitmap, rhino.TextureType.Diffuse, rhino.TextureType.Bump, rhino.TextureType.Transparency, rhino.TextureType.Opacity, rhino.TextureType.Emap ]; const pbrTextureTypes = [ rhino.TextureType.PBR_BaseColor, rhino.TextureType.PBR_Subsurface, rhino.TextureType.PBR_SubsurfaceScattering, rhino.TextureType.PBR_SubsurfaceScatteringRadius, rhino.TextureType.PBR_Metallic, rhino.TextureType.PBR_Specular, rhino.TextureType.PBR_SpecularTint, rhino.TextureType.PBR_Roughness, rhino.TextureType.PBR_Anisotropic, rhino.TextureType.PBR_Anisotropic_Rotation, rhino.TextureType.PBR_Sheen, rhino.TextureType.PBR_SheenTint, rhino.TextureType.PBR_Clearcoat, rhino.TextureType.PBR_ClearcoatBump, rhino.TextureType.PBR_ClearcoatRoughness, rhino.TextureType.PBR_OpacityIor, rhino.TextureType.PBR_OpacityRoughness, rhino.TextureType.PBR_Emission, rhino.TextureType.PBR_AmbientOcclusion, rhino.TextureType.PBR_Displacement ]; for ( let i = 0; i < doc.materials().count; i ++ ) { const _material = doc.materials().get( i ); let material = extractProperties( _material ); const textures = []; textures.push( ...extractTextures( _material, textureTypes, doc ) ); material.pbrSupported = _material.physicallyBased().supported; if ( material.pbrSupported ) { textures.push( ...extractTextures( _material, pbrTextureTypes, doc ) ); material.pbr = extractProperties( _material.physicallyBased() ); } material.textures = textures; materials.push( material ); _material.delete(); } // Handle layers for ( let i = 0; i < doc.layers().count; i ++ ) { const _layer = doc.layers().get( i ); const layer = extractProperties( _layer ); layers.push( layer ); _layer.delete(); } // Handle views for ( let i = 0; i < doc.views().count; i ++ ) { const _view = doc.views().get( i ); const view = extractProperties( _view ); views.push( view ); _view.delete(); } // Handle named views for ( let i = 0; i < doc.namedViews().count; i ++ ) { const _namedView = doc.namedViews().get( i ); const namedView = extractProperties( _namedView ); namedViews.push( namedView ); _namedView.delete(); } // Handle groups for ( let i = 0; i < doc.groups().count; i ++ ) { const _group = doc.groups().get( i ); const group = extractProperties( _group ); groups.push( group ); _group.delete(); } // Handle settings const settings = extractProperties( doc.settings() ); //TODO: Handle other document stuff like dimstyles, instance definitions, bitmaps etc. // Handle dimstyles // console.log( `Dimstyle Count: ${doc.dimstyles().count()}` ); // Handle bitmaps // console.log( `Bitmap Count: ${doc.bitmaps().count()}` ); // Handle strings // console.log( `Document Strings Count: ${doc.strings().count()}` ); // Note: doc.strings().documentUserTextCount() counts any doc.strings defined in a section // console.log( `Document User Text Count: ${doc.strings().documentUserTextCount()}` ); const strings_count = doc.strings().count; for ( let i = 0; i < strings_count; i ++ ) { strings.push( doc.strings().get( i ) ); } // Handle Render Environments for Material Environment // get the id of the active render environment skylight, which we'll use for environment texture const reflectionId = doc.settings().renderSettings().renderEnvironments.reflectionId const rc = doc.renderContent() let renderEnvironment = null for( let i = 0; i < rc.count; i++ ) { const content = rc.get(i) switch( content.kind ) { case 'environment': const id = content.id // there could be multiple render environments in a 3dm file if ( id !== reflectionId ) break; const renderTexture = content.findChild( 'texture' ) const fileName = renderTexture.fileName for ( let j = 0; j < doc.embeddedFiles().count; j ++ ) { const _fileName = doc.embeddedFiles().get( j ).fileName if ( fileName === _fileName ) { const background = doc.getEmbeddedFileAsBase64( fileName ) const backgroundImage = 'data:image/png;base64,' + background renderEnvironment = { type: 'renderEnvironment', image: backgroundImage, name: fileName }; } } break; } } // Handle Render Settings const renderSettings = { ambientLight: doc.settings().renderSettings().ambientLight, backgroundColorTop: doc.settings().renderSettings().backgroundColorTop, backgroundColorBottom: doc.settings().renderSettings().backgroundColorBottom, useHiddenLights: doc.settings().renderSettings().useHiddenLights, depthCue: doc.settings().renderSettings().depthCue, flatShade: doc.settings().renderSettings().flatShade, renderBackFaces: doc.settings().renderSettings().renderBackFaces, renderPoints: doc.settings().renderSettings().renderPoints, renderCurves: doc.settings().renderSettings().renderCurves, renderIsoParams: doc.settings().renderSettings().renderIsoParams, renderMeshEdges: doc.settings().renderSettings().renderMeshEdges, renderAnnotations: doc.settings().renderSettings().renderAnnotations, useViewportSize: doc.settings().renderSettings().useViewportSize, scaleBackgroundToFit: doc.settings().renderSettings().scaleBackgroundToFit, transparentBackground: doc.settings().renderSettings().transparentBackground, imageDpi: doc.settings().renderSettings().imageDpi, shadowMapLevel: doc.settings().renderSettings().shadowMapLevel, namedView: doc.settings().renderSettings().namedView, snapShot: doc.settings().renderSettings().snapShot, specificViewport: doc.settings().renderSettings().specificViewport, groundPlane: extractProperties( doc.settings().renderSettings().groundPlane ), safeFrame: extractProperties( doc.settings().renderSettings().safeFrame ), dithering: extractProperties( doc.settings().renderSettings().dithering ), skylight: extractProperties( doc.settings().renderSettings().skylight ), linearWorkflow: extractProperties( doc.settings().renderSettings().linearWorkflow ), renderChannels: extractProperties( doc.settings().renderSettings().renderChannels ), sun: extractProperties( doc.settings().renderSettings().sun ), renderEnvironments: extractProperties( doc.settings().renderSettings().renderEnvironments ), postEffects: extractProperties( doc.settings().renderSettings().postEffects ), } doc.delete(); return { objects, materials, layers, views, namedViews, groups, strings, settings, renderSettings, renderEnvironment }; } function extractTextures( m, tTypes, d ) { const textures = [] for ( let i = 0; i < tTypes.length; i ++ ) { const _texture = m.getTexture( tTypes[ i ] ); if ( _texture ) { let textureType = tTypes[ i ].constructor.name; textureType = textureType.substring( 12, textureType.length ); const texture = extractTextureData( _texture, textureType, d ); textures.push( texture ); _texture.delete(); } } return textures; } function extractTextureData( t, tType, d ) { const texture = { type: tType }; const image = d.getEmbeddedFileAsBase64( t.fileName ); texture.wrapU = t.wrapU; texture.wrapV = t.wrapV; texture.wrapW = t.wrapW; const uvw = t.uvwTransform.toFloatArray( true ); texture.repeat = [ uvw[ 0 ], uvw[ 5 ] ]; if ( image ) { texture.image = 'data:image/png;base64,' + image; } else { self.postMessage( { type: 'warning', id: taskID, data: { message: `THREE.3DMLoader: Image for ${tType} texture not embedded in file.`, type: 'missing resource' } } ); texture.image = null; } return texture; } function extractObjectData( object, doc ) { const _geometry = object.geometry(); const _attributes = object.attributes(); let objectType = _geometry.objectType; let geometry, attributes, position, data, mesh; // skip instance definition objects //if( _attributes.isInstanceDefinitionObject ) { continue; } // TODO: handle other geometry types switch ( objectType ) { case rhino.ObjectType.Curve: const pts = curveToPoints( _geometry, 100 ); position = {}; attributes = {}; data = {}; position.itemSize = 3; position.type = 'Float32Array'; position.array = []; for ( let j = 0; j < pts.length; j ++ ) { position.array.push( pts[ j ][ 0 ] ); position.array.push( pts[ j ][ 1 ] ); position.array.push( pts[ j ][ 2 ] ); } attributes.position = position; data.attributes = attributes; geometry = { data }; break; case rhino.ObjectType.Point: const pt = _geometry.location; position = {}; const color = {}; attributes = {}; data = {}; position.itemSize = 3; position.type = 'Float32Array'; position.array = [ pt[ 0 ], pt[ 1 ], pt[ 2 ] ]; const _color = _attributes.drawColor( doc ); color.itemSize = 3; color.type = 'Float32Array'; color.array = [ _color.r / 255.0, _color.g / 255.0, _color.b / 255.0 ]; attributes.position = position; attributes.color = color; data.attributes = attributes; geometry = { data }; break; case rhino.ObjectType.PointSet: case rhino.ObjectType.Mesh: geometry = _geometry.toThreejsJSON(); break; case rhino.ObjectType.Brep: const faces = _geometry.faces(); mesh = new rhino.Mesh(); for ( let faceIndex = 0; faceIndex < faces.count; faceIndex ++ ) { const face = faces.get( faceIndex ); const _mesh = face.getMesh( rhino.MeshType.Any ); if ( _mesh ) { mesh.append( _mesh ); _mesh.delete(); } face.delete(); } if ( mesh.faces().count > 0 ) { mesh.compact(); geometry = mesh.toThreejsJSON(); faces.delete(); } mesh.delete(); break; case rhino.ObjectType.Extrusion: mesh = _geometry.getMesh( rhino.MeshType.Any ); if ( mesh ) { geometry = mesh.toThreejsJSON(); mesh.delete(); } break; case rhino.ObjectType.TextDot: geometry = extractProperties( _geometry ); break; case rhino.ObjectType.Light: geometry = extractProperties( _geometry ); if ( geometry.lightStyle.name === 'LightStyle_WorldLinear' ) { self.postMessage( { type: 'warning', id: taskID, data: { message: `THREE.3DMLoader: No conversion exists for ${objectType.constructor.name} ${geometry.lightStyle.name}`, type: 'no conversion', guid: _attributes.id } } ); } break; case rhino.ObjectType.InstanceReference: geometry = extractProperties( _geometry ); geometry.xform = extractProperties( _geometry.xform ); geometry.xform.array = _geometry.xform.toFloatArray( true ); break; case rhino.ObjectType.SubD: // TODO: precalculate resulting vertices and faces and warn on excessive results _geometry.subdivide( 3 ); mesh = rhino.Mesh.createFromSubDControlNet( _geometry ); if ( mesh ) { geometry = mesh.toThreejsJSON(); mesh.delete(); } break; /* case rhino.ObjectType.Annotation: case rhino.ObjectType.Hatch: case rhino.ObjectType.ClipPlane: */ default: self.postMessage( { type: 'warning', id: taskID, data: { message: `THREE.3DMLoader: Conversion not implemented for ${objectType.constructor.name}`, type: 'not implemented', guid: _attributes.id } } ); break; } if ( geometry ) { attributes = extractProperties( _attributes ); attributes.geometry = extractProperties( _geometry ); if ( _attributes.groupCount > 0 ) { attributes.groupIds = _attributes.getGroupList(); } if ( _attributes.userStringCount > 0 ) { attributes.userStrings = _attributes.getUserStrings(); } if ( _geometry.userStringCount > 0 ) { attributes.geometry.userStrings = _geometry.getUserStrings(); } if ( _attributes.decals().count > 0 ) { self.postMessage( { type: 'warning', id: taskID, data: { message: `THREE.3DMLoader: No conversion exists for the decals associated with this object.`, type: 'no conversion', guid: _attributes.id } } ); } attributes.drawColor = _attributes.drawColor( doc ); objectType = objectType.constructor.name; objectType = objectType.substring( 11, objectType.length ); return { geometry, attributes, objectType }; } else { self.postMessage( { type: 'warning', id: taskID, data: { message: `THREE.3DMLoader: ${objectType.constructor.name} has no associated mesh geometry.`, type: 'missing mesh', guid: _attributes.id } } ); } } function extractProperties( object ) { const result = {}; for ( const property in object ) { const value = object[ property ]; if ( typeof value !== 'function' ) { if ( typeof value === 'object' && value !== null && value.hasOwnProperty( 'constructor' ) ) { result[ property ] = { name: value.constructor.name, value: value.value }; } else if ( typeof value === 'object' && value !== null ) { result[ property ] = extractProperties( value ); } else { result[ property ] = value; } } else { // these are functions that could be called to extract more data. //console.log( `${property}: ${object[ property ].constructor.name}` ); } } return result; } function curveToPoints( curve, pointLimit ) { let pointCount = pointLimit; let rc = []; const ts = []; if ( curve instanceof rhino.LineCurve ) { return [ curve.pointAtStart, curve.pointAtEnd ]; } if ( curve instanceof rhino.PolylineCurve ) { pointCount = curve.pointCount; for ( let i = 0; i < pointCount; i ++ ) { rc.push( curve.point( i ) ); } return rc; } if ( curve instanceof rhino.PolyCurve ) { const segmentCount = curve.segmentCount; for ( let i = 0; i < segmentCount; i ++ ) { const segment = curve.segmentCurve( i ); const segmentArray = curveToPoints( segment, pointCount ); rc = rc.concat( segmentArray ); segment.delete(); } return rc; } if ( curve instanceof rhino.ArcCurve ) { pointCount = Math.floor( curve.angleDegrees / 5 ); pointCount = pointCount < 2 ? 2 : pointCount; // alternative to this hardcoded version: https://stackoverflow.com/a/18499923/2179399 } if ( curve instanceof rhino.NurbsCurve && curve.degree === 1 ) { const pLine = curve.tryGetPolyline(); for ( let i = 0; i < pLine.count; i ++ ) { rc.push( pLine.get( i ) ); } pLine.delete(); return rc; } const domain = curve.domain; const divisions = pointCount - 1.0; for ( let j = 0; j < pointCount; j ++ ) { const t = domain[ 0 ] + ( j / divisions ) * ( domain[ 1 ] - domain[ 0 ] ); if ( t === domain[ 0 ] || t === domain[ 1 ] ) { ts.push( t ); continue; } const tan = curve.tangentAt( t ); const prevTan = curve.tangentAt( ts.slice( - 1 )[ 0 ] ); // Duplicated from THREE.Vector3 // How to pass imports to worker? const tS = tan[ 0 ] * tan[ 0 ] + tan[ 1 ] * tan[ 1 ] + tan[ 2 ] * tan[ 2 ]; const ptS = prevTan[ 0 ] * prevTan[ 0 ] + prevTan[ 1 ] * prevTan[ 1 ] + prevTan[ 2 ] * prevTan[ 2 ]; const denominator = Math.sqrt( tS * ptS ); let angle; if ( denominator === 0 ) { angle = Math.PI / 2; } else { const theta = ( tan.x * prevTan.x + tan.y * prevTan.y + tan.z * prevTan.z ) / denominator; angle = Math.acos( Math.max( - 1, Math.min( 1, theta ) ) ); } if ( angle < 0.1 ) continue; ts.push( t ); } rc = ts.map( t => curve.pointAt( t ) ); return rc; } } export { Rhino3dmLoader };"},{"title":"","date":"2023-10-12T14:08:40.642Z","updated":"2023-10-12T14:08:40.642Z","comments":true,"path":"js/three/jsm/loaders/3MFLoader.js","permalink":"http://19999997.xyz/js/three/jsm/loaders/3MFLoader.js","excerpt":"","text":"import { BufferAttribute, BufferGeometry, ClampToEdgeWrapping, Color, FileLoader, Float32BufferAttribute, Group, LinearFilter, LinearMipmapLinearFilter, Loader, Matrix4, Mesh, MeshPhongMaterial, MeshStandardMaterial, MirroredRepeatWrapping, NearestFilter, RepeatWrapping, TextureLoader, SRGBColorSpace } from 'three'; import * as fflate from '../libs/fflate.module.js'; const COLOR_SPACE_3MF = SRGBColorSpace; /** * * 3D Manufacturing Format (3MF) specification: https://3mf.io/specification/ * * The following features from the core specification are supported: * * - 3D Models * - Object Resources (Meshes and Components) * - Material Resources (Base Materials) * * 3MF Materials and Properties Extension are only partially supported. * * - Texture 2D * - Texture 2D Groups * - Color Groups (Vertex Colors) * - Metallic Display Properties (PBR) */ class ThreeMFLoader extends Loader { constructor( manager ) { super( manager ); this.availableExtensions = []; } load( url, onLoad, onProgress, onError ) { const scope = this; const loader = new FileLoader( scope.manager ); loader.setPath( scope.path ); loader.setResponseType( 'arraybuffer' ); loader.setRequestHeader( scope.requestHeader ); loader.setWithCredentials( scope.withCredentials ); loader.load( url, function ( buffer ) { try { onLoad( scope.parse( buffer ) ); } catch ( e ) { if ( onError ) { onError( e ); } else { console.error( e ); } scope.manager.itemError( url ); } }, onProgress, onError ); } parse( data ) { const scope = this; const textureLoader = new TextureLoader( this.manager ); function loadDocument( data ) { let zip = null; let file = null; let relsName; let modelRelsName; const modelPartNames = []; const texturesPartNames = []; let modelRels; const modelParts = {}; const printTicketParts = {}; const texturesParts = {}; const textDecoder = new TextDecoder(); try { zip = fflate.unzipSync( new Uint8Array( data ) ); } catch ( e ) { if ( e instanceof ReferenceError ) { console.error( 'THREE.3MFLoader: fflate missing and file is compressed.' ); return null; } } for ( file in zip ) { if ( file.match( /\\_rels\\/.rels$/ ) ) { relsName = file; } else if ( file.match( /3D\\/_rels\\/.*\\.model\\.rels$/ ) ) { modelRelsName = file; } else if ( file.match( /^3D\\/.*\\.model$/ ) ) { modelPartNames.push( file ); } else if ( file.match( /^3D\\/Textures?\\/.*/ ) ) { texturesPartNames.push( file ); } } // const relsView = zip[ relsName ]; const relsFileText = textDecoder.decode( relsView ); const rels = parseRelsXml( relsFileText ); // if ( modelRelsName ) { const relsView = zip[ modelRelsName ]; const relsFileText = textDecoder.decode( relsView ); modelRels = parseRelsXml( relsFileText ); } // for ( let i = 0; i < modelPartNames.length; i ++ ) { const modelPart = modelPartNames[ i ]; const view = zip[ modelPart ]; const fileText = textDecoder.decode( view ); const xmlData = new DOMParser().parseFromString( fileText, 'application/xml' ); if ( xmlData.documentElement.nodeName.toLowerCase() !== 'model' ) { console.error( 'THREE.3MFLoader: Error loading 3MF - no 3MF document found: ', modelPart ); } const modelNode = xmlData.querySelector( 'model' ); const extensions = {}; for ( let i = 0; i < modelNode.attributes.length; i ++ ) { const attr = modelNode.attributes[ i ]; if ( attr.name.match( /^xmlns:(.+)$/ ) ) { extensions[ attr.value ] = RegExp.$1; } } const modelData = parseModelNode( modelNode ); modelData[ 'xml' ] = modelNode; if ( 0 < Object.keys( extensions ).length ) { modelData[ 'extensions' ] = extensions; } modelParts[ modelPart ] = modelData; } // for ( let i = 0; i < texturesPartNames.length; i ++ ) { const texturesPartName = texturesPartNames[ i ]; texturesParts[ texturesPartName ] = zip[ texturesPartName ].buffer; } return { rels: rels, modelRels: modelRels, model: modelParts, printTicket: printTicketParts, texture: texturesParts }; } function parseRelsXml( relsFileText ) { const relationships = []; const relsXmlData = new DOMParser().parseFromString( relsFileText, 'application/xml' ); const relsNodes = relsXmlData.querySelectorAll( 'Relationship' ); for ( let i = 0; i < relsNodes.length; i ++ ) { const relsNode = relsNodes[ i ]; const relationship = { target: relsNode.getAttribute( 'Target' ), //required id: relsNode.getAttribute( 'Id' ), //required type: relsNode.getAttribute( 'Type' ) //required }; relationships.push( relationship ); } return relationships; } function parseMetadataNodes( metadataNodes ) { const metadataData = {}; for ( let i = 0; i < metadataNodes.length; i ++ ) { const metadataNode = metadataNodes[ i ]; const name = metadataNode.getAttribute( 'name' ); const validNames = [ 'Title', 'Designer', 'Description', 'Copyright', 'LicenseTerms', 'Rating', 'CreationDate', 'ModificationDate' ]; if ( 0"},{"title":"","date":"2023-10-12T14:08:40.644Z","updated":"2023-10-12T14:08:40.644Z","comments":true,"path":"js/three/jsm/loaders/AMFLoader.js","permalink":"http://19999997.xyz/js/three/jsm/loaders/AMFLoader.js","excerpt":"","text":"import { BufferGeometry, Color, FileLoader, Float32BufferAttribute, Group, Loader, Mesh, MeshPhongMaterial } from 'three'; import * as fflate from '../libs/fflate.module.js'; /** * Description: Early release of an AMF Loader following the pattern of the * example loaders in the three.js project. * * Usage: * const loader = new AMFLoader(); * loader.load('/path/to/project.amf', function(objecttree) { * scene.add(objecttree); * }); * * Materials now supported, material colors supported * Zip support, requires fflate * No constellation support (yet)! * */ class AMFLoader extends Loader { constructor( manager ) { super( manager ); } load( url, onLoad, onProgress, onError ) { const scope = this; const loader = new FileLoader( scope.manager ); loader.setPath( scope.path ); loader.setResponseType( 'arraybuffer' ); loader.setRequestHeader( scope.requestHeader ); loader.setWithCredentials( scope.withCredentials ); loader.load( url, function ( text ) { try { onLoad( scope.parse( text ) ); } catch ( e ) { if ( onError ) { onError( e ); } else { console.error( e ); } scope.manager.itemError( url ); } }, onProgress, onError ); } parse( data ) { function loadDocument( data ) { let view = new DataView( data ); const magic = String.fromCharCode( view.getUint8( 0 ), view.getUint8( 1 ) ); if ( magic === 'PK' ) { let zip = null; let file = null; console.log( 'THREE.AMFLoader: Loading Zip' ); try { zip = fflate.unzipSync( new Uint8Array( data ) ); } catch ( e ) { if ( e instanceof ReferenceError ) { console.log( 'THREE.AMFLoader: fflate missing and file is compressed.' ); return null; } } for ( file in zip ) { if ( file.toLowerCase().slice( - 4 ) === '.amf' ) { break; } } console.log( 'THREE.AMFLoader: Trying to load file asset: ' + file ); view = new DataView( zip[ file ].buffer ); } const fileText = new TextDecoder().decode( view ); const xmlData = new DOMParser().parseFromString( fileText, 'application/xml' ); if ( xmlData.documentElement.nodeName.toLowerCase() !== 'amf' ) { console.log( 'THREE.AMFLoader: Error loading AMF - no AMF document found.' ); return null; } return xmlData; } function loadDocumentScale( node ) { let scale = 1.0; let unit = 'millimeter'; if ( node.documentElement.attributes.unit !== undefined ) { unit = node.documentElement.attributes.unit.value.toLowerCase(); } const scaleUnits = { millimeter: 1.0, inch: 25.4, feet: 304.8, meter: 1000.0, micron: 0.001 }; if ( scaleUnits[ unit ] !== undefined ) { scale = scaleUnits[ unit ]; } console.log( 'THREE.AMFLoader: Unit scale: ' + scale ); return scale; } function loadMaterials( node ) { let matName = 'AMF Material'; const matId = node.attributes.id.textContent; let color = { r: 1.0, g: 1.0, b: 1.0, a: 1.0 }; let loadedMaterial = null; for ( let i = 0; i < node.childNodes.length; i ++ ) { const matChildEl = node.childNodes[ i ]; if ( matChildEl.nodeName === 'metadata' && matChildEl.attributes.type !== undefined ) { if ( matChildEl.attributes.type.value === 'name' ) { matName = matChildEl.textContent; } } else if ( matChildEl.nodeName === 'color' ) { color = loadColor( matChildEl ); } } loadedMaterial = new MeshPhongMaterial( { flatShading: true, color: new Color( color.r, color.g, color.b ), name: matName } ); if ( color.a !== 1.0 ) { loadedMaterial.transparent = true; loadedMaterial.opacity = color.a; } return { id: matId, material: loadedMaterial }; } function loadColor( node ) { const color = { r: 1.0, g: 1.0, b: 1.0, a: 1.0 }; for ( let i = 0; i < node.childNodes.length; i ++ ) { const matColor = node.childNodes[ i ]; if ( matColor.nodeName === 'r' ) { color.r = matColor.textContent; } else if ( matColor.nodeName === 'g' ) { color.g = matColor.textContent; } else if ( matColor.nodeName === 'b' ) { color.b = matColor.textContent; } else if ( matColor.nodeName === 'a' ) { color.a = matColor.textContent; } } return color; } function loadMeshVolume( node ) { const volume = { name: '', triangles: [], materialid: null }; let currVolumeNode = node.firstElementChild; if ( node.attributes.materialid !== undefined ) { volume.materialId = node.attributes.materialid.nodeValue; } while ( currVolumeNode ) { if ( currVolumeNode.nodeName === 'metadata' ) { if ( currVolumeNode.attributes.type !== undefined ) { if ( currVolumeNode.attributes.type.value === 'name' ) { volume.name = currVolumeNode.textContent; } } } else if ( currVolumeNode.nodeName === 'triangle' ) { const v1 = currVolumeNode.getElementsByTagName( 'v1' )[ 0 ].textContent; const v2 = currVolumeNode.getElementsByTagName( 'v2' )[ 0 ].textContent; const v3 = currVolumeNode.getElementsByTagName( 'v3' )[ 0 ].textContent; volume.triangles.push( v1, v2, v3 ); } currVolumeNode = currVolumeNode.nextElementSibling; } return volume; } function loadMeshVertices( node ) { const vertArray = []; const normalArray = []; let currVerticesNode = node.firstElementChild; while ( currVerticesNode ) { if ( currVerticesNode.nodeName === 'vertex' ) { let vNode = currVerticesNode.firstElementChild; while ( vNode ) { if ( vNode.nodeName === 'coordinates' ) { const x = vNode.getElementsByTagName( 'x' )[ 0 ].textContent; const y = vNode.getElementsByTagName( 'y' )[ 0 ].textContent; const z = vNode.getElementsByTagName( 'z' )[ 0 ].textContent; vertArray.push( x, y, z ); } else if ( vNode.nodeName === 'normal' ) { const nx = vNode.getElementsByTagName( 'nx' )[ 0 ].textContent; const ny = vNode.getElementsByTagName( 'ny' )[ 0 ].textContent; const nz = vNode.getElementsByTagName( 'nz' )[ 0 ].textContent; normalArray.push( nx, ny, nz ); } vNode = vNode.nextElementSibling; } } currVerticesNode = currVerticesNode.nextElementSibling; } return { 'vertices': vertArray, 'normals': normalArray }; } function loadObject( node ) { const objId = node.attributes.id.textContent; const loadedObject = { name: 'amfobject', meshes: [] }; let currColor = null; let currObjNode = node.firstElementChild; while ( currObjNode ) { if ( currObjNode.nodeName === 'metadata' ) { if ( currObjNode.attributes.type !== undefined ) { if ( currObjNode.attributes.type.value === 'name' ) { loadedObject.name = currObjNode.textContent; } } } else if ( currObjNode.nodeName === 'color' ) { currColor = loadColor( currObjNode ); } else if ( currObjNode.nodeName === 'mesh' ) { let currMeshNode = currObjNode.firstElementChild; const mesh = { vertices: [], normals: [], volumes: [], color: currColor }; while ( currMeshNode ) { if ( currMeshNode.nodeName === 'vertices' ) { const loadedVertices = loadMeshVertices( currMeshNode ); mesh.normals = mesh.normals.concat( loadedVertices.normals ); mesh.vertices = mesh.vertices.concat( loadedVertices.vertices ); } else if ( currMeshNode.nodeName === 'volume' ) { mesh.volumes.push( loadMeshVolume( currMeshNode ) ); } currMeshNode = currMeshNode.nextElementSibling; } loadedObject.meshes.push( mesh ); } currObjNode = currObjNode.nextElementSibling; } return { 'id': objId, 'obj': loadedObject }; } const xmlData = loadDocument( data ); let amfName = ''; let amfAuthor = ''; const amfScale = loadDocumentScale( xmlData ); const amfMaterials = {}; const amfObjects = {}; const childNodes = xmlData.documentElement.childNodes; let i, j; for ( i = 0; i < childNodes.length; i ++ ) { const child = childNodes[ i ]; if ( child.nodeName === 'metadata' ) { if ( child.attributes.type !== undefined ) { if ( child.attributes.type.value === 'name' ) { amfName = child.textContent; } else if ( child.attributes.type.value === 'author' ) { amfAuthor = child.textContent; } } } else if ( child.nodeName === 'material' ) { const loadedMaterial = loadMaterials( child ); amfMaterials[ loadedMaterial.id ] = loadedMaterial.material; } else if ( child.nodeName === 'object' ) { const loadedObject = loadObject( child ); amfObjects[ loadedObject.id ] = loadedObject.obj; } } const sceneObject = new Group(); const defaultMaterial = new MeshPhongMaterial( { name: Loader.DEFAULT_MATERIAL_NAME, color: 0xaaaaff, flatShading: true } ); sceneObject.name = amfName; sceneObject.userData.author = amfAuthor; sceneObject.userData.loader = 'AMF'; for ( const id in amfObjects ) { const part = amfObjects[ id ]; const meshes = part.meshes; const newObject = new Group(); newObject.name = part.name || ''; for ( i = 0; i < meshes.length; i ++ ) { let objDefaultMaterial = defaultMaterial; const mesh = meshes[ i ]; const vertices = new Float32BufferAttribute( mesh.vertices, 3 ); let normals = null; if ( mesh.normals.length ) { normals = new Float32BufferAttribute( mesh.normals, 3 ); } if ( mesh.color ) { const color = mesh.color; objDefaultMaterial = defaultMaterial.clone(); objDefaultMaterial.color = new Color( color.r, color.g, color.b ); if ( color.a !== 1.0 ) { objDefaultMaterial.transparent = true; objDefaultMaterial.opacity = color.a; } } const volumes = mesh.volumes; for ( j = 0; j < volumes.length; j ++ ) { const volume = volumes[ j ]; const newGeometry = new BufferGeometry(); let material = objDefaultMaterial; newGeometry.setIndex( volume.triangles ); newGeometry.setAttribute( 'position', vertices.clone() ); if ( normals ) { newGeometry.setAttribute( 'normal', normals.clone() ); } if ( amfMaterials[ volume.materialId ] !== undefined ) { material = amfMaterials[ volume.materialId ]; } newGeometry.scale( amfScale, amfScale, amfScale ); newObject.add( new Mesh( newGeometry, material.clone() ) ); } } sceneObject.add( newObject ); } return sceneObject; } } export { AMFLoader };"},{"title":"","date":"2023-10-12T14:08:40.646Z","updated":"2023-10-12T14:08:40.646Z","comments":true,"path":"js/three/jsm/loaders/BVHLoader.js","permalink":"http://19999997.xyz/js/three/jsm/loaders/BVHLoader.js","excerpt":"","text":"import { AnimationClip, Bone, FileLoader, Loader, Quaternion, QuaternionKeyframeTrack, Skeleton, Vector3, VectorKeyframeTrack } from 'three'; /** * Description: reads BVH files and outputs a single Skeleton and an AnimationClip * * Currently only supports bvh files containing a single root. * */ class BVHLoader extends Loader { constructor( manager ) { super( manager ); this.animateBonePositions = true; this.animateBoneRotations = true; } load( url, onLoad, onProgress, onError ) { const scope = this; const loader = new FileLoader( scope.manager ); loader.setPath( scope.path ); loader.setRequestHeader( scope.requestHeader ); loader.setWithCredentials( scope.withCredentials ); loader.load( url, function ( text ) { try { onLoad( scope.parse( text ) ); } catch ( e ) { if ( onError ) { onError( e ); } else { console.error( e ); } scope.manager.itemError( url ); } }, onProgress, onError ); } parse( text ) { /* reads a string array (lines) from a BVH file and outputs a skeleton structure including motion data returns thee root node: { name: '', channels: [], children: [] } */ function readBvh( lines ) { // read model structure if ( nextLine( lines ) !== 'HIERARCHY' ) { console.error( 'THREE.BVHLoader: HIERARCHY expected.' ); } const list = []; // collects flat array of all bones const root = readNode( lines, nextLine( lines ), list ); // read motion data if ( nextLine( lines ) !== 'MOTION' ) { console.error( 'THREE.BVHLoader: MOTION expected.' ); } // number of frames let tokens = nextLine( lines ).split( /[\\s]+/ ); const numFrames = parseInt( tokens[ 1 ] ); if ( isNaN( numFrames ) ) { console.error( 'THREE.BVHLoader: Failed to read number of frames.' ); } // frame time tokens = nextLine( lines ).split( /[\\s]+/ ); const frameTime = parseFloat( tokens[ 2 ] ); if ( isNaN( frameTime ) ) { console.error( 'THREE.BVHLoader: Failed to read frame time.' ); } // read frame data line by line for ( let i = 0; i < numFrames; i ++ ) { tokens = nextLine( lines ).split( /[\\s]+/ ); readFrameData( tokens, i * frameTime, root ); } return list; } /* Recursively reads data from a single frame into the bone hierarchy. The passed bone hierarchy has to be structured in the same order as the BVH file. keyframe data is stored in bone.frames. - data: splitted string array (frame values), values are shift()ed so this should be empty after parsing the whole hierarchy. - frameTime: playback time for this keyframe. - bone: the bone to read frame data from. */ function readFrameData( data, frameTime, bone ) { // end sites have no motion data if ( bone.type === 'ENDSITE' ) return; // add keyframe const keyframe = { time: frameTime, position: new Vector3(), rotation: new Quaternion() }; bone.frames.push( keyframe ); const quat = new Quaternion(); const vx = new Vector3( 1, 0, 0 ); const vy = new Vector3( 0, 1, 0 ); const vz = new Vector3( 0, 0, 1 ); // parse values for each channel in node for ( let i = 0; i < bone.channels.length; i ++ ) { switch ( bone.channels[ i ] ) { case 'Xposition': keyframe.position.x = parseFloat( data.shift().trim() ); break; case 'Yposition': keyframe.position.y = parseFloat( data.shift().trim() ); break; case 'Zposition': keyframe.position.z = parseFloat( data.shift().trim() ); break; case 'Xrotation': quat.setFromAxisAngle( vx, parseFloat( data.shift().trim() ) * Math.PI / 180 ); keyframe.rotation.multiply( quat ); break; case 'Yrotation': quat.setFromAxisAngle( vy, parseFloat( data.shift().trim() ) * Math.PI / 180 ); keyframe.rotation.multiply( quat ); break; case 'Zrotation': quat.setFromAxisAngle( vz, parseFloat( data.shift().trim() ) * Math.PI / 180 ); keyframe.rotation.multiply( quat ); break; default: console.warn( 'THREE.BVHLoader: Invalid channel type.' ); } } // parse child nodes for ( let i = 0; i < bone.children.length; i ++ ) { readFrameData( data, frameTime, bone.children[ i ] ); } } /* Recursively parses the HIERACHY section of the BVH file - lines: all lines of the file. lines are consumed as we go along. - firstline: line containing the node type and name e.g. 'JOINT hip' - list: collects a flat list of nodes returns: a BVH node including children */ function readNode( lines, firstline, list ) { const node = { name: '', type: '', frames: [] }; list.push( node ); // parse node type and name let tokens = firstline.split( /[\\s]+/ ); if ( tokens[ 0 ].toUpperCase() === 'END' && tokens[ 1 ].toUpperCase() === 'SITE' ) { node.type = 'ENDSITE'; node.name = 'ENDSITE'; // bvh end sites have no name } else { node.name = tokens[ 1 ]; node.type = tokens[ 0 ].toUpperCase(); } if ( nextLine( lines ) !== '{' ) { console.error( 'THREE.BVHLoader: Expected opening { after type & name' ); } // parse OFFSET tokens = nextLine( lines ).split( /[\\s]+/ ); if ( tokens[ 0 ] !== 'OFFSET' ) { console.error( 'THREE.BVHLoader: Expected OFFSET but got: ' + tokens[ 0 ] ); } if ( tokens.length !== 4 ) { console.error( 'THREE.BVHLoader: Invalid number of values for OFFSET.' ); } const offset = new Vector3( parseFloat( tokens[ 1 ] ), parseFloat( tokens[ 2 ] ), parseFloat( tokens[ 3 ] ) ); if ( isNaN( offset.x ) || isNaN( offset.y ) || isNaN( offset.z ) ) { console.error( 'THREE.BVHLoader: Invalid values of OFFSET.' ); } node.offset = offset; // parse CHANNELS definitions if ( node.type !== 'ENDSITE' ) { tokens = nextLine( lines ).split( /[\\s]+/ ); if ( tokens[ 0 ] !== 'CHANNELS' ) { console.error( 'THREE.BVHLoader: Expected CHANNELS definition.' ); } const numChannels = parseInt( tokens[ 1 ] ); node.channels = tokens.splice( 2, numChannels ); node.children = []; } // read children while ( true ) { const line = nextLine( lines ); if ( line === '}' ) { return node; } else { node.children.push( readNode( lines, line, list ) ); } } } /* recursively converts the internal bvh node structure to a Bone hierarchy source: the bvh root node list: pass an empty array, collects a flat list of all converted THREE.Bones returns the root Bone */ function toTHREEBone( source, list ) { const bone = new Bone(); list.push( bone ); bone.position.add( source.offset ); bone.name = source.name; if ( source.type !== 'ENDSITE' ) { for ( let i = 0; i < source.children.length; i ++ ) { bone.add( toTHREEBone( source.children[ i ], list ) ); } } return bone; } /* builds a AnimationClip from the keyframe data saved in each bone. bone: bvh root node returns: a AnimationClip containing position and quaternion tracks */ function toTHREEAnimation( bones ) { const tracks = []; // create a position and quaternion animation track for each node for ( let i = 0; i < bones.length; i ++ ) { const bone = bones[ i ]; if ( bone.type === 'ENDSITE' ) continue; // track data const times = []; const positions = []; const rotations = []; for ( let j = 0; j < bone.frames.length; j ++ ) { const frame = bone.frames[ j ]; times.push( frame.time ); // the animation system animates the position property, // so we have to add the joint offset to all values positions.push( frame.position.x + bone.offset.x ); positions.push( frame.position.y + bone.offset.y ); positions.push( frame.position.z + bone.offset.z ); rotations.push( frame.rotation.x ); rotations.push( frame.rotation.y ); rotations.push( frame.rotation.z ); rotations.push( frame.rotation.w ); } if ( scope.animateBonePositions ) { tracks.push( new VectorKeyframeTrack( bone.name + '.position', times, positions ) ); } if ( scope.animateBoneRotations ) { tracks.push( new QuaternionKeyframeTrack( bone.name + '.quaternion', times, rotations ) ); } } return new AnimationClip( 'animation', - 1, tracks ); } /* returns the next non-empty line in lines */ function nextLine( lines ) { let line; // skip empty lines while ( ( line = lines.shift().trim() ).length === 0 ) { } return line; } const scope = this; const lines = text.split( /[\\r\\n]+/g ); const bones = readBvh( lines ); const threeBones = []; toTHREEBone( bones[ 0 ], threeBones ); const threeClip = toTHREEAnimation( bones ); return { skeleton: new Skeleton( threeBones ), clip: threeClip }; } } export { BVHLoader };"},{"title":"","date":"2023-10-12T14:08:40.649Z","updated":"2023-10-12T14:08:40.649Z","comments":true,"path":"js/three/jsm/loaders/ColladaLoader.js","permalink":"http://19999997.xyz/js/three/jsm/loaders/ColladaLoader.js","excerpt":"","text":"import { AmbientLight, AnimationClip, Bone, BufferGeometry, ClampToEdgeWrapping, Color, DirectionalLight, DoubleSide, FileLoader, Float32BufferAttribute, FrontSide, Group, Line, LineBasicMaterial, LineSegments, Loader, LoaderUtils, MathUtils, Matrix4, Mesh, MeshBasicMaterial, MeshLambertMaterial, MeshPhongMaterial, OrthographicCamera, PerspectiveCamera, PointLight, Quaternion, QuaternionKeyframeTrack, RepeatWrapping, Scene, Skeleton, SkinnedMesh, SpotLight, TextureLoader, Vector2, Vector3, VectorKeyframeTrack, SRGBColorSpace } from 'three'; import { TGALoader } from '../loaders/TGALoader.js'; class ColladaLoader extends Loader { constructor( manager ) { super( manager ); } load( url, onLoad, onProgress, onError ) { const scope = this; const path = ( scope.path === '' ) ? LoaderUtils.extractUrlBase( url ) : scope.path; const loader = new FileLoader( scope.manager ); loader.setPath( scope.path ); loader.setRequestHeader( scope.requestHeader ); loader.setWithCredentials( scope.withCredentials ); loader.load( url, function ( text ) { try { onLoad( scope.parse( text, path ) ); } catch ( e ) { if ( onError ) { onError( e ); } else { console.error( e ); } scope.manager.itemError( url ); } }, onProgress, onError ); } parse( text, path ) { function getElementsByTagName( xml, name ) { // Non recursive xml.getElementsByTagName() ... const array = []; const childNodes = xml.childNodes; for ( let i = 0, l = childNodes.length; i < l; i ++ ) { const child = childNodes[ i ]; if ( child.nodeName === name ) { array.push( child ); } } return array; } function parseStrings( text ) { if ( text.length === 0 ) return []; const parts = text.trim().split( /\\s+/ ); const array = new Array( parts.length ); for ( let i = 0, l = parts.length; i < l; i ++ ) { array[ i ] = parts[ i ]; } return array; } function parseFloats( text ) { if ( text.length === 0 ) return []; const parts = text.trim().split( /\\s+/ ); const array = new Array( parts.length ); for ( let i = 0, l = parts.length; i < l; i ++ ) { array[ i ] = parseFloat( parts[ i ] ); } return array; } function parseInts( text ) { if ( text.length === 0 ) return []; const parts = text.trim().split( /\\s+/ ); const array = new Array( parts.length ); for ( let i = 0, l = parts.length; i < l; i ++ ) { array[ i ] = parseInt( parts[ i ] ); } return array; } function parseId( text ) { return text.substring( 1 ); } function generateId() { return 'three_default_' + ( count ++ ); } function isEmpty( object ) { return Object.keys( object ).length === 0; } // asset function parseAsset( xml ) { return { unit: parseAssetUnit( getElementsByTagName( xml, 'unit' )[ 0 ] ), upAxis: parseAssetUpAxis( getElementsByTagName( xml, 'up_axis' )[ 0 ] ) }; } function parseAssetUnit( xml ) { if ( ( xml !== undefined ) && ( xml.hasAttribute( 'meter' ) === true ) ) { return parseFloat( xml.getAttribute( 'meter' ) ); } else { return 1; // default 1 meter } } function parseAssetUpAxis( xml ) { return xml !== undefined ? xml.textContent : 'Y_UP'; } // library function parseLibrary( xml, libraryName, nodeName, parser ) { const library = getElementsByTagName( xml, libraryName )[ 0 ]; if ( library !== undefined ) { const elements = getElementsByTagName( library, nodeName ); for ( let i = 0; i < elements.length; i ++ ) { parser( elements[ i ] ); } } } function buildLibrary( data, builder ) { for ( const name in data ) { const object = data[ name ]; object.build = builder( data[ name ] ); } } // get function getBuild( data, builder ) { if ( data.build !== undefined ) return data.build; data.build = builder( data ); return data.build; } // animation function parseAnimation( xml ) { const data = { sources: {}, samplers: {}, channels: {} }; let hasChildren = false; for ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) { const child = xml.childNodes[ i ]; if ( child.nodeType !== 1 ) continue; let id; switch ( child.nodeName ) { case 'source': id = child.getAttribute( 'id' ); data.sources[ id ] = parseSource( child ); break; case 'sampler': id = child.getAttribute( 'id' ); data.samplers[ id ] = parseAnimationSampler( child ); break; case 'channel': id = child.getAttribute( 'target' ); data.channels[ id ] = parseAnimationChannel( child ); break; case 'animation': // hierarchy of related animations parseAnimation( child ); hasChildren = true; break; default: console.log( child ); } } if ( hasChildren === false ) { // since 'id' attributes can be optional, it's necessary to generate a UUID for unqiue assignment library.animations[ xml.getAttribute( 'id' ) || MathUtils.generateUUID() ] = data; } } function parseAnimationSampler( xml ) { const data = { inputs: {}, }; for ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) { const child = xml.childNodes[ i ]; if ( child.nodeType !== 1 ) continue; switch ( child.nodeName ) { case 'input': const id = parseId( child.getAttribute( 'source' ) ); const semantic = child.getAttribute( 'semantic' ); data.inputs[ semantic ] = id; break; } } return data; } function parseAnimationChannel( xml ) { const data = {}; const target = xml.getAttribute( 'target' ); // parsing SID Addressing Syntax let parts = target.split( '/' ); const id = parts.shift(); let sid = parts.shift(); // check selection syntax const arraySyntax = ( sid.indexOf( '(' ) !== - 1 ); const memberSyntax = ( sid.indexOf( '.' ) !== - 1 ); if ( memberSyntax ) { // member selection access parts = sid.split( '.' ); sid = parts.shift(); data.member = parts.shift(); } else if ( arraySyntax ) { // array-access syntax. can be used to express fields in one-dimensional vectors or two-dimensional matrices. const indices = sid.split( '(' ); sid = indices.shift(); for ( let i = 0; i < indices.length; i ++ ) { indices[ i ] = parseInt( indices[ i ].replace( /\\)/, '' ) ); } data.indices = indices; } data.id = id; data.sid = sid; data.arraySyntax = arraySyntax; data.memberSyntax = memberSyntax; data.sampler = parseId( xml.getAttribute( 'source' ) ); return data; } function buildAnimation( data ) { const tracks = []; const channels = data.channels; const samplers = data.samplers; const sources = data.sources; for ( const target in channels ) { if ( channels.hasOwnProperty( target ) ) { const channel = channels[ target ]; const sampler = samplers[ channel.sampler ]; const inputId = sampler.inputs.INPUT; const outputId = sampler.inputs.OUTPUT; const inputSource = sources[ inputId ]; const outputSource = sources[ outputId ]; const animation = buildAnimationChannel( channel, inputSource, outputSource ); createKeyframeTracks( animation, tracks ); } } return tracks; } function getAnimation( id ) { return getBuild( library.animations[ id ], buildAnimation ); } function buildAnimationChannel( channel, inputSource, outputSource ) { const node = library.nodes[ channel.id ]; const object3D = getNode( node.id ); const transform = node.transforms[ channel.sid ]; const defaultMatrix = node.matrix.clone().transpose(); let time, stride; let i, il, j, jl; const data = {}; // the collada spec allows the animation of data in various ways. // depending on the transform type (matrix, translate, rotate, scale), we execute different logic switch ( transform ) { case 'matrix': for ( i = 0, il = inputSource.array.length; i < il; i ++ ) { time = inputSource.array[ i ]; stride = i * outputSource.stride; if ( data[ time ] === undefined ) data[ time ] = {}; if ( channel.arraySyntax === true ) { const value = outputSource.array[ stride ]; const index = channel.indices[ 0 ] + 4 * channel.indices[ 1 ]; data[ time ][ index ] = value; } else { for ( j = 0, jl = outputSource.stride; j < jl; j ++ ) { data[ time ][ j ] = outputSource.array[ stride + j ]; } } } break; case 'translate': console.warn( 'THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform ); break; case 'rotate': console.warn( 'THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform ); break; case 'scale': console.warn( 'THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform ); break; } const keyframes = prepareAnimationData( data, defaultMatrix ); const animation = { name: object3D.uuid, keyframes: keyframes }; return animation; } function prepareAnimationData( data, defaultMatrix ) { const keyframes = []; // transfer data into a sortable array for ( const time in data ) { keyframes.push( { time: parseFloat( time ), value: data[ time ] } ); } // ensure keyframes are sorted by time keyframes.sort( ascending ); // now we clean up all animation data, so we can use them for keyframe tracks for ( let i = 0; i < 16; i ++ ) { transformAnimationData( keyframes, i, defaultMatrix.elements[ i ] ); } return keyframes; // array sort function function ascending( a, b ) { return a.time - b.time; } } const position = new Vector3(); const scale = new Vector3(); const quaternion = new Quaternion(); function createKeyframeTracks( animation, tracks ) { const keyframes = animation.keyframes; const name = animation.name; const times = []; const positionData = []; const quaternionData = []; const scaleData = []; for ( let i = 0, l = keyframes.length; i < l; i ++ ) { const keyframe = keyframes[ i ]; const time = keyframe.time; const value = keyframe.value; matrix.fromArray( value ).transpose(); matrix.decompose( position, quaternion, scale ); times.push( time ); positionData.push( position.x, position.y, position.z ); quaternionData.push( quaternion.x, quaternion.y, quaternion.z, quaternion.w ); scaleData.push( scale.x, scale.y, scale.z ); } if ( positionData.length > 0 ) tracks.push( new VectorKeyframeTrack( name + '.position', times, positionData ) ); if ( quaternionData.length > 0 ) tracks.push( new QuaternionKeyframeTrack( name + '.quaternion', times, quaternionData ) ); if ( scaleData.length > 0 ) tracks.push( new VectorKeyframeTrack( name + '.scale', times, scaleData ) ); return tracks; } function transformAnimationData( keyframes, property, defaultValue ) { let keyframe; let empty = true; let i, l; // check, if values of a property are missing in our keyframes for ( i = 0, l = keyframes.length; i < l; i ++ ) { keyframe = keyframes[ i ]; if ( keyframe.value[ property ] === undefined ) { keyframe.value[ property ] = null; // mark as missing } else { empty = false; } } if ( empty === true ) { // no values at all, so we set a default value for ( i = 0, l = keyframes.length; i < l; i ++ ) { keyframe = keyframes[ i ]; keyframe.value[ property ] = defaultValue; } } else { // filling gaps createMissingKeyframes( keyframes, property ); } } function createMissingKeyframes( keyframes, property ) { let prev, next; for ( let i = 0, l = keyframes.length; i < l; i ++ ) { const keyframe = keyframes[ i ]; if ( keyframe.value[ property ] === null ) { prev = getPrev( keyframes, i, property ); next = getNext( keyframes, i, property ); if ( prev === null ) { keyframe.value[ property ] = next.value[ property ]; continue; } if ( next === null ) { keyframe.value[ property ] = prev.value[ property ]; continue; } interpolate( keyframe, prev, next, property ); } } } function getPrev( keyframes, i, property ) { while ( i >= 0 ) { const keyframe = keyframes[ i ]; if ( keyframe.value[ property ] !== null ) return keyframe; i --; } return null; } function getNext( keyframes, i, property ) { while ( i < keyframes.length ) { const keyframe = keyframes[ i ]; if ( keyframe.value[ property ] !== null ) return keyframe; i ++; } return null; } function interpolate( key, prev, next, property ) { if ( ( next.time - prev.time ) === 0 ) { key.value[ property ] = prev.value[ property ]; return; } key.value[ property ] = ( ( key.time - prev.time ) * ( next.value[ property ] - prev.value[ property ] ) / ( next.time - prev.time ) ) + prev.value[ property ]; } // animation clips function parseAnimationClip( xml ) { const data = { name: xml.getAttribute( 'id' ) || 'default', start: parseFloat( xml.getAttribute( 'start' ) || 0 ), end: parseFloat( xml.getAttribute( 'end' ) || 0 ), animations: [] }; for ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) { const child = xml.childNodes[ i ]; if ( child.nodeType !== 1 ) continue; switch ( child.nodeName ) { case 'instance_animation': data.animations.push( parseId( child.getAttribute( 'url' ) ) ); break; } } library.clips[ xml.getAttribute( 'id' ) ] = data; } function buildAnimationClip( data ) { const tracks = []; const name = data.name; const duration = ( data.end - data.start ) || - 1; const animations = data.animations; for ( let i = 0, il = animations.length; i < il; i ++ ) { const animationTracks = getAnimation( animations[ i ] ); for ( let j = 0, jl = animationTracks.length; j < jl; j ++ ) { tracks.push( animationTracks[ j ] ); } } return new AnimationClip( name, duration, tracks ); } function getAnimationClip( id ) { return getBuild( library.clips[ id ], buildAnimationClip ); } // controller function parseController( xml ) { const data = {}; for ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) { const child = xml.childNodes[ i ]; if ( child.nodeType !== 1 ) continue; switch ( child.nodeName ) { case 'skin': // there is exactly one skin per controller data.id = parseId( child.getAttribute( 'source' ) ); data.skin = parseSkin( child ); break; case 'morph': data.id = parseId( child.getAttribute( 'source' ) ); console.warn( 'THREE.ColladaLoader: Morph target animation not supported yet.' ); break; } } library.controllers[ xml.getAttribute( 'id' ) ] = data; } function parseSkin( xml ) { const data = { sources: {} }; for ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) { const child = xml.childNodes[ i ]; if ( child.nodeType !== 1 ) continue; switch ( child.nodeName ) { case 'bind_shape_matrix': data.bindShapeMatrix = parseFloats( child.textContent ); break; case 'source': const id = child.getAttribute( 'id' ); data.sources[ id ] = parseSource( child ); break; case 'joints': data.joints = parseJoints( child ); break; case 'vertex_weights': data.vertexWeights = parseVertexWeights( child ); break; } } return data; } function parseJoints( xml ) { const data = { inputs: {} }; for ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) { const child = xml.childNodes[ i ]; if ( child.nodeType !== 1 ) continue; switch ( child.nodeName ) { case 'input': const semantic = child.getAttribute( 'semantic' ); const id = parseId( child.getAttribute( 'source' ) ); data.inputs[ semantic ] = id; break; } } return data; } function parseVertexWeights( xml ) { const data = { inputs: {} }; for ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) { const child = xml.childNodes[ i ]; if ( child.nodeType !== 1 ) continue; switch ( child.nodeName ) { case 'input': const semantic = child.getAttribute( 'semantic' ); const id = parseId( child.getAttribute( 'source' ) ); const offset = parseInt( child.getAttribute( 'offset' ) ); data.inputs[ semantic ] = { id: id, offset: offset }; break; case 'vcount': data.vcount = parseInts( child.textContent ); break; case 'v': data.v = parseInts( child.textContent ); break; } } return data; } function buildController( data ) { const build = { id: data.id }; const geometry = library.geometries[ build.id ]; if ( data.skin !== undefined ) { build.skin = buildSkin( data.skin ); // we enhance the 'sources' property of the corresponding geometry with our skin data geometry.sources.skinIndices = build.skin.indices; geometry.sources.skinWeights = build.skin.weights; } return build; } function buildSkin( data ) { const BONE_LIMIT = 4; const build = { joints: [], // this must be an array to preserve the joint order indices: { array: [], stride: BONE_LIMIT }, weights: { array: [], stride: BONE_LIMIT } }; const sources = data.sources; const vertexWeights = data.vertexWeights; const vcount = vertexWeights.vcount; const v = vertexWeights.v; const jointOffset = vertexWeights.inputs.JOINT.offset; const weightOffset = vertexWeights.inputs.WEIGHT.offset; const jointSource = data.sources[ data.joints.inputs.JOINT ]; const inverseSource = data.sources[ data.joints.inputs.INV_BIND_MATRIX ]; const weights = sources[ vertexWeights.inputs.WEIGHT.id ].array; let stride = 0; let i, j, l; // process skin data for each vertex for ( i = 0, l = vcount.length; i < l; i ++ ) { const jointCount = vcount[ i ]; // this is the amount of joints that affect a single vertex const vertexSkinData = []; for ( j = 0; j < jointCount; j ++ ) { const skinIndex = v[ stride + jointOffset ]; const weightId = v[ stride + weightOffset ]; const skinWeight = weights[ weightId ]; vertexSkinData.push( { index: skinIndex, weight: skinWeight } ); stride += 2; } // we sort the joints in descending order based on the weights. // this ensures, we only procced the most important joints of the vertex vertexSkinData.sort( descending ); // now we provide for each vertex a set of four index and weight values. // the order of the skin data matches the order of vertices for ( j = 0; j < BONE_LIMIT; j ++ ) { const d = vertexSkinData[ j ]; if ( d !== undefined ) { build.indices.array.push( d.index ); build.weights.array.push( d.weight ); } else { build.indices.array.push( 0 ); build.weights.array.push( 0 ); } } } // setup bind matrix if ( data.bindShapeMatrix ) { build.bindMatrix = new Matrix4().fromArray( data.bindShapeMatrix ).transpose(); } else { build.bindMatrix = new Matrix4().identity(); } // process bones and inverse bind matrix data for ( i = 0, l = jointSource.array.length; i < l; i ++ ) { const name = jointSource.array[ i ]; const boneInverse = new Matrix4().fromArray( inverseSource.array, i * inverseSource.stride ).transpose(); build.joints.push( { name: name, boneInverse: boneInverse } ); } return build; // array sort function function descending( a, b ) { return b.weight - a.weight; } } function getController( id ) { return getBuild( library.controllers[ id ], buildController ); } // image function parseImage( xml ) { const data = { init_from: getElementsByTagName( xml, 'init_from' )[ 0 ].textContent }; library.images[ xml.getAttribute( 'id' ) ] = data; } function buildImage( data ) { if ( data.build !== undefined ) return data.build; return data.init_from; } function getImage( id ) { const data = library.images[ id ]; if ( data !== undefined ) { return getBuild( data, buildImage ); } console.warn( 'THREE.ColladaLoader: Couldn\\'t find image with ID:', id ); return null; } // effect function parseEffect( xml ) { const data = {}; for ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) { const child = xml.childNodes[ i ]; if ( child.nodeType !== 1 ) continue; switch ( child.nodeName ) { case 'profile_COMMON': data.profile = parseEffectProfileCOMMON( child ); break; } } library.effects[ xml.getAttribute( 'id' ) ] = data; } function parseEffectProfileCOMMON( xml ) { const data = { surfaces: {}, samplers: {} }; for ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) { const child = xml.childNodes[ i ]; if ( child.nodeType !== 1 ) continue; switch ( child.nodeName ) { case 'newparam': parseEffectNewparam( child, data ); break; case 'technique': data.technique = parseEffectTechnique( child ); break; case 'extra': data.extra = parseEffectExtra( child ); break; } } return data; } function parseEffectNewparam( xml, data ) { const sid = xml.getAttribute( 'sid' ); for ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) { const child = xml.childNodes[ i ]; if ( child.nodeType !== 1 ) continue; switch ( child.nodeName ) { case 'surface': data.surfaces[ sid ] = parseEffectSurface( child ); break; case 'sampler2D': data.samplers[ sid ] = parseEffectSampler( child ); break; } } } function parseEffectSurface( xml ) { const data = {}; for ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) { const child = xml.childNodes[ i ]; if ( child.nodeType !== 1 ) continue; switch ( child.nodeName ) { case 'init_from': data.init_from = child.textContent; break; } } return data; } function parseEffectSampler( xml ) { const data = {}; for ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) { const child = xml.childNodes[ i ]; if ( child.nodeType !== 1 ) continue; switch ( child.nodeName ) { case 'source': data.source = child.textContent; break; } } return data; } function parseEffectTechnique( xml ) { const data = {}; for ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) { const child = xml.childNodes[ i ]; if ( child.nodeType !== 1 ) continue; switch ( child.nodeName ) { case 'constant': case 'lambert': case 'blinn': case 'phong': data.type = child.nodeName; data.parameters = parseEffectParameters( child ); break; case 'extra': data.extra = parseEffectExtra( child ); break; } } return data; } function parseEffectParameters( xml ) { const data = {}; for ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) { const child = xml.childNodes[ i ]; if ( child.nodeType !== 1 ) continue; switch ( child.nodeName ) { case 'emission': case 'diffuse': case 'specular': case 'bump': case 'ambient': case 'shininess': case 'transparency': data[ child.nodeName ] = parseEffectParameter( child ); break; case 'transparent': data[ child.nodeName ] = { opaque: child.hasAttribute( 'opaque' ) ? child.getAttribute( 'opaque' ) : 'A_ONE', data: parseEffectParameter( child ) }; break; } } return data; } function parseEffectParameter( xml ) { const data = {}; for ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) { const child = xml.childNodes[ i ]; if ( child.nodeType !== 1 ) continue; switch ( child.nodeName ) { case 'color': data[ child.nodeName ] = parseFloats( child.textContent ); break; case 'float': data[ child.nodeName ] = parseFloat( child.textContent ); break; case 'texture': data[ child.nodeName ] = { id: child.getAttribute( 'texture' ), extra: parseEffectParameterTexture( child ) }; break; } } return data; } function parseEffectParameterTexture( xml ) { const data = { technique: {} }; for ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) { const child = xml.childNodes[ i ]; if ( child.nodeType !== 1 ) continue; switch ( child.nodeName ) { case 'extra': parseEffectParameterTextureExtra( child, data ); break; } } return data; } function parseEffectParameterTextureExtra( xml, data ) { for ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) { const child = xml.childNodes[ i ]; if ( child.nodeType !== 1 ) continue; switch ( child.nodeName ) { case 'technique': parseEffectParameterTextureExtraTechnique( child, data ); break; } } } function parseEffectParameterTextureExtraTechnique( xml, data ) { for ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) { const child = xml.childNodes[ i ]; if ( child.nodeType !== 1 ) continue; switch ( child.nodeName ) { case 'repeatU': case 'repeatV': case 'offsetU': case 'offsetV': data.technique[ child.nodeName ] = parseFloat( child.textContent ); break; case 'wrapU': case 'wrapV': // some files have values for wrapU/wrapV which become NaN via parseInt if ( child.textContent.toUpperCase() === 'TRUE' ) { data.technique[ child.nodeName ] = 1; } else if ( child.textContent.toUpperCase() === 'FALSE' ) { data.technique[ child.nodeName ] = 0; } else { data.technique[ child.nodeName ] = parseInt( child.textContent ); } break; case 'bump': data[ child.nodeName ] = parseEffectExtraTechniqueBump( child ); break; } } } function parseEffectExtra( xml ) { const data = {}; for ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) { const child = xml.childNodes[ i ]; if ( child.nodeType !== 1 ) continue; switch ( child.nodeName ) { case 'technique': data.technique = parseEffectExtraTechnique( child ); break; } } return data; } function parseEffectExtraTechnique( xml ) { const data = {}; for ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) { const child = xml.childNodes[ i ]; if ( child.nodeType !== 1 ) continue; switch ( child.nodeName ) { case 'double_sided': data[ child.nodeName ] = parseInt( child.textContent ); break; case 'bump': data[ child.nodeName ] = parseEffectExtraTechniqueBump( child ); break; } } return data; } function parseEffectExtraTechniqueBump( xml ) { const data = {}; for ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) { const child = xml.childNodes[ i ]; if ( child.nodeType !== 1 ) continue; switch ( child.nodeName ) { case 'texture': data[ child.nodeName ] = { id: child.getAttribute( 'texture' ), texcoord: child.getAttribute( 'texcoord' ), extra: parseEffectParameterTexture( child ) }; break; } } return data; } function buildEffect( data ) { return data; } function getEffect( id ) { return getBuild( library.effects[ id ], buildEffect ); } // material function parseMaterial( xml ) { const data = { name: xml.getAttribute( 'name' ) }; for ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) { const child = xml.childNodes[ i ]; if ( child.nodeType !== 1 ) continue; switch ( child.nodeName ) { case 'instance_effect': data.url = parseId( child.getAttribute( 'url' ) ); break; } } library.materials[ xml.getAttribute( 'id' ) ] = data; } function getTextureLoader( image ) { let loader; let extension = image.slice( ( image.lastIndexOf( '.' ) - 1 >>> 0 ) + 2 ); // http://www.jstips.co/en/javascript/get-file-extension/ extension = extension.toLowerCase(); switch ( extension ) { case 'tga': loader = tgaLoader; break; default: loader = textureLoader; } return loader; } function buildMaterial( data ) { const effect = getEffect( data.url ); const technique = effect.profile.technique; let material; switch ( technique.type ) { case 'phong': case 'blinn': material = new MeshPhongMaterial(); break; case 'lambert': material = new MeshLambertMaterial(); break; default: material = new MeshBasicMaterial(); break; } material.name = data.name || ''; function getTexture( textureObject, colorSpace = null ) { const sampler = effect.profile.samplers[ textureObject.id ]; let image = null; // get image if ( sampler !== undefined ) { const surface = effect.profile.surfaces[ sampler.source ]; image = getImage( surface.init_from ); } else { console.warn( 'THREE.ColladaLoader: Undefined sampler. Access image directly (see #12530).' ); image = getImage( textureObject.id ); } // create texture if image is avaiable if ( image !== null ) { const loader = getTextureLoader( image ); if ( loader !== undefined ) { const texture = loader.load( image ); const extra = textureObject.extra; if ( extra !== undefined && extra.technique !== undefined && isEmpty( extra.technique ) === false ) { const technique = extra.technique; texture.wrapS = technique.wrapU ? RepeatWrapping : ClampToEdgeWrapping; texture.wrapT = technique.wrapV ? RepeatWrapping : ClampToEdgeWrapping; texture.offset.set( technique.offsetU || 0, technique.offsetV || 0 ); texture.repeat.set( technique.repeatU || 1, technique.repeatV || 1 ); } else { texture.wrapS = RepeatWrapping; texture.wrapT = RepeatWrapping; } if ( colorSpace !== null ) { texture.colorSpace = colorSpace; } return texture; } else { console.warn( 'THREE.ColladaLoader: Loader for texture %s not found.', image ); return null; } } else { console.warn( 'THREE.ColladaLoader: Couldn\\'t create texture with ID:', textureObject.id ); return null; } } const parameters = technique.parameters; for ( const key in parameters ) { const parameter = parameters[ key ]; switch ( key ) { case 'diffuse': if ( parameter.color ) material.color.fromArray( parameter.color ); if ( parameter.texture ) material.map = getTexture( parameter.texture, SRGBColorSpace ); break; case 'specular': if ( parameter.color && material.specular ) material.specular.fromArray( parameter.color ); if ( parameter.texture ) material.specularMap = getTexture( parameter.texture ); break; case 'bump': if ( parameter.texture ) material.normalMap = getTexture( parameter.texture ); break; case 'ambient': if ( parameter.texture ) material.lightMap = getTexture( parameter.texture, SRGBColorSpace ); break; case 'shininess': if ( parameter.float && material.shininess ) material.shininess = parameter.float; break; case 'emission': if ( parameter.color && material.emissive ) material.emissive.fromArray( parameter.color ); if ( parameter.texture ) material.emissiveMap = getTexture( parameter.texture, SRGBColorSpace ); break; } } material.color.convertSRGBToLinear(); if ( material.specular ) material.specular.convertSRGBToLinear(); if ( material.emissive ) material.emissive.convertSRGBToLinear(); // let transparent = parameters[ 'transparent' ]; let transparency = parameters[ 'transparency' ]; // does not exist but if ( transparency === undefined && transparent ) { transparency = { float: 1 }; } // does not exist but if ( transparent === undefined && transparency ) { transparent = { opaque: 'A_ONE', data: { color: [ 1, 1, 1, 1 ] } }; } if ( transparent && transparency ) { // handle case if a texture exists but no color if ( transparent.data.texture ) { // we do not set an alpha map (see #13792) material.transparent = true; } else { const color = transparent.data.color; switch ( transparent.opaque ) { case 'A_ONE': material.opacity = color[ 3 ] * transparency.float; break; case 'RGB_ZERO': material.opacity = 1 - ( color[ 0 ] * transparency.float ); break; case 'A_ZERO': material.opacity = 1 - ( color[ 3 ] * transparency.float ); break; case 'RGB_ONE': material.opacity = color[ 0 ] * transparency.float; break; default: console.warn( 'THREE.ColladaLoader: Invalid opaque type \"%s\" of transparent tag.', transparent.opaque ); } if ( material.opacity < 1 ) material.transparent = true; } } // if ( technique.extra !== undefined && technique.extra.technique !== undefined ) { const techniques = technique.extra.technique; for ( const k in techniques ) { const v = techniques[ k ]; switch ( k ) { case 'double_sided': material.side = ( v === 1 ? DoubleSide : FrontSide ); break; case 'bump': material.normalMap = getTexture( v.texture ); material.normalScale = new Vector2( 1, 1 ); break; } } } return material; } function getMaterial( id ) { return getBuild( library.materials[ id ], buildMaterial ); } // camera function parseCamera( xml ) { const data = { name: xml.getAttribute( 'name' ) }; for ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) { const child = xml.childNodes[ i ]; if ( child.nodeType !== 1 ) continue; switch ( child.nodeName ) { case 'optics': data.optics = parseCameraOptics( child ); break; } } library.cameras[ xml.getAttribute( 'id' ) ] = data; } function parseCameraOptics( xml ) { for ( let i = 0; i < xml.childNodes.length; i ++ ) { const child = xml.childNodes[ i ]; switch ( child.nodeName ) { case 'technique_common': return parseCameraTechnique( child ); } } return {}; } function parseCameraTechnique( xml ) { const data = {}; for ( let i = 0; i < xml.childNodes.length; i ++ ) { const child = xml.childNodes[ i ]; switch ( child.nodeName ) { case 'perspective': case 'orthographic': data.technique = child.nodeName; data.parameters = parseCameraParameters( child ); break; } } return data; } function parseCameraParameters( xml ) { const data = {}; for ( let i = 0; i < xml.childNodes.length; i ++ ) { const child = xml.childNodes[ i ]; switch ( child.nodeName ) { case 'xfov': case 'yfov': case 'xmag': case 'ymag': case 'znear': case 'zfar': case 'aspect_ratio': data[ child.nodeName ] = parseFloat( child.textContent ); break; } } return data; } function buildCamera( data ) { let camera; switch ( data.optics.technique ) { case 'perspective': camera = new PerspectiveCamera( data.optics.parameters.yfov, data.optics.parameters.aspect_ratio, data.optics.parameters.znear, data.optics.parameters.zfar ); break; case 'orthographic': let ymag = data.optics.parameters.ymag; let xmag = data.optics.parameters.xmag; const aspectRatio = data.optics.parameters.aspect_ratio; xmag = ( xmag === undefined ) ? ( ymag * aspectRatio ) : xmag; ymag = ( ymag === undefined ) ? ( xmag / aspectRatio ) : ymag; xmag *= 0.5; ymag *= 0.5; camera = new OrthographicCamera( - xmag, xmag, ymag, - ymag, // left, right, top, bottom data.optics.parameters.znear, data.optics.parameters.zfar ); break; default: camera = new PerspectiveCamera(); break; } camera.name = data.name || ''; return camera; } function getCamera( id ) { const data = library.cameras[ id ]; if ( data !== undefined ) { return getBuild( data, buildCamera ); } console.warn( 'THREE.ColladaLoader: Couldn\\'t find camera with ID:', id ); return null; } // light function parseLight( xml ) { let data = {}; for ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) { const child = xml.childNodes[ i ]; if ( child.nodeType !== 1 ) continue; switch ( child.nodeName ) { case 'technique_common': data = parseLightTechnique( child ); break; } } library.lights[ xml.getAttribute( 'id' ) ] = data; } function parseLightTechnique( xml ) { const data = {}; for ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) { const child = xml.childNodes[ i ]; if ( child.nodeType !== 1 ) continue; switch ( child.nodeName ) { case 'directional': case 'point': case 'spot': case 'ambient': data.technique = child.nodeName; data.parameters = parseLightParameters( child ); } } return data; } function parseLightParameters( xml ) { const data = {}; for ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) { const child = xml.childNodes[ i ]; if ( child.nodeType !== 1 ) continue; switch ( child.nodeName ) { case 'color': const array = parseFloats( child.textContent ); data.color = new Color().fromArray( array ).convertSRGBToLinear(); break; case 'falloff_angle': data.falloffAngle = parseFloat( child.textContent ); break; case 'quadratic_attenuation': const f = parseFloat( child.textContent ); data.distance = f ? Math.sqrt( 1 / f ) : 0; break; } } return data; } function buildLight( data ) { let light; switch ( data.technique ) { case 'directional': light = new DirectionalLight(); break; case 'point': light = new PointLight(); break; case 'spot': light = new SpotLight(); break; case 'ambient': light = new AmbientLight(); break; } if ( data.parameters.color ) light.color.copy( data.parameters.color ); if ( data.parameters.distance ) light.distance = data.parameters.distance; return light; } function getLight( id ) { const data = library.lights[ id ]; if ( data !== undefined ) { return getBuild( data, buildLight ); } console.warn( 'THREE.ColladaLoader: Couldn\\'t find light with ID:', id ); return null; } // geometry function parseGeometry( xml ) { const data = { name: xml.getAttribute( 'name' ), sources: {}, vertices: {}, primitives: [] }; const mesh = getElementsByTagName( xml, 'mesh' )[ 0 ]; // the following tags inside geometry are not supported yet (see https://github.com/mrdoob/three.js/pull/12606): convex_mesh, spline, brep if ( mesh === undefined ) return; for ( let i = 0; i < mesh.childNodes.length; i ++ ) { const child = mesh.childNodes[ i ]; if ( child.nodeType !== 1 ) continue; const id = child.getAttribute( 'id' ); switch ( child.nodeName ) { case 'source': data.sources[ id ] = parseSource( child ); break; case 'vertices': // data.sources[ id ] = data.sources[ parseId( getElementsByTagName( child, 'input' )[ 0 ].getAttribute( 'source' ) ) ]; data.vertices = parseGeometryVertices( child ); break; case 'polygons': console.warn( 'THREE.ColladaLoader: Unsupported primitive type: ', child.nodeName ); break; case 'lines': case 'linestrips': case 'polylist': case 'triangles': data.primitives.push( parseGeometryPrimitive( child ) ); break; default: console.log( child ); } } library.geometries[ xml.getAttribute( 'id' ) ] = data; } function parseSource( xml ) { const data = { array: [], stride: 3 }; for ( let i = 0; i < xml.childNodes.length; i ++ ) { const child = xml.childNodes[ i ]; if ( child.nodeType !== 1 ) continue; switch ( child.nodeName ) { case 'float_array': data.array = parseFloats( child.textContent ); break; case 'Name_array': data.array = parseStrings( child.textContent ); break; case 'technique_common': const accessor = getElementsByTagName( child, 'accessor' )[ 0 ]; if ( accessor !== undefined ) { data.stride = parseInt( accessor.getAttribute( 'stride' ) ); } break; } } return data; } function parseGeometryVertices( xml ) { const data = {}; for ( let i = 0; i < xml.childNodes.length; i ++ ) { const child = xml.childNodes[ i ]; if ( child.nodeType !== 1 ) continue; data[ child.getAttribute( 'semantic' ) ] = parseId( child.getAttribute( 'source' ) ); } return data; } function parseGeometryPrimitive( xml ) { const primitive = { type: xml.nodeName, material: xml.getAttribute( 'material' ), count: parseInt( xml.getAttribute( 'count' ) ), inputs: {}, stride: 0, hasUV: false }; for ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) { const child = xml.childNodes[ i ]; if ( child.nodeType !== 1 ) continue; switch ( child.nodeName ) { case 'input': const id = parseId( child.getAttribute( 'source' ) ); const semantic = child.getAttribute( 'semantic' ); const offset = parseInt( child.getAttribute( 'offset' ) ); const set = parseInt( child.getAttribute( 'set' ) ); const inputname = ( set > 0 ? semantic + set : semantic ); primitive.inputs[ inputname ] = { id: id, offset: offset }; primitive.stride = Math.max( primitive.stride, offset + 1 ); if ( semantic === 'TEXCOORD' ) primitive.hasUV = true; break; case 'vcount': primitive.vcount = parseInts( child.textContent ); break; case 'p': primitive.p = parseInts( child.textContent ); break; } } return primitive; } function groupPrimitives( primitives ) { const build = {}; for ( let i = 0; i < primitives.length; i ++ ) { const primitive = primitives[ i ]; if ( build[ primitive.type ] === undefined ) build[ primitive.type ] = []; build[ primitive.type ].push( primitive ); } return build; } function checkUVCoordinates( primitives ) { let count = 0; for ( let i = 0, l = primitives.length; i < l; i ++ ) { const primitive = primitives[ i ]; if ( primitive.hasUV === true ) { count ++; } } if ( count > 0 && count < primitives.length ) { primitives.uvsNeedsFix = true; } } function buildGeometry( data ) { const build = {}; const sources = data.sources; const vertices = data.vertices; const primitives = data.primitives; if ( primitives.length === 0 ) return {}; // our goal is to create one buffer geometry for a single type of primitives // first, we group all primitives by their type const groupedPrimitives = groupPrimitives( primitives ); for ( const type in groupedPrimitives ) { const primitiveType = groupedPrimitives[ type ]; // second, ensure consistent uv coordinates for each type of primitives (polylist,triangles or lines) checkUVCoordinates( primitiveType ); // third, create a buffer geometry for each type of primitives build[ type ] = buildGeometryType( primitiveType, sources, vertices ); } return build; } function buildGeometryType( primitives, sources, vertices ) { const build = {}; const position = { array: [], stride: 0 }; const normal = { array: [], stride: 0 }; const uv = { array: [], stride: 0 }; const uv1 = { array: [], stride: 0 }; const color = { array: [], stride: 0 }; const skinIndex = { array: [], stride: 4 }; const skinWeight = { array: [], stride: 4 }; const geometry = new BufferGeometry(); const materialKeys = []; let start = 0; for ( let p = 0; p < primitives.length; p ++ ) { const primitive = primitives[ p ]; const inputs = primitive.inputs; // groups let count = 0; switch ( primitive.type ) { case 'lines': case 'linestrips': count = primitive.count * 2; break; case 'triangles': count = primitive.count * 3; break; case 'polylist': for ( let g = 0; g < primitive.count; g ++ ) { const vc = primitive.vcount[ g ]; switch ( vc ) { case 3: count += 3; // single triangle break; case 4: count += 6; // quad, subdivided into two triangles break; default: count += ( vc - 2 ) * 3; // polylist with more than four vertices break; } } break; default: console.warn( 'THREE.ColladaLoader: Unknow primitive type:', primitive.type ); } geometry.addGroup( start, count, p ); start += count; // material if ( primitive.material ) { materialKeys.push( primitive.material ); } // geometry data for ( const name in inputs ) { const input = inputs[ name ]; switch ( name ) { case 'VERTEX': for ( const key in vertices ) { const id = vertices[ key ]; switch ( key ) { case 'POSITION': const prevLength = position.array.length; buildGeometryData( primitive, sources[ id ], input.offset, position.array ); position.stride = sources[ id ].stride; if ( sources.skinWeights && sources.skinIndices ) { buildGeometryData( primitive, sources.skinIndices, input.offset, skinIndex.array ); buildGeometryData( primitive, sources.skinWeights, input.offset, skinWeight.array ); } // see #3803 if ( primitive.hasUV === false && primitives.uvsNeedsFix === true ) { const count = ( position.array.length - prevLength ) / position.stride; for ( let i = 0; i < count; i ++ ) { // fill missing uv coordinates uv.array.push( 0, 0 ); } } break; case 'NORMAL': buildGeometryData( primitive, sources[ id ], input.offset, normal.array ); normal.stride = sources[ id ].stride; break; case 'COLOR': buildGeometryData( primitive, sources[ id ], input.offset, color.array ); color.stride = sources[ id ].stride; break; case 'TEXCOORD': buildGeometryData( primitive, sources[ id ], input.offset, uv.array ); uv.stride = sources[ id ].stride; break; case 'TEXCOORD1': buildGeometryData( primitive, sources[ id ], input.offset, uv1.array ); uv.stride = sources[ id ].stride; break; default: console.warn( 'THREE.ColladaLoader: Semantic \"%s\" not handled in geometry build process.', key ); } } break; case 'NORMAL': buildGeometryData( primitive, sources[ input.id ], input.offset, normal.array ); normal.stride = sources[ input.id ].stride; break; case 'COLOR': buildGeometryData( primitive, sources[ input.id ], input.offset, color.array, true ); color.stride = sources[ input.id ].stride; break; case 'TEXCOORD': buildGeometryData( primitive, sources[ input.id ], input.offset, uv.array ); uv.stride = sources[ input.id ].stride; break; case 'TEXCOORD1': buildGeometryData( primitive, sources[ input.id ], input.offset, uv1.array ); uv1.stride = sources[ input.id ].stride; break; } } } // build geometry if ( position.array.length > 0 ) geometry.setAttribute( 'position', new Float32BufferAttribute( position.array, position.stride ) ); if ( normal.array.length > 0 ) geometry.setAttribute( 'normal', new Float32BufferAttribute( normal.array, normal.stride ) ); if ( color.array.length > 0 ) geometry.setAttribute( 'color', new Float32BufferAttribute( color.array, color.stride ) ); if ( uv.array.length > 0 ) geometry.setAttribute( 'uv', new Float32BufferAttribute( uv.array, uv.stride ) ); if ( uv1.array.length > 0 ) geometry.setAttribute( 'uv1', new Float32BufferAttribute( uv1.array, uv1.stride ) ); if ( skinIndex.array.length > 0 ) geometry.setAttribute( 'skinIndex', new Float32BufferAttribute( skinIndex.array, skinIndex.stride ) ); if ( skinWeight.array.length > 0 ) geometry.setAttribute( 'skinWeight', new Float32BufferAttribute( skinWeight.array, skinWeight.stride ) ); build.data = geometry; build.type = primitives[ 0 ].type; build.materialKeys = materialKeys; return build; } function buildGeometryData( primitive, source, offset, array, isColor = false ) { const indices = primitive.p; const stride = primitive.stride; const vcount = primitive.vcount; function pushVector( i ) { let index = indices[ i + offset ] * sourceStride; const length = index + sourceStride; for ( ; index < length; index ++ ) { array.push( sourceArray[ index ] ); } if ( isColor ) { // convert the vertex colors from srgb to linear if present const startIndex = array.length - sourceStride - 1; tempColor.setRGB( array[ startIndex + 0 ], array[ startIndex + 1 ], array[ startIndex + 2 ] ).convertSRGBToLinear(); array[ startIndex + 0 ] = tempColor.r; array[ startIndex + 1 ] = tempColor.g; array[ startIndex + 2 ] = tempColor.b; } } const sourceArray = source.array; const sourceStride = source.stride; if ( primitive.vcount !== undefined ) { let index = 0; for ( let i = 0, l = vcount.length; i < l; i ++ ) { const count = vcount[ i ]; if ( count === 4 ) { const a = index + stride * 0; const b = index + stride * 1; const c = index + stride * 2; const d = index + stride * 3; pushVector( a ); pushVector( b ); pushVector( d ); pushVector( b ); pushVector( c ); pushVector( d ); } else if ( count === 3 ) { const a = index + stride * 0; const b = index + stride * 1; const c = index + stride * 2; pushVector( a ); pushVector( b ); pushVector( c ); } else if ( count > 4 ) { for ( let k = 1, kl = ( count - 2 ); k"},{"title":"","date":"2023-10-12T14:08:40.651Z","updated":"2023-10-12T14:08:40.651Z","comments":true,"path":"js/three/jsm/loaders/DDSLoader.js","permalink":"http://19999997.xyz/js/three/jsm/loaders/DDSLoader.js","excerpt":"","text":"import { CompressedTextureLoader, RGBAFormat, RGBA_S3TC_DXT3_Format, RGBA_S3TC_DXT5_Format, RGB_ETC1_Format, RGB_S3TC_DXT1_Format, RGB_BPTC_SIGNED_Format, RGB_BPTC_UNSIGNED_Format } from 'three'; class DDSLoader extends CompressedTextureLoader { constructor( manager ) { super( manager ); } parse( buffer, loadMipmaps ) { const dds = { mipmaps: [], width: 0, height: 0, format: null, mipmapCount: 1 }; // Adapted from @toji's DDS utils // https://github.com/toji/webgl-texture-utils/blob/master/texture-util/dds.js // All values and structures referenced from: // http://msdn.microsoft.com/en-us/library/bb943991.aspx/ const DDS_MAGIC = 0x20534444; // const DDSD_CAPS = 0x1; // const DDSD_HEIGHT = 0x2; // const DDSD_WIDTH = 0x4; // const DDSD_PITCH = 0x8; // const DDSD_PIXELFORMAT = 0x1000; const DDSD_MIPMAPCOUNT = 0x20000; // const DDSD_LINEARSIZE = 0x80000; // const DDSD_DEPTH = 0x800000; // const DDSCAPS_COMPLEX = 0x8; // const DDSCAPS_MIPMAP = 0x400000; // const DDSCAPS_TEXTURE = 0x1000; const DDSCAPS2_CUBEMAP = 0x200; const DDSCAPS2_CUBEMAP_POSITIVEX = 0x400; const DDSCAPS2_CUBEMAP_NEGATIVEX = 0x800; const DDSCAPS2_CUBEMAP_POSITIVEY = 0x1000; const DDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000; const DDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000; const DDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000; // const DDSCAPS2_VOLUME = 0x200000; // const DDPF_ALPHAPIXELS = 0x1; // const DDPF_ALPHA = 0x2; // const DDPF_FOURCC = 0x4; // const DDPF_RGB = 0x40; // const DDPF_YUV = 0x200; // const DDPF_LUMINANCE = 0x20000; const DXGI_FORMAT_BC6H_UF16 = 95; const DXGI_FORMAT_BC6H_SF16 = 96; function fourCCToInt32( value ) { return value.charCodeAt( 0 ) + ( value.charCodeAt( 1 ) < 8 ) + ( value.charCodeAt( 2 ) < 16 ) + ( value.charCodeAt( 3 ) < 24 ); } function int32ToFourCC( value ) { return String.fromCharCode( value & 0xff, ( value >> 8 ) & 0xff, ( value >> 16 ) & 0xff, ( value >> 24 ) & 0xff ); } function loadARGBMip( buffer, dataOffset, width, height ) { const dataLength = width * height * 4; const srcBuffer = new Uint8Array( buffer, dataOffset, dataLength ); const byteArray = new Uint8Array( dataLength ); let dst = 0; let src = 0; for ( let y = 0; y < height; y ++ ) { for ( let x = 0; x < width; x ++ ) { const b = srcBuffer[ src ]; src ++; const g = srcBuffer[ src ]; src ++; const r = srcBuffer[ src ]; src ++; const a = srcBuffer[ src ]; src ++; byteArray[ dst ] = r; dst ++; //r byteArray[ dst ] = g; dst ++; //g byteArray[ dst ] = b; dst ++; //b byteArray[ dst ] = a; dst ++; //a } } return byteArray; } const FOURCC_DXT1 = fourCCToInt32( 'DXT1' ); const FOURCC_DXT3 = fourCCToInt32( 'DXT3' ); const FOURCC_DXT5 = fourCCToInt32( 'DXT5' ); const FOURCC_ETC1 = fourCCToInt32( 'ETC1' ); const FOURCC_DX10 = fourCCToInt32( 'DX10' ); const headerLengthInt = 31; // The header length in 32 bit ints const extendedHeaderLengthInt = 5; // The extended header length in 32 bit ints // Offsets into the header array const off_magic = 0; const off_size = 1; const off_flags = 2; const off_height = 3; const off_width = 4; const off_mipmapCount = 7; // const off_pfFlags = 20; const off_pfFourCC = 21; const off_RGBBitCount = 22; const off_RBitMask = 23; const off_GBitMask = 24; const off_BBitMask = 25; const off_ABitMask = 26; // const off_caps = 27; const off_caps2 = 28; // const off_caps3 = 29; // const off_caps4 = 30; // If fourCC = DX10, the extended header starts after 32 const off_dxgiFormat = 0; // Parse header const header = new Int32Array( buffer, 0, headerLengthInt ); if ( header[ off_magic ] !== DDS_MAGIC ) { console.error( 'THREE.DDSLoader.parse: Invalid magic number in DDS header.' ); return dds; } let blockBytes; const fourCC = header[ off_pfFourCC ]; let isRGBAUncompressed = false; let dataOffset = header[ off_size ] + 4; switch ( fourCC ) { case FOURCC_DXT1: blockBytes = 8; dds.format = RGB_S3TC_DXT1_Format; break; case FOURCC_DXT3: blockBytes = 16; dds.format = RGBA_S3TC_DXT3_Format; break; case FOURCC_DXT5: blockBytes = 16; dds.format = RGBA_S3TC_DXT5_Format; break; case FOURCC_ETC1: blockBytes = 8; dds.format = RGB_ETC1_Format; break; case FOURCC_DX10: dataOffset += extendedHeaderLengthInt * 4; const extendedHeader = new Int32Array( buffer, ( headerLengthInt + 1 ) * 4, extendedHeaderLengthInt ); const dxgiFormat = extendedHeader[ off_dxgiFormat ]; switch ( dxgiFormat ) { case DXGI_FORMAT_BC6H_SF16: { blockBytes = 16; dds.format = RGB_BPTC_SIGNED_Format; break; } case DXGI_FORMAT_BC6H_UF16: { blockBytes = 16; dds.format = RGB_BPTC_UNSIGNED_Format; break; } default: { console.error( 'THREE.DDSLoader.parse: Unsupported DXGI_FORMAT code ', dxgiFormat ); return dds; } } break; default: if ( header[ off_RGBBitCount ] === 32 && header[ off_RBitMask ] & 0xff0000 && header[ off_GBitMask ] & 0xff00 && header[ off_BBitMask ] & 0xff && header[ off_ABitMask ] & 0xff000000 ) { isRGBAUncompressed = true; blockBytes = 64; dds.format = RGBAFormat; } else { console.error( 'THREE.DDSLoader.parse: Unsupported FourCC code ', int32ToFourCC( fourCC ) ); return dds; } } dds.mipmapCount = 1; if ( header[ off_flags ] & DDSD_MIPMAPCOUNT && loadMipmaps !== false ) { dds.mipmapCount = Math.max( 1, header[ off_mipmapCount ] ); } const caps2 = header[ off_caps2 ]; dds.isCubemap = caps2 & DDSCAPS2_CUBEMAP ? true : false; if ( dds.isCubemap && ( ! ( caps2 & DDSCAPS2_CUBEMAP_POSITIVEX ) || ! ( caps2 & DDSCAPS2_CUBEMAP_NEGATIVEX ) || ! ( caps2 & DDSCAPS2_CUBEMAP_POSITIVEY ) || ! ( caps2 & DDSCAPS2_CUBEMAP_NEGATIVEY ) || ! ( caps2 & DDSCAPS2_CUBEMAP_POSITIVEZ ) || ! ( caps2 & DDSCAPS2_CUBEMAP_NEGATIVEZ ) ) ) { console.error( 'THREE.DDSLoader.parse: Incomplete cubemap faces' ); return dds; } dds.width = header[ off_width ]; dds.height = header[ off_height ]; // Extract mipmaps buffers const faces = dds.isCubemap ? 6 : 1; for ( let face = 0; face < faces; face ++ ) { let width = dds.width; let height = dds.height; for ( let i = 0; i < dds.mipmapCount; i ++ ) { let byteArray, dataLength; if ( isRGBAUncompressed ) { byteArray = loadARGBMip( buffer, dataOffset, width, height ); dataLength = byteArray.length; } else { dataLength = Math.max( 4, width ) / 4 * Math.max( 4, height ) / 4 * blockBytes; byteArray = new Uint8Array( buffer, dataOffset, dataLength ); } const mipmap = { 'data': byteArray, 'width': width, 'height': height }; dds.mipmaps.push( mipmap ); dataOffset += dataLength; width = Math.max( width >> 1, 1 ); height = Math.max( height >> 1, 1 ); } } return dds; } } export { DDSLoader };"},{"title":"","date":"2023-10-12T14:08:40.654Z","updated":"2023-10-12T14:08:40.654Z","comments":true,"path":"js/three/jsm/loaders/DRACOLoader.js","permalink":"http://19999997.xyz/js/three/jsm/loaders/DRACOLoader.js","excerpt":"","text":"import { BufferAttribute, BufferGeometry, Color, FileLoader, Loader, LinearSRGBColorSpace, SRGBColorSpace } from 'three'; const _taskCache = new WeakMap(); class DRACOLoader extends Loader { constructor( manager ) { super( manager ); this.decoderPath = ''; this.decoderConfig = {}; this.decoderBinary = null; this.decoderPending = null; this.workerLimit = 4; this.workerPool = []; this.workerNextTaskID = 1; this.workerSourceURL = ''; this.defaultAttributeIDs = { position: 'POSITION', normal: 'NORMAL', color: 'COLOR', uv: 'TEX_COORD' }; this.defaultAttributeTypes = { position: 'Float32Array', normal: 'Float32Array', color: 'Float32Array', uv: 'Float32Array' }; } setDecoderPath( path ) { this.decoderPath = path; return this; } setDecoderConfig( config ) { this.decoderConfig = config; return this; } setWorkerLimit( workerLimit ) { this.workerLimit = workerLimit; return this; } load( url, onLoad, onProgress, onError ) { const loader = new FileLoader( this.manager ); loader.setPath( this.path ); loader.setResponseType( 'arraybuffer' ); loader.setRequestHeader( this.requestHeader ); loader.setWithCredentials( this.withCredentials ); loader.load( url, ( buffer ) => { this.parse( buffer, onLoad, onError ); }, onProgress, onError ); } parse( buffer, onLoad, onError ) { this.decodeDracoFile( buffer, onLoad, null, null, SRGBColorSpace ).catch( onError ); } decodeDracoFile( buffer, callback, attributeIDs, attributeTypes, vertexColorSpace = LinearSRGBColorSpace ) { const taskConfig = { attributeIDs: attributeIDs || this.defaultAttributeIDs, attributeTypes: attributeTypes || this.defaultAttributeTypes, useUniqueIDs: !! attributeIDs, vertexColorSpace: vertexColorSpace, }; return this.decodeGeometry( buffer, taskConfig ).then( callback ); } decodeGeometry( buffer, taskConfig ) { const taskKey = JSON.stringify( taskConfig ); // Check for an existing task using this buffer. A transferred buffer cannot be transferred // again from this thread. if ( _taskCache.has( buffer ) ) { const cachedTask = _taskCache.get( buffer ); if ( cachedTask.key === taskKey ) { return cachedTask.promise; } else if ( buffer.byteLength === 0 ) { // Technically, it would be possible to wait for the previous task to complete, // transfer the buffer back, and decode again with the second configuration. That // is complex, and I don't know of any reason to decode a Draco buffer twice in // different ways, so this is left unimplemented. throw new Error( 'THREE.DRACOLoader: Unable to re-decode a buffer with different ' + 'settings. Buffer has already been transferred.' ); } } // let worker; const taskID = this.workerNextTaskID ++; const taskCost = buffer.byteLength; // Obtain a worker and assign a task, and construct a geometry instance // when the task completes. const geometryPending = this._getWorker( taskID, taskCost ) .then( ( _worker ) => { worker = _worker; return new Promise( ( resolve, reject ) => { worker._callbacks[ taskID ] = { resolve, reject }; worker.postMessage( { type: 'decode', id: taskID, taskConfig, buffer }, [ buffer ] ); // this.debug(); } ); } ) .then( ( message ) => this._createGeometry( message.geometry ) ); // Remove task from the task list. // Note: replaced '.finally()' with '.catch().then()' block - iOS 11 support (#19416) geometryPending .catch( () => true ) .then( () => { if ( worker && taskID ) { this._releaseTask( worker, taskID ); // this.debug(); } } ); // Cache the task result. _taskCache.set( buffer, { key: taskKey, promise: geometryPending } ); return geometryPending; } _createGeometry( geometryData ) { const geometry = new BufferGeometry(); if ( geometryData.index ) { geometry.setIndex( new BufferAttribute( geometryData.index.array, 1 ) ); } for ( let i = 0; i < geometryData.attributes.length; i ++ ) { const result = geometryData.attributes[ i ]; const name = result.name; const array = result.array; const itemSize = result.itemSize; const attribute = new BufferAttribute( array, itemSize ); if ( name === 'color' ) { this._assignVertexColorSpace( attribute, result.vertexColorSpace ); attribute.normalized = ( array instanceof Float32Array ) === false; } geometry.setAttribute( name, attribute ); } return geometry; } _assignVertexColorSpace( attribute, inputColorSpace ) { // While .drc files do not specify colorspace, the only 'official' tooling // is PLY and OBJ converters, which use sRGB. We'll assume sRGB when a .drc // file is passed into .load() or .parse(). GLTFLoader uses internal APIs // to decode geometry, and vertex colors are already Linear-sRGB in there. if ( inputColorSpace !== SRGBColorSpace ) return; const _color = new Color(); for ( let i = 0, il = attribute.count; i < il; i ++ ) { _color.fromBufferAttribute( attribute, i ).convertSRGBToLinear(); attribute.setXYZ( i, _color.r, _color.g, _color.b ); } } _loadLibrary( url, responseType ) { const loader = new FileLoader( this.manager ); loader.setPath( this.decoderPath ); loader.setResponseType( responseType ); loader.setWithCredentials( this.withCredentials ); return new Promise( ( resolve, reject ) => { loader.load( url, resolve, undefined, reject ); } ); } preload() { this._initDecoder(); return this; } _initDecoder() { if ( this.decoderPending ) return this.decoderPending; const useJS = typeof WebAssembly !== 'object' || this.decoderConfig.type === 'js'; const librariesPending = []; if ( useJS ) { librariesPending.push( this._loadLibrary( 'draco_decoder.js', 'text' ) ); } else { librariesPending.push( this._loadLibrary( 'draco_wasm_wrapper.js', 'text' ) ); librariesPending.push( this._loadLibrary( 'draco_decoder.wasm', 'arraybuffer' ) ); } this.decoderPending = Promise.all( librariesPending ) .then( ( libraries ) => { const jsContent = libraries[ 0 ]; if ( ! useJS ) { this.decoderConfig.wasmBinary = libraries[ 1 ]; } const fn = DRACOWorker.toString(); const body = [ '/* draco decoder */', jsContent, '', '/* worker */', fn.substring( fn.indexOf( '{' ) + 1, fn.lastIndexOf( '}' ) ) ].join( '\\n' ); this.workerSourceURL = URL.createObjectURL( new Blob( [ body ] ) ); } ); return this.decoderPending; } _getWorker( taskID, taskCost ) { return this._initDecoder().then( () => { if ( this.workerPool.length < this.workerLimit ) { const worker = new Worker( this.workerSourceURL ); worker._callbacks = {}; worker._taskCosts = {}; worker._taskLoad = 0; worker.postMessage( { type: 'init', decoderConfig: this.decoderConfig } ); worker.onmessage = function ( e ) { const message = e.data; switch ( message.type ) { case 'decode': worker._callbacks[ message.id ].resolve( message ); break; case 'error': worker._callbacks[ message.id ].reject( message ); break; default: console.error( 'THREE.DRACOLoader: Unexpected message, \"' + message.type + '\"' ); } }; this.workerPool.push( worker ); } else { this.workerPool.sort( function ( a, b ) { return a._taskLoad > b._taskLoad ? - 1 : 1; } ); } const worker = this.workerPool[ this.workerPool.length - 1 ]; worker._taskCosts[ taskID ] = taskCost; worker._taskLoad += taskCost; return worker; } ); } _releaseTask( worker, taskID ) { worker._taskLoad -= worker._taskCosts[ taskID ]; delete worker._callbacks[ taskID ]; delete worker._taskCosts[ taskID ]; } debug() { console.log( 'Task load: ', this.workerPool.map( ( worker ) => worker._taskLoad ) ); } dispose() { for ( let i = 0; i < this.workerPool.length; ++ i ) { this.workerPool[ i ].terminate(); } this.workerPool.length = 0; if ( this.workerSourceURL !== '' ) { URL.revokeObjectURL( this.workerSourceURL ); } return this; } } /* WEB WORKER */ function DRACOWorker() { let decoderConfig; let decoderPending; onmessage = function ( e ) { const message = e.data; switch ( message.type ) { case 'init': decoderConfig = message.decoderConfig; decoderPending = new Promise( function ( resolve/*, reject*/ ) { decoderConfig.onModuleLoaded = function ( draco ) { // Module is Promise-like. Wrap before resolving to avoid loop. resolve( { draco: draco } ); }; DracoDecoderModule( decoderConfig ); // eslint-disable-line no-undef } ); break; case 'decode': const buffer = message.buffer; const taskConfig = message.taskConfig; decoderPending.then( ( module ) => { const draco = module.draco; const decoder = new draco.Decoder(); try { const geometry = decodeGeometry( draco, decoder, new Int8Array( buffer ), taskConfig ); const buffers = geometry.attributes.map( ( attr ) => attr.array.buffer ); if ( geometry.index ) buffers.push( geometry.index.array.buffer ); self.postMessage( { type: 'decode', id: message.id, geometry }, buffers ); } catch ( error ) { console.error( error ); self.postMessage( { type: 'error', id: message.id, error: error.message } ); } finally { draco.destroy( decoder ); } } ); break; } }; function decodeGeometry( draco, decoder, array, taskConfig ) { const attributeIDs = taskConfig.attributeIDs; const attributeTypes = taskConfig.attributeTypes; let dracoGeometry; let decodingStatus; const geometryType = decoder.GetEncodedGeometryType( array ); if ( geometryType === draco.TRIANGULAR_MESH ) { dracoGeometry = new draco.Mesh(); decodingStatus = decoder.DecodeArrayToMesh( array, array.byteLength, dracoGeometry ); } else if ( geometryType === draco.POINT_CLOUD ) { dracoGeometry = new draco.PointCloud(); decodingStatus = decoder.DecodeArrayToPointCloud( array, array.byteLength, dracoGeometry ); } else { throw new Error( 'THREE.DRACOLoader: Unexpected geometry type.' ); } if ( ! decodingStatus.ok() || dracoGeometry.ptr === 0 ) { throw new Error( 'THREE.DRACOLoader: Decoding failed: ' + decodingStatus.error_msg() ); } const geometry = { index: null, attributes: [] }; // Gather all vertex attributes. for ( const attributeName in attributeIDs ) { const attributeType = self[ attributeTypes[ attributeName ] ]; let attribute; let attributeID; // A Draco file may be created with default vertex attributes, whose attribute IDs // are mapped 1:1 from their semantic name (POSITION, NORMAL, ...). Alternatively, // a Draco file may contain a custom set of attributes, identified by known unique // IDs. glTF files always do the latter, and `.drc` files typically do the former. if ( taskConfig.useUniqueIDs ) { attributeID = attributeIDs[ attributeName ]; attribute = decoder.GetAttributeByUniqueId( dracoGeometry, attributeID ); } else { attributeID = decoder.GetAttributeId( dracoGeometry, draco[ attributeIDs[ attributeName ] ] ); if ( attributeID === - 1 ) continue; attribute = decoder.GetAttribute( dracoGeometry, attributeID ); } const attributeResult = decodeAttribute( draco, decoder, dracoGeometry, attributeName, attributeType, attribute ); if ( attributeName === 'color' ) { attributeResult.vertexColorSpace = taskConfig.vertexColorSpace; } geometry.attributes.push( attributeResult ); } // Add index. if ( geometryType === draco.TRIANGULAR_MESH ) { geometry.index = decodeIndex( draco, decoder, dracoGeometry ); } draco.destroy( dracoGeometry ); return geometry; } function decodeIndex( draco, decoder, dracoGeometry ) { const numFaces = dracoGeometry.num_faces(); const numIndices = numFaces * 3; const byteLength = numIndices * 4; const ptr = draco._malloc( byteLength ); decoder.GetTrianglesUInt32Array( dracoGeometry, byteLength, ptr ); const index = new Uint32Array( draco.HEAPF32.buffer, ptr, numIndices ).slice(); draco._free( ptr ); return { array: index, itemSize: 1 }; } function decodeAttribute( draco, decoder, dracoGeometry, attributeName, attributeType, attribute ) { const numComponents = attribute.num_components(); const numPoints = dracoGeometry.num_points(); const numValues = numPoints * numComponents; const byteLength = numValues * attributeType.BYTES_PER_ELEMENT; const dataType = getDracoDataType( draco, attributeType ); const ptr = draco._malloc( byteLength ); decoder.GetAttributeDataArrayForAllPoints( dracoGeometry, attribute, dataType, byteLength, ptr ); const array = new attributeType( draco.HEAPF32.buffer, ptr, numValues ).slice(); draco._free( ptr ); return { name: attributeName, array: array, itemSize: numComponents }; } function getDracoDataType( draco, attributeType ) { switch ( attributeType ) { case Float32Array: return draco.DT_FLOAT32; case Int8Array: return draco.DT_INT8; case Int16Array: return draco.DT_INT16; case Int32Array: return draco.DT_INT32; case Uint8Array: return draco.DT_UINT8; case Uint16Array: return draco.DT_UINT16; case Uint32Array: return draco.DT_UINT32; } } } export { DRACOLoader };"},{"title":"","date":"2023-10-12T14:08:40.657Z","updated":"2023-10-12T14:08:40.657Z","comments":true,"path":"js/three/jsm/loaders/EXRLoader.js","permalink":"http://19999997.xyz/js/three/jsm/loaders/EXRLoader.js","excerpt":"","text":"import { DataTextureLoader, DataUtils, FloatType, HalfFloatType, NoColorSpace, LinearFilter, LinearSRGBColorSpace, RedFormat, RGBAFormat } from 'three'; import * as fflate from '../libs/fflate.module.js'; /** * OpenEXR loader currently supports uncompressed, ZIP(S), RLE, PIZ and DWA/B compression. * Supports reading as UnsignedByte, HalfFloat and Float type data texture. * * Referred to the original Industrial Light & Magic OpenEXR implementation and the TinyEXR / Syoyo Fujita * implementation, so I have preserved their copyright notices. */ // /* // Copyright (c) 2014 - 2017, Syoyo Fujita // All rights reserved. // Redistribution and use in source and binary forms, with or without // modification, are permitted provided that the following conditions are met: // * Redistributions of source code must retain the above copyright // notice, this list of conditions and the following disclaimer. // * Redistributions in binary form must reproduce the above copyright // notice, this list of conditions and the following disclaimer in the // documentation and/or other materials provided with the distribution. // * Neither the name of the Syoyo Fujita nor the // names of its contributors may be used to endorse or promote products // derived from this software without specific prior written permission. // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND // ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED // WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE // DISCLAIMED. IN NO EVENT SHALL BE LIABLE FOR ANY // DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES // (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; // LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND // ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS // SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. // */ // // TinyEXR contains some OpenEXR code, which is licensed under ------------ // /////////////////////////////////////////////////////////////////////////// // // // // Copyright (c) 2002, Industrial Light & Magic, a division of Lucas // // Digital Ltd. LLC // // // // All rights reserved. // // // // Redistribution and use in source and binary forms, with or without // // modification, are permitted provided that the following conditions are // // met: // // * Redistributions of source code must retain the above copyright // // notice, this list of conditions and the following disclaimer. // // * Redistributions in binary form must reproduce the above // // copyright notice, this list of conditions and the following disclaimer // // in the documentation and/or other materials provided with the // // distribution. // // * Neither the name of Industrial Light & Magic nor the names of // // its contributors may be used to endorse or promote products derived // // from this software without specific prior written permission. // // // // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS // // \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT // // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR // // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT // // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, // // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT // // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, // // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY // // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT // // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE // // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. // // // /////////////////////////////////////////////////////////////////////////// // // End of OpenEXR license ------------------------------------------------- class EXRLoader extends DataTextureLoader { constructor( manager ) { super( manager ); this.type = HalfFloatType; } parse( buffer ) { const USHORT_RANGE = ( 1 < 16 ); const BITMAP_SIZE = ( USHORT_RANGE >> 3 ); const HUF_ENCBITS = 16; // literal (value) bit length const HUF_DECBITS = 14; // decoding bit size (>= 8) const HUF_ENCSIZE = ( 1 < HUF_ENCBITS ) + 1; // encoding table size const HUF_DECSIZE = 1 < HUF_DECBITS; // decoding table size const HUF_DECMASK = HUF_DECSIZE - 1; const NBITS = 16; const A_OFFSET = 1 < ( NBITS - 1 ); const MOD_MASK = ( 1 < NBITS ) - 1; const SHORT_ZEROCODE_RUN = 59; const LONG_ZEROCODE_RUN = 63; const SHORTEST_LONG_RUN = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN; const ULONG_SIZE = 8; const FLOAT32_SIZE = 4; const INT32_SIZE = 4; const INT16_SIZE = 2; const INT8_SIZE = 1; const STATIC_HUFFMAN = 0; const DEFLATE = 1; const UNKNOWN = 0; const LOSSY_DCT = 1; const RLE = 2; const logBase = Math.pow( 2.7182818, 2.2 ); function reverseLutFromBitmap( bitmap, lut ) { let k = 0; for ( let i = 0; i < USHORT_RANGE; ++ i ) { if ( ( i == 0 ) || ( bitmap[ i >> 3 ] & ( 1 < ( i & 7 ) ) ) ) { lut[ k ++ ] = i; } } const n = k - 1; while ( k < USHORT_RANGE ) lut[ k ++ ] = 0; return n; } function hufClearDecTable( hdec ) { for ( let i = 0; i < HUF_DECSIZE; i ++ ) { hdec[ i ] = {}; hdec[ i ].len = 0; hdec[ i ].lit = 0; hdec[ i ].p = null; } } const getBitsReturn = { l: 0, c: 0, lc: 0 }; function getBits( nBits, c, lc, uInt8Array, inOffset ) { while ( lc < nBits ) { c = ( c < 8 ) | parseUint8Array( uInt8Array, inOffset ); lc += 8; } lc -= nBits; getBitsReturn.l = ( c >> lc ) & ( ( 1 < nBits ) - 1 ); getBitsReturn.c = c; getBitsReturn.lc = lc; } const hufTableBuffer = new Array( 59 ); function hufCanonicalCodeTable( hcode ) { for ( let i = 0; i > ( l - HUF_DECBITS ) ) ]; if ( pl.len ) { throw new Error( 'Invalid table entry' ); } pl.lit ++; if ( pl.p ) { const p = pl.p; pl.p = new Array( pl.lit ); for ( let i = 0; i < pl.lit - 1; ++ i ) { pl.p[ i ] = p[ i ]; } } else { pl.p = new Array( 1 ); } pl.p[ pl.lit - 1 ] = im; } else if ( l ) { let plOffset = 0; for ( let i = 1 < ( HUF_DECBITS - l ); i > 0; i -- ) { const pl = hdecod[ ( c < ( HUF_DECBITS - l ) ) + plOffset ]; if ( pl.len || pl.p ) { throw new Error( 'Invalid table entry' ); } pl.len = l; pl.lit = im; plOffset ++; } } } return true; } const getCharReturn = { c: 0, lc: 0 }; function getChar( c, lc, uInt8Array, inOffset ) { c = ( c < 8 ) | parseUint8Array( uInt8Array, inOffset ); lc += 8; getCharReturn.c = c; getCharReturn.lc = lc; } const getCodeReturn = { c: 0, lc: 0 }; function getCode( po, rlc, c, lc, uInt8Array, inOffset, outBuffer, outBufferOffset, outBufferEndOffset ) { if ( po == rlc ) { if ( lc < 8 ) { getChar( c, lc, uInt8Array, inOffset ); c = getCharReturn.c; lc = getCharReturn.lc; } lc -= 8; let cs = ( c >> lc ); cs = new Uint8Array( [ cs ] )[ 0 ]; if ( outBufferOffset.value + cs > outBufferEndOffset ) { return false; } const s = outBuffer[ outBufferOffset.value - 1 ]; while ( cs -- > 0 ) { outBuffer[ outBufferOffset.value ++ ] = s; } } else if ( outBufferOffset.value < outBufferEndOffset ) { outBuffer[ outBufferOffset.value ++ ] = po; } else { return false; } getCodeReturn.c = c; getCodeReturn.lc = lc; } function UInt16( value ) { return ( value & 0xFFFF ); } function Int16( value ) { const ref = UInt16( value ); return ( ref > 0x7FFF ) ? ref - 0x10000 : ref; } const wdec14Return = { a: 0, b: 0 }; function wdec14( l, h ) { const ls = Int16( l ); const hs = Int16( h ); const hi = hs; const ai = ls + ( hi & 1 ) + ( hi >> 1 ); const as = ai; const bs = ai - hi; wdec14Return.a = as; wdec14Return.b = bs; } function wdec16( l, h ) { const m = UInt16( l ); const d = UInt16( h ); const bb = ( m - ( d >> 1 ) ) & MOD_MASK; const aa = ( d + bb - A_OFFSET ) & MOD_MASK; wdec14Return.a = aa; wdec14Return.b = bb; } function wav2Decode( buffer, j, nx, ox, ny, oy, mx ) { const w14 = mx < ( 1 < 14 ); const n = ( nx > ny ) ? ny : nx; let p = 1; let p2; let py; while ( p 0 ) { const pl = decodingTable[ ( c < ( HUF_DECBITS - lc ) ) & HUF_DECMASK ]; if ( pl.len ) { lc -= pl.len; getCode( pl.lit, rlc, c, lc, uInt8Array, inOffset, outBuffer, outOffset, outBufferEndOffset ); c = getCodeReturn.c; lc = getCodeReturn.lc; } else { throw new Error( 'hufDecode issues' ); } } return true; } function hufUncompress( uInt8Array, inDataView, inOffset, nCompressed, outBuffer, nRaw ) { const outOffset = { value: 0 }; const initialInOffset = inOffset.value; const im = parseUint32( inDataView, inOffset ); const iM = parseUint32( inDataView, inOffset ); inOffset.value += 4; const nBits = parseUint32( inDataView, inOffset ); inOffset.value += 4; if ( im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE ) { throw new Error( 'Something wrong with HUF_ENCSIZE' ); } const freq = new Array( HUF_ENCSIZE ); const hdec = new Array( HUF_DECSIZE ); hufClearDecTable( hdec ); const ni = nCompressed - ( inOffset.value - initialInOffset ); hufUnpackEncTable( uInt8Array, inOffset, ni, im, iM, freq ); if ( nBits > 8 * ( nCompressed - ( inOffset.value - initialInOffset ) ) ) { throw new Error( 'Something wrong with hufUncompress' ); } hufBuildDecTable( freq, im, iM, hdec ); hufDecode( freq, hdec, uInt8Array, inOffset, nBits, iM, nRaw, outBuffer, outOffset ); } function applyLut( lut, data, nData ) { for ( let i = 0; i < nData; ++ i ) { data[ i ] = lut[ data[ i ] ]; } } function predictor( source ) { for ( let t = 1; t < source.length; t ++ ) { const d = source[ t - 1 ] + source[ t ] - 128; source[ t ] = d; } } function interleaveScalar( source, out ) { let t1 = 0; let t2 = Math.floor( ( source.length + 1 ) / 2 ); let s = 0; const stop = source.length - 1; while ( true ) { if ( s > stop ) break; out[ s ++ ] = source[ t1 ++ ]; if ( s > stop ) break; out[ s ++ ] = source[ t2 ++ ]; } } function decodeRunLength( source ) { let size = source.byteLength; const out = new Array(); let p = 0; const reader = new DataView( source ); while ( size > 0 ) { const l = reader.getInt8( p ++ ); if ( l < 0 ) { const count = - l; size -= count + 1; for ( let i = 0; i < count; i ++ ) { out.push( reader.getUint8( p ++ ) ); } } else { const count = l; size -= 2; const value = reader.getUint8( p ++ ); for ( let i = 0; i < count + 1; i ++ ) { out.push( value ); } } } return out; } function lossyDctDecode( cscSet, rowPtrs, channelData, acBuffer, dcBuffer, outBuffer ) { let dataView = new DataView( outBuffer.buffer ); const width = channelData[ cscSet.idx[ 0 ] ].width; const height = channelData[ cscSet.idx[ 0 ] ].height; const numComp = 3; const numFullBlocksX = Math.floor( width / 8.0 ); const numBlocksX = Math.ceil( width / 8.0 ); const numBlocksY = Math.ceil( height / 8.0 ); const leftoverX = width - ( numBlocksX - 1 ) * 8; const leftoverY = height - ( numBlocksY - 1 ) * 8; const currAcComp = { value: 0 }; const currDcComp = new Array( numComp ); const dctData = new Array( numComp ); const halfZigBlock = new Array( numComp ); const rowBlock = new Array( numComp ); const rowOffsets = new Array( numComp ); for ( let comp = 0; comp < numComp; ++ comp ) { rowOffsets[ comp ] = rowPtrs[ cscSet.idx[ comp ] ]; currDcComp[ comp ] = ( comp < 1 ) ? 0 : currDcComp[ comp - 1 ] + numBlocksX * numBlocksY; dctData[ comp ] = new Float32Array( 64 ); halfZigBlock[ comp ] = new Uint16Array( 64 ); rowBlock[ comp ] = new Uint16Array( numBlocksX * 64 ); } for ( let blocky = 0; blocky < numBlocksY; ++ blocky ) { let maxY = 8; if ( blocky == numBlocksY - 1 ) maxY = leftoverY; let maxX = 8; for ( let blockx = 0; blockx < numBlocksX; ++ blockx ) { if ( blockx == numBlocksX - 1 ) maxX = leftoverX; for ( let comp = 0; comp < numComp; ++ comp ) { halfZigBlock[ comp ].fill( 0 ); // set block DC component halfZigBlock[ comp ][ 0 ] = dcBuffer[ currDcComp[ comp ] ++ ]; // set block AC components unRleAC( currAcComp, acBuffer, halfZigBlock[ comp ] ); // UnZigZag block to float unZigZag( halfZigBlock[ comp ], dctData[ comp ] ); // decode float dct dctInverse( dctData[ comp ] ); } if ( numComp == 3 ) { csc709Inverse( dctData ); } for ( let comp = 0; comp < numComp; ++ comp ) { convertToHalf( dctData[ comp ], rowBlock[ comp ], blockx * 64 ); } } // blockx let offset = 0; for ( let comp = 0; comp < numComp; ++ comp ) { const type = channelData[ cscSet.idx[ comp ] ].type; for ( let y = 8 * blocky; y < 8 * blocky + maxY; ++ y ) { offset = rowOffsets[ comp ][ y ]; for ( let blockx = 0; blockx < numFullBlocksX; ++ blockx ) { const src = blockx * 64 + ( ( y & 0x7 ) * 8 ); dataView.setUint16( offset + 0 * INT16_SIZE * type, rowBlock[ comp ][ src + 0 ], true ); dataView.setUint16( offset + 1 * INT16_SIZE * type, rowBlock[ comp ][ src + 1 ], true ); dataView.setUint16( offset + 2 * INT16_SIZE * type, rowBlock[ comp ][ src + 2 ], true ); dataView.setUint16( offset + 3 * INT16_SIZE * type, rowBlock[ comp ][ src + 3 ], true ); dataView.setUint16( offset + 4 * INT16_SIZE * type, rowBlock[ comp ][ src + 4 ], true ); dataView.setUint16( offset + 5 * INT16_SIZE * type, rowBlock[ comp ][ src + 5 ], true ); dataView.setUint16( offset + 6 * INT16_SIZE * type, rowBlock[ comp ][ src + 6 ], true ); dataView.setUint16( offset + 7 * INT16_SIZE * type, rowBlock[ comp ][ src + 7 ], true ); offset += 8 * INT16_SIZE * type; } } // handle partial X blocks if ( numFullBlocksX != numBlocksX ) { for ( let y = 8 * blocky; y < 8 * blocky + maxY; ++ y ) { const offset = rowOffsets[ comp ][ y ] + 8 * numFullBlocksX * INT16_SIZE * type; const src = numFullBlocksX * 64 + ( ( y & 0x7 ) * 8 ); for ( let x = 0; x < maxX; ++ x ) { dataView.setUint16( offset + x * INT16_SIZE * type, rowBlock[ comp ][ src + x ], true ); } } } } // comp } // blocky const halfRow = new Uint16Array( width ); dataView = new DataView( outBuffer.buffer ); // convert channels back to float, if needed for ( let comp = 0; comp < numComp; ++ comp ) { channelData[ cscSet.idx[ comp ] ].decoded = true; const type = channelData[ cscSet.idx[ comp ] ].type; if ( channelData[ comp ].type != 2 ) continue; for ( let y = 0; y < height; ++ y ) { const offset = rowOffsets[ comp ][ y ]; for ( let x = 0; x < width; ++ x ) { halfRow[ x ] = dataView.getUint16( offset + x * INT16_SIZE * type, true ); } for ( let x = 0; x < width; ++ x ) { dataView.setFloat32( offset + x * INT16_SIZE * type, decodeFloat16( halfRow[ x ] ), true ); } } } } function unRleAC( currAcComp, acBuffer, halfZigBlock ) { let acValue; let dctComp = 1; while ( dctComp < 64 ) { acValue = acBuffer[ currAcComp.value ]; if ( acValue == 0xff00 ) { dctComp = 64; } else if ( acValue >> 8 == 0xff ) { dctComp += acValue & 0xff; } else { halfZigBlock[ dctComp ] = acValue; dctComp ++; } currAcComp.value ++; } } function unZigZag( src, dst ) { dst[ 0 ] = decodeFloat16( src[ 0 ] ); dst[ 1 ] = decodeFloat16( src[ 1 ] ); dst[ 2 ] = decodeFloat16( src[ 5 ] ); dst[ 3 ] = decodeFloat16( src[ 6 ] ); dst[ 4 ] = decodeFloat16( src[ 14 ] ); dst[ 5 ] = decodeFloat16( src[ 15 ] ); dst[ 6 ] = decodeFloat16( src[ 27 ] ); dst[ 7 ] = decodeFloat16( src[ 28 ] ); dst[ 8 ] = decodeFloat16( src[ 2 ] ); dst[ 9 ] = decodeFloat16( src[ 4 ] ); dst[ 10 ] = decodeFloat16( src[ 7 ] ); dst[ 11 ] = decodeFloat16( src[ 13 ] ); dst[ 12 ] = decodeFloat16( src[ 16 ] ); dst[ 13 ] = decodeFloat16( src[ 26 ] ); dst[ 14 ] = decodeFloat16( src[ 29 ] ); dst[ 15 ] = decodeFloat16( src[ 42 ] ); dst[ 16 ] = decodeFloat16( src[ 3 ] ); dst[ 17 ] = decodeFloat16( src[ 8 ] ); dst[ 18 ] = decodeFloat16( src[ 12 ] ); dst[ 19 ] = decodeFloat16( src[ 17 ] ); dst[ 20 ] = decodeFloat16( src[ 25 ] ); dst[ 21 ] = decodeFloat16( src[ 30 ] ); dst[ 22 ] = decodeFloat16( src[ 41 ] ); dst[ 23 ] = decodeFloat16( src[ 43 ] ); dst[ 24 ] = decodeFloat16( src[ 9 ] ); dst[ 25 ] = decodeFloat16( src[ 11 ] ); dst[ 26 ] = decodeFloat16( src[ 18 ] ); dst[ 27 ] = decodeFloat16( src[ 24 ] ); dst[ 28 ] = decodeFloat16( src[ 31 ] ); dst[ 29 ] = decodeFloat16( src[ 40 ] ); dst[ 30 ] = decodeFloat16( src[ 44 ] ); dst[ 31 ] = decodeFloat16( src[ 53 ] ); dst[ 32 ] = decodeFloat16( src[ 10 ] ); dst[ 33 ] = decodeFloat16( src[ 19 ] ); dst[ 34 ] = decodeFloat16( src[ 23 ] ); dst[ 35 ] = decodeFloat16( src[ 32 ] ); dst[ 36 ] = decodeFloat16( src[ 39 ] ); dst[ 37 ] = decodeFloat16( src[ 45 ] ); dst[ 38 ] = decodeFloat16( src[ 52 ] ); dst[ 39 ] = decodeFloat16( src[ 54 ] ); dst[ 40 ] = decodeFloat16( src[ 20 ] ); dst[ 41 ] = decodeFloat16( src[ 22 ] ); dst[ 42 ] = decodeFloat16( src[ 33 ] ); dst[ 43 ] = decodeFloat16( src[ 38 ] ); dst[ 44 ] = decodeFloat16( src[ 46 ] ); dst[ 45 ] = decodeFloat16( src[ 51 ] ); dst[ 46 ] = decodeFloat16( src[ 55 ] ); dst[ 47 ] = decodeFloat16( src[ 60 ] ); dst[ 48 ] = decodeFloat16( src[ 21 ] ); dst[ 49 ] = decodeFloat16( src[ 34 ] ); dst[ 50 ] = decodeFloat16( src[ 37 ] ); dst[ 51 ] = decodeFloat16( src[ 47 ] ); dst[ 52 ] = decodeFloat16( src[ 50 ] ); dst[ 53 ] = decodeFloat16( src[ 56 ] ); dst[ 54 ] = decodeFloat16( src[ 59 ] ); dst[ 55 ] = decodeFloat16( src[ 61 ] ); dst[ 56 ] = decodeFloat16( src[ 35 ] ); dst[ 57 ] = decodeFloat16( src[ 36 ] ); dst[ 58 ] = decodeFloat16( src[ 48 ] ); dst[ 59 ] = decodeFloat16( src[ 49 ] ); dst[ 60 ] = decodeFloat16( src[ 57 ] ); dst[ 61 ] = decodeFloat16( src[ 58 ] ); dst[ 62 ] = decodeFloat16( src[ 62 ] ); dst[ 63 ] = decodeFloat16( src[ 63 ] ); } function dctInverse( data ) { const a = 0.5 * Math.cos( 3.14159 / 4.0 ); const b = 0.5 * Math.cos( 3.14159 / 16.0 ); const c = 0.5 * Math.cos( 3.14159 / 8.0 ); const d = 0.5 * Math.cos( 3.0 * 3.14159 / 16.0 ); const e = 0.5 * Math.cos( 5.0 * 3.14159 / 16.0 ); const f = 0.5 * Math.cos( 3.0 * 3.14159 / 8.0 ); const g = 0.5 * Math.cos( 7.0 * 3.14159 / 16.0 ); const alpha = new Array( 4 ); const beta = new Array( 4 ); const theta = new Array( 4 ); const gamma = new Array( 4 ); for ( let row = 0; row < 8; ++ row ) { const rowPtr = row * 8; alpha[ 0 ] = c * data[ rowPtr + 2 ]; alpha[ 1 ] = f * data[ rowPtr + 2 ]; alpha[ 2 ] = c * data[ rowPtr + 6 ]; alpha[ 3 ] = f * data[ rowPtr + 6 ]; beta[ 0 ] = b * data[ rowPtr + 1 ] + d * data[ rowPtr + 3 ] + e * data[ rowPtr + 5 ] + g * data[ rowPtr + 7 ]; beta[ 1 ] = d * data[ rowPtr + 1 ] - g * data[ rowPtr + 3 ] - b * data[ rowPtr + 5 ] - e * data[ rowPtr + 7 ]; beta[ 2 ] = e * data[ rowPtr + 1 ] - b * data[ rowPtr + 3 ] + g * data[ rowPtr + 5 ] + d * data[ rowPtr + 7 ]; beta[ 3 ] = g * data[ rowPtr + 1 ] - e * data[ rowPtr + 3 ] + d * data[ rowPtr + 5 ] - b * data[ rowPtr + 7 ]; theta[ 0 ] = a * ( data[ rowPtr + 0 ] + data[ rowPtr + 4 ] ); theta[ 3 ] = a * ( data[ rowPtr + 0 ] - data[ rowPtr + 4 ] ); theta[ 1 ] = alpha[ 0 ] + alpha[ 3 ]; theta[ 2 ] = alpha[ 1 ] - alpha[ 2 ]; gamma[ 0 ] = theta[ 0 ] + theta[ 1 ]; gamma[ 1 ] = theta[ 3 ] + theta[ 2 ]; gamma[ 2 ] = theta[ 3 ] - theta[ 2 ]; gamma[ 3 ] = theta[ 0 ] - theta[ 1 ]; data[ rowPtr + 0 ] = gamma[ 0 ] + beta[ 0 ]; data[ rowPtr + 1 ] = gamma[ 1 ] + beta[ 1 ]; data[ rowPtr + 2 ] = gamma[ 2 ] + beta[ 2 ]; data[ rowPtr + 3 ] = gamma[ 3 ] + beta[ 3 ]; data[ rowPtr + 4 ] = gamma[ 3 ] - beta[ 3 ]; data[ rowPtr + 5 ] = gamma[ 2 ] - beta[ 2 ]; data[ rowPtr + 6 ] = gamma[ 1 ] - beta[ 1 ]; data[ rowPtr + 7 ] = gamma[ 0 ] - beta[ 0 ]; } for ( let column = 0; column < 8; ++ column ) { alpha[ 0 ] = c * data[ 16 + column ]; alpha[ 1 ] = f * data[ 16 + column ]; alpha[ 2 ] = c * data[ 48 + column ]; alpha[ 3 ] = f * data[ 48 + column ]; beta[ 0 ] = b * data[ 8 + column ] + d * data[ 24 + column ] + e * data[ 40 + column ] + g * data[ 56 + column ]; beta[ 1 ] = d * data[ 8 + column ] - g * data[ 24 + column ] - b * data[ 40 + column ] - e * data[ 56 + column ]; beta[ 2 ] = e * data[ 8 + column ] - b * data[ 24 + column ] + g * data[ 40 + column ] + d * data[ 56 + column ]; beta[ 3 ] = g * data[ 8 + column ] - e * data[ 24 + column ] + d * data[ 40 + column ] - b * data[ 56 + column ]; theta[ 0 ] = a * ( data[ column ] + data[ 32 + column ] ); theta[ 3 ] = a * ( data[ column ] - data[ 32 + column ] ); theta[ 1 ] = alpha[ 0 ] + alpha[ 3 ]; theta[ 2 ] = alpha[ 1 ] - alpha[ 2 ]; gamma[ 0 ] = theta[ 0 ] + theta[ 1 ]; gamma[ 1 ] = theta[ 3 ] + theta[ 2 ]; gamma[ 2 ] = theta[ 3 ] - theta[ 2 ]; gamma[ 3 ] = theta[ 0 ] - theta[ 1 ]; data[ 0 + column ] = gamma[ 0 ] + beta[ 0 ]; data[ 8 + column ] = gamma[ 1 ] + beta[ 1 ]; data[ 16 + column ] = gamma[ 2 ] + beta[ 2 ]; data[ 24 + column ] = gamma[ 3 ] + beta[ 3 ]; data[ 32 + column ] = gamma[ 3 ] - beta[ 3 ]; data[ 40 + column ] = gamma[ 2 ] - beta[ 2 ]; data[ 48 + column ] = gamma[ 1 ] - beta[ 1 ]; data[ 56 + column ] = gamma[ 0 ] - beta[ 0 ]; } } function csc709Inverse( data ) { for ( let i = 0; i < 64; ++ i ) { const y = data[ 0 ][ i ]; const cb = data[ 1 ][ i ]; const cr = data[ 2 ][ i ]; data[ 0 ][ i ] = y + 1.5747 * cr; data[ 1 ][ i ] = y - 0.1873 * cb - 0.4682 * cr; data[ 2 ][ i ] = y + 1.8556 * cb; } } function convertToHalf( src, dst, idx ) { for ( let i = 0; i < 64; ++ i ) { dst[ idx + i ] = DataUtils.toHalfFloat( toLinear( src[ i ] ) ); } } function toLinear( float ) { if ( float"},{"title":"","date":"2023-10-12T14:08:40.662Z","updated":"2023-10-12T14:08:40.662Z","comments":true,"path":"js/three/jsm/loaders/FontLoader.js","permalink":"http://19999997.xyz/js/three/jsm/loaders/FontLoader.js","excerpt":"","text":"import { FileLoader, Loader, ShapePath } from 'three'; class FontLoader extends Loader { constructor( manager ) { super( manager ); } load( url, onLoad, onProgress, onError ) { const scope = this; const loader = new FileLoader( this.manager ); loader.setPath( this.path ); loader.setRequestHeader( this.requestHeader ); loader.setWithCredentials( this.withCredentials ); loader.load( url, function ( text ) { const font = scope.parse( JSON.parse( text ) ); if ( onLoad ) onLoad( font ); }, onProgress, onError ); } parse( json ) { return new Font( json ); } } // class Font { constructor( data ) { this.isFont = true; this.type = 'Font'; this.data = data; } generateShapes( text, size = 100 ) { const shapes = []; const paths = createPaths( text, size, this.data ); for ( let p = 0, pl = paths.length; p < pl; p ++ ) { shapes.push( ...paths[ p ].toShapes() ); } return shapes; } } function createPaths( text, size, data ) { const chars = Array.from( text ); const scale = size / data.resolution; const line_height = ( data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness ) * scale; const paths = []; let offsetX = 0, offsetY = 0; for ( let i = 0; i < chars.length; i ++ ) { const char = chars[ i ]; if ( char === '\\n' ) { offsetX = 0; offsetY -= line_height; } else { const ret = createPath( char, scale, offsetX, offsetY, data ); offsetX += ret.offsetX; paths.push( ret.path ); } } return paths; } function createPath( char, scale, offsetX, offsetY, data ) { const glyph = data.glyphs[ char ] || data.glyphs[ '?' ]; if ( ! glyph ) { console.error( 'THREE.Font: character \"' + char + '\" does not exists in font family ' + data.familyName + '.' ); return; } const path = new ShapePath(); let x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2; if ( glyph.o ) { const outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) ); for ( let i = 0, l = outline.length; i < l; ) { const action = outline[ i ++ ]; switch ( action ) { case 'm': // moveTo x = outline[ i ++ ] * scale + offsetX; y = outline[ i ++ ] * scale + offsetY; path.moveTo( x, y ); break; case 'l': // lineTo x = outline[ i ++ ] * scale + offsetX; y = outline[ i ++ ] * scale + offsetY; path.lineTo( x, y ); break; case 'q': // quadraticCurveTo cpx = outline[ i ++ ] * scale + offsetX; cpy = outline[ i ++ ] * scale + offsetY; cpx1 = outline[ i ++ ] * scale + offsetX; cpy1 = outline[ i ++ ] * scale + offsetY; path.quadraticCurveTo( cpx1, cpy1, cpx, cpy ); break; case 'b': // bezierCurveTo cpx = outline[ i ++ ] * scale + offsetX; cpy = outline[ i ++ ] * scale + offsetY; cpx1 = outline[ i ++ ] * scale + offsetX; cpy1 = outline[ i ++ ] * scale + offsetY; cpx2 = outline[ i ++ ] * scale + offsetX; cpy2 = outline[ i ++ ] * scale + offsetY; path.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy ); break; } } } return { offsetX: glyph.ha * scale, path: path }; } export { FontLoader, Font };"},{"title":"","date":"2023-10-12T14:08:40.665Z","updated":"2023-10-12T14:08:40.665Z","comments":true,"path":"js/three/jsm/loaders/GCodeLoader.js","permalink":"http://19999997.xyz/js/three/jsm/loaders/GCodeLoader.js","excerpt":"","text":"import { BufferGeometry, FileLoader, Float32BufferAttribute, Group, LineBasicMaterial, LineSegments, Loader } from 'three'; /** * GCodeLoader is used to load gcode files usually used for 3D printing or CNC applications. * * Gcode files are composed by commands used by machines to create objects. * * @class GCodeLoader * @param {Manager} manager Loading manager. */ class GCodeLoader extends Loader { constructor( manager ) { super( manager ); this.splitLayer = false; } load( url, onLoad, onProgress, onError ) { const scope = this; const loader = new FileLoader( scope.manager ); loader.setPath( scope.path ); loader.setRequestHeader( scope.requestHeader ); loader.setWithCredentials( scope.withCredentials ); loader.load( url, function ( text ) { try { onLoad( scope.parse( text ) ); } catch ( e ) { if ( onError ) { onError( e ); } else { console.error( e ); } scope.manager.itemError( url ); } }, onProgress, onError ); } parse( data ) { let state = { x: 0, y: 0, z: 0, e: 0, f: 0, extruding: false, relative: false }; const layers = []; let currentLayer = undefined; const pathMaterial = new LineBasicMaterial( { color: 0xFF0000 } ); pathMaterial.name = 'path'; const extrudingMaterial = new LineBasicMaterial( { color: 0x00FF00 } ); extrudingMaterial.name = 'extruded'; function newLayer( line ) { currentLayer = { vertex: [], pathVertex: [], z: line.z }; layers.push( currentLayer ); } //Create lie segment between p1 and p2 function addSegment( p1, p2 ) { if ( currentLayer === undefined ) { newLayer( p1 ); } if ( state.extruding ) { currentLayer.vertex.push( p1.x, p1.y, p1.z ); currentLayer.vertex.push( p2.x, p2.y, p2.z ); } else { currentLayer.pathVertex.push( p1.x, p1.y, p1.z ); currentLayer.pathVertex.push( p2.x, p2.y, p2.z ); } } function delta( v1, v2 ) { return state.relative ? v2 : v2 - v1; } function absolute( v1, v2 ) { return state.relative ? v1 + v2 : v2; } const lines = data.replace( /;.+/g, '' ).split( '\\n' ); for ( let i = 0; i < lines.length; i ++ ) { const tokens = lines[ i ].split( ' ' ); const cmd = tokens[ 0 ].toUpperCase(); //Argumments const args = {}; tokens.splice( 1 ).forEach( function ( token ) { if ( token[ 0 ] !== undefined ) { const key = token[ 0 ].toLowerCase(); const value = parseFloat( token.substring( 1 ) ); args[ key ] = value; } } ); //Process commands //G0/G1 – Linear Movement if ( cmd === 'G0' || cmd === 'G1' ) { const line = { x: args.x !== undefined ? absolute( state.x, args.x ) : state.x, y: args.y !== undefined ? absolute( state.y, args.y ) : state.y, z: args.z !== undefined ? absolute( state.z, args.z ) : state.z, e: args.e !== undefined ? absolute( state.e, args.e ) : state.e, f: args.f !== undefined ? absolute( state.f, args.f ) : state.f, }; //Layer change detection is or made by watching Z, it's made by watching when we extrude at a new Z position if ( delta( state.e, line.e ) > 0 ) { state.extruding = delta( state.e, line.e ) > 0; if ( currentLayer == undefined || line.z != currentLayer.z ) { newLayer( line ); } } addSegment( state, line ); state = line; } else if ( cmd === 'G2' || cmd === 'G3' ) { //G2/G3 - Arc Movement ( G2 clock wise and G3 counter clock wise ) //console.warn( 'THREE.GCodeLoader: Arc command not supported' ); } else if ( cmd === 'G90' ) { //G90: Set to Absolute Positioning state.relative = false; } else if ( cmd === 'G91' ) { //G91: Set to state.relative Positioning state.relative = true; } else if ( cmd === 'G92' ) { //G92: Set Position const line = state; line.x = args.x !== undefined ? args.x : line.x; line.y = args.y !== undefined ? args.y : line.y; line.z = args.z !== undefined ? args.z : line.z; line.e = args.e !== undefined ? args.e : line.e; } else { //console.warn( 'THREE.GCodeLoader: Command not supported:' + cmd ); } } function addObject( vertex, extruding, i ) { const geometry = new BufferGeometry(); geometry.setAttribute( 'position', new Float32BufferAttribute( vertex, 3 ) ); const segments = new LineSegments( geometry, extruding ? extrudingMaterial : pathMaterial ); segments.name = 'layer' + i; object.add( segments ); } const object = new Group(); object.name = 'gcode'; if ( this.splitLayer ) { for ( let i = 0; i < layers.length; i ++ ) { const layer = layers[ i ]; addObject( layer.vertex, true, i ); addObject( layer.pathVertex, false, i ); } } else { const vertex = [], pathVertex = []; for ( let i = 0; i < layers.length; i ++ ) { const layer = layers[ i ]; const layerVertex = layer.vertex; const layerPathVertex = layer.pathVertex; for ( let j = 0; j < layerVertex.length; j ++ ) { vertex.push( layerVertex[ j ] ); } for ( let j = 0; j < layerPathVertex.length; j ++ ) { pathVertex.push( layerPathVertex[ j ] ); } } addObject( vertex, true, layers.length ); addObject( pathVertex, false, layers.length ); } object.rotation.set( - Math.PI / 2, 0, 0 ); return object; } } export { GCodeLoader };"},{"title":"","date":"2023-10-12T14:08:40.671Z","updated":"2023-10-12T14:08:40.671Z","comments":true,"path":"js/three/jsm/loaders/HDRCubeTextureLoader.js","permalink":"http://19999997.xyz/js/three/jsm/loaders/HDRCubeTextureLoader.js","excerpt":"","text":"import { CubeTexture, DataTexture, FileLoader, FloatType, HalfFloatType, LinearFilter, LinearSRGBColorSpace, Loader } from 'three'; import { RGBELoader } from '../loaders/RGBELoader.js'; class HDRCubeTextureLoader extends Loader { constructor( manager ) { super( manager ); this.hdrLoader = new RGBELoader(); this.type = HalfFloatType; } load( urls, onLoad, onProgress, onError ) { const texture = new CubeTexture(); texture.type = this.type; switch ( texture.type ) { case FloatType: texture.colorSpace = LinearSRGBColorSpace; texture.minFilter = LinearFilter; texture.magFilter = LinearFilter; texture.generateMipmaps = false; break; case HalfFloatType: texture.colorSpace = LinearSRGBColorSpace; texture.minFilter = LinearFilter; texture.magFilter = LinearFilter; texture.generateMipmaps = false; break; } const scope = this; let loaded = 0; function loadHDRData( i, onLoad, onProgress, onError ) { new FileLoader( scope.manager ) .setPath( scope.path ) .setResponseType( 'arraybuffer' ) .setWithCredentials( scope.withCredentials ) .load( urls[ i ], function ( buffer ) { loaded ++; const texData = scope.hdrLoader.parse( buffer ); if ( ! texData ) return; if ( texData.data !== undefined ) { const dataTexture = new DataTexture( texData.data, texData.width, texData.height ); dataTexture.type = texture.type; dataTexture.colorSpace = texture.colorSpace; dataTexture.format = texture.format; dataTexture.minFilter = texture.minFilter; dataTexture.magFilter = texture.magFilter; dataTexture.generateMipmaps = texture.generateMipmaps; texture.images[ i ] = dataTexture; } if ( loaded === 6 ) { texture.needsUpdate = true; if ( onLoad ) onLoad( texture ); } }, onProgress, onError ); } for ( let i = 0; i < urls.length; i ++ ) { loadHDRData( i, onLoad, onProgress, onError ); } return texture; } setDataType( value ) { this.type = value; this.hdrLoader.setDataType( value ); return this; } } export { HDRCubeTextureLoader };"},{"title":"","date":"2023-10-12T14:08:40.659Z","updated":"2023-10-12T14:08:40.659Z","comments":true,"path":"js/three/jsm/loaders/FBXLoader.js","permalink":"http://19999997.xyz/js/three/jsm/loaders/FBXLoader.js","excerpt":"","text":"import { AmbientLight, AnimationClip, Bone, BufferGeometry, ClampToEdgeWrapping, Color, DirectionalLight, EquirectangularReflectionMapping, Euler, FileLoader, Float32BufferAttribute, Group, Line, LineBasicMaterial, Loader, LoaderUtils, MathUtils, Matrix3, Matrix4, Mesh, MeshLambertMaterial, MeshPhongMaterial, NumberKeyframeTrack, Object3D, OrthographicCamera, PerspectiveCamera, PointLight, PropertyBinding, Quaternion, QuaternionKeyframeTrack, RepeatWrapping, Skeleton, SkinnedMesh, SpotLight, Texture, TextureLoader, Uint16BufferAttribute, Vector3, Vector4, VectorKeyframeTrack, SRGBColorSpace } from 'three'; import * as fflate from '../libs/fflate.module.js'; import { NURBSCurve } from '../curves/NURBSCurve.js'; /** * Loader loads FBX file and generates Group representing FBX scene. * Requires FBX file to be >= 7.0 and in ASCII or >= 6400 in Binary format * Versions lower than this may load but will probably have errors * * Needs Support: * Morph normals / blend shape normals * * FBX format references: * https://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_index_html (C++ SDK reference) * * Binary format specification: * https://code.blender.org/2013/08/fbx-binary-file-format-specification/ */ let fbxTree; let connections; let sceneGraph; class FBXLoader extends Loader { constructor( manager ) { super( manager ); } load( url, onLoad, onProgress, onError ) { const scope = this; const path = ( scope.path === '' ) ? LoaderUtils.extractUrlBase( url ) : scope.path; const loader = new FileLoader( this.manager ); loader.setPath( scope.path ); loader.setResponseType( 'arraybuffer' ); loader.setRequestHeader( scope.requestHeader ); loader.setWithCredentials( scope.withCredentials ); loader.load( url, function ( buffer ) { try { onLoad( scope.parse( buffer, path ) ); } catch ( e ) { if ( onError ) { onError( e ); } else { console.error( e ); } scope.manager.itemError( url ); } }, onProgress, onError ); } parse( FBXBuffer, path ) { if ( isFbxFormatBinary( FBXBuffer ) ) { fbxTree = new BinaryParser().parse( FBXBuffer ); } else { const FBXText = convertArrayBufferToString( FBXBuffer ); if ( ! isFbxFormatASCII( FBXText ) ) { throw new Error( 'THREE.FBXLoader: Unknown format.' ); } if ( getFbxVersion( FBXText ) < 7000 ) { throw new Error( 'THREE.FBXLoader: FBX version not supported, FileVersion: ' + getFbxVersion( FBXText ) ); } fbxTree = new TextParser().parse( FBXText ); } // console.log( fbxTree ); const textureLoader = new TextureLoader( this.manager ).setPath( this.resourcePath || path ).setCrossOrigin( this.crossOrigin ); return new FBXTreeParser( textureLoader, this.manager ).parse( fbxTree ); } } // Parse the FBXTree object returned by the BinaryParser or TextParser and return a Group class FBXTreeParser { constructor( textureLoader, manager ) { this.textureLoader = textureLoader; this.manager = manager; } parse() { connections = this.parseConnections(); const images = this.parseImages(); const textures = this.parseTextures( images ); const materials = this.parseMaterials( textures ); const deformers = this.parseDeformers(); const geometryMap = new GeometryParser().parse( deformers ); this.parseScene( deformers, geometryMap, materials ); return sceneGraph; } // Parses FBXTree.Connections which holds parent-child connections between objects (e.g. material -> texture, model->geometry ) // and details the connection type parseConnections() { const connectionMap = new Map(); if ( 'Connections' in fbxTree ) { const rawConnections = fbxTree.Connections.connections; rawConnections.forEach( function ( rawConnection ) { const fromID = rawConnection[ 0 ]; const toID = rawConnection[ 1 ]; const relationship = rawConnection[ 2 ]; if ( ! connectionMap.has( fromID ) ) { connectionMap.set( fromID, { parents: [], children: [] } ); } const parentRelationship = { ID: toID, relationship: relationship }; connectionMap.get( fromID ).parents.push( parentRelationship ); if ( ! connectionMap.has( toID ) ) { connectionMap.set( toID, { parents: [], children: [] } ); } const childRelationship = { ID: fromID, relationship: relationship }; connectionMap.get( toID ).children.push( childRelationship ); } ); } return connectionMap; } // Parse FBXTree.Objects.Video for embedded image data // These images are connected to textures in FBXTree.Objects.Textures // via FBXTree.Connections. parseImages() { const images = {}; const blobs = {}; if ( 'Video' in fbxTree.Objects ) { const videoNodes = fbxTree.Objects.Video; for ( const nodeID in videoNodes ) { const videoNode = videoNodes[ nodeID ]; const id = parseInt( nodeID ); images[ id ] = videoNode.RelativeFilename || videoNode.Filename; // raw image data is in videoNode.Content if ( 'Content' in videoNode ) { const arrayBufferContent = ( videoNode.Content instanceof ArrayBuffer ) && ( videoNode.Content.byteLength > 0 ); const base64Content = ( typeof videoNode.Content === 'string' ) && ( videoNode.Content !== '' ); if ( arrayBufferContent || base64Content ) { const image = this.parseImage( videoNodes[ nodeID ] ); blobs[ videoNode.RelativeFilename || videoNode.Filename ] = image; } } } } for ( const id in images ) { const filename = images[ id ]; if ( blobs[ filename ] !== undefined ) images[ id ] = blobs[ filename ]; else images[ id ] = images[ id ].split( '\\\\' ).pop(); } return images; } // Parse embedded image data in FBXTree.Video.Content parseImage( videoNode ) { const content = videoNode.Content; const fileName = videoNode.RelativeFilename || videoNode.Filename; const extension = fileName.slice( fileName.lastIndexOf( '.' ) + 1 ).toLowerCase(); let type; switch ( extension ) { case 'bmp': type = 'image/bmp'; break; case 'jpg': case 'jpeg': type = 'image/jpeg'; break; case 'png': type = 'image/png'; break; case 'tif': type = 'image/tiff'; break; case 'tga': if ( this.manager.getHandler( '.tga' ) === null ) { console.warn( 'FBXLoader: TGA loader not found, skipping ', fileName ); } type = 'image/tga'; break; default: console.warn( 'FBXLoader: Image type \"' + extension + '\" is not supported.' ); return; } if ( typeof content === 'string' ) { // ASCII format return 'data:' + type + ';base64,' + content; } else { // Binary Format const array = new Uint8Array( content ); return window.URL.createObjectURL( new Blob( [ array ], { type: type } ) ); } } // Parse nodes in FBXTree.Objects.Texture // These contain details such as UV scaling, cropping, rotation etc and are connected // to images in FBXTree.Objects.Video parseTextures( images ) { const textureMap = new Map(); if ( 'Texture' in fbxTree.Objects ) { const textureNodes = fbxTree.Objects.Texture; for ( const nodeID in textureNodes ) { const texture = this.parseTexture( textureNodes[ nodeID ], images ); textureMap.set( parseInt( nodeID ), texture ); } } return textureMap; } // Parse individual node in FBXTree.Objects.Texture parseTexture( textureNode, images ) { const texture = this.loadTexture( textureNode, images ); texture.ID = textureNode.id; texture.name = textureNode.attrName; const wrapModeU = textureNode.WrapModeU; const wrapModeV = textureNode.WrapModeV; const valueU = wrapModeU !== undefined ? wrapModeU.value : 0; const valueV = wrapModeV !== undefined ? wrapModeV.value : 0; // http://download.autodesk.com/us/fbx/SDKdocs/FBX_SDK_Help/files/fbxsdkref/class_k_fbx_texture.html#889640e63e2e681259ea81061b85143a // 0: repeat(default), 1: clamp texture.wrapS = valueU === 0 ? RepeatWrapping : ClampToEdgeWrapping; texture.wrapT = valueV === 0 ? RepeatWrapping : ClampToEdgeWrapping; if ( 'Scaling' in textureNode ) { const values = textureNode.Scaling.value; texture.repeat.x = values[ 0 ]; texture.repeat.y = values[ 1 ]; } if ( 'Translation' in textureNode ) { const values = textureNode.Translation.value; texture.offset.x = values[ 0 ]; texture.offset.y = values[ 1 ]; } return texture; } // load a texture specified as a blob or data URI, or via an external URL using TextureLoader loadTexture( textureNode, images ) { let fileName; const currentPath = this.textureLoader.path; const children = connections.get( textureNode.id ).children; if ( children !== undefined && children.length > 0 && images[ children[ 0 ].ID ] !== undefined ) { fileName = images[ children[ 0 ].ID ]; if ( fileName.indexOf( 'blob:' ) === 0 || fileName.indexOf( 'data:' ) === 0 ) { this.textureLoader.setPath( undefined ); } } let texture; const extension = textureNode.FileName.slice( - 3 ).toLowerCase(); if ( extension === 'tga' ) { const loader = this.manager.getHandler( '.tga' ); if ( loader === null ) { console.warn( 'FBXLoader: TGA loader not found, creating placeholder texture for', textureNode.RelativeFilename ); texture = new Texture(); } else { loader.setPath( this.textureLoader.path ); texture = loader.load( fileName ); } } else if ( extension === 'psd' ) { console.warn( 'FBXLoader: PSD textures are not supported, creating placeholder texture for', textureNode.RelativeFilename ); texture = new Texture(); } else { texture = this.textureLoader.load( fileName ); } this.textureLoader.setPath( currentPath ); return texture; } // Parse nodes in FBXTree.Objects.Material parseMaterials( textureMap ) { const materialMap = new Map(); if ( 'Material' in fbxTree.Objects ) { const materialNodes = fbxTree.Objects.Material; for ( const nodeID in materialNodes ) { const material = this.parseMaterial( materialNodes[ nodeID ], textureMap ); if ( material !== null ) materialMap.set( parseInt( nodeID ), material ); } } return materialMap; } // Parse single node in FBXTree.Objects.Material // Materials are connected to texture maps in FBXTree.Objects.Textures // FBX format currently only supports Lambert and Phong shading models parseMaterial( materialNode, textureMap ) { const ID = materialNode.id; const name = materialNode.attrName; let type = materialNode.ShadingModel; // Case where FBX wraps shading model in property object. if ( typeof type === 'object' ) { type = type.value; } // Ignore unused materials which don't have any connections. if ( ! connections.has( ID ) ) return null; const parameters = this.parseParameters( materialNode, textureMap, ID ); let material; switch ( type.toLowerCase() ) { case 'phong': material = new MeshPhongMaterial(); break; case 'lambert': material = new MeshLambertMaterial(); break; default: console.warn( 'THREE.FBXLoader: unknown material type \"%s\". Defaulting to MeshPhongMaterial.', type ); material = new MeshPhongMaterial(); break; } material.setValues( parameters ); material.name = name; return material; } // Parse FBX material and return parameters suitable for a three.js material // Also parse the texture map and return any textures associated with the material parseParameters( materialNode, textureMap, ID ) { const parameters = {}; if ( materialNode.BumpFactor ) { parameters.bumpScale = materialNode.BumpFactor.value; } if ( materialNode.Diffuse ) { parameters.color = new Color().fromArray( materialNode.Diffuse.value ).convertSRGBToLinear(); } else if ( materialNode.DiffuseColor && ( materialNode.DiffuseColor.type === 'Color' || materialNode.DiffuseColor.type === 'ColorRGB' ) ) { // The blender exporter exports diffuse here instead of in materialNode.Diffuse parameters.color = new Color().fromArray( materialNode.DiffuseColor.value ).convertSRGBToLinear(); } if ( materialNode.DisplacementFactor ) { parameters.displacementScale = materialNode.DisplacementFactor.value; } if ( materialNode.Emissive ) { parameters.emissive = new Color().fromArray( materialNode.Emissive.value ).convertSRGBToLinear(); } else if ( materialNode.EmissiveColor && ( materialNode.EmissiveColor.type === 'Color' || materialNode.EmissiveColor.type === 'ColorRGB' ) ) { // The blender exporter exports emissive color here instead of in materialNode.Emissive parameters.emissive = new Color().fromArray( materialNode.EmissiveColor.value ).convertSRGBToLinear(); } if ( materialNode.EmissiveFactor ) { parameters.emissiveIntensity = parseFloat( materialNode.EmissiveFactor.value ); } if ( materialNode.Opacity ) { parameters.opacity = parseFloat( materialNode.Opacity.value ); } if ( parameters.opacity < 1.0 ) { parameters.transparent = true; } if ( materialNode.ReflectionFactor ) { parameters.reflectivity = materialNode.ReflectionFactor.value; } if ( materialNode.Shininess ) { parameters.shininess = materialNode.Shininess.value; } if ( materialNode.Specular ) { parameters.specular = new Color().fromArray( materialNode.Specular.value ).convertSRGBToLinear(); } else if ( materialNode.SpecularColor && materialNode.SpecularColor.type === 'Color' ) { // The blender exporter exports specular color here instead of in materialNode.Specular parameters.specular = new Color().fromArray( materialNode.SpecularColor.value ).convertSRGBToLinear(); } const scope = this; connections.get( ID ).children.forEach( function ( child ) { const type = child.relationship; switch ( type ) { case 'Bump': parameters.bumpMap = scope.getTexture( textureMap, child.ID ); break; case 'Maya|TEX_ao_map': parameters.aoMap = scope.getTexture( textureMap, child.ID ); break; case 'DiffuseColor': case 'Maya|TEX_color_map': parameters.map = scope.getTexture( textureMap, child.ID ); if ( parameters.map !== undefined ) { parameters.map.colorSpace = SRGBColorSpace; } break; case 'DisplacementColor': parameters.displacementMap = scope.getTexture( textureMap, child.ID ); break; case 'EmissiveColor': parameters.emissiveMap = scope.getTexture( textureMap, child.ID ); if ( parameters.emissiveMap !== undefined ) { parameters.emissiveMap.colorSpace = SRGBColorSpace; } break; case 'NormalMap': case 'Maya|TEX_normal_map': parameters.normalMap = scope.getTexture( textureMap, child.ID ); break; case 'ReflectionColor': parameters.envMap = scope.getTexture( textureMap, child.ID ); if ( parameters.envMap !== undefined ) { parameters.envMap.mapping = EquirectangularReflectionMapping; parameters.envMap.colorSpace = SRGBColorSpace; } break; case 'SpecularColor': parameters.specularMap = scope.getTexture( textureMap, child.ID ); if ( parameters.specularMap !== undefined ) { parameters.specularMap.colorSpace = SRGBColorSpace; } break; case 'TransparentColor': case 'TransparencyFactor': parameters.alphaMap = scope.getTexture( textureMap, child.ID ); parameters.transparent = true; break; case 'AmbientColor': case 'ShininessExponent': // AKA glossiness map case 'SpecularFactor': // AKA specularLevel case 'VectorDisplacementColor': // NOTE: Seems to be a copy of DisplacementColor default: console.warn( 'THREE.FBXLoader: %s map is not supported in three.js, skipping texture.', type ); break; } } ); return parameters; } // get a texture from the textureMap for use by a material. getTexture( textureMap, id ) { // if the texture is a layered texture, just use the first layer and issue a warning if ( 'LayeredTexture' in fbxTree.Objects && id in fbxTree.Objects.LayeredTexture ) { console.warn( 'THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer.' ); id = connections.get( id ).children[ 0 ].ID; } return textureMap.get( id ); } // Parse nodes in FBXTree.Objects.Deformer // Deformer node can contain skinning or Vertex Cache animation data, however only skinning is supported here // Generates map of Skeleton-like objects for use later when generating and binding skeletons. parseDeformers() { const skeletons = {}; const morphTargets = {}; if ( 'Deformer' in fbxTree.Objects ) { const DeformerNodes = fbxTree.Objects.Deformer; for ( const nodeID in DeformerNodes ) { const deformerNode = DeformerNodes[ nodeID ]; const relationships = connections.get( parseInt( nodeID ) ); if ( deformerNode.attrType === 'Skin' ) { const skeleton = this.parseSkeleton( relationships, DeformerNodes ); skeleton.ID = nodeID; if ( relationships.parents.length > 1 ) console.warn( 'THREE.FBXLoader: skeleton attached to more than one geometry is not supported.' ); skeleton.geometryID = relationships.parents[ 0 ].ID; skeletons[ nodeID ] = skeleton; } else if ( deformerNode.attrType === 'BlendShape' ) { const morphTarget = { id: nodeID, }; morphTarget.rawTargets = this.parseMorphTargets( relationships, DeformerNodes ); morphTarget.id = nodeID; if ( relationships.parents.length > 1 ) console.warn( 'THREE.FBXLoader: morph target attached to more than one geometry is not supported.' ); morphTargets[ nodeID ] = morphTarget; } } } return { skeletons: skeletons, morphTargets: morphTargets, }; } // Parse single nodes in FBXTree.Objects.Deformer // The top level skeleton node has type 'Skin' and sub nodes have type 'Cluster' // Each skin node represents a skeleton and each cluster node represents a bone parseSkeleton( relationships, deformerNodes ) { const rawBones = []; relationships.children.forEach( function ( child ) { const boneNode = deformerNodes[ child.ID ]; if ( boneNode.attrType !== 'Cluster' ) return; const rawBone = { ID: child.ID, indices: [], weights: [], transformLink: new Matrix4().fromArray( boneNode.TransformLink.a ), // transform: new Matrix4().fromArray( boneNode.Transform.a ), // linkMode: boneNode.Mode, }; if ( 'Indexes' in boneNode ) { rawBone.indices = boneNode.Indexes.a; rawBone.weights = boneNode.Weights.a; } rawBones.push( rawBone ); } ); return { rawBones: rawBones, bones: [] }; } // The top level morph deformer node has type \"BlendShape\" and sub nodes have type \"BlendShapeChannel\" parseMorphTargets( relationships, deformerNodes ) { const rawMorphTargets = []; for ( let i = 0; i < relationships.children.length; i ++ ) { const child = relationships.children[ i ]; const morphTargetNode = deformerNodes[ child.ID ]; const rawMorphTarget = { name: morphTargetNode.attrName, initialWeight: morphTargetNode.DeformPercent, id: morphTargetNode.id, fullWeights: morphTargetNode.FullWeights.a }; if ( morphTargetNode.attrType !== 'BlendShapeChannel' ) return; rawMorphTarget.geoID = connections.get( parseInt( child.ID ) ).children.filter( function ( child ) { return child.relationship === undefined; } )[ 0 ].ID; rawMorphTargets.push( rawMorphTarget ); } return rawMorphTargets; } // create the main Group() to be returned by the loader parseScene( deformers, geometryMap, materialMap ) { sceneGraph = new Group(); const modelMap = this.parseModels( deformers.skeletons, geometryMap, materialMap ); const modelNodes = fbxTree.Objects.Model; const scope = this; modelMap.forEach( function ( model ) { const modelNode = modelNodes[ model.ID ]; scope.setLookAtProperties( model, modelNode ); const parentConnections = connections.get( model.ID ).parents; parentConnections.forEach( function ( connection ) { const parent = modelMap.get( connection.ID ); if ( parent !== undefined ) parent.add( model ); } ); if ( model.parent === null ) { sceneGraph.add( model ); } } ); this.bindSkeleton( deformers.skeletons, geometryMap, modelMap ); this.createAmbientLight(); sceneGraph.traverse( function ( node ) { if ( node.userData.transformData ) { if ( node.parent ) { node.userData.transformData.parentMatrix = node.parent.matrix; node.userData.transformData.parentMatrixWorld = node.parent.matrixWorld; } const transform = generateTransform( node.userData.transformData ); node.applyMatrix4( transform ); node.updateWorldMatrix(); } } ); const animations = new AnimationParser().parse(); // if all the models where already combined in a single group, just return that if ( sceneGraph.children.length === 1 && sceneGraph.children[ 0 ].isGroup ) { sceneGraph.children[ 0 ].animations = animations; sceneGraph = sceneGraph.children[ 0 ]; } sceneGraph.animations = animations; } // parse nodes in FBXTree.Objects.Model parseModels( skeletons, geometryMap, materialMap ) { const modelMap = new Map(); const modelNodes = fbxTree.Objects.Model; for ( const nodeID in modelNodes ) { const id = parseInt( nodeID ); const node = modelNodes[ nodeID ]; const relationships = connections.get( id ); let model = this.buildSkeleton( relationships, skeletons, id, node.attrName ); if ( ! model ) { switch ( node.attrType ) { case 'Camera': model = this.createCamera( relationships ); break; case 'Light': model = this.createLight( relationships ); break; case 'Mesh': model = this.createMesh( relationships, geometryMap, materialMap ); break; case 'NurbsCurve': model = this.createCurve( relationships, geometryMap ); break; case 'LimbNode': case 'Root': model = new Bone(); break; case 'Null': default: model = new Group(); break; } model.name = node.attrName ? PropertyBinding.sanitizeNodeName( node.attrName ) : ''; model.userData.originalName = node.attrName; model.ID = id; } this.getTransformData( model, node ); modelMap.set( id, model ); } return modelMap; } buildSkeleton( relationships, skeletons, id, name ) { let bone = null; relationships.parents.forEach( function ( parent ) { for ( const ID in skeletons ) { const skeleton = skeletons[ ID ]; skeleton.rawBones.forEach( function ( rawBone, i ) { if ( rawBone.ID === parent.ID ) { const subBone = bone; bone = new Bone(); bone.matrixWorld.copy( rawBone.transformLink ); // set name and id here - otherwise in cases where \"subBone\" is created it will not have a name / id bone.name = name ? PropertyBinding.sanitizeNodeName( name ) : ''; bone.userData.originalName = name; bone.ID = id; skeleton.bones[ i ] = bone; // In cases where a bone is shared between multiple meshes // duplicate the bone here and and it as a child of the first bone if ( subBone !== null ) { bone.add( subBone ); } } } ); } } ); return bone; } // create a PerspectiveCamera or OrthographicCamera createCamera( relationships ) { let model; let cameraAttribute; relationships.children.forEach( function ( child ) { const attr = fbxTree.Objects.NodeAttribute[ child.ID ]; if ( attr !== undefined ) { cameraAttribute = attr; } } ); if ( cameraAttribute === undefined ) { model = new Object3D(); } else { let type = 0; if ( cameraAttribute.CameraProjectionType !== undefined && cameraAttribute.CameraProjectionType.value === 1 ) { type = 1; } let nearClippingPlane = 1; if ( cameraAttribute.NearPlane !== undefined ) { nearClippingPlane = cameraAttribute.NearPlane.value / 1000; } let farClippingPlane = 1000; if ( cameraAttribute.FarPlane !== undefined ) { farClippingPlane = cameraAttribute.FarPlane.value / 1000; } let width = window.innerWidth; let height = window.innerHeight; if ( cameraAttribute.AspectWidth !== undefined && cameraAttribute.AspectHeight !== undefined ) { width = cameraAttribute.AspectWidth.value; height = cameraAttribute.AspectHeight.value; } const aspect = width / height; let fov = 45; if ( cameraAttribute.FieldOfView !== undefined ) { fov = cameraAttribute.FieldOfView.value; } const focalLength = cameraAttribute.FocalLength ? cameraAttribute.FocalLength.value : null; switch ( type ) { case 0: // Perspective model = new PerspectiveCamera( fov, aspect, nearClippingPlane, farClippingPlane ); if ( focalLength !== null ) model.setFocalLength( focalLength ); break; case 1: // Orthographic model = new OrthographicCamera( - width / 2, width / 2, height / 2, - height / 2, nearClippingPlane, farClippingPlane ); break; default: console.warn( 'THREE.FBXLoader: Unknown camera type ' + type + '.' ); model = new Object3D(); break; } } return model; } // Create a DirectionalLight, PointLight or SpotLight createLight( relationships ) { let model; let lightAttribute; relationships.children.forEach( function ( child ) { const attr = fbxTree.Objects.NodeAttribute[ child.ID ]; if ( attr !== undefined ) { lightAttribute = attr; } } ); if ( lightAttribute === undefined ) { model = new Object3D(); } else { let type; // LightType can be undefined for Point lights if ( lightAttribute.LightType === undefined ) { type = 0; } else { type = lightAttribute.LightType.value; } let color = 0xffffff; if ( lightAttribute.Color !== undefined ) { color = new Color().fromArray( lightAttribute.Color.value ).convertSRGBToLinear(); } let intensity = ( lightAttribute.Intensity === undefined ) ? 1 : lightAttribute.Intensity.value / 100; // light disabled if ( lightAttribute.CastLightOnObject !== undefined && lightAttribute.CastLightOnObject.value === 0 ) { intensity = 0; } let distance = 0; if ( lightAttribute.FarAttenuationEnd !== undefined ) { if ( lightAttribute.EnableFarAttenuation !== undefined && lightAttribute.EnableFarAttenuation.value === 0 ) { distance = 0; } else { distance = lightAttribute.FarAttenuationEnd.value; } } // TODO: could this be calculated linearly from FarAttenuationStart to FarAttenuationEnd? const decay = 1; switch ( type ) { case 0: // Point model = new PointLight( color, intensity, distance, decay ); break; case 1: // Directional model = new DirectionalLight( color, intensity ); break; case 2: // Spot let angle = Math.PI / 3; if ( lightAttribute.InnerAngle !== undefined ) { angle = MathUtils.degToRad( lightAttribute.InnerAngle.value ); } let penumbra = 0; if ( lightAttribute.OuterAngle !== undefined ) { // TODO: this is not correct - FBX calculates outer and inner angle in degrees // with OuterAngle > InnerAngle && OuterAngle 1 ) { material = materials; } else if ( materials.length > 0 ) { material = materials[ 0 ]; } else { material = new MeshPhongMaterial( { name: Loader.DEFAULT_MATERIAL_NAME, color: 0xcccccc } ); materials.push( material ); } if ( 'color' in geometry.attributes ) { materials.forEach( function ( material ) { material.vertexColors = true; } ); } if ( geometry.FBX_Deformer ) { model = new SkinnedMesh( geometry, material ); model.normalizeSkinWeights(); } else { model = new Mesh( geometry, material ); } return model; } createCurve( relationships, geometryMap ) { const geometry = relationships.children.reduce( function ( geo, child ) { if ( geometryMap.has( child.ID ) ) geo = geometryMap.get( child.ID ); return geo; }, null ); // FBX does not list materials for Nurbs lines, so we'll just put our own in here. const material = new LineBasicMaterial( { name: Loader.DEFAULT_MATERIAL_NAME, color: 0x3300ff, linewidth: 1 } ); return new Line( geometry, material ); } // parse the model node for transform data getTransformData( model, modelNode ) { const transformData = {}; if ( 'InheritType' in modelNode ) transformData.inheritType = parseInt( modelNode.InheritType.value ); if ( 'RotationOrder' in modelNode ) transformData.eulerOrder = getEulerOrder( modelNode.RotationOrder.value ); else transformData.eulerOrder = 'ZYX'; if ( 'Lcl_Translation' in modelNode ) transformData.translation = modelNode.Lcl_Translation.value; if ( 'PreRotation' in modelNode ) transformData.preRotation = modelNode.PreRotation.value; if ( 'Lcl_Rotation' in modelNode ) transformData.rotation = modelNode.Lcl_Rotation.value; if ( 'PostRotation' in modelNode ) transformData.postRotation = modelNode.PostRotation.value; if ( 'Lcl_Scaling' in modelNode ) transformData.scale = modelNode.Lcl_Scaling.value; if ( 'ScalingOffset' in modelNode ) transformData.scalingOffset = modelNode.ScalingOffset.value; if ( 'ScalingPivot' in modelNode ) transformData.scalingPivot = modelNode.ScalingPivot.value; if ( 'RotationOffset' in modelNode ) transformData.rotationOffset = modelNode.RotationOffset.value; if ( 'RotationPivot' in modelNode ) transformData.rotationPivot = modelNode.RotationPivot.value; model.userData.transformData = transformData; } setLookAtProperties( model, modelNode ) { if ( 'LookAtProperty' in modelNode ) { const children = connections.get( model.ID ).children; children.forEach( function ( child ) { if ( child.relationship === 'LookAtProperty' ) { const lookAtTarget = fbxTree.Objects.Model[ child.ID ]; if ( 'Lcl_Translation' in lookAtTarget ) { const pos = lookAtTarget.Lcl_Translation.value; // DirectionalLight, SpotLight if ( model.target !== undefined ) { model.target.position.fromArray( pos ); sceneGraph.add( model.target ); } else { // Cameras and other Object3Ds model.lookAt( new Vector3().fromArray( pos ) ); } } } } ); } } bindSkeleton( skeletons, geometryMap, modelMap ) { const bindMatrices = this.parsePoseNodes(); for ( const ID in skeletons ) { const skeleton = skeletons[ ID ]; const parents = connections.get( parseInt( skeleton.ID ) ).parents; parents.forEach( function ( parent ) { if ( geometryMap.has( parent.ID ) ) { const geoID = parent.ID; const geoRelationships = connections.get( geoID ); geoRelationships.parents.forEach( function ( geoConnParent ) { if ( modelMap.has( geoConnParent.ID ) ) { const model = modelMap.get( geoConnParent.ID ); model.bind( new Skeleton( skeleton.bones ), bindMatrices[ geoConnParent.ID ] ); } } ); } } ); } } parsePoseNodes() { const bindMatrices = {}; if ( 'Pose' in fbxTree.Objects ) { const BindPoseNode = fbxTree.Objects.Pose; for ( const nodeID in BindPoseNode ) { if ( BindPoseNode[ nodeID ].attrType === 'BindPose' && BindPoseNode[ nodeID ].NbPoseNodes > 0 ) { const poseNodes = BindPoseNode[ nodeID ].PoseNode; if ( Array.isArray( poseNodes ) ) { poseNodes.forEach( function ( poseNode ) { bindMatrices[ poseNode.Node ] = new Matrix4().fromArray( poseNode.Matrix.a ); } ); } else { bindMatrices[ poseNodes.Node ] = new Matrix4().fromArray( poseNodes.Matrix.a ); } } } } return bindMatrices; } // Parse ambient color in FBXTree.GlobalSettings - if it's not set to black (default), create an ambient light createAmbientLight() { if ( 'GlobalSettings' in fbxTree && 'AmbientColor' in fbxTree.GlobalSettings ) { const ambientColor = fbxTree.GlobalSettings.AmbientColor.value; const r = ambientColor[ 0 ]; const g = ambientColor[ 1 ]; const b = ambientColor[ 2 ]; if ( r !== 0 || g !== 0 || b !== 0 ) { const color = new Color( r, g, b ).convertSRGBToLinear(); sceneGraph.add( new AmbientLight( color, 1 ) ); } } } } // parse Geometry data from FBXTree and return map of BufferGeometries class GeometryParser { constructor() { this.negativeMaterialIndices = false; } // Parse nodes in FBXTree.Objects.Geometry parse( deformers ) { const geometryMap = new Map(); if ( 'Geometry' in fbxTree.Objects ) { const geoNodes = fbxTree.Objects.Geometry; for ( const nodeID in geoNodes ) { const relationships = connections.get( parseInt( nodeID ) ); const geo = this.parseGeometry( relationships, geoNodes[ nodeID ], deformers ); geometryMap.set( parseInt( nodeID ), geo ); } } // report warnings if ( this.negativeMaterialIndices === true ) { console.warn( 'THREE.FBXLoader: The FBX file contains invalid (negative) material indices. The asset might not render as expected.' ); } return geometryMap; } // Parse single node in FBXTree.Objects.Geometry parseGeometry( relationships, geoNode, deformers ) { switch ( geoNode.attrType ) { case 'Mesh': return this.parseMeshGeometry( relationships, geoNode, deformers ); break; case 'NurbsCurve': return this.parseNurbsGeometry( geoNode ); break; } } // Parse single node mesh geometry in FBXTree.Objects.Geometry parseMeshGeometry( relationships, geoNode, deformers ) { const skeletons = deformers.skeletons; const morphTargets = []; const modelNodes = relationships.parents.map( function ( parent ) { return fbxTree.Objects.Model[ parent.ID ]; } ); // don't create geometry if it is not associated with any models if ( modelNodes.length === 0 ) return; const skeleton = relationships.children.reduce( function ( skeleton, child ) { if ( skeletons[ child.ID ] !== undefined ) skeleton = skeletons[ child.ID ]; return skeleton; }, null ); relationships.children.forEach( function ( child ) { if ( deformers.morphTargets[ child.ID ] !== undefined ) { morphTargets.push( deformers.morphTargets[ child.ID ] ); } } ); // Assume one model and get the preRotation from that // if there is more than one model associated with the geometry this may cause problems const modelNode = modelNodes[ 0 ]; const transformData = {}; if ( 'RotationOrder' in modelNode ) transformData.eulerOrder = getEulerOrder( modelNode.RotationOrder.value ); if ( 'InheritType' in modelNode ) transformData.inheritType = parseInt( modelNode.InheritType.value ); if ( 'GeometricTranslation' in modelNode ) transformData.translation = modelNode.GeometricTranslation.value; if ( 'GeometricRotation' in modelNode ) transformData.rotation = modelNode.GeometricRotation.value; if ( 'GeometricScaling' in modelNode ) transformData.scale = modelNode.GeometricScaling.value; const transform = generateTransform( transformData ); return this.genGeometry( geoNode, skeleton, morphTargets, transform ); } // Generate a BufferGeometry from a node in FBXTree.Objects.Geometry genGeometry( geoNode, skeleton, morphTargets, preTransform ) { const geo = new BufferGeometry(); if ( geoNode.attrName ) geo.name = geoNode.attrName; const geoInfo = this.parseGeoNode( geoNode, skeleton ); const buffers = this.genBuffers( geoInfo ); const positionAttribute = new Float32BufferAttribute( buffers.vertex, 3 ); positionAttribute.applyMatrix4( preTransform ); geo.setAttribute( 'position', positionAttribute ); if ( buffers.colors.length > 0 ) { geo.setAttribute( 'color', new Float32BufferAttribute( buffers.colors, 3 ) ); } if ( skeleton ) { geo.setAttribute( 'skinIndex', new Uint16BufferAttribute( buffers.weightsIndices, 4 ) ); geo.setAttribute( 'skinWeight', new Float32BufferAttribute( buffers.vertexWeights, 4 ) ); // used later to bind the skeleton to the model geo.FBX_Deformer = skeleton; } if ( buffers.normal.length > 0 ) { const normalMatrix = new Matrix3().getNormalMatrix( preTransform ); const normalAttribute = new Float32BufferAttribute( buffers.normal, 3 ); normalAttribute.applyNormalMatrix( normalMatrix ); geo.setAttribute( 'normal', normalAttribute ); } buffers.uvs.forEach( function ( uvBuffer, i ) { const name = i === 0 ? 'uv' : `uv${ i }`; geo.setAttribute( name, new Float32BufferAttribute( buffers.uvs[ i ], 2 ) ); } ); if ( geoInfo.material && geoInfo.material.mappingType !== 'AllSame' ) { // Convert the material indices of each vertex into rendering groups on the geometry. let prevMaterialIndex = buffers.materialIndex[ 0 ]; let startIndex = 0; buffers.materialIndex.forEach( function ( currentIndex, i ) { if ( currentIndex !== prevMaterialIndex ) { geo.addGroup( startIndex, i - startIndex, prevMaterialIndex ); prevMaterialIndex = currentIndex; startIndex = i; } } ); // the loop above doesn't add the last group, do that here. if ( geo.groups.length > 0 ) { const lastGroup = geo.groups[ geo.groups.length - 1 ]; const lastIndex = lastGroup.start + lastGroup.count; if ( lastIndex !== buffers.materialIndex.length ) { geo.addGroup( lastIndex, buffers.materialIndex.length - lastIndex, prevMaterialIndex ); } } // case where there are multiple materials but the whole geometry is only // using one of them if ( geo.groups.length === 0 ) { geo.addGroup( 0, buffers.materialIndex.length, buffers.materialIndex[ 0 ] ); } } this.addMorphTargets( geo, geoNode, morphTargets, preTransform ); return geo; } parseGeoNode( geoNode, skeleton ) { const geoInfo = {}; geoInfo.vertexPositions = ( geoNode.Vertices !== undefined ) ? geoNode.Vertices.a : []; geoInfo.vertexIndices = ( geoNode.PolygonVertexIndex !== undefined ) ? geoNode.PolygonVertexIndex.a : []; if ( geoNode.LayerElementColor ) { geoInfo.color = this.parseVertexColors( geoNode.LayerElementColor[ 0 ] ); } if ( geoNode.LayerElementMaterial ) { geoInfo.material = this.parseMaterialIndices( geoNode.LayerElementMaterial[ 0 ] ); } if ( geoNode.LayerElementNormal ) { geoInfo.normal = this.parseNormals( geoNode.LayerElementNormal[ 0 ] ); } if ( geoNode.LayerElementUV ) { geoInfo.uv = []; let i = 0; while ( geoNode.LayerElementUV[ i ] ) { if ( geoNode.LayerElementUV[ i ].UV ) { geoInfo.uv.push( this.parseUVs( geoNode.LayerElementUV[ i ] ) ); } i ++; } } geoInfo.weightTable = {}; if ( skeleton !== null ) { geoInfo.skeleton = skeleton; skeleton.rawBones.forEach( function ( rawBone, i ) { // loop over the bone's vertex indices and weights rawBone.indices.forEach( function ( index, j ) { if ( geoInfo.weightTable[ index ] === undefined ) geoInfo.weightTable[ index ] = []; geoInfo.weightTable[ index ].push( { id: i, weight: rawBone.weights[ j ], } ); } ); } ); } return geoInfo; } genBuffers( geoInfo ) { const buffers = { vertex: [], normal: [], colors: [], uvs: [], materialIndex: [], vertexWeights: [], weightsIndices: [], }; let polygonIndex = 0; let faceLength = 0; let displayedWeightsWarning = false; // these will hold data for a single face let facePositionIndexes = []; let faceNormals = []; let faceColors = []; let faceUVs = []; let faceWeights = []; let faceWeightIndices = []; const scope = this; geoInfo.vertexIndices.forEach( function ( vertexIndex, polygonVertexIndex ) { let materialIndex; let endOfFace = false; // Face index and vertex index arrays are combined in a single array // A cube with quad faces looks like this: // PolygonVertexIndex: *24 { // a: 0, 1, 3, -3, 2, 3, 5, -5, 4, 5, 7, -7, 6, 7, 1, -1, 1, 7, 5, -4, 6, 0, 2, -5 // } // Negative numbers mark the end of a face - first face here is 0, 1, 3, -3 // to find index of last vertex bit shift the index: ^ - 1 if ( vertexIndex < 0 ) { vertexIndex = vertexIndex ^ - 1; // equivalent to ( x * -1 ) - 1 endOfFace = true; } let weightIndices = []; let weights = []; facePositionIndexes.push( vertexIndex * 3, vertexIndex * 3 + 1, vertexIndex * 3 + 2 ); if ( geoInfo.color ) { const data = getData( polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.color ); faceColors.push( data[ 0 ], data[ 1 ], data[ 2 ] ); } if ( geoInfo.skeleton ) { if ( geoInfo.weightTable[ vertexIndex ] !== undefined ) { geoInfo.weightTable[ vertexIndex ].forEach( function ( wt ) { weights.push( wt.weight ); weightIndices.push( wt.id ); } ); } if ( weights.length > 4 ) { if ( ! displayedWeightsWarning ) { console.warn( 'THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights.' ); displayedWeightsWarning = true; } const wIndex = [ 0, 0, 0, 0 ]; const Weight = [ 0, 0, 0, 0 ]; weights.forEach( function ( weight, weightIndex ) { let currentWeight = weight; let currentIndex = weightIndices[ weightIndex ]; Weight.forEach( function ( comparedWeight, comparedWeightIndex, comparedWeightArray ) { if ( currentWeight > comparedWeight ) { comparedWeightArray[ comparedWeightIndex ] = currentWeight; currentWeight = comparedWeight; const tmp = wIndex[ comparedWeightIndex ]; wIndex[ comparedWeightIndex ] = currentIndex; currentIndex = tmp; } } ); } ); weightIndices = wIndex; weights = Weight; } // if the weight array is shorter than 4 pad with 0s while ( weights.length < 4 ) { weights.push( 0 ); weightIndices.push( 0 ); } for ( let i = 0; i < 4; ++ i ) { faceWeights.push( weights[ i ] ); faceWeightIndices.push( weightIndices[ i ] ); } } if ( geoInfo.normal ) { const data = getData( polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.normal ); faceNormals.push( data[ 0 ], data[ 1 ], data[ 2 ] ); } if ( geoInfo.material && geoInfo.material.mappingType !== 'AllSame' ) { materialIndex = getData( polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.material )[ 0 ]; if ( materialIndex < 0 ) { scope.negativeMaterialIndices = true; materialIndex = 0; // fallback } } if ( geoInfo.uv ) { geoInfo.uv.forEach( function ( uv, i ) { const data = getData( polygonVertexIndex, polygonIndex, vertexIndex, uv ); if ( faceUVs[ i ] === undefined ) { faceUVs[ i ] = []; } faceUVs[ i ].push( data[ 0 ] ); faceUVs[ i ].push( data[ 1 ] ); } ); } faceLength ++; if ( endOfFace ) { if ( faceLength > 4 ) console.warn( 'THREE.FBXLoader: Polygons with more than four sides are not supported. Make sure to triangulate the geometry during export.' ); scope.genFace( buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength ); polygonIndex ++; faceLength = 0; // reset arrays for the next face facePositionIndexes = []; faceNormals = []; faceColors = []; faceUVs = []; faceWeights = []; faceWeightIndices = []; } } ); return buffers; } // Generate data for a single face in a geometry. If the face is a quad then split it into 2 tris genFace( buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength ) { for ( let i = 2; i < faceLength; i ++ ) { buffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ 0 ] ] ); buffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ 1 ] ] ); buffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ 2 ] ] ); buffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ ( i - 1 ) * 3 ] ] ); buffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ ( i - 1 ) * 3 + 1 ] ] ); buffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ ( i - 1 ) * 3 + 2 ] ] ); buffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i * 3 ] ] ); buffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i * 3 + 1 ] ] ); buffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i * 3 + 2 ] ] ); if ( geoInfo.skeleton ) { buffers.vertexWeights.push( faceWeights[ 0 ] ); buffers.vertexWeights.push( faceWeights[ 1 ] ); buffers.vertexWeights.push( faceWeights[ 2 ] ); buffers.vertexWeights.push( faceWeights[ 3 ] ); buffers.vertexWeights.push( faceWeights[ ( i - 1 ) * 4 ] ); buffers.vertexWeights.push( faceWeights[ ( i - 1 ) * 4 + 1 ] ); buffers.vertexWeights.push( faceWeights[ ( i - 1 ) * 4 + 2 ] ); buffers.vertexWeights.push( faceWeights[ ( i - 1 ) * 4 + 3 ] ); buffers.vertexWeights.push( faceWeights[ i * 4 ] ); buffers.vertexWeights.push( faceWeights[ i * 4 + 1 ] ); buffers.vertexWeights.push( faceWeights[ i * 4 + 2 ] ); buffers.vertexWeights.push( faceWeights[ i * 4 + 3 ] ); buffers.weightsIndices.push( faceWeightIndices[ 0 ] ); buffers.weightsIndices.push( faceWeightIndices[ 1 ] ); buffers.weightsIndices.push( faceWeightIndices[ 2 ] ); buffers.weightsIndices.push( faceWeightIndices[ 3 ] ); buffers.weightsIndices.push( faceWeightIndices[ ( i - 1 ) * 4 ] ); buffers.weightsIndices.push( faceWeightIndices[ ( i - 1 ) * 4 + 1 ] ); buffers.weightsIndices.push( faceWeightIndices[ ( i - 1 ) * 4 + 2 ] ); buffers.weightsIndices.push( faceWeightIndices[ ( i - 1 ) * 4 + 3 ] ); buffers.weightsIndices.push( faceWeightIndices[ i * 4 ] ); buffers.weightsIndices.push( faceWeightIndices[ i * 4 + 1 ] ); buffers.weightsIndices.push( faceWeightIndices[ i * 4 + 2 ] ); buffers.weightsIndices.push( faceWeightIndices[ i * 4 + 3 ] ); } if ( geoInfo.color ) { buffers.colors.push( faceColors[ 0 ] ); buffers.colors.push( faceColors[ 1 ] ); buffers.colors.push( faceColors[ 2 ] ); buffers.colors.push( faceColors[ ( i - 1 ) * 3 ] ); buffers.colors.push( faceColors[ ( i - 1 ) * 3 + 1 ] ); buffers.colors.push( faceColors[ ( i - 1 ) * 3 + 2 ] ); buffers.colors.push( faceColors[ i * 3 ] ); buffers.colors.push( faceColors[ i * 3 + 1 ] ); buffers.colors.push( faceColors[ i * 3 + 2 ] ); } if ( geoInfo.material && geoInfo.material.mappingType !== 'AllSame' ) { buffers.materialIndex.push( materialIndex ); buffers.materialIndex.push( materialIndex ); buffers.materialIndex.push( materialIndex ); } if ( geoInfo.normal ) { buffers.normal.push( faceNormals[ 0 ] ); buffers.normal.push( faceNormals[ 1 ] ); buffers.normal.push( faceNormals[ 2 ] ); buffers.normal.push( faceNormals[ ( i - 1 ) * 3 ] ); buffers.normal.push( faceNormals[ ( i - 1 ) * 3 + 1 ] ); buffers.normal.push( faceNormals[ ( i - 1 ) * 3 + 2 ] ); buffers.normal.push( faceNormals[ i * 3 ] ); buffers.normal.push( faceNormals[ i * 3 + 1 ] ); buffers.normal.push( faceNormals[ i * 3 + 2 ] ); } if ( geoInfo.uv ) { geoInfo.uv.forEach( function ( uv, j ) { if ( buffers.uvs[ j ] === undefined ) buffers.uvs[ j ] = []; buffers.uvs[ j ].push( faceUVs[ j ][ 0 ] ); buffers.uvs[ j ].push( faceUVs[ j ][ 1 ] ); buffers.uvs[ j ].push( faceUVs[ j ][ ( i - 1 ) * 2 ] ); buffers.uvs[ j ].push( faceUVs[ j ][ ( i - 1 ) * 2 + 1 ] ); buffers.uvs[ j ].push( faceUVs[ j ][ i * 2 ] ); buffers.uvs[ j ].push( faceUVs[ j ][ i * 2 + 1 ] ); } ); } } } addMorphTargets( parentGeo, parentGeoNode, morphTargets, preTransform ) { if ( morphTargets.length === 0 ) return; parentGeo.morphTargetsRelative = true; parentGeo.morphAttributes.position = []; // parentGeo.morphAttributes.normal = []; // not implemented const scope = this; morphTargets.forEach( function ( morphTarget ) { morphTarget.rawTargets.forEach( function ( rawTarget ) { const morphGeoNode = fbxTree.Objects.Geometry[ rawTarget.geoID ]; if ( morphGeoNode !== undefined ) { scope.genMorphGeometry( parentGeo, parentGeoNode, morphGeoNode, preTransform, rawTarget.name ); } } ); } ); } // a morph geometry node is similar to a standard node, and the node is also contained // in FBXTree.Objects.Geometry, however it can only have attributes for position, normal // and a special attribute Index defining which vertices of the original geometry are affected // Normal and position attributes only have data for the vertices that are affected by the morph genMorphGeometry( parentGeo, parentGeoNode, morphGeoNode, preTransform, name ) { const vertexIndices = ( parentGeoNode.PolygonVertexIndex !== undefined ) ? parentGeoNode.PolygonVertexIndex.a : []; const morphPositionsSparse = ( morphGeoNode.Vertices !== undefined ) ? morphGeoNode.Vertices.a : []; const indices = ( morphGeoNode.Indexes !== undefined ) ? morphGeoNode.Indexes.a : []; const length = parentGeo.attributes.position.count * 3; const morphPositions = new Float32Array( length ); for ( let i = 0; i < indices.length; i ++ ) { const morphIndex = indices[ i ] * 3; morphPositions[ morphIndex ] = morphPositionsSparse[ i * 3 ]; morphPositions[ morphIndex + 1 ] = morphPositionsSparse[ i * 3 + 1 ]; morphPositions[ morphIndex + 2 ] = morphPositionsSparse[ i * 3 + 2 ]; } // TODO: add morph normal support const morphGeoInfo = { vertexIndices: vertexIndices, vertexPositions: morphPositions, }; const morphBuffers = this.genBuffers( morphGeoInfo ); const positionAttribute = new Float32BufferAttribute( morphBuffers.vertex, 3 ); positionAttribute.name = name || morphGeoNode.attrName; positionAttribute.applyMatrix4( preTransform ); parentGeo.morphAttributes.position.push( positionAttribute ); } // Parse normal from FBXTree.Objects.Geometry.LayerElementNormal if it exists parseNormals( NormalNode ) { const mappingType = NormalNode.MappingInformationType; const referenceType = NormalNode.ReferenceInformationType; const buffer = NormalNode.Normals.a; let indexBuffer = []; if ( referenceType === 'IndexToDirect' ) { if ( 'NormalIndex' in NormalNode ) { indexBuffer = NormalNode.NormalIndex.a; } else if ( 'NormalsIndex' in NormalNode ) { indexBuffer = NormalNode.NormalsIndex.a; } } return { dataSize: 3, buffer: buffer, indices: indexBuffer, mappingType: mappingType, referenceType: referenceType }; } // Parse UVs from FBXTree.Objects.Geometry.LayerElementUV if it exists parseUVs( UVNode ) { const mappingType = UVNode.MappingInformationType; const referenceType = UVNode.ReferenceInformationType; const buffer = UVNode.UV.a; let indexBuffer = []; if ( referenceType === 'IndexToDirect' ) { indexBuffer = UVNode.UVIndex.a; } return { dataSize: 2, buffer: buffer, indices: indexBuffer, mappingType: mappingType, referenceType: referenceType }; } // Parse Vertex Colors from FBXTree.Objects.Geometry.LayerElementColor if it exists parseVertexColors( ColorNode ) { const mappingType = ColorNode.MappingInformationType; const referenceType = ColorNode.ReferenceInformationType; const buffer = ColorNode.Colors.a; let indexBuffer = []; if ( referenceType === 'IndexToDirect' ) { indexBuffer = ColorNode.ColorIndex.a; } for ( let i = 0, c = new Color(); i < buffer.length; i += 4 ) { c.fromArray( buffer, i ).convertSRGBToLinear().toArray( buffer, i ); } return { dataSize: 4, buffer: buffer, indices: indexBuffer, mappingType: mappingType, referenceType: referenceType }; } // Parse mapping and material data in FBXTree.Objects.Geometry.LayerElementMaterial if it exists parseMaterialIndices( MaterialNode ) { const mappingType = MaterialNode.MappingInformationType; const referenceType = MaterialNode.ReferenceInformationType; if ( mappingType === 'NoMappingInformation' ) { return { dataSize: 1, buffer: [ 0 ], indices: [ 0 ], mappingType: 'AllSame', referenceType: referenceType }; } const materialIndexBuffer = MaterialNode.Materials.a; // Since materials are stored as indices, there's a bit of a mismatch between FBX and what // we expect.So we create an intermediate buffer that points to the index in the buffer, // for conforming with the other functions we've written for other data. const materialIndices = []; for ( let i = 0; i < materialIndexBuffer.length; ++ i ) { materialIndices.push( i ); } return { dataSize: 1, buffer: materialIndexBuffer, indices: materialIndices, mappingType: mappingType, referenceType: referenceType }; } // Generate a NurbGeometry from a node in FBXTree.Objects.Geometry parseNurbsGeometry( geoNode ) { const order = parseInt( geoNode.Order ); if ( isNaN( order ) ) { console.error( 'THREE.FBXLoader: Invalid Order %s given for geometry ID: %s', geoNode.Order, geoNode.id ); return new BufferGeometry(); } const degree = order - 1; const knots = geoNode.KnotVector.a; const controlPoints = []; const pointsValues = geoNode.Points.a; for ( let i = 0, l = pointsValues.length; i < l; i += 4 ) { controlPoints.push( new Vector4().fromArray( pointsValues, i ) ); } let startKnot, endKnot; if ( geoNode.Form === 'Closed' ) { controlPoints.push( controlPoints[ 0 ] ); } else if ( geoNode.Form === 'Periodic' ) { startKnot = degree; endKnot = knots.length - 1 - startKnot; for ( let i = 0; i < degree; ++ i ) { controlPoints.push( controlPoints[ i ] ); } } const curve = new NURBSCurve( degree, knots, controlPoints, startKnot, endKnot ); const points = curve.getPoints( controlPoints.length * 12 ); return new BufferGeometry().setFromPoints( points ); } } // parse animation data from FBXTree class AnimationParser { // take raw animation clips and turn them into three.js animation clips parse() { const animationClips = []; const rawClips = this.parseClips(); if ( rawClips !== undefined ) { for ( const key in rawClips ) { const rawClip = rawClips[ key ]; const clip = this.addClip( rawClip ); animationClips.push( clip ); } } return animationClips; } parseClips() { // since the actual transformation data is stored in FBXTree.Objects.AnimationCurve, // if this is undefined we can safely assume there are no animations if ( fbxTree.Objects.AnimationCurve === undefined ) return undefined; const curveNodesMap = this.parseAnimationCurveNodes(); this.parseAnimationCurves( curveNodesMap ); const layersMap = this.parseAnimationLayers( curveNodesMap ); const rawClips = this.parseAnimStacks( layersMap ); return rawClips; } // parse nodes in FBXTree.Objects.AnimationCurveNode // each AnimationCurveNode holds data for an animation transform for a model (e.g. left arm rotation ) // and is referenced by an AnimationLayer parseAnimationCurveNodes() { const rawCurveNodes = fbxTree.Objects.AnimationCurveNode; const curveNodesMap = new Map(); for ( const nodeID in rawCurveNodes ) { const rawCurveNode = rawCurveNodes[ nodeID ]; if ( rawCurveNode.attrName.match( /S|R|T|DeformPercent/ ) !== null ) { const curveNode = { id: rawCurveNode.id, attr: rawCurveNode.attrName, curves: {}, }; curveNodesMap.set( curveNode.id, curveNode ); } } return curveNodesMap; } // parse nodes in FBXTree.Objects.AnimationCurve and connect them up to // previously parsed AnimationCurveNodes. Each AnimationCurve holds data for a single animated // axis ( e.g. times and values of x rotation) parseAnimationCurves( curveNodesMap ) { const rawCurves = fbxTree.Objects.AnimationCurve; // TODO: Many values are identical up to roundoff error, but won't be optimised // e.g. position times: [0, 0.4, 0. 8] // position values: [7.23538335023477e-7, 93.67518615722656, -0.9982695579528809, 7.23538335023477e-7, 93.67518615722656, -0.9982695579528809, 7.235384487103147e-7, 93.67520904541016, -0.9982695579528809] // clearly, this should be optimised to // times: [0], positions [7.23538335023477e-7, 93.67518615722656, -0.9982695579528809] // this shows up in nearly every FBX file, and generally time array is length > 100 for ( const nodeID in rawCurves ) { const animationCurve = { id: rawCurves[ nodeID ].id, times: rawCurves[ nodeID ].KeyTime.a.map( convertFBXTimeToSeconds ), values: rawCurves[ nodeID ].KeyValueFloat.a, }; const relationships = connections.get( animationCurve.id ); if ( relationships !== undefined ) { const animationCurveID = relationships.parents[ 0 ].ID; const animationCurveRelationship = relationships.parents[ 0 ].relationship; if ( animationCurveRelationship.match( /X/ ) ) { curveNodesMap.get( animationCurveID ).curves[ 'x' ] = animationCurve; } else if ( animationCurveRelationship.match( /Y/ ) ) { curveNodesMap.get( animationCurveID ).curves[ 'y' ] = animationCurve; } else if ( animationCurveRelationship.match( /Z/ ) ) { curveNodesMap.get( animationCurveID ).curves[ 'z' ] = animationCurve; } else if ( animationCurveRelationship.match( /DeformPercent/ ) && curveNodesMap.has( animationCurveID ) ) { curveNodesMap.get( animationCurveID ).curves[ 'morph' ] = animationCurve; } } } } // parse nodes in FBXTree.Objects.AnimationLayer. Each layers holds references // to various AnimationCurveNodes and is referenced by an AnimationStack node // note: theoretically a stack can have multiple layers, however in practice there always seems to be one per stack parseAnimationLayers( curveNodesMap ) { const rawLayers = fbxTree.Objects.AnimationLayer; const layersMap = new Map(); for ( const nodeID in rawLayers ) { const layerCurveNodes = []; const connection = connections.get( parseInt( nodeID ) ); if ( connection !== undefined ) { // all the animationCurveNodes used in the layer const children = connection.children; children.forEach( function ( child, i ) { if ( curveNodesMap.has( child.ID ) ) { const curveNode = curveNodesMap.get( child.ID ); // check that the curves are defined for at least one axis, otherwise ignore the curveNode if ( curveNode.curves.x !== undefined || curveNode.curves.y !== undefined || curveNode.curves.z !== undefined ) { if ( layerCurveNodes[ i ] === undefined ) { const modelID = connections.get( child.ID ).parents.filter( function ( parent ) { return parent.relationship !== undefined; } )[ 0 ].ID; if ( modelID !== undefined ) { const rawModel = fbxTree.Objects.Model[ modelID.toString() ]; if ( rawModel === undefined ) { console.warn( 'THREE.FBXLoader: Encountered a unused curve.', child ); return; } const node = { modelName: rawModel.attrName ? PropertyBinding.sanitizeNodeName( rawModel.attrName ) : '', ID: rawModel.id, initialPosition: [ 0, 0, 0 ], initialRotation: [ 0, 0, 0 ], initialScale: [ 1, 1, 1 ], }; sceneGraph.traverse( function ( child ) { if ( child.ID === rawModel.id ) { node.transform = child.matrix; if ( child.userData.transformData ) node.eulerOrder = child.userData.transformData.eulerOrder; } } ); if ( ! node.transform ) node.transform = new Matrix4(); // if the animated model is pre rotated, we'll have to apply the pre rotations to every // animation value as well if ( 'PreRotation' in rawModel ) node.preRotation = rawModel.PreRotation.value; if ( 'PostRotation' in rawModel ) node.postRotation = rawModel.PostRotation.value; layerCurveNodes[ i ] = node; } } if ( layerCurveNodes[ i ] ) layerCurveNodes[ i ][ curveNode.attr ] = curveNode; } else if ( curveNode.curves.morph !== undefined ) { if ( layerCurveNodes[ i ] === undefined ) { const deformerID = connections.get( child.ID ).parents.filter( function ( parent ) { return parent.relationship !== undefined; } )[ 0 ].ID; const morpherID = connections.get( deformerID ).parents[ 0 ].ID; const geoID = connections.get( morpherID ).parents[ 0 ].ID; // assuming geometry is not used in more than one model const modelID = connections.get( geoID ).parents[ 0 ].ID; const rawModel = fbxTree.Objects.Model[ modelID ]; const node = { modelName: rawModel.attrName ? PropertyBinding.sanitizeNodeName( rawModel.attrName ) : '', morphName: fbxTree.Objects.Deformer[ deformerID ].attrName, }; layerCurveNodes[ i ] = node; } layerCurveNodes[ i ][ curveNode.attr ] = curveNode; } } } ); layersMap.set( parseInt( nodeID ), layerCurveNodes ); } } return layersMap; } // parse nodes in FBXTree.Objects.AnimationStack. These are the top level node in the animation // hierarchy. Each Stack node will be used to create a AnimationClip parseAnimStacks( layersMap ) { const rawStacks = fbxTree.Objects.AnimationStack; // connect the stacks (clips) up to the layers const rawClips = {}; for ( const nodeID in rawStacks ) { const children = connections.get( parseInt( nodeID ) ).children; if ( children.length > 1 ) { // it seems like stacks will always be associated with a single layer. But just in case there are files // where there are multiple layers per stack, we'll display a warning console.warn( 'THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.' ); } const layer = layersMap.get( children[ 0 ].ID ); rawClips[ nodeID ] = { name: rawStacks[ nodeID ].attrName, layer: layer, }; } return rawClips; } addClip( rawClip ) { let tracks = []; const scope = this; rawClip.layer.forEach( function ( rawTracks ) { tracks = tracks.concat( scope.generateTracks( rawTracks ) ); } ); return new AnimationClip( rawClip.name, - 1, tracks ); } generateTracks( rawTracks ) { const tracks = []; let initialPosition = new Vector3(); let initialRotation = new Quaternion(); let initialScale = new Vector3(); if ( rawTracks.transform ) rawTracks.transform.decompose( initialPosition, initialRotation, initialScale ); initialPosition = initialPosition.toArray(); initialRotation = new Euler().setFromQuaternion( initialRotation, rawTracks.eulerOrder ).toArray(); initialScale = initialScale.toArray(); if ( rawTracks.T !== undefined && Object.keys( rawTracks.T.curves ).length > 0 ) { const positionTrack = this.generateVectorTrack( rawTracks.modelName, rawTracks.T.curves, initialPosition, 'position' ); if ( positionTrack !== undefined ) tracks.push( positionTrack ); } if ( rawTracks.R !== undefined && Object.keys( rawTracks.R.curves ).length > 0 ) { const rotationTrack = this.generateRotationTrack( rawTracks.modelName, rawTracks.R.curves, initialRotation, rawTracks.preRotation, rawTracks.postRotation, rawTracks.eulerOrder ); if ( rotationTrack !== undefined ) tracks.push( rotationTrack ); } if ( rawTracks.S !== undefined && Object.keys( rawTracks.S.curves ).length > 0 ) { const scaleTrack = this.generateVectorTrack( rawTracks.modelName, rawTracks.S.curves, initialScale, 'scale' ); if ( scaleTrack !== undefined ) tracks.push( scaleTrack ); } if ( rawTracks.DeformPercent !== undefined ) { const morphTrack = this.generateMorphTrack( rawTracks ); if ( morphTrack !== undefined ) tracks.push( morphTrack ); } return tracks; } generateVectorTrack( modelName, curves, initialValue, type ) { const times = this.getTimesForAllAxes( curves ); const values = this.getKeyframeTrackValues( times, curves, initialValue ); return new VectorKeyframeTrack( modelName + '.' + type, times, values ); } generateRotationTrack( modelName, curves, initialValue, preRotation, postRotation, eulerOrder ) { if ( curves.x !== undefined ) { this.interpolateRotations( curves.x ); curves.x.values = curves.x.values.map( MathUtils.degToRad ); } if ( curves.y !== undefined ) { this.interpolateRotations( curves.y ); curves.y.values = curves.y.values.map( MathUtils.degToRad ); } if ( curves.z !== undefined ) { this.interpolateRotations( curves.z ); curves.z.values = curves.z.values.map( MathUtils.degToRad ); } const times = this.getTimesForAllAxes( curves ); const values = this.getKeyframeTrackValues( times, curves, initialValue ); if ( preRotation !== undefined ) { preRotation = preRotation.map( MathUtils.degToRad ); preRotation.push( eulerOrder ); preRotation = new Euler().fromArray( preRotation ); preRotation = new Quaternion().setFromEuler( preRotation ); } if ( postRotation !== undefined ) { postRotation = postRotation.map( MathUtils.degToRad ); postRotation.push( eulerOrder ); postRotation = new Euler().fromArray( postRotation ); postRotation = new Quaternion().setFromEuler( postRotation ).invert(); } const quaternion = new Quaternion(); const euler = new Euler(); const quaternionValues = []; for ( let i = 0; i < values.length; i += 3 ) { euler.set( values[ i ], values[ i + 1 ], values[ i + 2 ], eulerOrder ); quaternion.setFromEuler( euler ); if ( preRotation !== undefined ) quaternion.premultiply( preRotation ); if ( postRotation !== undefined ) quaternion.multiply( postRotation ); quaternion.toArray( quaternionValues, ( i / 3 ) * 4 ); } return new QuaternionKeyframeTrack( modelName + '.quaternion', times, quaternionValues ); } generateMorphTrack( rawTracks ) { const curves = rawTracks.DeformPercent.curves.morph; const values = curves.values.map( function ( val ) { return val / 100; } ); const morphNum = sceneGraph.getObjectByName( rawTracks.modelName ).morphTargetDictionary[ rawTracks.morphName ]; return new NumberKeyframeTrack( rawTracks.modelName + '.morphTargetInfluences[' + morphNum + ']', curves.times, values ); } // For all animated objects, times are defined separately for each axis // Here we'll combine the times into one sorted array without duplicates getTimesForAllAxes( curves ) { let times = []; // first join together the times for each axis, if defined if ( curves.x !== undefined ) times = times.concat( curves.x.times ); if ( curves.y !== undefined ) times = times.concat( curves.y.times ); if ( curves.z !== undefined ) times = times.concat( curves.z.times ); // then sort them times = times.sort( function ( a, b ) { return a - b; } ); // and remove duplicates if ( times.length > 1 ) { let targetIndex = 1; let lastValue = times[ 0 ]; for ( let i = 1; i < times.length; i ++ ) { const currentValue = times[ i ]; if ( currentValue !== lastValue ) { times[ targetIndex ] = currentValue; lastValue = currentValue; targetIndex ++; } } times = times.slice( 0, targetIndex ); } return times; } getKeyframeTrackValues( times, curves, initialValue ) { const prevValue = initialValue; const values = []; let xIndex = - 1; let yIndex = - 1; let zIndex = - 1; times.forEach( function ( time ) { if ( curves.x ) xIndex = curves.x.times.indexOf( time ); if ( curves.y ) yIndex = curves.y.times.indexOf( time ); if ( curves.z ) zIndex = curves.z.times.indexOf( time ); // if there is an x value defined for this frame, use that if ( xIndex !== - 1 ) { const xValue = curves.x.values[ xIndex ]; values.push( xValue ); prevValue[ 0 ] = xValue; } else { // otherwise use the x value from the previous frame values.push( prevValue[ 0 ] ); } if ( yIndex !== - 1 ) { const yValue = curves.y.values[ yIndex ]; values.push( yValue ); prevValue[ 1 ] = yValue; } else { values.push( prevValue[ 1 ] ); } if ( zIndex !== - 1 ) { const zValue = curves.z.values[ zIndex ]; values.push( zValue ); prevValue[ 2 ] = zValue; } else { values.push( prevValue[ 2 ] ); } } ); return values; } // Rotations are defined as Euler angles which can have values of any size // These will be converted to quaternions which don't support values greater than // PI, so we'll interpolate large rotations interpolateRotations( curve ) { for ( let i = 1; i < curve.values.length; i ++ ) { const initialValue = curve.values[ i - 1 ]; const valuesSpan = curve.values[ i ] - initialValue; const absoluteSpan = Math.abs( valuesSpan ); if ( absoluteSpan >= 180 ) { const numSubIntervals = absoluteSpan / 180; const step = valuesSpan / numSubIntervals; let nextValue = initialValue + step; const initialTime = curve.times[ i - 1 ]; const timeSpan = curve.times[ i ] - initialTime; const interval = timeSpan / numSubIntervals; let nextTime = initialTime + interval; const interpolatedTimes = []; const interpolatedValues = []; while ( nextTime < curve.times[ i ] ) { interpolatedTimes.push( nextTime ); nextTime += interval; interpolatedValues.push( nextValue ); nextValue += step; } curve.times = inject( curve.times, i, interpolatedTimes ); curve.values = inject( curve.values, i, interpolatedValues ); } } } } // parse an FBX file in ASCII format class TextParser { getPrevNode() { return this.nodeStack[ this.currentIndent - 2 ]; } getCurrentNode() { return this.nodeStack[ this.currentIndent - 1 ]; } getCurrentProp() { return this.currentProp; } pushStack( node ) { this.nodeStack.push( node ); this.currentIndent += 1; } popStack() { this.nodeStack.pop(); this.currentIndent -= 1; } setCurrentProp( val, name ) { this.currentProp = val; this.currentPropName = name; } parse( text ) { this.currentIndent = 0; this.allNodes = new FBXTree(); this.nodeStack = []; this.currentProp = []; this.currentPropName = ''; const scope = this; const split = text.split( /[\\r\\n]+/ ); split.forEach( function ( line, i ) { const matchComment = line.match( /^[\\s\\t]*;/ ); const matchEmpty = line.match( /^[\\s\\t]*$/ ); if ( matchComment || matchEmpty ) return; const matchBeginning = line.match( '^\\\\t{' + scope.currentIndent + '}(\\\\w+):(.*){', '' ); const matchProperty = line.match( '^\\\\t{' + ( scope.currentIndent ) + '}(\\\\w+):[\\\\s\\\\t\\\\r\\\\n](.*)' ); const matchEnd = line.match( '^\\\\t{' + ( scope.currentIndent - 1 ) + '}}' ); if ( matchBeginning ) { scope.parseNodeBegin( line, matchBeginning ); } else if ( matchProperty ) { scope.parseNodeProperty( line, matchProperty, split[ ++ i ] ); } else if ( matchEnd ) { scope.popStack(); } else if ( line.match( /^[^\\s\\t}]/ ) ) { // large arrays are split over multiple lines terminated with a ',' character // if this is encountered the line needs to be joined to the previous line scope.parseNodePropertyContinued( line ); } } ); return this.allNodes; } parseNodeBegin( line, property ) { const nodeName = property[ 1 ].trim().replace( /^\"/, '' ).replace( /\"$/, '' ); const nodeAttrs = property[ 2 ].split( ',' ).map( function ( attr ) { return attr.trim().replace( /^\"/, '' ).replace( /\"$/, '' ); } ); const node = { name: nodeName }; const attrs = this.parseNodeAttr( nodeAttrs ); const currentNode = this.getCurrentNode(); // a top node if ( this.currentIndent === 0 ) { this.allNodes.add( nodeName, node ); } else { // a subnode // if the subnode already exists, append it if ( nodeName in currentNode ) { // special case Pose needs PoseNodes as an array if ( nodeName === 'PoseNode' ) { currentNode.PoseNode.push( node ); } else if ( currentNode[ nodeName ].id !== undefined ) { currentNode[ nodeName ] = {}; currentNode[ nodeName ][ currentNode[ nodeName ].id ] = currentNode[ nodeName ]; } if ( attrs.id !== '' ) currentNode[ nodeName ][ attrs.id ] = node; } else if ( typeof attrs.id === 'number' ) { currentNode[ nodeName ] = {}; currentNode[ nodeName ][ attrs.id ] = node; } else if ( nodeName !== 'Properties70' ) { if ( nodeName === 'PoseNode' ) currentNode[ nodeName ] = [ node ]; else currentNode[ nodeName ] = node; } } if ( typeof attrs.id === 'number' ) node.id = attrs.id; if ( attrs.name !== '' ) node.attrName = attrs.name; if ( attrs.type !== '' ) node.attrType = attrs.type; this.pushStack( node ); } parseNodeAttr( attrs ) { let id = attrs[ 0 ]; if ( attrs[ 0 ] !== '' ) { id = parseInt( attrs[ 0 ] ); if ( isNaN( id ) ) { id = attrs[ 0 ]; } } let name = '', type = ''; if ( attrs.length > 1 ) { name = attrs[ 1 ].replace( /^(\\w+)::/, '' ); type = attrs[ 2 ]; } return { id: id, name: name, type: type }; } parseNodeProperty( line, property, contentLine ) { let propName = property[ 1 ].replace( /^\"/, '' ).replace( /\"$/, '' ).trim(); let propValue = property[ 2 ].replace( /^\"/, '' ).replace( /\"$/, '' ).trim(); // for special case: base64 image data follows \"Content: ,\" line // Content: , // \"/9j/4RDaRXhpZgAATU0A...\" if ( propName === 'Content' && propValue === ',' ) { propValue = contentLine.replace( /\"/g, '' ).replace( /,$/, '' ).trim(); } const currentNode = this.getCurrentNode(); const parentName = currentNode.name; if ( parentName === 'Properties70' ) { this.parseNodeSpecialProperty( line, propName, propValue ); return; } // Connections if ( propName === 'C' ) { const connProps = propValue.split( ',' ).slice( 1 ); const from = parseInt( connProps[ 0 ] ); const to = parseInt( connProps[ 1 ] ); let rest = propValue.split( ',' ).slice( 3 ); rest = rest.map( function ( elem ) { return elem.trim().replace( /^\"/, '' ); } ); propName = 'connections'; propValue = [ from, to ]; append( propValue, rest ); if ( currentNode[ propName ] === undefined ) { currentNode[ propName ] = []; } } // Node if ( propName === 'Node' ) currentNode.id = propValue; // connections if ( propName in currentNode && Array.isArray( currentNode[ propName ] ) ) { currentNode[ propName ].push( propValue ); } else { if ( propName !== 'a' ) currentNode[ propName ] = propValue; else currentNode.a = propValue; } this.setCurrentProp( currentNode, propName ); // convert string to array, unless it ends in ',' in which case more will be added to it if ( propName === 'a' && propValue.slice( - 1 ) !== ',' ) { currentNode.a = parseNumberArray( propValue ); } } parseNodePropertyContinued( line ) { const currentNode = this.getCurrentNode(); currentNode.a += line; // if the line doesn't end in ',' we have reached the end of the property value // so convert the string to an array if ( line.slice( - 1 ) !== ',' ) { currentNode.a = parseNumberArray( currentNode.a ); } } // parse \"Property70\" parseNodeSpecialProperty( line, propName, propValue ) { // split this // P: \"Lcl Scaling\", \"Lcl Scaling\", \"\", \"A\",1,1,1 // into array like below // [\"Lcl Scaling\", \"Lcl Scaling\", \"\", \"A\", \"1,1,1\" ] const props = propValue.split( '\",' ).map( function ( prop ) { return prop.trim().replace( /^\\\"/, '' ).replace( /\\s/, '_' ); } ); const innerPropName = props[ 0 ]; const innerPropType1 = props[ 1 ]; const innerPropType2 = props[ 2 ]; const innerPropFlag = props[ 3 ]; let innerPropValue = props[ 4 ]; // cast values where needed, otherwise leave as strings switch ( innerPropType1 ) { case 'int': case 'enum': case 'bool': case 'ULongLong': case 'double': case 'Number': case 'FieldOfView': innerPropValue = parseFloat( innerPropValue ); break; case 'Color': case 'ColorRGB': case 'Vector3D': case 'Lcl_Translation': case 'Lcl_Rotation': case 'Lcl_Scaling': innerPropValue = parseNumberArray( innerPropValue ); break; } // CAUTION: these props must append to parent's parent this.getPrevNode()[ innerPropName ] = { 'type': innerPropType1, 'type2': innerPropType2, 'flag': innerPropFlag, 'value': innerPropValue }; this.setCurrentProp( this.getPrevNode(), innerPropName ); } } // Parse an FBX file in Binary format class BinaryParser { parse( buffer ) { const reader = new BinaryReader( buffer ); reader.skip( 23 ); // skip magic 23 bytes const version = reader.getUint32(); if ( version < 6400 ) { throw new Error( 'THREE.FBXLoader: FBX version not supported, FileVersion: ' + version ); } const allNodes = new FBXTree(); while ( ! this.endOfContent( reader ) ) { const node = this.parseNode( reader, version ); if ( node !== null ) allNodes.add( node.name, node ); } return allNodes; } // Check if reader has reached the end of content. endOfContent( reader ) { // footer size: 160bytes + 16-byte alignment padding // - 16bytes: magic // - padding til 16-byte alignment (at least 1byte?) // (seems like some exporters embed fixed 15 or 16bytes?) // - 4bytes: magic // - 4bytes: version // - 120bytes: zero // - 16bytes: magic if ( reader.size() % 16 === 0 ) { return ( ( reader.getOffset() + 160 + 16 ) & ~ 0xf ) >= reader.size(); } else { return reader.getOffset() + 160 + 16 >= reader.size(); } } // recursively parse nodes until the end of the file is reached parseNode( reader, version ) { const node = {}; // The first three data sizes depends on version. const endOffset = ( version >= 7500 ) ? reader.getUint64() : reader.getUint32(); const numProperties = ( version >= 7500 ) ? reader.getUint64() : reader.getUint32(); ( version >= 7500 ) ? reader.getUint64() : reader.getUint32(); // the returned propertyListLen is not used const nameLen = reader.getUint8(); const name = reader.getString( nameLen ); // Regards this node as NULL-record if endOffset is zero if ( endOffset === 0 ) return null; const propertyList = []; for ( let i = 0; i < numProperties; i ++ ) { propertyList.push( this.parseProperty( reader ) ); } // Regards the first three elements in propertyList as id, attrName, and attrType const id = propertyList.length > 0 ? propertyList[ 0 ] : ''; const attrName = propertyList.length > 1 ? propertyList[ 1 ] : ''; const attrType = propertyList.length > 2 ? propertyList[ 2 ] : ''; // check if this node represents just a single property // like (name, 0) set or (name2, [0, 1, 2]) set of {name: 0, name2: [0, 1, 2]} node.singleProperty = ( numProperties === 1 && reader.getOffset() === endOffset ) ? true : false; while ( endOffset > reader.getOffset() ) { const subNode = this.parseNode( reader, version ); if ( subNode !== null ) this.parseSubNode( name, node, subNode ); } node.propertyList = propertyList; // raw property list used by parent if ( typeof id === 'number' ) node.id = id; if ( attrName !== '' ) node.attrName = attrName; if ( attrType !== '' ) node.attrType = attrType; if ( name !== '' ) node.name = name; return node; } parseSubNode( name, node, subNode ) { // special case: child node is single property if ( subNode.singleProperty === true ) { const value = subNode.propertyList[ 0 ]; if ( Array.isArray( value ) ) { node[ subNode.name ] = subNode; subNode.a = value; } else { node[ subNode.name ] = value; } } else if ( name === 'Connections' && subNode.name === 'C' ) { const array = []; subNode.propertyList.forEach( function ( property, i ) { // first Connection is FBX type (OO, OP, etc.). We'll discard these if ( i !== 0 ) array.push( property ); } ); if ( node.connections === undefined ) { node.connections = []; } node.connections.push( array ); } else if ( subNode.name === 'Properties70' ) { const keys = Object.keys( subNode ); keys.forEach( function ( key ) { node[ key ] = subNode[ key ]; } ); } else if ( name === 'Properties70' && subNode.name === 'P' ) { let innerPropName = subNode.propertyList[ 0 ]; let innerPropType1 = subNode.propertyList[ 1 ]; const innerPropType2 = subNode.propertyList[ 2 ]; const innerPropFlag = subNode.propertyList[ 3 ]; let innerPropValue; if ( innerPropName.indexOf( 'Lcl ' ) === 0 ) innerPropName = innerPropName.replace( 'Lcl ', 'Lcl_' ); if ( innerPropType1.indexOf( 'Lcl ' ) === 0 ) innerPropType1 = innerPropType1.replace( 'Lcl ', 'Lcl_' ); if ( innerPropType1 === 'Color' || innerPropType1 === 'ColorRGB' || innerPropType1 === 'Vector' || innerPropType1 === 'Vector3D' || innerPropType1.indexOf( 'Lcl_' ) === 0 ) { innerPropValue = [ subNode.propertyList[ 4 ], subNode.propertyList[ 5 ], subNode.propertyList[ 6 ] ]; } else { innerPropValue = subNode.propertyList[ 4 ]; } // this will be copied to parent, see above node[ innerPropName ] = { 'type': innerPropType1, 'type2': innerPropType2, 'flag': innerPropFlag, 'value': innerPropValue }; } else if ( node[ subNode.name ] === undefined ) { if ( typeof subNode.id === 'number' ) { node[ subNode.name ] = {}; node[ subNode.name ][ subNode.id ] = subNode; } else { node[ subNode.name ] = subNode; } } else { if ( subNode.name === 'PoseNode' ) { if ( ! Array.isArray( node[ subNode.name ] ) ) { node[ subNode.name ] = [ node[ subNode.name ] ]; } node[ subNode.name ].push( subNode ); } else if ( node[ subNode.name ][ subNode.id ] === undefined ) { node[ subNode.name ][ subNode.id ] = subNode; } } } parseProperty( reader ) { const type = reader.getString( 1 ); let length; switch ( type ) { case 'C': return reader.getBoolean(); case 'D': return reader.getFloat64(); case 'F': return reader.getFloat32(); case 'I': return reader.getInt32(); case 'L': return reader.getInt64(); case 'R': length = reader.getUint32(); return reader.getArrayBuffer( length ); case 'S': length = reader.getUint32(); return reader.getString( length ); case 'Y': return reader.getInt16(); case 'b': case 'c': case 'd': case 'f': case 'i': case 'l': const arrayLength = reader.getUint32(); const encoding = reader.getUint32(); // 0: non-compressed, 1: compressed const compressedLength = reader.getUint32(); if ( encoding === 0 ) { switch ( type ) { case 'b': case 'c': return reader.getBooleanArray( arrayLength ); case 'd': return reader.getFloat64Array( arrayLength ); case 'f': return reader.getFloat32Array( arrayLength ); case 'i': return reader.getInt32Array( arrayLength ); case 'l': return reader.getInt64Array( arrayLength ); } } const data = fflate.unzlibSync( new Uint8Array( reader.getArrayBuffer( compressedLength ) ) ); const reader2 = new BinaryReader( data.buffer ); switch ( type ) { case 'b': case 'c': return reader2.getBooleanArray( arrayLength ); case 'd': return reader2.getFloat64Array( arrayLength ); case 'f': return reader2.getFloat32Array( arrayLength ); case 'i': return reader2.getInt32Array( arrayLength ); case 'l': return reader2.getInt64Array( arrayLength ); } break; // cannot happen but is required by the DeepScan default: throw new Error( 'THREE.FBXLoader: Unknown property type ' + type ); } } } class BinaryReader { constructor( buffer, littleEndian ) { this.dv = new DataView( buffer ); this.offset = 0; this.littleEndian = ( littleEndian !== undefined ) ? littleEndian : true; this._textDecoder = new TextDecoder(); } getOffset() { return this.offset; } size() { return this.dv.buffer.byteLength; } skip( length ) { this.offset += length; } // seems like true/false representation depends on exporter. // true: 1 or 'Y'(=0x59), false: 0 or 'T'(=0x54) // then sees LSB. getBoolean() { return ( this.getUint8() & 1 ) === 1; } getBooleanArray( size ) { const a = []; for ( let i = 0; i < size; i ++ ) { a.push( this.getBoolean() ); } return a; } getUint8() { const value = this.dv.getUint8( this.offset ); this.offset += 1; return value; } getInt16() { const value = this.dv.getInt16( this.offset, this.littleEndian ); this.offset += 2; return value; } getInt32() { const value = this.dv.getInt32( this.offset, this.littleEndian ); this.offset += 4; return value; } getInt32Array( size ) { const a = []; for ( let i = 0; i < size; i ++ ) { a.push( this.getInt32() ); } return a; } getUint32() { const value = this.dv.getUint32( this.offset, this.littleEndian ); this.offset += 4; return value; } // JavaScript doesn't support 64-bit integer so calculate this here // 1 < 32 will return 1 so using multiply operation instead here. // There's a possibility that this method returns wrong value if the value // is out of the range between Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER. // TODO: safely handle 64-bit integer getInt64() { let low, high; if ( this.littleEndian ) { low = this.getUint32(); high = this.getUint32(); } else { high = this.getUint32(); low = this.getUint32(); } // calculate negative value if ( high & 0x80000000 ) { high = ~ high & 0xFFFFFFFF; low = ~ low & 0xFFFFFFFF; if ( low === 0xFFFFFFFF ) high = ( high + 1 ) & 0xFFFFFFFF; low = ( low + 1 ) & 0xFFFFFFFF; return - ( high * 0x100000000 + low ); } return high * 0x100000000 + low; } getInt64Array( size ) { const a = []; for ( let i = 0; i < size; i ++ ) { a.push( this.getInt64() ); } return a; } // Note: see getInt64() comment getUint64() { let low, high; if ( this.littleEndian ) { low = this.getUint32(); high = this.getUint32(); } else { high = this.getUint32(); low = this.getUint32(); } return high * 0x100000000 + low; } getFloat32() { const value = this.dv.getFloat32( this.offset, this.littleEndian ); this.offset += 4; return value; } getFloat32Array( size ) { const a = []; for ( let i = 0; i < size; i ++ ) { a.push( this.getFloat32() ); } return a; } getFloat64() { const value = this.dv.getFloat64( this.offset, this.littleEndian ); this.offset += 8; return value; } getFloat64Array( size ) { const a = []; for ( let i = 0; i < size; i ++ ) { a.push( this.getFloat64() ); } return a; } getArrayBuffer( size ) { const value = this.dv.buffer.slice( this.offset, this.offset + size ); this.offset += size; return value; } getString( size ) { const start = this.offset; let a = new Uint8Array( this.dv.buffer, start, size ); this.skip( size ); const nullByte = a.indexOf( 0 ); if ( nullByte >= 0 ) a = new Uint8Array( this.dv.buffer, start, nullByte ); return this._textDecoder.decode( a ); } } // FBXTree holds a representation of the FBX data, returned by the TextParser ( FBX ASCII format) // and BinaryParser( FBX Binary format) class FBXTree { add( key, val ) { this[ key ] = val; } } // ************** UTILITY FUNCTIONS ************** function isFbxFormatBinary( buffer ) { const CORRECT = 'Kaydara\\u0020FBX\\u0020Binary\\u0020\\u0020\\0'; return buffer.byteLength >= CORRECT.length && CORRECT === convertArrayBufferToString( buffer, 0, CORRECT.length ); } function isFbxFormatASCII( text ) { const CORRECT = [ 'K', 'a', 'y', 'd', 'a', 'r', 'a', '\\\\', 'F', 'B', 'X', '\\\\', 'B', 'i', 'n', 'a', 'r', 'y', '\\\\', '\\\\' ]; let cursor = 0; function read( offset ) { const result = text[ offset - 1 ]; text = text.slice( cursor + offset ); cursor ++; return result; } for ( let i = 0; i < CORRECT.length; ++ i ) { const num = read( 1 ); if ( num === CORRECT[ i ] ) { return false; } } return true; } function getFbxVersion( text ) { const versionRegExp = /FBXVersion: (\\d+)/; const match = text.match( versionRegExp ); if ( match ) { const version = parseInt( match[ 1 ] ); return version; } throw new Error( 'THREE.FBXLoader: Cannot find the version number for the file given.' ); } // Converts FBX ticks into real time seconds. function convertFBXTimeToSeconds( time ) { return time / 46186158000; } const dataArray = []; // extracts the data from the correct position in the FBX array based on indexing type function getData( polygonVertexIndex, polygonIndex, vertexIndex, infoObject ) { let index; switch ( infoObject.mappingType ) { case 'ByPolygonVertex' : index = polygonVertexIndex; break; case 'ByPolygon' : index = polygonIndex; break; case 'ByVertice' : index = vertexIndex; break; case 'AllSame' : index = infoObject.indices[ 0 ]; break; default : console.warn( 'THREE.FBXLoader: unknown attribute mapping type ' + infoObject.mappingType ); } if ( infoObject.referenceType === 'IndexToDirect' ) index = infoObject.indices[ index ]; const from = index * infoObject.dataSize; const to = from + infoObject.dataSize; return slice( dataArray, infoObject.buffer, from, to ); } const tempEuler = new Euler(); const tempVec = new Vector3(); // generate transformation from FBX transform data // ref: https://help.autodesk.com/view/FBX/2017/ENU/?guid=__files_GUID_10CDD63C_79C1_4F2D_BB28_AD2BE65A02ED_htm // ref: http://docs.autodesk.com/FBX/2014/ENU/FBX-SDK-Documentation/index.html?url=cpp_ref/_transformations_2main_8cxx-example.html,topicNumber=cpp_ref__transformations_2main_8cxx_example_htmlfc10a1e1-b18d-4e72-9dc0-70d0f1959f5e function generateTransform( transformData ) { const lTranslationM = new Matrix4(); const lPreRotationM = new Matrix4(); const lRotationM = new Matrix4(); const lPostRotationM = new Matrix4(); const lScalingM = new Matrix4(); const lScalingPivotM = new Matrix4(); const lScalingOffsetM = new Matrix4(); const lRotationOffsetM = new Matrix4(); const lRotationPivotM = new Matrix4(); const lParentGX = new Matrix4(); const lParentLX = new Matrix4(); const lGlobalT = new Matrix4(); const inheritType = ( transformData.inheritType ) ? transformData.inheritType : 0; if ( transformData.translation ) lTranslationM.setPosition( tempVec.fromArray( transformData.translation ) ); if ( transformData.preRotation ) { const array = transformData.preRotation.map( MathUtils.degToRad ); array.push( transformData.eulerOrder || Euler.DEFAULT_ORDER ); lPreRotationM.makeRotationFromEuler( tempEuler.fromArray( array ) ); } if ( transformData.rotation ) { const array = transformData.rotation.map( MathUtils.degToRad ); array.push( transformData.eulerOrder || Euler.DEFAULT_ORDER ); lRotationM.makeRotationFromEuler( tempEuler.fromArray( array ) ); } if ( transformData.postRotation ) { const array = transformData.postRotation.map( MathUtils.degToRad ); array.push( transformData.eulerOrder || Euler.DEFAULT_ORDER ); lPostRotationM.makeRotationFromEuler( tempEuler.fromArray( array ) ); lPostRotationM.invert(); } if ( transformData.scale ) lScalingM.scale( tempVec.fromArray( transformData.scale ) ); // Pivots and offsets if ( transformData.scalingOffset ) lScalingOffsetM.setPosition( tempVec.fromArray( transformData.scalingOffset ) ); if ( transformData.scalingPivot ) lScalingPivotM.setPosition( tempVec.fromArray( transformData.scalingPivot ) ); if ( transformData.rotationOffset ) lRotationOffsetM.setPosition( tempVec.fromArray( transformData.rotationOffset ) ); if ( transformData.rotationPivot ) lRotationPivotM.setPosition( tempVec.fromArray( transformData.rotationPivot ) ); // parent transform if ( transformData.parentMatrixWorld ) { lParentLX.copy( transformData.parentMatrix ); lParentGX.copy( transformData.parentMatrixWorld ); } const lLRM = lPreRotationM.clone().multiply( lRotationM ).multiply( lPostRotationM ); // Global Rotation const lParentGRM = new Matrix4(); lParentGRM.extractRotation( lParentGX ); // Global Shear*Scaling const lParentTM = new Matrix4(); lParentTM.copyPosition( lParentGX ); const lParentGRSM = lParentTM.clone().invert().multiply( lParentGX ); const lParentGSM = lParentGRM.clone().invert().multiply( lParentGRSM ); const lLSM = lScalingM; const lGlobalRS = new Matrix4(); if ( inheritType === 0 ) { lGlobalRS.copy( lParentGRM ).multiply( lLRM ).multiply( lParentGSM ).multiply( lLSM ); } else if ( inheritType === 1 ) { lGlobalRS.copy( lParentGRM ).multiply( lParentGSM ).multiply( lLRM ).multiply( lLSM ); } else { const lParentLSM = new Matrix4().scale( new Vector3().setFromMatrixScale( lParentLX ) ); const lParentLSM_inv = lParentLSM.clone().invert(); const lParentGSM_noLocal = lParentGSM.clone().multiply( lParentLSM_inv ); lGlobalRS.copy( lParentGRM ).multiply( lLRM ).multiply( lParentGSM_noLocal ).multiply( lLSM ); } const lRotationPivotM_inv = lRotationPivotM.clone().invert(); const lScalingPivotM_inv = lScalingPivotM.clone().invert(); // Calculate the local transform matrix let lTransform = lTranslationM.clone().multiply( lRotationOffsetM ).multiply( lRotationPivotM ).multiply( lPreRotationM ).multiply( lRotationM ).multiply( lPostRotationM ).multiply( lRotationPivotM_inv ).multiply( lScalingOffsetM ).multiply( lScalingPivotM ).multiply( lScalingM ).multiply( lScalingPivotM_inv ); const lLocalTWithAllPivotAndOffsetInfo = new Matrix4().copyPosition( lTransform ); const lGlobalTranslation = lParentGX.clone().multiply( lLocalTWithAllPivotAndOffsetInfo ); lGlobalT.copyPosition( lGlobalTranslation ); lTransform = lGlobalT.clone().multiply( lGlobalRS ); // from global to local lTransform.premultiply( lParentGX.invert() ); return lTransform; } // Returns the three.js intrinsic Euler order corresponding to FBX extrinsic Euler order // ref: http://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_class_fbx_euler_html function getEulerOrder( order ) { order = order || 0; const enums = [ 'ZYX', // -> XYZ extrinsic 'YZX', // -> XZY extrinsic 'XZY', // -> YZX extrinsic 'ZXY', // -> YXZ extrinsic 'YXZ', // -> ZXY extrinsic 'XYZ', // -> ZYX extrinsic //'SphericXYZ', // not possible to support ]; if ( order === 6 ) { console.warn( 'THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect.' ); return enums[ 0 ]; } return enums[ order ]; } // Parses comma separated list of numbers and returns them an array. // Used internally by the TextParser function parseNumberArray( value ) { const array = value.split( ',' ).map( function ( val ) { return parseFloat( val ); } ); return array; } function convertArrayBufferToString( buffer, from, to ) { if ( from === undefined ) from = 0; if ( to === undefined ) to = buffer.byteLength; return new TextDecoder().decode( new Uint8Array( buffer, from, to ) ); } function append( a, b ) { for ( let i = 0, j = a.length, l = b.length; i < l; i ++, j ++ ) { a[ j ] = b[ i ]; } } function slice( a, b, from, to ) { for ( let i = from, j = 0; i < to; i ++, j ++ ) { a[ j ] = b[ i ]; } return a; } // inject array a2 into array a1 at index function inject( a1, index, a2 ) { return a1.slice( 0, index ).concat( a2 ).concat( a1.slice( index ) ); } export { FBXLoader };"},{"title":"","date":"2023-10-12T14:08:40.676Z","updated":"2023-10-12T14:08:40.676Z","comments":true,"path":"js/three/jsm/loaders/KMZLoader.js","permalink":"http://19999997.xyz/js/three/jsm/loaders/KMZLoader.js","excerpt":"","text":"import { FileLoader, Group, Loader, LoadingManager } from 'three'; import { ColladaLoader } from '../loaders/ColladaLoader.js'; import * as fflate from '../libs/fflate.module.js'; class KMZLoader extends Loader { constructor( manager ) { super( manager ); } load( url, onLoad, onProgress, onError ) { const scope = this; const loader = new FileLoader( scope.manager ); loader.setPath( scope.path ); loader.setResponseType( 'arraybuffer' ); loader.setRequestHeader( scope.requestHeader ); loader.setWithCredentials( scope.withCredentials ); loader.load( url, function ( text ) { try { onLoad( scope.parse( text ) ); } catch ( e ) { if ( onError ) { onError( e ); } else { console.error( e ); } scope.manager.itemError( url ); } }, onProgress, onError ); } parse( data ) { function findFile( url ) { for ( const path in zip ) { if ( path.slice( - url.length ) === url ) { return zip[ path ]; } } } const manager = new LoadingManager(); manager.setURLModifier( function ( url ) { const image = findFile( url ); if ( image ) { console.log( 'Loading', url ); const blob = new Blob( [ image.buffer ], { type: 'application/octet-stream' } ); return URL.createObjectURL( blob ); } return url; } ); // const zip = fflate.unzipSync( new Uint8Array( data ) ); if ( zip[ 'doc.kml' ] ) { const xml = new DOMParser().parseFromString( fflate.strFromU8( zip[ 'doc.kml' ] ), 'application/xml' ); const model = xml.querySelector( 'Placemark Model Link href' ); if ( model ) { const loader = new ColladaLoader( manager ); return loader.parse( fflate.strFromU8( zip[ model.textContent ] ) ); } } else { console.warn( 'KMZLoader: Missing doc.kml file.' ); for ( const path in zip ) { const extension = path.split( '.' ).pop().toLowerCase(); if ( extension === 'dae' ) { const loader = new ColladaLoader( manager ); return loader.parse( fflate.strFromU8( zip[ path ] ) ); } } } console.error( 'KMZLoader: Couldn\\'t find .dae file.' ); return { scene: new Group() }; } } export { KMZLoader };"},{"title":"","date":"2023-10-12T14:08:40.679Z","updated":"2023-10-12T14:08:40.679Z","comments":true,"path":"js/three/jsm/loaders/KTX2Loader.js","permalink":"http://19999997.xyz/js/three/jsm/loaders/KTX2Loader.js","excerpt":"","text":"/** * Loader for KTX 2.0 GPU Texture containers. * * KTX 2.0 is a container format for various GPU texture formats. The loader * supports Basis Universal GPU textures, which can be quickly transcoded to * a wide variety of GPU texture compression formats, as well as some * uncompressed DataTexture and Data3DTexture formats. * * References: * - KTX: http://github.khronos.org/KTX-Specification/ * - DFD: https://www.khronos.org/registry/DataFormat/specs/1.3/dataformat.1.3.html#basicdescriptor */ import { CompressedTexture, CompressedArrayTexture, CompressedCubeTexture, Data3DTexture, DataTexture, DisplayP3ColorSpace, FileLoader, FloatType, HalfFloatType, NoColorSpace, LinearFilter, LinearMipmapLinearFilter, LinearDisplayP3ColorSpace, LinearSRGBColorSpace, Loader, RedFormat, RGB_ETC1_Format, RGB_ETC2_Format, RGB_PVRTC_4BPPV1_Format, RGB_S3TC_DXT1_Format, RGBA_ASTC_4x4_Format, RGBA_ASTC_6x6_Format, RGBA_BPTC_Format, RGBA_ETC2_EAC_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_S3TC_DXT5_Format, RGBAFormat, RGFormat, SRGBColorSpace, UnsignedByteType, } from 'three'; import { WorkerPool } from '../utils/WorkerPool.js'; import { read, KHR_DF_FLAG_ALPHA_PREMULTIPLIED, KHR_DF_TRANSFER_SRGB, KHR_SUPERCOMPRESSION_NONE, KHR_SUPERCOMPRESSION_ZSTD, VK_FORMAT_UNDEFINED, VK_FORMAT_R16_SFLOAT, VK_FORMAT_R16G16_SFLOAT, VK_FORMAT_R16G16B16A16_SFLOAT, VK_FORMAT_R32_SFLOAT, VK_FORMAT_R32G32_SFLOAT, VK_FORMAT_R32G32B32A32_SFLOAT, VK_FORMAT_R8_SRGB, VK_FORMAT_R8_UNORM, VK_FORMAT_R8G8_SRGB, VK_FORMAT_R8G8_UNORM, VK_FORMAT_R8G8B8A8_SRGB, VK_FORMAT_R8G8B8A8_UNORM, VK_FORMAT_ASTC_6x6_SRGB_BLOCK, VK_FORMAT_ASTC_6x6_UNORM_BLOCK, KHR_DF_PRIMARIES_UNSPECIFIED, KHR_DF_PRIMARIES_BT709, KHR_DF_PRIMARIES_DISPLAYP3 } from '../libs/ktx-parse.module.js'; import { ZSTDDecoder } from '../libs/zstddec.module.js'; const _taskCache = new WeakMap(); let _activeLoaders = 0; let _zstd; class KTX2Loader extends Loader { constructor( manager ) { super( manager ); this.transcoderPath = ''; this.transcoderBinary = null; this.transcoderPending = null; this.workerPool = new WorkerPool(); this.workerSourceURL = ''; this.workerConfig = null; if ( typeof MSC_TRANSCODER !== 'undefined' ) { console.warn( 'THREE.KTX2Loader: Please update to latest \"basis_transcoder\".' + ' \"msc_basis_transcoder\" is no longer supported in three.js r125+.' ); } } setTranscoderPath( path ) { this.transcoderPath = path; return this; } setWorkerLimit( num ) { this.workerPool.setWorkerLimit( num ); return this; } detectSupport( renderer ) { if ( renderer.isWebGPURenderer === true ) { this.workerConfig = { astcSupported: renderer.hasFeature( 'texture-compression-astc' ), etc1Supported: false, etc2Supported: renderer.hasFeature( 'texture-compression-etc2' ), dxtSupported: renderer.hasFeature( 'texture-compression-bc' ), bptcSupported: false, pvrtcSupported: false }; } else { this.workerConfig = { astcSupported: renderer.extensions.has( 'WEBGL_compressed_texture_astc' ), etc1Supported: renderer.extensions.has( 'WEBGL_compressed_texture_etc1' ), etc2Supported: renderer.extensions.has( 'WEBGL_compressed_texture_etc' ), dxtSupported: renderer.extensions.has( 'WEBGL_compressed_texture_s3tc' ), bptcSupported: renderer.extensions.has( 'EXT_texture_compression_bptc' ), pvrtcSupported: renderer.extensions.has( 'WEBGL_compressed_texture_pvrtc' ) || renderer.extensions.has( 'WEBKIT_WEBGL_compressed_texture_pvrtc' ) }; if ( renderer.capabilities.isWebGL2 ) { // https://github.com/mrdoob/three.js/pull/22928 this.workerConfig.etc1Supported = false; } } return this; } init() { if ( ! this.transcoderPending ) { // Load transcoder wrapper. const jsLoader = new FileLoader( this.manager ); jsLoader.setPath( this.transcoderPath ); jsLoader.setWithCredentials( this.withCredentials ); const jsContent = jsLoader.loadAsync( 'basis_transcoder.js' ); // Load transcoder WASM binary. const binaryLoader = new FileLoader( this.manager ); binaryLoader.setPath( this.transcoderPath ); binaryLoader.setResponseType( 'arraybuffer' ); binaryLoader.setWithCredentials( this.withCredentials ); const binaryContent = binaryLoader.loadAsync( 'basis_transcoder.wasm' ); this.transcoderPending = Promise.all( [ jsContent, binaryContent ] ) .then( ( [ jsContent, binaryContent ] ) => { const fn = KTX2Loader.BasisWorker.toString(); const body = [ '/* constants */', 'let _EngineFormat = ' + JSON.stringify( KTX2Loader.EngineFormat ), 'let _TranscoderFormat = ' + JSON.stringify( KTX2Loader.TranscoderFormat ), 'let _BasisFormat = ' + JSON.stringify( KTX2Loader.BasisFormat ), '/* basis_transcoder.js */', jsContent, '/* worker */', fn.substring( fn.indexOf( '{' ) + 1, fn.lastIndexOf( '}' ) ) ].join( '\\n' ); this.workerSourceURL = URL.createObjectURL( new Blob( [ body ] ) ); this.transcoderBinary = binaryContent; this.workerPool.setWorkerCreator( () => { const worker = new Worker( this.workerSourceURL ); const transcoderBinary = this.transcoderBinary.slice( 0 ); worker.postMessage( { type: 'init', config: this.workerConfig, transcoderBinary }, [ transcoderBinary ] ); return worker; } ); } ); if ( _activeLoaders > 0 ) { // Each instance loads a transcoder and allocates workers, increasing network and memory cost. console.warn( 'THREE.KTX2Loader: Multiple active KTX2 loaders may cause performance issues.' + ' Use a single KTX2Loader instance, or call .dispose() on old instances.' ); } _activeLoaders ++; } return this.transcoderPending; } load( url, onLoad, onProgress, onError ) { if ( this.workerConfig === null ) { throw new Error( 'THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.' ); } const loader = new FileLoader( this.manager ); loader.setResponseType( 'arraybuffer' ); loader.setWithCredentials( this.withCredentials ); loader.load( url, ( buffer ) => { // Check for an existing task using this buffer. A transferred buffer cannot be transferred // again from this thread. if ( _taskCache.has( buffer ) ) { const cachedTask = _taskCache.get( buffer ); return cachedTask.promise.then( onLoad ).catch( onError ); } this._createTexture( buffer ) .then( ( texture ) => onLoad ? onLoad( texture ) : null ) .catch( onError ); }, onProgress, onError ); } _createTextureFrom( transcodeResult, container ) { const { faces, width, height, format, type, error, dfdFlags } = transcodeResult; if ( type === 'error' ) return Promise.reject( error ); let texture; if ( container.faceCount === 6 ) { texture = new CompressedCubeTexture( faces, format, UnsignedByteType ); } else { const mipmaps = faces[ 0 ].mipmaps; texture = container.layerCount > 1 ? new CompressedArrayTexture( mipmaps, width, height, container.layerCount, format, UnsignedByteType ) : new CompressedTexture( mipmaps, width, height, format, UnsignedByteType ); } texture.minFilter = faces[ 0 ].mipmaps.length === 1 ? LinearFilter : LinearMipmapLinearFilter; texture.magFilter = LinearFilter; texture.generateMipmaps = false; texture.needsUpdate = true; texture.colorSpace = parseColorSpace( container ); texture.premultiplyAlpha = !! ( dfdFlags & KHR_DF_FLAG_ALPHA_PREMULTIPLIED ); return texture; } /** * @param {ArrayBuffer} buffer * @param {object?} config * @return {Promise} */ async _createTexture( buffer, config = {} ) { const container = read( new Uint8Array( buffer ) ); if ( container.vkFormat !== VK_FORMAT_UNDEFINED ) { return createRawTexture( container ); } // const taskConfig = config; const texturePending = this.init().then( () => { return this.workerPool.postMessage( { type: 'transcode', buffer, taskConfig: taskConfig }, [ buffer ] ); } ).then( ( e ) => this._createTextureFrom( e.data, container ) ); // Cache the task result. _taskCache.set( buffer, { promise: texturePending } ); return texturePending; } dispose() { this.workerPool.dispose(); if ( this.workerSourceURL ) URL.revokeObjectURL( this.workerSourceURL ); _activeLoaders --; return this; } } /* CONSTANTS */ KTX2Loader.BasisFormat = { ETC1S: 0, UASTC_4x4: 1, }; KTX2Loader.TranscoderFormat = { ETC1: 0, ETC2: 1, BC1: 2, BC3: 3, BC4: 4, BC5: 5, BC7_M6_OPAQUE_ONLY: 6, BC7_M5: 7, PVRTC1_4_RGB: 8, PVRTC1_4_RGBA: 9, ASTC_4x4: 10, ATC_RGB: 11, ATC_RGBA_INTERPOLATED_ALPHA: 12, RGBA32: 13, RGB565: 14, BGR565: 15, RGBA4444: 16, }; KTX2Loader.EngineFormat = { RGBAFormat: RGBAFormat, RGBA_ASTC_4x4_Format: RGBA_ASTC_4x4_Format, RGBA_BPTC_Format: RGBA_BPTC_Format, RGBA_ETC2_EAC_Format: RGBA_ETC2_EAC_Format, RGBA_PVRTC_4BPPV1_Format: RGBA_PVRTC_4BPPV1_Format, RGBA_S3TC_DXT5_Format: RGBA_S3TC_DXT5_Format, RGB_ETC1_Format: RGB_ETC1_Format, RGB_ETC2_Format: RGB_ETC2_Format, RGB_PVRTC_4BPPV1_Format: RGB_PVRTC_4BPPV1_Format, RGB_S3TC_DXT1_Format: RGB_S3TC_DXT1_Format, }; /* WEB WORKER */ KTX2Loader.BasisWorker = function () { let config; let transcoderPending; let BasisModule; const EngineFormat = _EngineFormat; // eslint-disable-line no-undef const TranscoderFormat = _TranscoderFormat; // eslint-disable-line no-undef const BasisFormat = _BasisFormat; // eslint-disable-line no-undef self.addEventListener( 'message', function ( e ) { const message = e.data; switch ( message.type ) { case 'init': config = message.config; init( message.transcoderBinary ); break; case 'transcode': transcoderPending.then( () => { try { const { faces, buffers, width, height, hasAlpha, format, dfdFlags } = transcode( message.buffer ); self.postMessage( { type: 'transcode', id: message.id, faces, width, height, hasAlpha, format, dfdFlags }, buffers ); } catch ( error ) { console.error( error ); self.postMessage( { type: 'error', id: message.id, error: error.message } ); } } ); break; } } ); function init( wasmBinary ) { transcoderPending = new Promise( ( resolve ) => { BasisModule = { wasmBinary, onRuntimeInitialized: resolve }; BASIS( BasisModule ); // eslint-disable-line no-undef } ).then( () => { BasisModule.initializeBasis(); if ( BasisModule.KTX2File === undefined ) { console.warn( 'THREE.KTX2Loader: Please update Basis Universal transcoder.' ); } } ); } function transcode( buffer ) { const ktx2File = new BasisModule.KTX2File( new Uint8Array( buffer ) ); function cleanup() { ktx2File.close(); ktx2File.delete(); } if ( ! ktx2File.isValid() ) { cleanup(); throw new Error( 'THREE.KTX2Loader: Invalid or unsupported .ktx2 file' ); } const basisFormat = ktx2File.isUASTC() ? BasisFormat.UASTC_4x4 : BasisFormat.ETC1S; const width = ktx2File.getWidth(); const height = ktx2File.getHeight(); const layerCount = ktx2File.getLayers() || 1; const levelCount = ktx2File.getLevels(); const faceCount = ktx2File.getFaces(); const hasAlpha = ktx2File.getHasAlpha(); const dfdFlags = ktx2File.getDFDFlags(); const { transcoderFormat, engineFormat } = getTranscoderFormat( basisFormat, width, height, hasAlpha ); if ( ! width || ! height || ! levelCount ) { cleanup(); throw new Error( 'THREE.KTX2Loader: Invalid texture' ); } if ( ! ktx2File.startTranscoding() ) { cleanup(); throw new Error( 'THREE.KTX2Loader: .startTranscoding failed' ); } const faces = []; const buffers = []; for ( let face = 0; face < faceCount; face ++ ) { const mipmaps = []; for ( let mip = 0; mip < levelCount; mip ++ ) { const layerMips = []; let mipWidth, mipHeight; for ( let layer = 0; layer < layerCount; layer ++ ) { const levelInfo = ktx2File.getImageLevelInfo( mip, layer, face ); if ( face === 0 && mip === 0 && layer === 0 && ( levelInfo.origWidth % 4 !== 0 || levelInfo.origHeight % 4 !== 0 ) ) { console.warn( 'THREE.KTX2Loader: ETC1S and UASTC textures should use multiple-of-four dimensions.' ); } if ( levelCount > 1 ) { mipWidth = levelInfo.origWidth; mipHeight = levelInfo.origHeight; } else { // Handles non-multiple-of-four dimensions in textures without mipmaps. Textures with // mipmaps must use multiple-of-four dimensions, for some texture formats and APIs. // See mrdoob/three.js#25908. mipWidth = levelInfo.width; mipHeight = levelInfo.height; } const dst = new Uint8Array( ktx2File.getImageTranscodedSizeInBytes( mip, layer, 0, transcoderFormat ) ); const status = ktx2File.transcodeImage( dst, mip, layer, face, transcoderFormat, 0, - 1, - 1 ); if ( ! status ) { cleanup(); throw new Error( 'THREE.KTX2Loader: .transcodeImage failed.' ); } layerMips.push( dst ); } const mipData = concat( layerMips ); mipmaps.push( { data: mipData, width: mipWidth, height: mipHeight } ); buffers.push( mipData.buffer ); } faces.push( { mipmaps, width, height, format: engineFormat } ); } cleanup(); return { faces, buffers, width, height, hasAlpha, format: engineFormat, dfdFlags }; } // // Optimal choice of a transcoder target format depends on the Basis format (ETC1S or UASTC), // device capabilities, and texture dimensions. The list below ranks the formats separately // for ETC1S and UASTC. // // In some cases, transcoding UASTC to RGBA32 might be preferred for higher quality (at // significant memory cost) compared to ETC1/2, BC1/3, and PVRTC. The transcoder currently // chooses RGBA32 only as a last resort and does not expose that option to the caller. const FORMAT_OPTIONS = [ { if: 'astcSupported', basisFormat: [ BasisFormat.UASTC_4x4 ], transcoderFormat: [ TranscoderFormat.ASTC_4x4, TranscoderFormat.ASTC_4x4 ], engineFormat: [ EngineFormat.RGBA_ASTC_4x4_Format, EngineFormat.RGBA_ASTC_4x4_Format ], priorityETC1S: Infinity, priorityUASTC: 1, needsPowerOfTwo: false, }, { if: 'bptcSupported', basisFormat: [ BasisFormat.ETC1S, BasisFormat.UASTC_4x4 ], transcoderFormat: [ TranscoderFormat.BC7_M5, TranscoderFormat.BC7_M5 ], engineFormat: [ EngineFormat.RGBA_BPTC_Format, EngineFormat.RGBA_BPTC_Format ], priorityETC1S: 3, priorityUASTC: 2, needsPowerOfTwo: false, }, { if: 'dxtSupported', basisFormat: [ BasisFormat.ETC1S, BasisFormat.UASTC_4x4 ], transcoderFormat: [ TranscoderFormat.BC1, TranscoderFormat.BC3 ], engineFormat: [ EngineFormat.RGB_S3TC_DXT1_Format, EngineFormat.RGBA_S3TC_DXT5_Format ], priorityETC1S: 4, priorityUASTC: 5, needsPowerOfTwo: false, }, { if: 'etc2Supported', basisFormat: [ BasisFormat.ETC1S, BasisFormat.UASTC_4x4 ], transcoderFormat: [ TranscoderFormat.ETC1, TranscoderFormat.ETC2 ], engineFormat: [ EngineFormat.RGB_ETC2_Format, EngineFormat.RGBA_ETC2_EAC_Format ], priorityETC1S: 1, priorityUASTC: 3, needsPowerOfTwo: false, }, { if: 'etc1Supported', basisFormat: [ BasisFormat.ETC1S, BasisFormat.UASTC_4x4 ], transcoderFormat: [ TranscoderFormat.ETC1 ], engineFormat: [ EngineFormat.RGB_ETC1_Format ], priorityETC1S: 2, priorityUASTC: 4, needsPowerOfTwo: false, }, { if: 'pvrtcSupported', basisFormat: [ BasisFormat.ETC1S, BasisFormat.UASTC_4x4 ], transcoderFormat: [ TranscoderFormat.PVRTC1_4_RGB, TranscoderFormat.PVRTC1_4_RGBA ], engineFormat: [ EngineFormat.RGB_PVRTC_4BPPV1_Format, EngineFormat.RGBA_PVRTC_4BPPV1_Format ], priorityETC1S: 5, priorityUASTC: 6, needsPowerOfTwo: true, }, ]; const ETC1S_OPTIONS = FORMAT_OPTIONS.sort( function ( a, b ) { return a.priorityETC1S - b.priorityETC1S; } ); const UASTC_OPTIONS = FORMAT_OPTIONS.sort( function ( a, b ) { return a.priorityUASTC - b.priorityUASTC; } ); function getTranscoderFormat( basisFormat, width, height, hasAlpha ) { let transcoderFormat; let engineFormat; const options = basisFormat === BasisFormat.ETC1S ? ETC1S_OPTIONS : UASTC_OPTIONS; for ( let i = 0; i < options.length; i ++ ) { const opt = options[ i ]; if ( ! config[ opt.if ] ) continue; if ( ! opt.basisFormat.includes( basisFormat ) ) continue; if ( hasAlpha && opt.transcoderFormat.length < 2 ) continue; if ( opt.needsPowerOfTwo && ! ( isPowerOfTwo( width ) && isPowerOfTwo( height ) ) ) continue; transcoderFormat = opt.transcoderFormat[ hasAlpha ? 1 : 0 ]; engineFormat = opt.engineFormat[ hasAlpha ? 1 : 0 ]; return { transcoderFormat, engineFormat }; } console.warn( 'THREE.KTX2Loader: No suitable compressed texture format found. Decoding to RGBA32.' ); transcoderFormat = TranscoderFormat.RGBA32; engineFormat = EngineFormat.RGBAFormat; return { transcoderFormat, engineFormat }; } function isPowerOfTwo( value ) { if ( value > levelIndex ); const levelDepth = container.pixelDepth ? Math.max( 1, container.pixelDepth >> levelIndex ) : 0; const level = container.levels[ levelIndex ]; let levelData; if ( container.supercompressionScheme === KHR_SUPERCOMPRESSION_NONE ) { levelData = level.levelData; } else if ( container.supercompressionScheme === KHR_SUPERCOMPRESSION_ZSTD ) { levelData = zstd.decode( level.levelData, level.uncompressedByteLength ); } else { throw new Error( 'THREE.KTX2Loader: Unsupported supercompressionScheme.' ); } let data; if ( TYPE_MAP[ vkFormat ] === FloatType ) { data = new Float32Array( levelData.buffer, levelData.byteOffset, levelData.byteLength / Float32Array.BYTES_PER_ELEMENT ); } else if ( TYPE_MAP[ vkFormat ] === HalfFloatType ) { data = new Uint16Array( levelData.buffer, levelData.byteOffset, levelData.byteLength / Uint16Array.BYTES_PER_ELEMENT ); } else { data = levelData; } mipmaps.push( { data: data, width: levelWidth, height: levelHeight, depth: levelDepth, } ); } let texture; if ( UNCOMPRESSED_FORMATS.has( FORMAT_MAP[ vkFormat ] ) ) { texture = container.pixelDepth === 0 ? new DataTexture( mipmaps[ 0 ].data, container.pixelWidth, container.pixelHeight ) : new Data3DTexture( mipmaps[ 0 ].data, container.pixelWidth, container.pixelHeight, container.pixelDepth ); } else { if ( container.pixelDepth > 0 ) throw new Error( 'THREE.KTX2Loader: Unsupported pixelDepth.' ); texture = new CompressedTexture( mipmaps, container.pixelWidth, container.pixelHeight ); } texture.mipmaps = mipmaps; texture.type = TYPE_MAP[ vkFormat ]; texture.format = FORMAT_MAP[ vkFormat ]; texture.colorSpace = parseColorSpace( container ); texture.needsUpdate = true; // return Promise.resolve( texture ); } function parseColorSpace( container ) { const dfd = container.dataFormatDescriptor[ 0 ]; if ( dfd.colorPrimaries === KHR_DF_PRIMARIES_BT709 ) { return dfd.transferFunction === KHR_DF_TRANSFER_SRGB ? SRGBColorSpace : LinearSRGBColorSpace; } else if ( dfd.colorPrimaries === KHR_DF_PRIMARIES_DISPLAYP3 ) { return dfd.transferFunction === KHR_DF_TRANSFER_SRGB ? DisplayP3ColorSpace : LinearDisplayP3ColorSpace; } else if ( dfd.colorPrimaries === KHR_DF_PRIMARIES_UNSPECIFIED ) { return NoColorSpace; } else { console.warn( `THREE.KTX2Loader: Unsupported color primaries, \"${ dfd.colorPrimaries }\"` ); return NoColorSpace; } } export { KTX2Loader };"},{"title":"","date":"2023-10-12T14:08:40.674Z","updated":"2023-10-12T14:08:40.674Z","comments":true,"path":"js/three/jsm/loaders/IESLoader.js","permalink":"http://19999997.xyz/js/three/jsm/loaders/IESLoader.js","excerpt":"","text":"import { DataTexture, FileLoader, FloatType, RedFormat, MathUtils, Loader, UnsignedByteType, LinearFilter, HalfFloatType, DataUtils } from 'three'; class IESLoader extends Loader { constructor( manager ) { super( manager ); this.type = HalfFloatType; } _getIESValues( iesLamp, type ) { const width = 360; const height = 180; const size = width * height; const data = new Array( size ); function interpolateCandelaValues( phi, theta ) { let phiIndex = 0, thetaIndex = 0; let startTheta = 0, endTheta = 0, startPhi = 0, endPhi = 0; for ( let i = 0; i < iesLamp.numHorAngles - 1; ++ i ) { // numHorAngles = horAngles.length-1 because of extra padding, so this wont cause an out of bounds error if ( theta < iesLamp.horAngles[ i + 1 ] || i == iesLamp.numHorAngles - 2 ) { thetaIndex = i; startTheta = iesLamp.horAngles[ i ]; endTheta = iesLamp.horAngles[ i + 1 ]; break; } } for ( let i = 0; i < iesLamp.numVerAngles - 1; ++ i ) { if ( phi < iesLamp.verAngles[ i + 1 ] || i == iesLamp.numVerAngles - 2 ) { phiIndex = i; startPhi = iesLamp.verAngles[ i ]; endPhi = iesLamp.verAngles[ i + 1 ]; break; } } const deltaTheta = endTheta - startTheta; const deltaPhi = endPhi - startPhi; if ( deltaPhi === 0 ) // Outside range return 0; const t1 = deltaTheta === 0 ? 0 : ( theta - startTheta ) / deltaTheta; const t2 = ( phi - startPhi ) / deltaPhi; const nextThetaIndex = deltaTheta === 0 ? thetaIndex : thetaIndex + 1; const v1 = MathUtils.lerp( iesLamp.candelaValues[ thetaIndex ][ phiIndex ], iesLamp.candelaValues[ nextThetaIndex ][ phiIndex ], t1 ); const v2 = MathUtils.lerp( iesLamp.candelaValues[ thetaIndex ][ phiIndex + 1 ], iesLamp.candelaValues[ nextThetaIndex ][ phiIndex + 1 ], t1 ); const v = MathUtils.lerp( v1, v2, t2 ); return v; } const startTheta = iesLamp.horAngles[ 0 ], endTheta = iesLamp.horAngles[ iesLamp.numHorAngles - 1 ]; for ( let i = 0; i < size; ++ i ) { let theta = i % width; const phi = Math.floor( i / width ); if ( endTheta - startTheta !== 0 && ( theta < startTheta || theta >= endTheta ) ) { // Handle symmetry for hor angles theta %= endTheta * 2; if ( theta > endTheta ) theta = endTheta * 2 - theta; } data[ phi + theta * height ] = interpolateCandelaValues( phi, theta ); } let result = null; if ( type === UnsignedByteType ) result = Uint8Array.from( data.map( v => Math.min( v * 0xFF, 0xFF ) ) ); else if ( type === HalfFloatType ) result = Uint16Array.from( data.map( v => DataUtils.toHalfFloat( v ) ) ); else if ( type === FloatType ) result = Float32Array.from( data ); else console.error( 'IESLoader: Unsupported type:', type ); return result; } load( url, onLoad, onProgress, onError ) { const loader = new FileLoader( this.manager ); loader.setResponseType( 'text' ); loader.setCrossOrigin( this.crossOrigin ); loader.setWithCredentials( this.withCredentials ); loader.setPath( this.path ); loader.setRequestHeader( this.requestHeader ); loader.load( url, text => { onLoad( this.parse( text ) ); }, onProgress, onError ); } parse( text ) { const type = this.type; const iesLamp = new IESLamp( text ); const data = this._getIESValues( iesLamp, type ); const texture = new DataTexture( data, 180, 1, RedFormat, type ); texture.minFilter = LinearFilter; texture.magFilter = LinearFilter; texture.needsUpdate = true; return texture; } } function IESLamp( text ) { const _self = this; const textArray = text.split( '\\n' ); let lineNumber = 0; let line; _self.verAngles = [ ]; _self.horAngles = [ ]; _self.candelaValues = [ ]; _self.tiltData = { }; _self.tiltData.angles = [ ]; _self.tiltData.mulFactors = [ ]; function textToArray( text ) { text = text.replace( /^\\s+|\\s+$/g, '' ); // remove leading or trailing spaces text = text.replace( /,/g, ' ' ); // replace commas with spaces text = text.replace( /\\s\\s+/g, ' ' ); // replace white space/tabs etc by single whitespace const array = text.split( ' ' ); return array; } function readArray( count, array ) { while ( true ) { const line = textArray[ lineNumber ++ ]; const lineData = textToArray( line ); for ( let i = 0; i < lineData.length; ++ i ) { array.push( Number( lineData[ i ] ) ); } if ( array.length === count ) break; } } function readTilt() { let line = textArray[ lineNumber ++ ]; let lineData = textToArray( line ); _self.tiltData.lampToLumGeometry = Number( lineData[ 0 ] ); line = textArray[ lineNumber ++ ]; lineData = textToArray( line ); _self.tiltData.numAngles = Number( lineData[ 0 ] ); readArray( _self.tiltData.numAngles, _self.tiltData.angles ); readArray( _self.tiltData.numAngles, _self.tiltData.mulFactors ); } function readLampValues() { const values = [ ]; readArray( 10, values ); _self.count = Number( values[ 0 ] ); _self.lumens = Number( values[ 1 ] ); _self.multiplier = Number( values[ 2 ] ); _self.numVerAngles = Number( values[ 3 ] ); _self.numHorAngles = Number( values[ 4 ] ); _self.gonioType = Number( values[ 5 ] ); _self.units = Number( values[ 6 ] ); _self.width = Number( values[ 7 ] ); _self.length = Number( values[ 8 ] ); _self.height = Number( values[ 9 ] ); } function readLampFactors() { const values = [ ]; readArray( 3, values ); _self.ballFactor = Number( values[ 0 ] ); _self.blpFactor = Number( values[ 1 ] ); _self.inputWatts = Number( values[ 2 ] ); } while ( true ) { line = textArray[ lineNumber ++ ]; if ( line.includes( 'TILT' ) ) { break; } } if ( ! line.includes( 'NONE' ) ) { if ( line.includes( 'INCLUDE' ) ) { readTilt(); } else { // TODO:: Read tilt data from a file } } readLampValues(); readLampFactors(); // Initialize candela value array for ( let i = 0; i < _self.numHorAngles; ++ i ) { _self.candelaValues.push( [ ] ); } // Parse Angles readArray( _self.numVerAngles, _self.verAngles ); readArray( _self.numHorAngles, _self.horAngles ); // Parse Candela values for ( let i = 0; i < _self.numHorAngles; ++ i ) { readArray( _self.numVerAngles, _self.candelaValues[ i ] ); } // Calculate actual candela values, and normalize. for ( let i = 0; i < _self.numHorAngles; ++ i ) { for ( let j = 0; j < _self.numVerAngles; ++ j ) { _self.candelaValues[ i ][ j ] *= _self.candelaValues[ i ][ j ] * _self.multiplier * _self.ballFactor * _self.blpFactor; } } let maxVal = - 1; for ( let i = 0; i < _self.numHorAngles; ++ i ) { for ( let j = 0; j < _self.numVerAngles; ++ j ) { const value = _self.candelaValues[ i ][ j ]; maxVal = maxVal < value ? value : maxVal; } } const bNormalize = true; if ( bNormalize && maxVal > 0 ) { for ( let i = 0; i < _self.numHorAngles; ++ i ) { for ( let j = 0; j < _self.numVerAngles; ++ j ) { _self.candelaValues[ i ][ j ] /= maxVal; } } } } export { IESLoader };"},{"title":"","date":"2023-10-12T14:08:40.681Z","updated":"2023-10-12T14:08:40.681Z","comments":true,"path":"js/three/jsm/loaders/KTXLoader.js","permalink":"http://19999997.xyz/js/three/jsm/loaders/KTXLoader.js","excerpt":"","text":"import { CompressedTextureLoader } from 'three'; /** * for description see https://www.khronos.org/opengles/sdk/tools/KTX/ * for file layout see https://www.khronos.org/opengles/sdk/tools/KTX/file_format_spec/ * * ported from https://github.com/BabylonJS/Babylon.js/blob/master/src/Misc/khronosTextureContainer.ts */ class KTXLoader extends CompressedTextureLoader { constructor( manager ) { super( manager ); } parse( buffer, loadMipmaps ) { const ktx = new KhronosTextureContainer( buffer, 1 ); return { mipmaps: ktx.mipmaps( loadMipmaps ), width: ktx.pixelWidth, height: ktx.pixelHeight, format: ktx.glInternalFormat, isCubemap: ktx.numberOfFaces === 6, mipmapCount: ktx.numberOfMipmapLevels }; } } const HEADER_LEN = 12 + ( 13 * 4 ); // identifier + header elements (not including key value meta-data pairs) // load types const COMPRESSED_2D = 0; // uses a gl.compressedTexImage2D() //const COMPRESSED_3D = 1; // uses a gl.compressedTexImage3D() //const TEX_2D = 2; // uses a gl.texImage2D() //const TEX_3D = 3; // uses a gl.texImage3D() class KhronosTextureContainer { /** * @param {ArrayBuffer} arrayBuffer- contents of the KTX container file * @param {number} facesExpected- should be either 1 or 6, based whether a cube texture or or * @param {boolean} threeDExpected- provision for indicating that data should be a 3D texture, not implemented * @param {boolean} textureArrayExpected- provision for indicating that data should be a texture array, not implemented */ constructor( arrayBuffer, facesExpected /*, threeDExpected, textureArrayExpected */ ) { this.arrayBuffer = arrayBuffer; // Test that it is a ktx formatted file, based on the first 12 bytes, character representation is: // '´', 'K', 'T', 'X', ' ', '1', '1', 'ª', '\\r', '\\n', '\\x1A', '\\n' // 0xAB, 0x4B, 0x54, 0x58, 0x20, 0x31, 0x31, 0xBB, 0x0D, 0x0A, 0x1A, 0x0A const identifier = new Uint8Array( this.arrayBuffer, 0, 12 ); if ( identifier[ 0 ] !== 0xAB || identifier[ 1 ] !== 0x4B || identifier[ 2 ] !== 0x54 || identifier[ 3 ] !== 0x58 || identifier[ 4 ] !== 0x20 || identifier[ 5 ] !== 0x31 || identifier[ 6 ] !== 0x31 || identifier[ 7 ] !== 0xBB || identifier[ 8 ] !== 0x0D || identifier[ 9 ] !== 0x0A || identifier[ 10 ] !== 0x1A || identifier[ 11 ] !== 0x0A ) { console.error( 'texture missing KTX identifier' ); return; } // load the reset of the header in native 32 bit uint const dataSize = Uint32Array.BYTES_PER_ELEMENT; const headerDataView = new DataView( this.arrayBuffer, 12, 13 * dataSize ); const endianness = headerDataView.getUint32( 0, true ); const littleEndian = endianness === 0x04030201; this.glType = headerDataView.getUint32( 1 * dataSize, littleEndian ); // must be 0 for compressed textures this.glTypeSize = headerDataView.getUint32( 2 * dataSize, littleEndian ); // must be 1 for compressed textures this.glFormat = headerDataView.getUint32( 3 * dataSize, littleEndian ); // must be 0 for compressed textures this.glInternalFormat = headerDataView.getUint32( 4 * dataSize, littleEndian ); // the value of arg passed to gl.compressedTexImage2D(,,x,,,,) this.glBaseInternalFormat = headerDataView.getUint32( 5 * dataSize, littleEndian ); // specify GL_RGB, GL_RGBA, GL_ALPHA, etc (un-compressed only) this.pixelWidth = headerDataView.getUint32( 6 * dataSize, littleEndian ); // level 0 value of arg passed to gl.compressedTexImage2D(,,,x,,,) this.pixelHeight = headerDataView.getUint32( 7 * dataSize, littleEndian ); // level 0 value of arg passed to gl.compressedTexImage2D(,,,,x,,) this.pixelDepth = headerDataView.getUint32( 8 * dataSize, littleEndian ); // level 0 value of arg passed to gl.compressedTexImage3D(,,,,,x,,) this.numberOfArrayElements = headerDataView.getUint32( 9 * dataSize, littleEndian ); // used for texture arrays this.numberOfFaces = headerDataView.getUint32( 10 * dataSize, littleEndian ); // used for cubemap textures, should either be 1 or 6 this.numberOfMipmapLevels = headerDataView.getUint32( 11 * dataSize, littleEndian ); // number of levels; disregard possibility of 0 for compressed textures this.bytesOfKeyValueData = headerDataView.getUint32( 12 * dataSize, littleEndian ); // the amount of space after the header for meta-data // Make sure we have a compressed type. Not only reduces work, but probably better to let dev know they are not compressing. if ( this.glType !== 0 ) { console.warn( 'only compressed formats currently supported' ); return; } else { // value of zero is an indication to generate mipmaps @ runtime. Not usually allowed for compressed, so disregard. this.numberOfMipmapLevels = Math.max( 1, this.numberOfMipmapLevels ); } if ( this.pixelHeight === 0 || this.pixelDepth !== 0 ) { console.warn( 'only 2D textures currently supported' ); return; } if ( this.numberOfArrayElements !== 0 ) { console.warn( 'texture arrays not currently supported' ); return; } if ( this.numberOfFaces !== facesExpected ) { console.warn( 'number of faces expected' + facesExpected + ', but found ' + this.numberOfFaces ); return; } // we now have a completely validated file, so could use existence of loadType as success // would need to make this more elaborate & adjust checks above to support more than one load type this.loadType = COMPRESSED_2D; } mipmaps( loadMipmaps ) { const mipmaps = []; // initialize width & height for level 1 let dataOffset = HEADER_LEN + this.bytesOfKeyValueData; let width = this.pixelWidth; let height = this.pixelHeight; const mipmapCount = loadMipmaps ? this.numberOfMipmapLevels : 1; for ( let level = 0; level < mipmapCount; level ++ ) { const imageSize = new Int32Array( this.arrayBuffer, dataOffset, 1 )[ 0 ]; // size per face, since not supporting array cubemaps dataOffset += 4; // size of the image + 4 for the imageSize field for ( let face = 0; face < this.numberOfFaces; face ++ ) { const byteArray = new Uint8Array( this.arrayBuffer, dataOffset, imageSize ); mipmaps.push( { 'data': byteArray, 'width': width, 'height': height } ); dataOffset += imageSize; dataOffset += 3 - ( ( imageSize + 3 ) % 4 ); // add padding for odd sized image } width = Math.max( 1.0, width * 0.5 ); height = Math.max( 1.0, height * 0.5 ); } return mipmaps; } } export { KTXLoader };"},{"title":"","date":"2023-10-12T14:08:40.687Z","updated":"2023-10-12T14:08:40.687Z","comments":true,"path":"js/three/jsm/loaders/LUT3dlLoader.js","permalink":"http://19999997.xyz/js/three/jsm/loaders/LUT3dlLoader.js","excerpt":"","text":"// http://download.autodesk.com/us/systemdocs/help/2011/lustre/index.html?url=./files/WSc4e151a45a3b785a24c3d9a411df9298473-7ffd.htm,topicNumber=d0e9492 // https://community.foundry.com/discuss/topic/103636/format-spec-for-3dl?mode=Post&postID=895258 import { Loader, FileLoader, DataTexture, Data3DTexture, RGBAFormat, UnsignedByteType, ClampToEdgeWrapping, LinearFilter, } from 'three'; export class LUT3dlLoader extends Loader { load( url, onLoad, onProgress, onError ) { const loader = new FileLoader( this.manager ); loader.setPath( this.path ); loader.setResponseType( 'text' ); loader.load( url, text => { try { onLoad( this.parse( text ) ); } catch ( e ) { if ( onError ) { onError( e ); } else { console.error( e ); } this.manager.itemError( url ); } }, onProgress, onError ); } parse( str ) { // remove empty lines and comment lints str = str .replace( /^#.*?(\\n|\\r)/gm, '' ) .replace( /^\\s*?(\\n|\\r)/gm, '' ) .trim(); const lines = str.split( /[\\n\\r]+/g ); // first line is the positions on the grid that are provided by the LUT const gridLines = lines[ 0 ].trim().split( /\\s+/g ).map( e => parseFloat( e ) ); const gridStep = gridLines[ 1 ] - gridLines[ 0 ]; const size = gridLines.length; for ( let i = 1, l = gridLines.length; i < l; i ++ ) { if ( gridStep !== ( gridLines[ i ] - gridLines[ i - 1 ] ) ) { throw new Error( 'LUT3dlLoader: Inconsistent grid size not supported.' ); } } const dataArray = new Array( size * size * size * 4 ); let index = 0; let maxOutputValue = 0.0; for ( let i = 1, l = lines.length; i < l; i ++ ) { const line = lines[ i ].trim(); const split = line.split( /\\s/g ); const r = parseFloat( split[ 0 ] ); const g = parseFloat( split[ 1 ] ); const b = parseFloat( split[ 2 ] ); maxOutputValue = Math.max( maxOutputValue, r, g, b ); const bLayer = index % size; const gLayer = Math.floor( index / size ) % size; const rLayer = Math.floor( index / ( size * size ) ) % size; // b grows first, then g, then r const pixelIndex = bLayer * size * size + gLayer * size + rLayer; dataArray[ 4 * pixelIndex + 0 ] = r; dataArray[ 4 * pixelIndex + 1 ] = g; dataArray[ 4 * pixelIndex + 2 ] = b; dataArray[ 4 * pixelIndex + 3 ] = 1.0; index += 1; } // Find the apparent bit depth of the stored RGB values and map the // values to [ 0, 255 ]. const bits = Math.ceil( Math.log2( maxOutputValue ) ); const maxBitValue = Math.pow( 2.0, bits ); for ( let i = 0, l = dataArray.length; i < l; i += 4 ) { const r = dataArray[ i + 0 ]; const g = dataArray[ i + 1 ]; const b = dataArray[ i + 2 ]; dataArray[ i + 0 ] = 255 * r / maxBitValue; // r dataArray[ i + 1 ] = 255 * g / maxBitValue; // g dataArray[ i + 2 ] = 255 * b / maxBitValue; // b } const data = new Uint8Array( dataArray ); const texture = new DataTexture(); texture.image.data = data; texture.image.width = size; texture.image.height = size * size; texture.format = RGBAFormat; texture.type = UnsignedByteType; texture.magFilter = LinearFilter; texture.minFilter = LinearFilter; texture.wrapS = ClampToEdgeWrapping; texture.wrapT = ClampToEdgeWrapping; texture.generateMipmaps = false; texture.needsUpdate = true; const texture3D = new Data3DTexture(); texture3D.image.data = data; texture3D.image.width = size; texture3D.image.height = size; texture3D.image.depth = size; texture3D.format = RGBAFormat; texture3D.type = UnsignedByteType; texture3D.magFilter = LinearFilter; texture3D.minFilter = LinearFilter; texture3D.wrapS = ClampToEdgeWrapping; texture3D.wrapT = ClampToEdgeWrapping; texture3D.wrapR = ClampToEdgeWrapping; texture3D.generateMipmaps = false; texture3D.needsUpdate = true; return { size, texture, texture3D, }; } }"},{"title":"","date":"2023-10-12T14:08:40.690Z","updated":"2023-10-12T14:08:40.690Z","comments":true,"path":"js/three/jsm/loaders/LUTCubeLoader.js","permalink":"http://19999997.xyz/js/three/jsm/loaders/LUTCubeLoader.js","excerpt":"","text":"// https://wwwimages2.adobe.com/content/dam/acom/en/products/speedgrade/cc/pdfs/cube-lut-specification-1.0.pdf import { Loader, FileLoader, Vector3, DataTexture, Data3DTexture, UnsignedByteType, ClampToEdgeWrapping, LinearFilter, } from 'three'; export class LUTCubeLoader extends Loader { load( url, onLoad, onProgress, onError ) { const loader = new FileLoader( this.manager ); loader.setPath( this.path ); loader.setResponseType( 'text' ); loader.load( url, text => { try { onLoad( this.parse( text ) ); } catch ( e ) { if ( onError ) { onError( e ); } else { console.error( e ); } this.manager.itemError( url ); } }, onProgress, onError ); } parse( str ) { // Remove empty lines and comments str = str .replace( /^#.*?(\\n|\\r)/gm, '' ) .replace( /^\\s*?(\\n|\\r)/gm, '' ) .trim(); let title = null; let size = null; const domainMin = new Vector3( 0, 0, 0 ); const domainMax = new Vector3( 1, 1, 1 ); const lines = str.split( /[\\n\\r]+/g ); let data = null; let currIndex = 0; for ( let i = 0, l = lines.length; i < l; i ++ ) { const line = lines[ i ].trim(); const split = line.split( /\\s/g ); switch ( split[ 0 ] ) { case 'TITLE': title = line.substring( 7, line.length - 1 ); break; case 'LUT_3D_SIZE': // TODO: A .CUBE LUT file specifies floating point values and could be represented with // more precision than can be captured with Uint8Array. const sizeToken = split[ 1 ]; size = parseFloat( sizeToken ); data = new Uint8Array( size * size * size * 4 ); break; case 'DOMAIN_MIN': domainMin.x = parseFloat( split[ 1 ] ); domainMin.y = parseFloat( split[ 2 ] ); domainMin.z = parseFloat( split[ 3 ] ); break; case 'DOMAIN_MAX': domainMax.x = parseFloat( split[ 1 ] ); domainMax.y = parseFloat( split[ 2 ] ); domainMax.z = parseFloat( split[ 3 ] ); break; default: const r = parseFloat( split[ 0 ] ); const g = parseFloat( split[ 1 ] ); const b = parseFloat( split[ 2 ] ); if ( r > 1.0 || r < 0.0 || g > 1.0 || g < 0.0 || b > 1.0 || b < 0.0 ) { throw new Error( 'LUTCubeLoader : Non normalized values not supported.' ); } data[ currIndex + 0 ] = r * 255; data[ currIndex + 1 ] = g * 255; data[ currIndex + 2 ] = b * 255; data[ currIndex + 3 ] = 255; currIndex += 4; } } const texture = new DataTexture(); texture.image.data = data; texture.image.width = size; texture.image.height = size * size; texture.type = UnsignedByteType; texture.magFilter = LinearFilter; texture.minFilter = LinearFilter; texture.wrapS = ClampToEdgeWrapping; texture.wrapT = ClampToEdgeWrapping; texture.generateMipmaps = false; texture.needsUpdate = true; const texture3D = new Data3DTexture(); texture3D.image.data = data; texture3D.image.width = size; texture3D.image.height = size; texture3D.image.depth = size; texture3D.type = UnsignedByteType; texture3D.magFilter = LinearFilter; texture3D.minFilter = LinearFilter; texture3D.wrapS = ClampToEdgeWrapping; texture3D.wrapT = ClampToEdgeWrapping; texture3D.wrapR = ClampToEdgeWrapping; texture3D.generateMipmaps = false; texture3D.needsUpdate = true; return { title, size, domainMin, domainMax, texture, texture3D, }; } }"},{"title":"","date":"2023-10-12T14:08:40.684Z","updated":"2023-10-12T14:08:40.684Z","comments":true,"path":"js/three/jsm/loaders/LDrawLoader.js","permalink":"http://19999997.xyz/js/three/jsm/loaders/LDrawLoader.js","excerpt":"","text":"import { BufferAttribute, BufferGeometry, Color, FileLoader, Group, LineBasicMaterial, LineSegments, Loader, Matrix4, Mesh, MeshStandardMaterial, ShaderMaterial, SRGBColorSpace, UniformsLib, UniformsUtils, Vector3, Ray } from 'three'; // Special surface finish tag types. // Note: \"MATERIAL\" tag (e.g. GLITTER, SPECKLE) is not implemented const FINISH_TYPE_DEFAULT = 0; const FINISH_TYPE_CHROME = 1; const FINISH_TYPE_PEARLESCENT = 2; const FINISH_TYPE_RUBBER = 3; const FINISH_TYPE_MATTE_METALLIC = 4; const FINISH_TYPE_METAL = 5; // State machine to search a subobject path. // The LDraw standard establishes these various possible subfolders. const FILE_LOCATION_TRY_PARTS = 0; const FILE_LOCATION_TRY_P = 1; const FILE_LOCATION_TRY_MODELS = 2; const FILE_LOCATION_AS_IS = 3; const FILE_LOCATION_TRY_RELATIVE = 4; const FILE_LOCATION_TRY_ABSOLUTE = 5; const FILE_LOCATION_NOT_FOUND = 6; const MAIN_COLOUR_CODE = '16'; const MAIN_EDGE_COLOUR_CODE = '24'; const COLOR_SPACE_LDRAW = SRGBColorSpace; const _tempVec0 = new Vector3(); const _tempVec1 = new Vector3(); class LDrawConditionalLineMaterial extends ShaderMaterial { constructor( parameters ) { super( { uniforms: UniformsUtils.merge( [ UniformsLib.fog, { diffuse: { value: new Color() }, opacity: { value: 1.0 } } ] ), vertexShader: /* glsl */` attribute vec3 control0; attribute vec3 control1; attribute vec3 direction; varying float discardFlag; #include #include #include #include #include void main() { #include vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 ); gl_Position = projectionMatrix * mvPosition; // Transform the line segment ends and control points into camera clip space vec4 c0 = projectionMatrix * modelViewMatrix * vec4( control0, 1.0 ); vec4 c1 = projectionMatrix * modelViewMatrix * vec4( control1, 1.0 ); vec4 p0 = projectionMatrix * modelViewMatrix * vec4( position, 1.0 ); vec4 p1 = projectionMatrix * modelViewMatrix * vec4( position + direction, 1.0 ); c0.xy /= c0.w; c1.xy /= c1.w; p0.xy /= p0.w; p1.xy /= p1.w; // Get the direction of the segment and an orthogonal vector vec2 dir = p1.xy - p0.xy; vec2 norm = vec2( -dir.y, dir.x ); // Get control point directions from the line vec2 c0dir = c0.xy - p1.xy; vec2 c1dir = c1.xy - p1.xy; // If the vectors to the controls points are pointed in different directions away // from the line segment then the line should not be drawn. float d0 = dot( normalize( norm ), normalize( c0dir ) ); float d1 = dot( normalize( norm ), normalize( c1dir ) ); discardFlag = float( sign( d0 ) != sign( d1 ) ); #include #include #include } `, fragmentShader: /* glsl */` uniform vec3 diffuse; uniform float opacity; varying float discardFlag; #include #include #include #include #include void main() { if ( discardFlag > 0.5 ) discard; #include vec3 outgoingLight = vec3( 0.0 ); vec4 diffuseColor = vec4( diffuse, opacity ); #include #include outgoingLight = diffuseColor.rgb; // simple shader gl_FragColor = vec4( outgoingLight, diffuseColor.a ); #include #include #include #include } `, } ); Object.defineProperties( this, { opacity: { get: function () { return this.uniforms.opacity.value; }, set: function ( value ) { this.uniforms.opacity.value = value; } }, color: { get: function () { return this.uniforms.diffuse.value; } } } ); this.setValues( parameters ); this.isLDrawConditionalLineMaterial = true; } } class ConditionalLineSegments extends LineSegments { constructor( geometry, material ) { super( geometry, material ); this.isConditionalLine = true; } } function generateFaceNormals( faces ) { for ( let i = 0, l = faces.length; i < l; i ++ ) { const face = faces[ i ]; const vertices = face.vertices; const v0 = vertices[ 0 ]; const v1 = vertices[ 1 ]; const v2 = vertices[ 2 ]; _tempVec0.subVectors( v1, v0 ); _tempVec1.subVectors( v2, v1 ); face.faceNormal = new Vector3() .crossVectors( _tempVec0, _tempVec1 ) .normalize(); } } const _ray = new Ray(); function smoothNormals( faces, lineSegments, checkSubSegments = false ) { // NOTE: 1e2 is pretty coarse but was chosen to quantize the resulting value because // it allows edges to be smoothed as expected (see minifig arms). // -- // And the vector values are initialize multiplied by 1 + 1e-10 to account for floating // point errors on vertices along quantization boundaries. Ie after matrix multiplication // vertices that should be merged might be set to \"1.7\" and \"1.6999...\" meaning they won't // get merged. This added epsilon attempts to push these error values to the same quantized // value for the sake of hashing. See \"AT-ST mini\" dishes. See mrdoob/three#23169. const hashMultiplier = ( 1 + 1e-10 ) * 1e2; function hashVertex( v ) { const x = ~ ~ ( v.x * hashMultiplier ); const y = ~ ~ ( v.y * hashMultiplier ); const z = ~ ~ ( v.z * hashMultiplier ); return `${ x },${ y },${ z }`; } function hashEdge( v0, v1 ) { return `${ hashVertex( v0 ) }_${ hashVertex( v1 ) }`; } // converts the two vertices to a ray with a normalized direction and origin of 0, 0, 0 projected // onto the original line. function toNormalizedRay( v0, v1, targetRay ) { targetRay.direction.subVectors( v1, v0 ).normalize(); const scalar = v0.dot( targetRay.direction ); targetRay.origin.copy( v0 ).addScaledVector( targetRay.direction, - scalar ); return targetRay; } function hashRay( ray ) { return hashEdge( ray.origin, ray.direction ); } const hardEdges = new Set(); const hardEdgeRays = new Map(); const halfEdgeList = {}; const normals = []; // Save the list of hard edges by hash for ( let i = 0, l = lineSegments.length; i < l; i ++ ) { const ls = lineSegments[ i ]; const vertices = ls.vertices; const v0 = vertices[ 0 ]; const v1 = vertices[ 1 ]; hardEdges.add( hashEdge( v0, v1 ) ); hardEdges.add( hashEdge( v1, v0 ) ); // only generate the hard edge ray map if we're checking subsegments because it's more expensive to check // and requires more memory. if ( checkSubSegments ) { // add both ray directions to the map const ray = toNormalizedRay( v0, v1, new Ray() ); const rh1 = hashRay( ray ); if ( ! hardEdgeRays.has( rh1 ) ) { toNormalizedRay( v1, v0, ray ); const rh2 = hashRay( ray ); const info = { ray, distances: [], }; hardEdgeRays.set( rh1, info ); hardEdgeRays.set( rh2, info ); } // store both segments ends in min, max order in the distances array to check if a face edge is a // subsegment later. const info = hardEdgeRays.get( rh1 ); let d0 = info.ray.direction.dot( v0 ); let d1 = info.ray.direction.dot( v1 ); if ( d0 > d1 ) { [ d0, d1 ] = [ d1, d0 ]; } info.distances.push( d0, d1 ); } } // track the half edges associated with each triangle for ( let i = 0, l = faces.length; i < l; i ++ ) { const tri = faces[ i ]; const vertices = tri.vertices; const vertCount = vertices.length; for ( let i2 = 0; i2 < vertCount; i2 ++ ) { const index = i2; const next = ( i2 + 1 ) % vertCount; const v0 = vertices[ index ]; const v1 = vertices[ next ]; const hash = hashEdge( v0, v1 ); // don't add the triangle if the edge is supposed to be hard if ( hardEdges.has( hash ) ) { continue; } // if checking subsegments then check to see if this edge lies on a hard edge ray and whether its within any ray bounds if ( checkSubSegments ) { toNormalizedRay( v0, v1, _ray ); const rayHash = hashRay( _ray ); if ( hardEdgeRays.has( rayHash ) ) { const info = hardEdgeRays.get( rayHash ); const { ray, distances } = info; let d0 = ray.direction.dot( v0 ); let d1 = ray.direction.dot( v1 ); if ( d0 > d1 ) { [ d0, d1 ] = [ d1, d0 ]; } // return early if the face edge is found to be a subsegment of a line edge meaning the edge will have \"hard\" normals let found = false; for ( let i = 0, l = distances.length; i < l; i += 2 ) { if ( d0 >= distances[ i ] && d1 67.5 degrees then assume it's // hard edge. There are some cases where the line segments do not line up exactly // with or span multiple triangle edges (see Lunar Vehicle wheels). if ( Math.abs( otherTri.faceNormal.dot( tri.faceNormal ) ) < 0.25 ) { continue; } // if this triangle has already been traversed then it won't be in // the halfEdgeList. If it has not then add it to the queue and delete // it so it won't be found again. if ( reverseHash in halfEdgeList ) { queue.push( otherInfo ); delete halfEdgeList[ reverseHash ]; } // share the first normal const otherNext = ( otherIndex + 1 ) % otherVertCount; if ( vertNormals[ index ] && otherNormals[ otherNext ] && vertNormals[ index ] !== otherNormals[ otherNext ] ) { otherNormals[ otherNext ].norm.add( vertNormals[ index ].norm ); vertNormals[ index ].norm = otherNormals[ otherNext ].norm; } let sharedNormal1 = vertNormals[ index ] || otherNormals[ otherNext ]; if ( sharedNormal1 === null ) { // it's possible to encounter an edge of a triangle that has already been traversed meaning // both edges already have different normals defined and shared. To work around this we create // a wrapper object so when those edges are merged the normals can be updated everywhere. sharedNormal1 = { norm: new Vector3() }; normals.push( sharedNormal1.norm ); } if ( vertNormals[ index ] === null ) { vertNormals[ index ] = sharedNormal1; sharedNormal1.norm.add( faceNormal ); } if ( otherNormals[ otherNext ] === null ) { otherNormals[ otherNext ] = sharedNormal1; sharedNormal1.norm.add( otherFaceNormal ); } // share the second normal if ( vertNormals[ next ] && otherNormals[ otherIndex ] && vertNormals[ next ] !== otherNormals[ otherIndex ] ) { otherNormals[ otherIndex ].norm.add( vertNormals[ next ].norm ); vertNormals[ next ].norm = otherNormals[ otherIndex ].norm; } let sharedNormal2 = vertNormals[ next ] || otherNormals[ otherIndex ]; if ( sharedNormal2 === null ) { sharedNormal2 = { norm: new Vector3() }; normals.push( sharedNormal2.norm ); } if ( vertNormals[ next ] === null ) { vertNormals[ next ] = sharedNormal2; sharedNormal2.norm.add( faceNormal ); } if ( otherNormals[ otherIndex ] === null ) { otherNormals[ otherIndex ] = sharedNormal2; sharedNormal2.norm.add( otherFaceNormal ); } } } } } // The normals of each face have been added up so now we average them by normalizing the vector. for ( let i = 0, l = normals.length; i < l; i ++ ) { normals[ i ].normalize(); } } function isPartType( type ) { return type === 'Part' || type === 'Unofficial_Part'; } function isPrimitiveType( type ) { return /primitive/i.test( type ) || type === 'Subpart'; } class LineParser { constructor( line, lineNumber ) { this.line = line; this.lineLength = line.length; this.currentCharIndex = 0; this.currentChar = ' '; this.lineNumber = lineNumber; } seekNonSpace() { while ( this.currentCharIndex < this.lineLength ) { this.currentChar = this.line.charAt( this.currentCharIndex ); if ( this.currentChar !== ' ' && this.currentChar !== '\\t' ) { return; } this.currentCharIndex ++; } } getToken() { const pos0 = this.currentCharIndex ++; // Seek space while ( this.currentCharIndex < this.lineLength ) { this.currentChar = this.line.charAt( this.currentCharIndex ); if ( this.currentChar === ' ' || this.currentChar === '\\t' ) { break; } this.currentCharIndex ++; } const pos1 = this.currentCharIndex; this.seekNonSpace(); return this.line.substring( pos0, pos1 ); } getVector() { return new Vector3( parseFloat( this.getToken() ), parseFloat( this.getToken() ), parseFloat( this.getToken() ) ); } getRemainingString() { return this.line.substring( this.currentCharIndex, this.lineLength ); } isAtTheEnd() { return this.currentCharIndex >= this.lineLength; } setToEnd() { this.currentCharIndex = this.lineLength; } getLineNumberString() { return this.lineNumber >= 0 ? ' at line ' + this.lineNumber : ''; } } // Fetches and parses an intermediate representation of LDraw parts files. class LDrawParsedCache { constructor( loader ) { this.loader = loader; this._cache = {}; } cloneResult( original ) { const result = {}; // vertices are transformed and normals computed before being converted to geometry // so these pieces must be cloned. result.faces = original.faces.map( face => { return { colorCode: face.colorCode, material: face.material, vertices: face.vertices.map( v => v.clone() ), normals: face.normals.map( () => null ), faceNormal: null }; } ); result.conditionalSegments = original.conditionalSegments.map( face => { return { colorCode: face.colorCode, material: face.material, vertices: face.vertices.map( v => v.clone() ), controlPoints: face.controlPoints.map( v => v.clone() ) }; } ); result.lineSegments = original.lineSegments.map( face => { return { colorCode: face.colorCode, material: face.material, vertices: face.vertices.map( v => v.clone() ) }; } ); // none if this is subsequently modified result.type = original.type; result.category = original.category; result.keywords = original.keywords; result.author = original.author; result.subobjects = original.subobjects; result.fileName = original.fileName; result.totalFaces = original.totalFaces; result.startingBuildingStep = original.startingBuildingStep; result.materials = original.materials; result.group = null; return result; } async fetchData( fileName ) { let triedLowerCase = false; let locationState = FILE_LOCATION_TRY_PARTS; while ( locationState !== FILE_LOCATION_NOT_FOUND ) { let subobjectURL = fileName; switch ( locationState ) { case FILE_LOCATION_AS_IS: locationState = locationState + 1; break; case FILE_LOCATION_TRY_PARTS: subobjectURL = 'parts/' + subobjectURL; locationState = locationState + 1; break; case FILE_LOCATION_TRY_P: subobjectURL = 'p/' + subobjectURL; locationState = locationState + 1; break; case FILE_LOCATION_TRY_MODELS: subobjectURL = 'models/' + subobjectURL; locationState = locationState + 1; break; case FILE_LOCATION_TRY_RELATIVE: subobjectURL = fileName.substring( 0, fileName.lastIndexOf( '/' ) + 1 ) + subobjectURL; locationState = locationState + 1; break; case FILE_LOCATION_TRY_ABSOLUTE: if ( triedLowerCase ) { // Try absolute path locationState = FILE_LOCATION_NOT_FOUND; } else { // Next attempt is lower case fileName = fileName.toLowerCase(); subobjectURL = fileName; triedLowerCase = true; locationState = FILE_LOCATION_TRY_PARTS; } break; } const loader = this.loader; const fileLoader = new FileLoader( loader.manager ); fileLoader.setPath( loader.partsLibraryPath ); fileLoader.setRequestHeader( loader.requestHeader ); fileLoader.setWithCredentials( loader.withCredentials ); try { const text = await fileLoader.loadAsync( subobjectURL ); return text; } catch ( _ ) { continue; } } throw new Error( 'LDrawLoader: Subobject \"' + fileName + '\" could not be loaded.' ); } parse( text, fileName = null ) { const loader = this.loader; // final results const faces = []; const lineSegments = []; const conditionalSegments = []; const subobjects = []; const materials = {}; const getLocalMaterial = colorCode => { return materials[ colorCode ] || null; }; let type = 'Model'; let category = null; let keywords = null; let author = null; let totalFaces = 0; // split into lines if ( text.indexOf( '\\r\\n' ) !== - 1 ) { // This is faster than String.split with regex that splits on both text = text.replace( /\\r\\n/g, '\\n' ); } const lines = text.split( '\\n' ); const numLines = lines.length; let parsingEmbeddedFiles = false; let currentEmbeddedFileName = null; let currentEmbeddedText = null; let bfcCertified = false; let bfcCCW = true; let bfcInverted = false; let bfcCull = true; let startingBuildingStep = false; // Parse all line commands for ( let lineIndex = 0; lineIndex < numLines; lineIndex ++ ) { const line = lines[ lineIndex ]; if ( line.length === 0 ) continue; if ( parsingEmbeddedFiles ) { if ( line.startsWith( '0 FILE ' ) ) { // Save previous embedded file in the cache this.setData( currentEmbeddedFileName, currentEmbeddedText ); // New embedded text file currentEmbeddedFileName = line.substring( 7 ); currentEmbeddedText = ''; } else { currentEmbeddedText += line + '\\n'; } continue; } const lp = new LineParser( line, lineIndex + 1 ); lp.seekNonSpace(); if ( lp.isAtTheEnd() ) { // Empty line continue; } // Parse the line type const lineType = lp.getToken(); let material; let colorCode; let segment; let ccw; let doubleSided; let v0, v1, v2, v3, c0, c1; switch ( lineType ) { // Line type 0: Comment or META case '0': // Parse meta directive const meta = lp.getToken(); if ( meta ) { switch ( meta ) { case '!LDRAW_ORG': type = lp.getToken(); break; case '!COLOUR': material = loader.parseColorMetaDirective( lp ); if ( material ) { materials[ material.userData.code ] = material; } else { console.warn( 'LDrawLoader: Error parsing material' + lp.getLineNumberString() ); } break; case '!CATEGORY': category = lp.getToken(); break; case '!KEYWORDS': const newKeywords = lp.getRemainingString().split( ',' ); if ( newKeywords.length > 0 ) { if ( ! keywords ) { keywords = []; } newKeywords.forEach( function ( keyword ) { keywords.push( keyword.trim() ); } ); } break; case 'FILE': if ( lineIndex > 0 ) { // Start embedded text files parsing parsingEmbeddedFiles = true; currentEmbeddedFileName = lp.getRemainingString(); currentEmbeddedText = ''; bfcCertified = false; bfcCCW = true; } break; case 'BFC': // Changes to the backface culling state while ( ! lp.isAtTheEnd() ) { const token = lp.getToken(); switch ( token ) { case 'CERTIFY': case 'NOCERTIFY': bfcCertified = token === 'CERTIFY'; bfcCCW = true; break; case 'CW': case 'CCW': bfcCCW = token === 'CCW'; break; case 'INVERTNEXT': bfcInverted = true; break; case 'CLIP': case 'NOCLIP': bfcCull = token === 'CLIP'; break; default: console.warn( 'THREE.LDrawLoader: BFC directive \"' + token + '\" is unknown.' ); break; } } break; case 'STEP': startingBuildingStep = true; break; case 'Author:': author = lp.getToken(); break; default: // Other meta directives are not implemented break; } } break; // Line type 1: Sub-object file case '1': colorCode = lp.getToken(); material = getLocalMaterial( colorCode ); const posX = parseFloat( lp.getToken() ); const posY = parseFloat( lp.getToken() ); const posZ = parseFloat( lp.getToken() ); const m0 = parseFloat( lp.getToken() ); const m1 = parseFloat( lp.getToken() ); const m2 = parseFloat( lp.getToken() ); const m3 = parseFloat( lp.getToken() ); const m4 = parseFloat( lp.getToken() ); const m5 = parseFloat( lp.getToken() ); const m6 = parseFloat( lp.getToken() ); const m7 = parseFloat( lp.getToken() ); const m8 = parseFloat( lp.getToken() ); const matrix = new Matrix4().set( m0, m1, m2, posX, m3, m4, m5, posY, m6, m7, m8, posZ, 0, 0, 0, 1 ); let fileName = lp.getRemainingString().trim().replace( /\\\\/g, '/' ); if ( loader.fileMap[ fileName ] ) { // Found the subobject path in the preloaded file path map fileName = loader.fileMap[ fileName ]; } else { // Standardized subfolders if ( fileName.startsWith( 's/' ) ) { fileName = 'parts/' + fileName; } else if ( fileName.startsWith( '48/' ) ) { fileName = 'p/' + fileName; } } subobjects.push( { material: material, colorCode: colorCode, matrix: matrix, fileName: fileName, inverted: bfcInverted, startingBuildingStep: startingBuildingStep } ); startingBuildingStep = false; bfcInverted = false; break; // Line type 2: Line segment case '2': colorCode = lp.getToken(); material = getLocalMaterial( colorCode ); v0 = lp.getVector(); v1 = lp.getVector(); segment = { material: material, colorCode: colorCode, vertices: [ v0, v1 ], }; lineSegments.push( segment ); break; // Line type 5: Conditional Line segment case '5': colorCode = lp.getToken(); material = getLocalMaterial( colorCode ); v0 = lp.getVector(); v1 = lp.getVector(); c0 = lp.getVector(); c1 = lp.getVector(); segment = { material: material, colorCode: colorCode, vertices: [ v0, v1 ], controlPoints: [ c0, c1 ], }; conditionalSegments.push( segment ); break; // Line type 3: Triangle case '3': colorCode = lp.getToken(); material = getLocalMaterial( colorCode ); ccw = bfcCCW; doubleSided = ! bfcCertified || ! bfcCull; if ( ccw === true ) { v0 = lp.getVector(); v1 = lp.getVector(); v2 = lp.getVector(); } else { v2 = lp.getVector(); v1 = lp.getVector(); v0 = lp.getVector(); } faces.push( { material: material, colorCode: colorCode, faceNormal: null, vertices: [ v0, v1, v2 ], normals: [ null, null, null ], } ); totalFaces ++; if ( doubleSided === true ) { faces.push( { material: material, colorCode: colorCode, faceNormal: null, vertices: [ v2, v1, v0 ], normals: [ null, null, null ], } ); totalFaces ++; } break; // Line type 4: Quadrilateral case '4': colorCode = lp.getToken(); material = getLocalMaterial( colorCode ); ccw = bfcCCW; doubleSided = ! bfcCertified || ! bfcCull; if ( ccw === true ) { v0 = lp.getVector(); v1 = lp.getVector(); v2 = lp.getVector(); v3 = lp.getVector(); } else { v3 = lp.getVector(); v2 = lp.getVector(); v1 = lp.getVector(); v0 = lp.getVector(); } // specifically place the triangle diagonal in the v0 and v1 slots so we can // account for the doubling of vertices later when smoothing normals. faces.push( { material: material, colorCode: colorCode, faceNormal: null, vertices: [ v0, v1, v2, v3 ], normals: [ null, null, null, null ], } ); totalFaces += 2; if ( doubleSided === true ) { faces.push( { material: material, colorCode: colorCode, faceNormal: null, vertices: [ v3, v2, v1, v0 ], normals: [ null, null, null, null ], } ); totalFaces += 2; } break; default: throw new Error( 'LDrawLoader: Unknown line type \"' + lineType + '\"' + lp.getLineNumberString() + '.' ); } } if ( parsingEmbeddedFiles ) { this.setData( currentEmbeddedFileName, currentEmbeddedText ); } return { faces, conditionalSegments, lineSegments, type, category, keywords, author, subobjects, totalFaces, startingBuildingStep, materials, fileName, group: null }; } // returns an (optionally cloned) instance of the data getData( fileName, clone = true ) { const key = fileName.toLowerCase(); const result = this._cache[ key ]; if ( result === null || result instanceof Promise ) { return null; } if ( clone ) { return this.cloneResult( result ); } else { return result; } } // kicks off a fetch and parse of the requested data if it hasn't already been loaded. Returns when // the data is ready to use and can be retrieved synchronously with \"getData\". async ensureDataLoaded( fileName ) { const key = fileName.toLowerCase(); if ( ! ( key in this._cache ) ) { // replace the promise with a copy of the parsed data for immediate processing this._cache[ key ] = this.fetchData( fileName ).then( text => { const info = this.parse( text, fileName ); this._cache[ key ] = info; return info; } ); } await this._cache[ key ]; } // sets the data in the cache from parsed data setData( fileName, text ) { const key = fileName.toLowerCase(); this._cache[ key ] = this.parse( text, fileName ); } } // returns the material for an associated color code. If the color code is 16 for a face or 24 for // an edge then the passthroughColorCode is used. function getMaterialFromCode( colorCode, parentColorCode, materialHierarchy, forEdge ) { const isPassthrough = ! forEdge && colorCode === MAIN_COLOUR_CODE || forEdge && colorCode === MAIN_EDGE_COLOUR_CODE; if ( isPassthrough ) { colorCode = parentColorCode; } return materialHierarchy[ colorCode ] || null; } // Class used to parse and build LDraw parts as three.js objects and cache them if they're a \"Part\" type. class LDrawPartsGeometryCache { constructor( loader ) { this.loader = loader; this.parseCache = new LDrawParsedCache( loader ); this._cache = {}; } // Convert the given file information into a mesh by processing subobjects. async processIntoMesh( info ) { const loader = this.loader; const parseCache = this.parseCache; const faceMaterials = new Set(); // Processes the part subobject information to load child parts and merge geometry onto part // piece object. const processInfoSubobjects = async ( info, subobject = null ) => { const subobjects = info.subobjects; const promises = []; // Trigger load of all subobjects. If a subobject isn't a primitive then load it as a separate // group which lets instruction steps apply correctly. for ( let i = 0, l = subobjects.length; i < l; i ++ ) { const subobject = subobjects[ i ]; const promise = parseCache.ensureDataLoaded( subobject.fileName ).then( () => { const subobjectInfo = parseCache.getData( subobject.fileName, false ); if ( ! isPrimitiveType( subobjectInfo.type ) ) { return this.loadModel( subobject.fileName ).catch( error => { console.warn( error ); return null; } ); } return processInfoSubobjects( parseCache.getData( subobject.fileName ), subobject ); } ); promises.push( promise ); } const group = new Group(); group.userData.category = info.category; group.userData.keywords = info.keywords; group.userData.author = info.author; group.userData.type = info.type; group.userData.fileName = info.fileName; info.group = group; const subobjectInfos = await Promise.all( promises ); for ( let i = 0, l = subobjectInfos.length; i < l; i ++ ) { const subobject = info.subobjects[ i ]; const subobjectInfo = subobjectInfos[ i ]; if ( subobjectInfo === null ) { // the subobject failed to load continue; } // if the subobject was loaded as a separate group then apply the parent scopes materials if ( subobjectInfo.isGroup ) { const subobjectGroup = subobjectInfo; subobject.matrix.decompose( subobjectGroup.position, subobjectGroup.quaternion, subobjectGroup.scale ); subobjectGroup.userData.startingBuildingStep = subobject.startingBuildingStep; subobjectGroup.name = subobject.fileName; loader.applyMaterialsToMesh( subobjectGroup, subobject.colorCode, info.materials ); subobjectGroup.userData.colorCode = subobject.colorCode; group.add( subobjectGroup ); continue; } // add the subobject group if it has children in case it has both children and primitives if ( subobjectInfo.group.children.length ) { group.add( subobjectInfo.group ); } // transform the primitives into the local space of the parent piece and append them to // to the parent primitives list. const parentLineSegments = info.lineSegments; const parentConditionalSegments = info.conditionalSegments; const parentFaces = info.faces; const lineSegments = subobjectInfo.lineSegments; const conditionalSegments = subobjectInfo.conditionalSegments; const faces = subobjectInfo.faces; const matrix = subobject.matrix; const inverted = subobject.inverted; const matrixScaleInverted = matrix.determinant() < 0; const colorCode = subobject.colorCode; const lineColorCode = colorCode === MAIN_COLOUR_CODE ? MAIN_EDGE_COLOUR_CODE : colorCode; for ( let i = 0, l = lineSegments.length; i < l; i ++ ) { const ls = lineSegments[ i ]; const vertices = ls.vertices; vertices[ 0 ].applyMatrix4( matrix ); vertices[ 1 ].applyMatrix4( matrix ); ls.colorCode = ls.colorCode === MAIN_EDGE_COLOUR_CODE ? lineColorCode : ls.colorCode; ls.material = ls.material || getMaterialFromCode( ls.colorCode, ls.colorCode, info.materials, true ); parentLineSegments.push( ls ); } for ( let i = 0, l = conditionalSegments.length; i < l; i ++ ) { const os = conditionalSegments[ i ]; const vertices = os.vertices; const controlPoints = os.controlPoints; vertices[ 0 ].applyMatrix4( matrix ); vertices[ 1 ].applyMatrix4( matrix ); controlPoints[ 0 ].applyMatrix4( matrix ); controlPoints[ 1 ].applyMatrix4( matrix ); os.colorCode = os.colorCode === MAIN_EDGE_COLOUR_CODE ? lineColorCode : os.colorCode; os.material = os.material || getMaterialFromCode( os.colorCode, os.colorCode, info.materials, true ); parentConditionalSegments.push( os ); } for ( let i = 0, l = faces.length; i < l; i ++ ) { const tri = faces[ i ]; const vertices = tri.vertices; for ( let i = 0, l = vertices.length; i < l; i ++ ) { vertices[ i ].applyMatrix4( matrix ); } tri.colorCode = tri.colorCode === MAIN_COLOUR_CODE ? colorCode : tri.colorCode; tri.material = tri.material || getMaterialFromCode( tri.colorCode, colorCode, info.materials, false ); faceMaterials.add( tri.colorCode ); // If the scale of the object is negated then the triangle winding order // needs to be flipped. if ( matrixScaleInverted !== inverted ) { vertices.reverse(); } parentFaces.push( tri ); } info.totalFaces += subobjectInfo.totalFaces; } // Apply the parent subobjects pass through material code to this object. This is done several times due // to material scoping. if ( subobject ) { loader.applyMaterialsToMesh( group, subobject.colorCode, info.materials ); group.userData.colorCode = subobject.colorCode; } return info; }; // Track material use to see if we need to use the normal smooth slow path for hard edges. for ( let i = 0, l = info.faces; i < l; i ++ ) { faceMaterials.add( info.faces[ i ].colorCode ); } await processInfoSubobjects( info ); if ( loader.smoothNormals ) { const checkSubSegments = faceMaterials.size > 1; generateFaceNormals( info.faces ); smoothNormals( info.faces, info.lineSegments, checkSubSegments ); } // Add the primitive objects and metadata. const group = info.group; if ( info.faces.length > 0 ) { group.add( createObject( this.loader, info.faces, 3, false, info.totalFaces ) ); } if ( info.lineSegments.length > 0 ) { group.add( createObject( this.loader, info.lineSegments, 2 ) ); } if ( info.conditionalSegments.length > 0 ) { group.add( createObject( this.loader, info.conditionalSegments, 2, true ) ); } return group; } hasCachedModel( fileName ) { return fileName !== null && fileName.toLowerCase() in this._cache; } async getCachedModel( fileName ) { if ( fileName !== null && this.hasCachedModel( fileName ) ) { const key = fileName.toLowerCase(); const group = await this._cache[ key ]; return group.clone(); } else { return null; } } // Loads and parses the model with the given file name. Returns a cached copy if available. async loadModel( fileName ) { const parseCache = this.parseCache; const key = fileName.toLowerCase(); if ( this.hasCachedModel( fileName ) ) { // Return cached model if available. return this.getCachedModel( fileName ); } else { // Otherwise parse a new model. // Ensure the file data is loaded and pre parsed. await parseCache.ensureDataLoaded( fileName ); const info = parseCache.getData( fileName ); const promise = this.processIntoMesh( info ); // Now that the file has loaded it's possible that another part parse has been waiting in parallel // so check the cache again to see if it's been added since the last async operation so we don't // do unnecessary work. if ( this.hasCachedModel( fileName ) ) { return this.getCachedModel( fileName ); } // Cache object if it's a part so it can be reused later. if ( isPartType( info.type ) ) { this._cache[ key ] = promise; } // return a copy const group = await promise; return group.clone(); } } // parses the given model text into a renderable object. Returns cached copy if available. async parseModel( text ) { const parseCache = this.parseCache; const info = parseCache.parse( text ); if ( isPartType( info.type ) && this.hasCachedModel( info.fileName ) ) { return this.getCachedModel( info.fileName ); } return this.processIntoMesh( info ); } } function sortByMaterial( a, b ) { if ( a.colorCode === b.colorCode ) { return 0; } if ( a.colorCode < b.colorCode ) { return - 1; } return 1; } function createObject( loader, elements, elementSize, isConditionalSegments = false, totalElements = null ) { // Creates a LineSegments (elementSize = 2) or a Mesh (elementSize = 3 ) // With per face / segment material, implemented with mesh groups and materials array // Sort the faces or line segments by color code to make later the mesh groups elements.sort( sortByMaterial ); if ( totalElements === null ) { totalElements = elements.length; } const positions = new Float32Array( elementSize * totalElements * 3 ); const normals = elementSize === 3 ? new Float32Array( elementSize * totalElements * 3 ) : null; const materials = []; const quadArray = new Array( 6 ); const bufferGeometry = new BufferGeometry(); let prevMaterial = null; let index0 = 0; let numGroupVerts = 0; let offset = 0; for ( let iElem = 0, nElem = elements.length; iElem < nElem; iElem ++ ) { const elem = elements[ iElem ]; let vertices = elem.vertices; if ( vertices.length === 4 ) { quadArray[ 0 ] = vertices[ 0 ]; quadArray[ 1 ] = vertices[ 1 ]; quadArray[ 2 ] = vertices[ 2 ]; quadArray[ 3 ] = vertices[ 0 ]; quadArray[ 4 ] = vertices[ 2 ]; quadArray[ 5 ] = vertices[ 3 ]; vertices = quadArray; } for ( let j = 0, l = vertices.length; j < l; j ++ ) { const v = vertices[ j ]; const index = offset + j * 3; positions[ index + 0 ] = v.x; positions[ index + 1 ] = v.y; positions[ index + 2 ] = v.z; } // create the normals array if this is a set of faces if ( elementSize === 3 ) { if ( ! elem.faceNormal ) { const v0 = vertices[ 0 ]; const v1 = vertices[ 1 ]; const v2 = vertices[ 2 ]; _tempVec0.subVectors( v1, v0 ); _tempVec1.subVectors( v2, v1 ); elem.faceNormal = new Vector3() .crossVectors( _tempVec0, _tempVec1 ) .normalize(); } let elemNormals = elem.normals; if ( elemNormals.length === 4 ) { quadArray[ 0 ] = elemNormals[ 0 ]; quadArray[ 1 ] = elemNormals[ 1 ]; quadArray[ 2 ] = elemNormals[ 2 ]; quadArray[ 3 ] = elemNormals[ 0 ]; quadArray[ 4 ] = elemNormals[ 2 ]; quadArray[ 5 ] = elemNormals[ 3 ]; elemNormals = quadArray; } for ( let j = 0, l = elemNormals.length; j < l; j ++ ) { // use face normal if a vertex normal is not provided let n = elem.faceNormal; if ( elemNormals[ j ] ) { n = elemNormals[ j ].norm; } const index = offset + j * 3; normals[ index + 0 ] = n.x; normals[ index + 1 ] = n.y; normals[ index + 2 ] = n.z; } } if ( prevMaterial !== elem.colorCode ) { if ( prevMaterial !== null ) { bufferGeometry.addGroup( index0, numGroupVerts, materials.length - 1 ); } const material = elem.material; if ( material !== null ) { if ( elementSize === 3 ) { materials.push( material ); } else if ( elementSize === 2 ) { if ( isConditionalSegments ) { const edgeMaterial = loader.edgeMaterialCache.get( material ); materials.push( loader.conditionalEdgeMaterialCache.get( edgeMaterial ) ); } else { materials.push( loader.edgeMaterialCache.get( material ) ); } } } else { // If a material has not been made available yet then keep the color code string in the material array // to save the spot for the material once a parent scopes materials are being applied to the object. materials.push( elem.colorCode ); } prevMaterial = elem.colorCode; index0 = offset / 3; numGroupVerts = vertices.length; } else { numGroupVerts += vertices.length; } offset += 3 * vertices.length; } if ( numGroupVerts > 0 ) { bufferGeometry.addGroup( index0, Infinity, materials.length - 1 ); } bufferGeometry.setAttribute( 'position', new BufferAttribute( positions, 3 ) ); if ( normals !== null ) { bufferGeometry.setAttribute( 'normal', new BufferAttribute( normals, 3 ) ); } let object3d = null; if ( elementSize === 2 ) { if ( isConditionalSegments ) { object3d = new ConditionalLineSegments( bufferGeometry, materials.length === 1 ? materials[ 0 ] : materials ); } else { object3d = new LineSegments( bufferGeometry, materials.length === 1 ? materials[ 0 ] : materials ); } } else if ( elementSize === 3 ) { object3d = new Mesh( bufferGeometry, materials.length === 1 ? materials[ 0 ] : materials ); } if ( isConditionalSegments ) { object3d.isConditionalLine = true; const controlArray0 = new Float32Array( elements.length * 3 * 2 ); const controlArray1 = new Float32Array( elements.length * 3 * 2 ); const directionArray = new Float32Array( elements.length * 3 * 2 ); for ( let i = 0, l = elements.length; i < l; i ++ ) { const os = elements[ i ]; const vertices = os.vertices; const controlPoints = os.controlPoints; const c0 = controlPoints[ 0 ]; const c1 = controlPoints[ 1 ]; const v0 = vertices[ 0 ]; const v1 = vertices[ 1 ]; const index = i * 3 * 2; controlArray0[ index + 0 ] = c0.x; controlArray0[ index + 1 ] = c0.y; controlArray0[ index + 2 ] = c0.z; controlArray0[ index + 3 ] = c0.x; controlArray0[ index + 4 ] = c0.y; controlArray0[ index + 5 ] = c0.z; controlArray1[ index + 0 ] = c1.x; controlArray1[ index + 1 ] = c1.y; controlArray1[ index + 2 ] = c1.z; controlArray1[ index + 3 ] = c1.x; controlArray1[ index + 4 ] = c1.y; controlArray1[ index + 5 ] = c1.z; directionArray[ index + 0 ] = v1.x - v0.x; directionArray[ index + 1 ] = v1.y - v0.y; directionArray[ index + 2 ] = v1.z - v0.z; directionArray[ index + 3 ] = v1.x - v0.x; directionArray[ index + 4 ] = v1.y - v0.y; directionArray[ index + 5 ] = v1.z - v0.z; } bufferGeometry.setAttribute( 'control0', new BufferAttribute( controlArray0, 3, false ) ); bufferGeometry.setAttribute( 'control1', new BufferAttribute( controlArray1, 3, false ) ); bufferGeometry.setAttribute( 'direction', new BufferAttribute( directionArray, 3, false ) ); } return object3d; } // class LDrawLoader extends Loader { constructor( manager ) { super( manager ); // Array of THREE.Material this.materials = []; this.materialLibrary = {}; this.edgeMaterialCache = new WeakMap(); this.conditionalEdgeMaterialCache = new WeakMap(); // This also allows to handle the embedded text files (\"0 FILE\" lines) this.partsCache = new LDrawPartsGeometryCache( this ); // This object is a map from file names to paths. It agilizes the paths search. If it is not set then files will be searched by trial and error. this.fileMap = {}; // Initializes the materials library with default materials this.setMaterials( [] ); // If this flag is set to true the vertex normals will be smoothed. this.smoothNormals = true; // The path to load parts from the LDraw parts library from. this.partsLibraryPath = ''; // Material assigned to not available colors for meshes and edges this.missingColorMaterial = new MeshStandardMaterial( { name: Loader.DEFAULT_MATERIAL_NAME, color: 0xFF00FF, roughness: 0.3, metalness: 0 } ); this.missingEdgeColorMaterial = new LineBasicMaterial( { name: Loader.DEFAULT_MATERIAL_NAME, color: 0xFF00FF } ); this.missingConditionalEdgeColorMaterial = new LDrawConditionalLineMaterial( { name: Loader.DEFAULT_MATERIAL_NAME, fog: true, color: 0xFF00FF } ); this.edgeMaterialCache.set( this.missingColorMaterial, this.missingEdgeColorMaterial ); this.conditionalEdgeMaterialCache.set( this.missingEdgeColorMaterial, this.missingConditionalEdgeColorMaterial ); } setPartsLibraryPath( path ) { this.partsLibraryPath = path; return this; } async preloadMaterials( url ) { const fileLoader = new FileLoader( this.manager ); fileLoader.setPath( this.path ); fileLoader.setRequestHeader( this.requestHeader ); fileLoader.setWithCredentials( this.withCredentials ); const text = await fileLoader.loadAsync( url ); const colorLineRegex = /^0 !COLOUR/; const lines = text.split( /[\\n\\r]/g ); const materials = []; for ( let i = 0, l = lines.length; i < l; i ++ ) { const line = lines[ i ]; if ( colorLineRegex.test( line ) ) { const directive = line.replace( colorLineRegex, '' ); const material = this.parseColorMetaDirective( new LineParser( directive ) ); materials.push( material ); } } this.setMaterials( materials ); } load( url, onLoad, onProgress, onError ) { const fileLoader = new FileLoader( this.manager ); fileLoader.setPath( this.path ); fileLoader.setRequestHeader( this.requestHeader ); fileLoader.setWithCredentials( this.withCredentials ); fileLoader.load( url, text => { this.partsCache .parseModel( text, this.materialLibrary ) .then( group => { this.applyMaterialsToMesh( group, MAIN_COLOUR_CODE, this.materialLibrary, true ); this.computeBuildingSteps( group ); group.userData.fileName = url; onLoad( group ); } ) .catch( onError ); }, onProgress, onError ); } parse( text, onLoad ) { this.partsCache .parseModel( text, this.materialLibrary ) .then( group => { this.applyMaterialsToMesh( group, MAIN_COLOUR_CODE, this.materialLibrary, true ); this.computeBuildingSteps( group ); group.userData.fileName = ''; onLoad( group ); } ); } setMaterials( materials ) { this.materialLibrary = {}; this.materials = []; for ( let i = 0, l = materials.length; i < l; i ++ ) { this.addMaterial( materials[ i ] ); } // Add default main triangle and line edge materials (used in pieces that can be colored with a main color) this.addMaterial( this.parseColorMetaDirective( new LineParser( 'Main_Colour CODE 16 VALUE #FF8080 EDGE #333333' ) ) ); this.addMaterial( this.parseColorMetaDirective( new LineParser( 'Edge_Colour CODE 24 VALUE #A0A0A0 EDGE #333333' ) ) ); return this; } setFileMap( fileMap ) { this.fileMap = fileMap; return this; } addMaterial( material ) { // Adds a material to the material library which is on top of the parse scopes stack. And also to the materials array const matLib = this.materialLibrary; if ( ! matLib[ material.userData.code ] ) { this.materials.push( material ); matLib[ material.userData.code ] = material; } return this; } getMaterial( colorCode ) { if ( colorCode.startsWith( '0x2' ) ) { // Special 'direct' material value (RGB color) const color = colorCode.substring( 3 ); return this.parseColorMetaDirective( new LineParser( 'Direct_Color_' + color + ' CODE -1 VALUE #' + color + ' EDGE #' + color + '' ) ); } return this.materialLibrary[ colorCode ] || null; } // Applies the appropriate materials to a prebuilt hierarchy of geometry. Assumes that color codes are present // in the material array if they need to be filled in. applyMaterialsToMesh( group, parentColorCode, materialHierarchy, finalMaterialPass = false ) { // find any missing materials as indicated by a color code string and replace it with a material from the current material lib const loader = this; const parentIsPassthrough = parentColorCode === MAIN_COLOUR_CODE; group.traverse( c => { if ( c.isMesh || c.isLineSegments ) { if ( Array.isArray( c.material ) ) { for ( let i = 0, l = c.material.length; i < l; i ++ ) { if ( ! c.material[ i ].isMaterial ) { c.material[ i ] = getMaterial( c, c.material[ i ] ); } } } else if ( ! c.material.isMaterial ) { c.material = getMaterial( c, c.material ); } } } ); // Returns the appropriate material for the object (line or face) given color code. If the code is \"pass through\" // (24 for lines, 16 for edges) then the pass through color code is used. If that is also pass through then it's // simply returned for the subsequent material application. function getMaterial( c, colorCode ) { // if our parent is a passthrough color code and we don't have the current material color available then // return early. if ( parentIsPassthrough && ! ( colorCode in materialHierarchy ) && ! finalMaterialPass ) { return colorCode; } const forEdge = c.isLineSegments || c.isConditionalLine; const isPassthrough = ! forEdge && colorCode === MAIN_COLOUR_CODE || forEdge && colorCode === MAIN_EDGE_COLOUR_CODE; if ( isPassthrough ) { colorCode = parentColorCode; } let material = null; if ( colorCode in materialHierarchy ) { material = materialHierarchy[ colorCode ]; } else if ( finalMaterialPass ) { // see if we can get the final material from from the \"getMaterial\" function which will attempt to // parse the \"direct\" colors material = loader.getMaterial( colorCode ); if ( material === null ) { // otherwise throw a warning if this is final opportunity to set the material console.warn( `LDrawLoader: Material properties for code ${ colorCode } not available.` ); // And return the 'missing color' material material = loader.missingColorMaterial; } } else { return colorCode; } if ( c.isLineSegments ) { material = loader.edgeMaterialCache.get( material ); if ( c.isConditionalLine ) { material = loader.conditionalEdgeMaterialCache.get( material ); } } return material; } } getMainMaterial() { return this.getMaterial( MAIN_COLOUR_CODE ); } getMainEdgeMaterial() { const mat = this.getMaterial( MAIN_EDGE_COLOUR_CODE ); return mat ? this.edgeMaterialCache.get( mat ) : null; } parseColorMetaDirective( lineParser ) { // Parses a color definition and returns a THREE.Material let code = null; // Triangle and line colors let fillColor = '#FF00FF'; let edgeColor = '#FF00FF'; // Transparency let alpha = 1; let isTransparent = false; // Self-illumination: let luminance = 0; let finishType = FINISH_TYPE_DEFAULT; let edgeMaterial = null; const name = lineParser.getToken(); if ( ! name ) { throw new Error( 'LDrawLoader: Material name was expected after \"!COLOUR tag' + lineParser.getLineNumberString() + '.' ); } // Parse tag tokens and their parameters let token = null; while ( true ) { token = lineParser.getToken(); if ( ! token ) { break; } if ( ! parseLuminance( token ) ) { switch ( token.toUpperCase() ) { case 'CODE': code = lineParser.getToken(); break; case 'VALUE': fillColor = lineParser.getToken(); if ( fillColor.startsWith( '0x' ) ) { fillColor = '#' + fillColor.substring( 2 ); } else if ( ! fillColor.startsWith( '#' ) ) { throw new Error( 'LDrawLoader: Invalid color while parsing material' + lineParser.getLineNumberString() + '.' ); } break; case 'EDGE': edgeColor = lineParser.getToken(); if ( edgeColor.startsWith( '0x' ) ) { edgeColor = '#' + edgeColor.substring( 2 ); } else if ( ! edgeColor.startsWith( '#' ) ) { // Try to see if edge color is a color code edgeMaterial = this.getMaterial( edgeColor ); if ( ! edgeMaterial ) { throw new Error( 'LDrawLoader: Invalid edge color while parsing material' + lineParser.getLineNumberString() + '.' ); } // Get the edge material for this triangle material edgeMaterial = this.edgeMaterialCache.get( edgeMaterial ); } break; case 'ALPHA': alpha = parseInt( lineParser.getToken() ); if ( isNaN( alpha ) ) { throw new Error( 'LDrawLoader: Invalid alpha value in material definition' + lineParser.getLineNumberString() + '.' ); } alpha = Math.max( 0, Math.min( 1, alpha / 255 ) ); if ( alpha < 1 ) { isTransparent = true; } break; case 'LUMINANCE': if ( ! parseLuminance( lineParser.getToken() ) ) { throw new Error( 'LDrawLoader: Invalid luminance value in material definition' + LineParser.getLineNumberString() + '.' ); } break; case 'CHROME': finishType = FINISH_TYPE_CHROME; break; case 'PEARLESCENT': finishType = FINISH_TYPE_PEARLESCENT; break; case 'RUBBER': finishType = FINISH_TYPE_RUBBER; break; case 'MATTE_METALLIC': finishType = FINISH_TYPE_MATTE_METALLIC; break; case 'METAL': finishType = FINISH_TYPE_METAL; break; case 'MATERIAL': // Not implemented lineParser.setToEnd(); break; default: throw new Error( 'LDrawLoader: Unknown token \"' + token + '\" while parsing material' + lineParser.getLineNumberString() + '.' ); } } } let material = null; switch ( finishType ) { case FINISH_TYPE_DEFAULT: material = new MeshStandardMaterial( { roughness: 0.3, metalness: 0 } ); break; case FINISH_TYPE_PEARLESCENT: // Try to imitate pearlescency by making the surface glossy material = new MeshStandardMaterial( { roughness: 0.3, metalness: 0.25 } ); break; case FINISH_TYPE_CHROME: // Mirror finish surface material = new MeshStandardMaterial( { roughness: 0, metalness: 1 } ); break; case FINISH_TYPE_RUBBER: // Rubber finish material = new MeshStandardMaterial( { roughness: 0.9, metalness: 0 } ); break; case FINISH_TYPE_MATTE_METALLIC: // Brushed metal finish material = new MeshStandardMaterial( { roughness: 0.8, metalness: 0.4 } ); break; case FINISH_TYPE_METAL: // Average metal finish material = new MeshStandardMaterial( { roughness: 0.2, metalness: 0.85 } ); break; default: // Should not happen break; } material.color.setStyle( fillColor, COLOR_SPACE_LDRAW ); material.transparent = isTransparent; material.premultipliedAlpha = true; material.opacity = alpha; material.depthWrite = ! isTransparent; material.polygonOffset = true; material.polygonOffsetFactor = 1; if ( luminance !== 0 ) { material.emissive.setStyle( fillColor, COLOR_SPACE_LDRAW ).multiplyScalar( luminance ); } if ( ! edgeMaterial ) { // This is the material used for edges edgeMaterial = new LineBasicMaterial( { color: new Color().setStyle( edgeColor, COLOR_SPACE_LDRAW ), transparent: isTransparent, opacity: alpha, depthWrite: ! isTransparent } ); edgeMaterial.color; edgeMaterial.userData.code = code; edgeMaterial.name = name + ' - Edge'; // This is the material used for conditional edges const conditionalEdgeMaterial = new LDrawConditionalLineMaterial( { fog: true, transparent: isTransparent, depthWrite: ! isTransparent, color: new Color().setStyle( edgeColor, COLOR_SPACE_LDRAW ), opacity: alpha, } ); conditionalEdgeMaterial.userData.code = code; conditionalEdgeMaterial.name = name + ' - Conditional Edge'; this.conditionalEdgeMaterialCache.set( edgeMaterial, conditionalEdgeMaterial ); } material.userData.code = code; material.name = name; this.edgeMaterialCache.set( material, edgeMaterial ); this.addMaterial( material ); return material; function parseLuminance( token ) { // Returns success let lum; if ( token.startsWith( 'LUMINANCE' ) ) { lum = parseInt( token.substring( 9 ) ); } else { lum = parseInt( token ); } if ( isNaN( lum ) ) { return false; } luminance = Math.max( 0, Math.min( 1, lum / 255 ) ); return true; } } computeBuildingSteps( model ) { // Sets userdata.buildingStep number in Group objects and userData.numBuildingSteps number in the root Group object. let stepNumber = 0; model.traverse( c => { if ( c.isGroup ) { if ( c.userData.startingBuildingStep ) { stepNumber ++; } c.userData.buildingStep = stepNumber; } } ); model.userData.numBuildingSteps = stepNumber + 1; } } export { LDrawLoader };"},{"title":"","date":"2023-10-12T14:08:40.692Z","updated":"2023-10-12T14:08:40.692Z","comments":true,"path":"js/three/jsm/loaders/LWOLoader.js","permalink":"http://19999997.xyz/js/three/jsm/loaders/LWOLoader.js","excerpt":"","text":"/** * @version 1.1.1 * * @desc Load files in LWO3 and LWO2 format on Three.js * * LWO3 format specification: * https://static.lightwave3d.com/sdk/2019/html/filefmts/lwo3.html * * LWO2 format specification: * https://static.lightwave3d.com/sdk/2019/html/filefmts/lwo2.html * **/ import { AddOperation, BackSide, BufferGeometry, ClampToEdgeWrapping, Color, DoubleSide, EquirectangularReflectionMapping, EquirectangularRefractionMapping, FileLoader, Float32BufferAttribute, FrontSide, LineBasicMaterial, LineSegments, Loader, Mesh, MeshPhongMaterial, MeshPhysicalMaterial, MeshStandardMaterial, MirroredRepeatWrapping, Points, PointsMaterial, RepeatWrapping, SRGBColorSpace, TextureLoader, Vector2 } from 'three'; import { IFFParser } from './lwo/IFFParser.js'; let _lwoTree; class LWOLoader extends Loader { constructor( manager, parameters = {} ) { super( manager ); this.resourcePath = ( parameters.resourcePath !== undefined ) ? parameters.resourcePath : ''; } load( url, onLoad, onProgress, onError ) { const scope = this; const path = ( scope.path === '' ) ? extractParentUrl( url, 'Objects' ) : scope.path; // give the mesh a default name based on the filename const modelName = url.split( path ).pop().split( '.' )[ 0 ]; const loader = new FileLoader( this.manager ); loader.setPath( scope.path ); loader.setResponseType( 'arraybuffer' ); loader.load( url, function ( buffer ) { // console.time( 'Total parsing: ' ); try { onLoad( scope.parse( buffer, path, modelName ) ); } catch ( e ) { if ( onError ) { onError( e ); } else { console.error( e ); } scope.manager.itemError( url ); } // console.timeEnd( 'Total parsing: ' ); }, onProgress, onError ); } parse( iffBuffer, path, modelName ) { _lwoTree = new IFFParser().parse( iffBuffer ); // console.log( 'lwoTree', lwoTree ); const textureLoader = new TextureLoader( this.manager ).setPath( this.resourcePath || path ).setCrossOrigin( this.crossOrigin ); return new LWOTreeParser( textureLoader ).parse( modelName ); } } // Parse the lwoTree object class LWOTreeParser { constructor( textureLoader ) { this.textureLoader = textureLoader; } parse( modelName ) { this.materials = new MaterialParser( this.textureLoader ).parse(); this.defaultLayerName = modelName; this.meshes = this.parseLayers(); return { materials: this.materials, meshes: this.meshes, }; } parseLayers() { // array of all meshes for building hierarchy const meshes = []; // final array containing meshes with scene graph hierarchy set up const finalMeshes = []; const geometryParser = new GeometryParser(); const scope = this; _lwoTree.layers.forEach( function ( layer ) { const geometry = geometryParser.parse( layer.geometry, layer ); const mesh = scope.parseMesh( geometry, layer ); meshes[ layer.number ] = mesh; if ( layer.parent === - 1 ) finalMeshes.push( mesh ); else meshes[ layer.parent ].add( mesh ); } ); this.applyPivots( finalMeshes ); return finalMeshes; } parseMesh( geometry, layer ) { let mesh; const materials = this.getMaterials( geometry.userData.matNames, layer.geometry.type ); if ( layer.geometry.type === 'points' ) mesh = new Points( geometry, materials ); else if ( layer.geometry.type === 'lines' ) mesh = new LineSegments( geometry, materials ); else mesh = new Mesh( geometry, materials ); if ( layer.name ) mesh.name = layer.name; else mesh.name = this.defaultLayerName + '_layer_' + layer.number; mesh.userData.pivot = layer.pivot; return mesh; } // TODO: may need to be reversed in z to convert LWO to three.js coordinates applyPivots( meshes ) { meshes.forEach( function ( mesh ) { mesh.traverse( function ( child ) { const pivot = child.userData.pivot; child.position.x += pivot[ 0 ]; child.position.y += pivot[ 1 ]; child.position.z += pivot[ 2 ]; if ( child.parent ) { const parentPivot = child.parent.userData.pivot; child.position.x -= parentPivot[ 0 ]; child.position.y -= parentPivot[ 1 ]; child.position.z -= parentPivot[ 2 ]; } } ); } ); } getMaterials( namesArray, type ) { const materials = []; const scope = this; namesArray.forEach( function ( name, i ) { materials[ i ] = scope.getMaterialByName( name ); } ); // convert materials to line or point mats if required if ( type === 'points' || type === 'lines' ) { materials.forEach( function ( mat, i ) { const spec = { color: mat.color, }; if ( type === 'points' ) { spec.size = 0.1; spec.map = mat.map; materials[ i ] = new PointsMaterial( spec ); } else if ( type === 'lines' ) { materials[ i ] = new LineBasicMaterial( spec ); } } ); } // if there is only one material, return that directly instead of array const filtered = materials.filter( Boolean ); if ( filtered.length === 1 ) return filtered[ 0 ]; return materials; } getMaterialByName( name ) { return this.materials.filter( function ( m ) { return m.name === name; } )[ 0 ]; } } class MaterialParser { constructor( textureLoader ) { this.textureLoader = textureLoader; } parse() { const materials = []; this.textures = {}; for ( const name in _lwoTree.materials ) { if ( _lwoTree.format === 'LWO3' ) { materials.push( this.parseMaterial( _lwoTree.materials[ name ], name, _lwoTree.textures ) ); } else if ( _lwoTree.format === 'LWO2' ) { materials.push( this.parseMaterialLwo2( _lwoTree.materials[ name ], name, _lwoTree.textures ) ); } } return materials; } parseMaterial( materialData, name, textures ) { let params = { name: name, side: this.getSide( materialData.attributes ), flatShading: this.getSmooth( materialData.attributes ), }; const connections = this.parseConnections( materialData.connections, materialData.nodes ); const maps = this.parseTextureNodes( connections.maps ); this.parseAttributeImageMaps( connections.attributes, textures, maps, materialData.maps ); const attributes = this.parseAttributes( connections.attributes, maps ); this.parseEnvMap( connections, maps, attributes ); params = Object.assign( maps, params ); params = Object.assign( params, attributes ); const materialType = this.getMaterialType( connections.attributes ); if ( materialType !== MeshPhongMaterial ) delete params.refractionRatio; // PBR materials do not support \"refractionRatio\" return new materialType( params ); } parseMaterialLwo2( materialData, name/*, textures*/ ) { let params = { name: name, side: this.getSide( materialData.attributes ), flatShading: this.getSmooth( materialData.attributes ), }; const attributes = this.parseAttributes( materialData.attributes, {} ); params = Object.assign( params, attributes ); return new MeshPhongMaterial( params ); } // Note: converting from left to right handed coords by switching x -> -x in vertices, and // then switching mat FrontSide -> BackSide // NB: this means that FrontSide and BackSide have been switched! getSide( attributes ) { if ( ! attributes.side ) return BackSide; switch ( attributes.side ) { case 0: case 1: return BackSide; case 2: return FrontSide; case 3: return DoubleSide; } } getSmooth( attributes ) { if ( ! attributes.smooth ) return true; return ! attributes.smooth; } parseConnections( connections, nodes ) { const materialConnections = { maps: {} }; const inputName = connections.inputName; const inputNodeName = connections.inputNodeName; const nodeName = connections.nodeName; const scope = this; inputName.forEach( function ( name, index ) { if ( name === 'Material' ) { const matNode = scope.getNodeByRefName( inputNodeName[ index ], nodes ); materialConnections.attributes = matNode.attributes; materialConnections.envMap = matNode.fileName; materialConnections.name = inputNodeName[ index ]; } } ); nodeName.forEach( function ( name, index ) { if ( name === materialConnections.name ) { materialConnections.maps[ inputName[ index ] ] = scope.getNodeByRefName( inputNodeName[ index ], nodes ); } } ); return materialConnections; } getNodeByRefName( refName, nodes ) { for ( const name in nodes ) { if ( nodes[ name ].refName === refName ) return nodes[ name ]; } } parseTextureNodes( textureNodes ) { const maps = {}; for ( const name in textureNodes ) { const node = textureNodes[ name ]; const path = node.fileName; if ( ! path ) return; const texture = this.loadTexture( path ); if ( node.widthWrappingMode !== undefined ) texture.wrapS = this.getWrappingType( node.widthWrappingMode ); if ( node.heightWrappingMode !== undefined ) texture.wrapT = this.getWrappingType( node.heightWrappingMode ); switch ( name ) { case 'Color': maps.map = texture; maps.map.colorSpace = SRGBColorSpace; break; case 'Roughness': maps.roughnessMap = texture; maps.roughness = 1; break; case 'Specular': maps.specularMap = texture; maps.specularMap.colorSpace = SRGBColorSpace; maps.specular = 0xffffff; break; case 'Luminous': maps.emissiveMap = texture; maps.emissiveMap.colorSpace = SRGBColorSpace; maps.emissive = 0x808080; break; case 'Luminous Color': maps.emissive = 0x808080; break; case 'Metallic': maps.metalnessMap = texture; maps.metalness = 1; break; case 'Transparency': case 'Alpha': maps.alphaMap = texture; maps.transparent = true; break; case 'Normal': maps.normalMap = texture; if ( node.amplitude !== undefined ) maps.normalScale = new Vector2( node.amplitude, node.amplitude ); break; case 'Bump': maps.bumpMap = texture; break; } } // LWO BSDF materials can have both spec and rough, but this is not valid in three if ( maps.roughnessMap && maps.specularMap ) delete maps.specularMap; return maps; } // maps can also be defined on individual material attributes, parse those here // This occurs on Standard (Phong) surfaces parseAttributeImageMaps( attributes, textures, maps ) { for ( const name in attributes ) { const attribute = attributes[ name ]; if ( attribute.maps ) { const mapData = attribute.maps[ 0 ]; const path = this.getTexturePathByIndex( mapData.imageIndex, textures ); if ( ! path ) return; const texture = this.loadTexture( path ); if ( mapData.wrap !== undefined ) texture.wrapS = this.getWrappingType( mapData.wrap.w ); if ( mapData.wrap !== undefined ) texture.wrapT = this.getWrappingType( mapData.wrap.h ); switch ( name ) { case 'Color': maps.map = texture; maps.map.colorSpace = SRGBColorSpace; break; case 'Diffuse': maps.aoMap = texture; break; case 'Roughness': maps.roughnessMap = texture; maps.roughness = 1; break; case 'Specular': maps.specularMap = texture; maps.specularMap.colorSpace = SRGBColorSpace; maps.specular = 0xffffff; break; case 'Luminosity': maps.emissiveMap = texture; maps.emissiveMap.colorSpace = SRGBColorSpace; maps.emissive = 0x808080; break; case 'Metallic': maps.metalnessMap = texture; maps.metalness = 1; break; case 'Transparency': case 'Alpha': maps.alphaMap = texture; maps.transparent = true; break; case 'Normal': maps.normalMap = texture; break; case 'Bump': maps.bumpMap = texture; break; } } } } parseAttributes( attributes, maps ) { const params = {}; // don't use color data if color map is present if ( attributes.Color && ! maps.map ) { params.color = new Color().fromArray( attributes.Color.value ); } else { params.color = new Color(); } if ( attributes.Transparency && attributes.Transparency.value !== 0 ) { params.opacity = 1 - attributes.Transparency.value; params.transparent = true; } if ( attributes[ 'Bump Height' ] ) params.bumpScale = attributes[ 'Bump Height' ].value * 0.1; this.parsePhysicalAttributes( params, attributes, maps ); this.parseStandardAttributes( params, attributes, maps ); this.parsePhongAttributes( params, attributes, maps ); return params; } parsePhysicalAttributes( params, attributes/*, maps*/ ) { if ( attributes.Clearcoat && attributes.Clearcoat.value > 0 ) { params.clearcoat = attributes.Clearcoat.value; if ( attributes[ 'Clearcoat Gloss' ] ) { params.clearcoatRoughness = 0.5 * ( 1 - attributes[ 'Clearcoat Gloss' ].value ); } } } parseStandardAttributes( params, attributes, maps ) { if ( attributes.Luminous ) { params.emissiveIntensity = attributes.Luminous.value; if ( attributes[ 'Luminous Color' ] && ! maps.emissive ) { params.emissive = new Color().fromArray( attributes[ 'Luminous Color' ].value ); } else { params.emissive = new Color( 0x808080 ); } } if ( attributes.Roughness && ! maps.roughnessMap ) params.roughness = attributes.Roughness.value; if ( attributes.Metallic && ! maps.metalnessMap ) params.metalness = attributes.Metallic.value; } parsePhongAttributes( params, attributes, maps ) { if ( attributes[ 'Refraction Index' ] ) params.refractionRatio = 0.98 / attributes[ 'Refraction Index' ].value; if ( attributes.Diffuse ) params.color.multiplyScalar( attributes.Diffuse.value ); if ( attributes.Reflection ) { params.reflectivity = attributes.Reflection.value; params.combine = AddOperation; } if ( attributes.Luminosity ) { params.emissiveIntensity = attributes.Luminosity.value; if ( ! maps.emissiveMap && ! maps.map ) { params.emissive = params.color; } else { params.emissive = new Color( 0x808080 ); } } // parse specular if there is no roughness - we will interpret the material as 'Phong' in this case if ( ! attributes.Roughness && attributes.Specular && ! maps.specularMap ) { if ( attributes[ 'Color Highlight' ] ) { params.specular = new Color().setScalar( attributes.Specular.value ).lerp( params.color.clone().multiplyScalar( attributes.Specular.value ), attributes[ 'Color Highlight' ].value ); } else { params.specular = new Color().setScalar( attributes.Specular.value ); } } if ( params.specular && attributes.Glossiness ) params.shininess = 7 + Math.pow( 2, attributes.Glossiness.value * 12 + 2 ); } parseEnvMap( connections, maps, attributes ) { if ( connections.envMap ) { const envMap = this.loadTexture( connections.envMap ); if ( attributes.transparent && attributes.opacity < 0.999 ) { envMap.mapping = EquirectangularRefractionMapping; // Reflectivity and refraction mapping don't work well together in Phong materials if ( attributes.reflectivity !== undefined ) { delete attributes.reflectivity; delete attributes.combine; } if ( attributes.metalness !== undefined ) { attributes.metalness = 1; // For most transparent materials metalness should be set to 1 if not otherwise defined. If set to 0 no refraction will be visible } attributes.opacity = 1; // transparency fades out refraction, forcing opacity to 1 ensures a closer visual match to the material in Lightwave. } else envMap.mapping = EquirectangularReflectionMapping; maps.envMap = envMap; } } // get texture defined at top level by its index getTexturePathByIndex( index ) { let fileName = ''; if ( ! _lwoTree.textures ) return fileName; _lwoTree.textures.forEach( function ( texture ) { if ( texture.index === index ) fileName = texture.fileName; } ); return fileName; } loadTexture( path ) { if ( ! path ) return null; const texture = this.textureLoader.load( path, undefined, undefined, function () { console.warn( 'LWOLoader: non-standard resource hierarchy. Use \\`resourcePath\\` parameter to specify root content directory.' ); } ); return texture; } // 0 = Reset, 1 = Repeat, 2 = Mirror, 3 = Edge getWrappingType( num ) { switch ( num ) { case 0: console.warn( 'LWOLoader: \"Reset\" texture wrapping type is not supported in three.js' ); return ClampToEdgeWrapping; case 1: return RepeatWrapping; case 2: return MirroredRepeatWrapping; case 3: return ClampToEdgeWrapping; } } getMaterialType( nodeData ) { if ( nodeData.Clearcoat && nodeData.Clearcoat.value > 0 ) return MeshPhysicalMaterial; if ( nodeData.Roughness ) return MeshStandardMaterial; return MeshPhongMaterial; } } class GeometryParser { parse( geoData, layer ) { const geometry = new BufferGeometry(); geometry.setAttribute( 'position', new Float32BufferAttribute( geoData.points, 3 ) ); const indices = this.splitIndices( geoData.vertexIndices, geoData.polygonDimensions ); geometry.setIndex( indices ); this.parseGroups( geometry, geoData ); geometry.computeVertexNormals(); this.parseUVs( geometry, layer, indices ); this.parseMorphTargets( geometry, layer, indices ); // TODO: z may need to be reversed to account for coordinate system change geometry.translate( - layer.pivot[ 0 ], - layer.pivot[ 1 ], - layer.pivot[ 2 ] ); // let userData = geometry.userData; // geometry = geometry.toNonIndexed() // geometry.userData = userData; return geometry; } // split quads into tris splitIndices( indices, polygonDimensions ) { const remappedIndices = []; let i = 0; polygonDimensions.forEach( function ( dim ) { if ( dim < 4 ) { for ( let k = 0; k < dim; k ++ ) remappedIndices.push( indices[ i + k ] ); } else if ( dim === 4 ) { remappedIndices.push( indices[ i ], indices[ i + 1 ], indices[ i + 2 ], indices[ i ], indices[ i + 2 ], indices[ i + 3 ] ); } else if ( dim > 4 ) { for ( let k = 1; k < dim - 1; k ++ ) { remappedIndices.push( indices[ i ], indices[ i + k ], indices[ i + k + 1 ] ); } console.warn( 'LWOLoader: polygons with greater than 4 sides are not supported' ); } i += dim; } ); return remappedIndices; } // NOTE: currently ignoring poly indices and assuming that they are intelligently ordered parseGroups( geometry, geoData ) { const tags = _lwoTree.tags; const matNames = []; let elemSize = 3; if ( geoData.type === 'lines' ) elemSize = 2; if ( geoData.type === 'points' ) elemSize = 1; const remappedIndices = this.splitMaterialIndices( geoData.polygonDimensions, geoData.materialIndices ); let indexNum = 0; // create new indices in numerical order const indexPairs = {}; // original indices mapped to numerical indices let prevMaterialIndex; let materialIndex; let prevStart = 0; let currentCount = 0; for ( let i = 0; i < remappedIndices.length; i += 2 ) { materialIndex = remappedIndices[ i + 1 ]; if ( i === 0 ) matNames[ indexNum ] = tags[ materialIndex ]; if ( prevMaterialIndex === undefined ) prevMaterialIndex = materialIndex; if ( materialIndex !== prevMaterialIndex ) { let currentIndex; if ( indexPairs[ tags[ prevMaterialIndex ] ] ) { currentIndex = indexPairs[ tags[ prevMaterialIndex ] ]; } else { currentIndex = indexNum; indexPairs[ tags[ prevMaterialIndex ] ] = indexNum; matNames[ indexNum ] = tags[ prevMaterialIndex ]; indexNum ++; } geometry.addGroup( prevStart, currentCount, currentIndex ); prevStart += currentCount; prevMaterialIndex = materialIndex; currentCount = 0; } currentCount += elemSize; } // the loop above doesn't add the last group, do that here. if ( geometry.groups.length > 0 ) { let currentIndex; if ( indexPairs[ tags[ materialIndex ] ] ) { currentIndex = indexPairs[ tags[ materialIndex ] ]; } else { currentIndex = indexNum; indexPairs[ tags[ materialIndex ] ] = indexNum; matNames[ indexNum ] = tags[ materialIndex ]; } geometry.addGroup( prevStart, currentCount, currentIndex ); } // Mat names from TAGS chunk, used to build up an array of materials for this geometry geometry.userData.matNames = matNames; } splitMaterialIndices( polygonDimensions, indices ) { const remappedIndices = []; polygonDimensions.forEach( function ( dim, i ) { if ( dim 4 for now for ( let k = 0; k < dim - 2; k ++ ) { remappedIndices.push( indices[ i * 2 ], indices[ i * 2 + 1 ] ); } } } ); return remappedIndices; } // UV maps: // 1: are defined via index into an array of points, not into a geometry // - the geometry is also defined by an index into this array, but the indexes may not match // 2: there can be any number of UV maps for a single geometry. Here these are combined, // with preference given to the first map encountered // 3: UV maps can be partial - that is, defined for only a part of the geometry // 4: UV maps can be VMAP or VMAD (discontinuous, to allow for seams). In practice, most // UV maps are defined as partially VMAP and partially VMAD // VMADs are currently not supported parseUVs( geometry, layer ) { // start by creating a UV map set to zero for the whole geometry const remappedUVs = Array.from( Array( geometry.attributes.position.count * 2 ), function () { return 0; } ); for ( const name in layer.uvs ) { const uvs = layer.uvs[ name ].uvs; const uvIndices = layer.uvs[ name ].uvIndices; uvIndices.forEach( function ( i, j ) { remappedUVs[ i * 2 ] = uvs[ j * 2 ]; remappedUVs[ i * 2 + 1 ] = uvs[ j * 2 + 1 ]; } ); } geometry.setAttribute( 'uv', new Float32BufferAttribute( remappedUVs, 2 ) ); } parseMorphTargets( geometry, layer ) { let num = 0; for ( const name in layer.morphTargets ) { const remappedPoints = geometry.attributes.position.array.slice(); if ( ! geometry.morphAttributes.position ) geometry.morphAttributes.position = []; const morphPoints = layer.morphTargets[ name ].points; const morphIndices = layer.morphTargets[ name ].indices; const type = layer.morphTargets[ name ].type; morphIndices.forEach( function ( i, j ) { if ( type === 'relative' ) { remappedPoints[ i * 3 ] += morphPoints[ j * 3 ]; remappedPoints[ i * 3 + 1 ] += morphPoints[ j * 3 + 1 ]; remappedPoints[ i * 3 + 2 ] += morphPoints[ j * 3 + 2 ]; } else { remappedPoints[ i * 3 ] = morphPoints[ j * 3 ]; remappedPoints[ i * 3 + 1 ] = morphPoints[ j * 3 + 1 ]; remappedPoints[ i * 3 + 2 ] = morphPoints[ j * 3 + 2 ]; } } ); geometry.morphAttributes.position[ num ] = new Float32BufferAttribute( remappedPoints, 3 ); geometry.morphAttributes.position[ num ].name = name; num ++; } geometry.morphTargetsRelative = false; } } // ************** UTILITY FUNCTIONS ************** function extractParentUrl( url, dir ) { const index = url.indexOf( dir ); if ( index === - 1 ) return './'; return url.slice( 0, index ); } export { LWOLoader };"},{"title":"","date":"2023-10-12T14:08:40.669Z","updated":"2023-10-12T14:08:40.669Z","comments":true,"path":"js/three/jsm/loaders/GLTFLoader.js","permalink":"http://19999997.xyz/js/three/jsm/loaders/GLTFLoader.js","excerpt":"","text":"import { AnimationClip, Bone, Box3, BufferAttribute, BufferGeometry, ClampToEdgeWrapping, Color, ColorManagement, DirectionalLight, DoubleSide, FileLoader, FrontSide, Group, ImageBitmapLoader, InstancedMesh, InterleavedBuffer, InterleavedBufferAttribute, Interpolant, InterpolateDiscrete, InterpolateLinear, Line, LineBasicMaterial, LineLoop, LineSegments, LinearFilter, LinearMipmapLinearFilter, LinearMipmapNearestFilter, LinearSRGBColorSpace, Loader, LoaderUtils, Material, MathUtils, Matrix4, Mesh, MeshBasicMaterial, MeshPhysicalMaterial, MeshStandardMaterial, MirroredRepeatWrapping, NearestFilter, NearestMipmapLinearFilter, NearestMipmapNearestFilter, NumberKeyframeTrack, Object3D, OrthographicCamera, PerspectiveCamera, PointLight, Points, PointsMaterial, PropertyBinding, Quaternion, QuaternionKeyframeTrack, RepeatWrapping, Skeleton, SkinnedMesh, Sphere, SpotLight, Texture, TextureLoader, TriangleFanDrawMode, TriangleStripDrawMode, Vector2, Vector3, VectorKeyframeTrack, SRGBColorSpace } from 'three'; import { toTrianglesDrawMode } from '../utils/BufferGeometryUtils.js'; class GLTFLoader extends Loader { constructor( manager ) { super( manager ); this.dracoLoader = null; this.ktx2Loader = null; this.meshoptDecoder = null; this.pluginCallbacks = []; this.register( function ( parser ) { return new GLTFMaterialsClearcoatExtension( parser ); } ); this.register( function ( parser ) { return new GLTFTextureBasisUExtension( parser ); } ); this.register( function ( parser ) { return new GLTFTextureWebPExtension( parser ); } ); this.register( function ( parser ) { return new GLTFTextureAVIFExtension( parser ); } ); this.register( function ( parser ) { return new GLTFMaterialsSheenExtension( parser ); } ); this.register( function ( parser ) { return new GLTFMaterialsTransmissionExtension( parser ); } ); this.register( function ( parser ) { return new GLTFMaterialsVolumeExtension( parser ); } ); this.register( function ( parser ) { return new GLTFMaterialsIorExtension( parser ); } ); this.register( function ( parser ) { return new GLTFMaterialsEmissiveStrengthExtension( parser ); } ); this.register( function ( parser ) { return new GLTFMaterialsSpecularExtension( parser ); } ); this.register( function ( parser ) { return new GLTFMaterialsIridescenceExtension( parser ); } ); this.register( function ( parser ) { return new GLTFMaterialsAnisotropyExtension( parser ); } ); this.register( function ( parser ) { return new GLTFLightsExtension( parser ); } ); this.register( function ( parser ) { return new GLTFMeshoptCompression( parser ); } ); this.register( function ( parser ) { return new GLTFMeshGpuInstancing( parser ); } ); } load( url, onLoad, onProgress, onError ) { const scope = this; let resourcePath; if ( this.resourcePath !== '' ) { resourcePath = this.resourcePath; } else if ( this.path !== '' ) { resourcePath = this.path; } else { resourcePath = LoaderUtils.extractUrlBase( url ); } // Tells the LoadingManager to track an extra item, which resolves after // the model is fully loaded. This means the count of items loaded will // be incorrect, but ensures manager.onLoad() does not fire early. this.manager.itemStart( url ); const _onError = function ( e ) { if ( onError ) { onError( e ); } else { console.error( e ); } scope.manager.itemError( url ); scope.manager.itemEnd( url ); }; const loader = new FileLoader( this.manager ); loader.setPath( this.path ); loader.setResponseType( 'arraybuffer' ); loader.setRequestHeader( this.requestHeader ); loader.setWithCredentials( this.withCredentials ); loader.load( url, function ( data ) { try { scope.parse( data, resourcePath, function ( gltf ) { onLoad( gltf ); scope.manager.itemEnd( url ); }, _onError ); } catch ( e ) { _onError( e ); } }, onProgress, _onError ); } setDRACOLoader( dracoLoader ) { this.dracoLoader = dracoLoader; return this; } setDDSLoader() { throw new Error( 'THREE.GLTFLoader: \"MSFT_texture_dds\" no longer supported. Please update to \"KHR_texture_basisu\".' ); } setKTX2Loader( ktx2Loader ) { this.ktx2Loader = ktx2Loader; return this; } setMeshoptDecoder( meshoptDecoder ) { this.meshoptDecoder = meshoptDecoder; return this; } register( callback ) { if ( this.pluginCallbacks.indexOf( callback ) === - 1 ) { this.pluginCallbacks.push( callback ); } return this; } unregister( callback ) { if ( this.pluginCallbacks.indexOf( callback ) !== - 1 ) { this.pluginCallbacks.splice( this.pluginCallbacks.indexOf( callback ), 1 ); } return this; } parse( data, path, onLoad, onError ) { let json; const extensions = {}; const plugins = {}; const textDecoder = new TextDecoder(); if ( typeof data === 'string' ) { json = JSON.parse( data ); } else if ( data instanceof ArrayBuffer ) { const magic = textDecoder.decode( new Uint8Array( data, 0, 4 ) ); if ( magic === BINARY_EXTENSION_HEADER_MAGIC ) { try { extensions[ EXTENSIONS.KHR_BINARY_GLTF ] = new GLTFBinaryExtension( data ); } catch ( error ) { if ( onError ) onError( error ); return; } json = JSON.parse( extensions[ EXTENSIONS.KHR_BINARY_GLTF ].content ); } else { json = JSON.parse( textDecoder.decode( data ) ); } } else { json = data; } if ( json.asset === undefined || json.asset.version[ 0 ] < 2 ) { if ( onError ) onError( new Error( 'THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.' ) ); return; } const parser = new GLTFParser( json, { path: path || this.resourcePath || '', crossOrigin: this.crossOrigin, requestHeader: this.requestHeader, manager: this.manager, ktx2Loader: this.ktx2Loader, meshoptDecoder: this.meshoptDecoder } ); parser.fileLoader.setRequestHeader( this.requestHeader ); for ( let i = 0; i < this.pluginCallbacks.length; i ++ ) { const plugin = this.pluginCallbacks[ i ]( parser ); plugins[ plugin.name ] = plugin; // Workaround to avoid determining as unknown extension // in addUnknownExtensionsToUserData(). // Remove this workaround if we move all the existing // extension handlers to plugin system extensions[ plugin.name ] = true; } if ( json.extensionsUsed ) { for ( let i = 0; i < json.extensionsUsed.length; ++ i ) { const extensionName = json.extensionsUsed[ i ]; const extensionsRequired = json.extensionsRequired || []; switch ( extensionName ) { case EXTENSIONS.KHR_MATERIALS_UNLIT: extensions[ extensionName ] = new GLTFMaterialsUnlitExtension(); break; case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION: extensions[ extensionName ] = new GLTFDracoMeshCompressionExtension( json, this.dracoLoader ); break; case EXTENSIONS.KHR_TEXTURE_TRANSFORM: extensions[ extensionName ] = new GLTFTextureTransformExtension(); break; case EXTENSIONS.KHR_MESH_QUANTIZATION: extensions[ extensionName ] = new GLTFMeshQuantizationExtension(); break; default: if ( extensionsRequired.indexOf( extensionName ) >= 0 && plugins[ extensionName ] === undefined ) { console.warn( 'THREE.GLTFLoader: Unknown extension \"' + extensionName + '\".' ); } } } } parser.setExtensions( extensions ); parser.setPlugins( plugins ); parser.parse( onLoad, onError ); } parseAsync( data, path ) { const scope = this; return new Promise( function ( resolve, reject ) { scope.parse( data, path, resolve, reject ); } ); } } /* GLTFREGISTRY */ function GLTFRegistry() { let objects = {}; return { get: function ( key ) { return objects[ key ]; }, add: function ( key, object ) { objects[ key ] = object; }, remove: function ( key ) { delete objects[ key ]; }, removeAll: function () { objects = {}; } }; } /*********************************/ /********** EXTENSIONS ***********/ /*********************************/ const EXTENSIONS = { KHR_BINARY_GLTF: 'KHR_binary_glTF', KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression', KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual', KHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat', KHR_MATERIALS_IOR: 'KHR_materials_ior', KHR_MATERIALS_SHEEN: 'KHR_materials_sheen', KHR_MATERIALS_SPECULAR: 'KHR_materials_specular', KHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission', KHR_MATERIALS_IRIDESCENCE: 'KHR_materials_iridescence', KHR_MATERIALS_ANISOTROPY: 'KHR_materials_anisotropy', KHR_MATERIALS_UNLIT: 'KHR_materials_unlit', KHR_MATERIALS_VOLUME: 'KHR_materials_volume', KHR_TEXTURE_BASISU: 'KHR_texture_basisu', KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform', KHR_MESH_QUANTIZATION: 'KHR_mesh_quantization', KHR_MATERIALS_EMISSIVE_STRENGTH: 'KHR_materials_emissive_strength', EXT_TEXTURE_WEBP: 'EXT_texture_webp', EXT_TEXTURE_AVIF: 'EXT_texture_avif', EXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression', EXT_MESH_GPU_INSTANCING: 'EXT_mesh_gpu_instancing' }; /** * Punctual Lights Extension * * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual */ class GLTFLightsExtension { constructor( parser ) { this.parser = parser; this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL; // Object3D instance caches this.cache = { refs: {}, uses: {} }; } _markDefs() { const parser = this.parser; const nodeDefs = this.parser.json.nodes || []; for ( let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) { const nodeDef = nodeDefs[ nodeIndex ]; if ( nodeDef.extensions && nodeDef.extensions[ this.name ] && nodeDef.extensions[ this.name ].light !== undefined ) { parser._addNodeRef( this.cache, nodeDef.extensions[ this.name ].light ); } } } _loadLight( lightIndex ) { const parser = this.parser; const cacheKey = 'light:' + lightIndex; let dependency = parser.cache.get( cacheKey ); if ( dependency ) return dependency; const json = parser.json; const extensions = ( json.extensions && json.extensions[ this.name ] ) || {}; const lightDefs = extensions.lights || []; const lightDef = lightDefs[ lightIndex ]; let lightNode; const color = new Color( 0xffffff ); if ( lightDef.color !== undefined ) color.setRGB( lightDef.color[ 0 ], lightDef.color[ 1 ], lightDef.color[ 2 ], LinearSRGBColorSpace ); const range = lightDef.range !== undefined ? lightDef.range : 0; switch ( lightDef.type ) { case 'directional': lightNode = new DirectionalLight( color ); lightNode.target.position.set( 0, 0, - 1 ); lightNode.add( lightNode.target ); break; case 'point': lightNode = new PointLight( color ); lightNode.distance = range; break; case 'spot': lightNode = new SpotLight( color ); lightNode.distance = range; // Handle spotlight properties. lightDef.spot = lightDef.spot || {}; lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0; lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0; lightNode.angle = lightDef.spot.outerConeAngle; lightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle; lightNode.target.position.set( 0, 0, - 1 ); lightNode.add( lightNode.target ); break; default: throw new Error( 'THREE.GLTFLoader: Unexpected light type: ' + lightDef.type ); } // Some lights (e.g. spot) default to a position other than the origin. Reset the position // here, because node-level parsing will only override position if explicitly specified. lightNode.position.set( 0, 0, 0 ); lightNode.decay = 2; assignExtrasToUserData( lightNode, lightDef ); if ( lightDef.intensity !== undefined ) lightNode.intensity = lightDef.intensity; lightNode.name = parser.createUniqueName( lightDef.name || ( 'light_' + lightIndex ) ); dependency = Promise.resolve( lightNode ); parser.cache.add( cacheKey, dependency ); return dependency; } getDependency( type, index ) { if ( type !== 'light' ) return; return this._loadLight( index ); } createNodeAttachment( nodeIndex ) { const self = this; const parser = this.parser; const json = parser.json; const nodeDef = json.nodes[ nodeIndex ]; const lightDef = ( nodeDef.extensions && nodeDef.extensions[ this.name ] ) || {}; const lightIndex = lightDef.light; if ( lightIndex === undefined ) return null; return this._loadLight( lightIndex ).then( function ( light ) { return parser._getNodeRef( self.cache, lightIndex, light ); } ); } } /** * Unlit Materials Extension * * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit */ class GLTFMaterialsUnlitExtension { constructor() { this.name = EXTENSIONS.KHR_MATERIALS_UNLIT; } getMaterialType() { return MeshBasicMaterial; } extendParams( materialParams, materialDef, parser ) { const pending = []; materialParams.color = new Color( 1.0, 1.0, 1.0 ); materialParams.opacity = 1.0; const metallicRoughness = materialDef.pbrMetallicRoughness; if ( metallicRoughness ) { if ( Array.isArray( metallicRoughness.baseColorFactor ) ) { const array = metallicRoughness.baseColorFactor; materialParams.color.setRGB( array[ 0 ], array[ 1 ], array[ 2 ], LinearSRGBColorSpace ); materialParams.opacity = array[ 3 ]; } if ( metallicRoughness.baseColorTexture !== undefined ) { pending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture, SRGBColorSpace ) ); } } return Promise.all( pending ); } } /** * Materials Emissive Strength Extension * * Specification: https://github.com/KhronosGroup/glTF/blob/5768b3ce0ef32bc39cdf1bef10b948586635ead3/extensions/2.0/Khronos/KHR_materials_emissive_strength/README.md */ class GLTFMaterialsEmissiveStrengthExtension { constructor( parser ) { this.parser = parser; this.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH; } extendMaterialParams( materialIndex, materialParams ) { const parser = this.parser; const materialDef = parser.json.materials[ materialIndex ]; if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) { return Promise.resolve(); } const emissiveStrength = materialDef.extensions[ this.name ].emissiveStrength; if ( emissiveStrength !== undefined ) { materialParams.emissiveIntensity = emissiveStrength; } return Promise.resolve(); } } /** * Clearcoat Materials Extension * * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat */ class GLTFMaterialsClearcoatExtension { constructor( parser ) { this.parser = parser; this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT; } getMaterialType( materialIndex ) { const parser = this.parser; const materialDef = parser.json.materials[ materialIndex ]; if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null; return MeshPhysicalMaterial; } extendMaterialParams( materialIndex, materialParams ) { const parser = this.parser; const materialDef = parser.json.materials[ materialIndex ]; if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) { return Promise.resolve(); } const pending = []; const extension = materialDef.extensions[ this.name ]; if ( extension.clearcoatFactor !== undefined ) { materialParams.clearcoat = extension.clearcoatFactor; } if ( extension.clearcoatTexture !== undefined ) { pending.push( parser.assignTexture( materialParams, 'clearcoatMap', extension.clearcoatTexture ) ); } if ( extension.clearcoatRoughnessFactor !== undefined ) { materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor; } if ( extension.clearcoatRoughnessTexture !== undefined ) { pending.push( parser.assignTexture( materialParams, 'clearcoatRoughnessMap', extension.clearcoatRoughnessTexture ) ); } if ( extension.clearcoatNormalTexture !== undefined ) { pending.push( parser.assignTexture( materialParams, 'clearcoatNormalMap', extension.clearcoatNormalTexture ) ); if ( extension.clearcoatNormalTexture.scale !== undefined ) { const scale = extension.clearcoatNormalTexture.scale; materialParams.clearcoatNormalScale = new Vector2( scale, scale ); } } return Promise.all( pending ); } } /** * Iridescence Materials Extension * * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_iridescence */ class GLTFMaterialsIridescenceExtension { constructor( parser ) { this.parser = parser; this.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE; } getMaterialType( materialIndex ) { const parser = this.parser; const materialDef = parser.json.materials[ materialIndex ]; if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null; return MeshPhysicalMaterial; } extendMaterialParams( materialIndex, materialParams ) { const parser = this.parser; const materialDef = parser.json.materials[ materialIndex ]; if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) { return Promise.resolve(); } const pending = []; const extension = materialDef.extensions[ this.name ]; if ( extension.iridescenceFactor !== undefined ) { materialParams.iridescence = extension.iridescenceFactor; } if ( extension.iridescenceTexture !== undefined ) { pending.push( parser.assignTexture( materialParams, 'iridescenceMap', extension.iridescenceTexture ) ); } if ( extension.iridescenceIor !== undefined ) { materialParams.iridescenceIOR = extension.iridescenceIor; } if ( materialParams.iridescenceThicknessRange === undefined ) { materialParams.iridescenceThicknessRange = [ 100, 400 ]; } if ( extension.iridescenceThicknessMinimum !== undefined ) { materialParams.iridescenceThicknessRange[ 0 ] = extension.iridescenceThicknessMinimum; } if ( extension.iridescenceThicknessMaximum !== undefined ) { materialParams.iridescenceThicknessRange[ 1 ] = extension.iridescenceThicknessMaximum; } if ( extension.iridescenceThicknessTexture !== undefined ) { pending.push( parser.assignTexture( materialParams, 'iridescenceThicknessMap', extension.iridescenceThicknessTexture ) ); } return Promise.all( pending ); } } /** * Sheen Materials Extension * * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen */ class GLTFMaterialsSheenExtension { constructor( parser ) { this.parser = parser; this.name = EXTENSIONS.KHR_MATERIALS_SHEEN; } getMaterialType( materialIndex ) { const parser = this.parser; const materialDef = parser.json.materials[ materialIndex ]; if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null; return MeshPhysicalMaterial; } extendMaterialParams( materialIndex, materialParams ) { const parser = this.parser; const materialDef = parser.json.materials[ materialIndex ]; if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) { return Promise.resolve(); } const pending = []; materialParams.sheenColor = new Color( 0, 0, 0 ); materialParams.sheenRoughness = 0; materialParams.sheen = 1; const extension = materialDef.extensions[ this.name ]; if ( extension.sheenColorFactor !== undefined ) { const colorFactor = extension.sheenColorFactor; materialParams.sheenColor.setRGB( colorFactor[ 0 ], colorFactor[ 1 ], colorFactor [ 2 ], LinearSRGBColorSpace ); } if ( extension.sheenRoughnessFactor !== undefined ) { materialParams.sheenRoughness = extension.sheenRoughnessFactor; } if ( extension.sheenColorTexture !== undefined ) { pending.push( parser.assignTexture( materialParams, 'sheenColorMap', extension.sheenColorTexture, SRGBColorSpace ) ); } if ( extension.sheenRoughnessTexture !== undefined ) { pending.push( parser.assignTexture( materialParams, 'sheenRoughnessMap', extension.sheenRoughnessTexture ) ); } return Promise.all( pending ); } } /** * Transmission Materials Extension * * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission * Draft: https://github.com/KhronosGroup/glTF/pull/1698 */ class GLTFMaterialsTransmissionExtension { constructor( parser ) { this.parser = parser; this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION; } getMaterialType( materialIndex ) { const parser = this.parser; const materialDef = parser.json.materials[ materialIndex ]; if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null; return MeshPhysicalMaterial; } extendMaterialParams( materialIndex, materialParams ) { const parser = this.parser; const materialDef = parser.json.materials[ materialIndex ]; if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) { return Promise.resolve(); } const pending = []; const extension = materialDef.extensions[ this.name ]; if ( extension.transmissionFactor !== undefined ) { materialParams.transmission = extension.transmissionFactor; } if ( extension.transmissionTexture !== undefined ) { pending.push( parser.assignTexture( materialParams, 'transmissionMap', extension.transmissionTexture ) ); } return Promise.all( pending ); } } /** * Materials Volume Extension * * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume */ class GLTFMaterialsVolumeExtension { constructor( parser ) { this.parser = parser; this.name = EXTENSIONS.KHR_MATERIALS_VOLUME; } getMaterialType( materialIndex ) { const parser = this.parser; const materialDef = parser.json.materials[ materialIndex ]; if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null; return MeshPhysicalMaterial; } extendMaterialParams( materialIndex, materialParams ) { const parser = this.parser; const materialDef = parser.json.materials[ materialIndex ]; if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) { return Promise.resolve(); } const pending = []; const extension = materialDef.extensions[ this.name ]; materialParams.thickness = extension.thicknessFactor !== undefined ? extension.thicknessFactor : 0; if ( extension.thicknessTexture !== undefined ) { pending.push( parser.assignTexture( materialParams, 'thicknessMap', extension.thicknessTexture ) ); } materialParams.attenuationDistance = extension.attenuationDistance || Infinity; const colorArray = extension.attenuationColor || [ 1, 1, 1 ]; materialParams.attenuationColor = new Color().setRGB( colorArray[ 0 ], colorArray[ 1 ], colorArray[ 2 ], LinearSRGBColorSpace ); return Promise.all( pending ); } } /** * Materials ior Extension * * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_ior */ class GLTFMaterialsIorExtension { constructor( parser ) { this.parser = parser; this.name = EXTENSIONS.KHR_MATERIALS_IOR; } getMaterialType( materialIndex ) { const parser = this.parser; const materialDef = parser.json.materials[ materialIndex ]; if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null; return MeshPhysicalMaterial; } extendMaterialParams( materialIndex, materialParams ) { const parser = this.parser; const materialDef = parser.json.materials[ materialIndex ]; if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) { return Promise.resolve(); } const extension = materialDef.extensions[ this.name ]; materialParams.ior = extension.ior !== undefined ? extension.ior : 1.5; return Promise.resolve(); } } /** * Materials specular Extension * * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_specular */ class GLTFMaterialsSpecularExtension { constructor( parser ) { this.parser = parser; this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR; } getMaterialType( materialIndex ) { const parser = this.parser; const materialDef = parser.json.materials[ materialIndex ]; if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null; return MeshPhysicalMaterial; } extendMaterialParams( materialIndex, materialParams ) { const parser = this.parser; const materialDef = parser.json.materials[ materialIndex ]; if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) { return Promise.resolve(); } const pending = []; const extension = materialDef.extensions[ this.name ]; materialParams.specularIntensity = extension.specularFactor !== undefined ? extension.specularFactor : 1.0; if ( extension.specularTexture !== undefined ) { pending.push( parser.assignTexture( materialParams, 'specularIntensityMap', extension.specularTexture ) ); } const colorArray = extension.specularColorFactor || [ 1, 1, 1 ]; materialParams.specularColor = new Color().setRGB( colorArray[ 0 ], colorArray[ 1 ], colorArray[ 2 ], LinearSRGBColorSpace ); if ( extension.specularColorTexture !== undefined ) { pending.push( parser.assignTexture( materialParams, 'specularColorMap', extension.specularColorTexture, SRGBColorSpace ) ); } return Promise.all( pending ); } } /** * Materials anisotropy Extension * * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_anisotropy */ class GLTFMaterialsAnisotropyExtension { constructor( parser ) { this.parser = parser; this.name = EXTENSIONS.KHR_MATERIALS_ANISOTROPY; } getMaterialType( materialIndex ) { const parser = this.parser; const materialDef = parser.json.materials[ materialIndex ]; if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null; return MeshPhysicalMaterial; } extendMaterialParams( materialIndex, materialParams ) { const parser = this.parser; const materialDef = parser.json.materials[ materialIndex ]; if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) { return Promise.resolve(); } const pending = []; const extension = materialDef.extensions[ this.name ]; if ( extension.anisotropyStrength !== undefined ) { materialParams.anisotropy = extension.anisotropyStrength; } if ( extension.anisotropyRotation !== undefined ) { materialParams.anisotropyRotation = extension.anisotropyRotation; } if ( extension.anisotropyTexture !== undefined ) { pending.push( parser.assignTexture( materialParams, 'anisotropyMap', extension.anisotropyTexture ) ); } return Promise.all( pending ); } } /** * BasisU Texture Extension * * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_basisu */ class GLTFTextureBasisUExtension { constructor( parser ) { this.parser = parser; this.name = EXTENSIONS.KHR_TEXTURE_BASISU; } loadTexture( textureIndex ) { const parser = this.parser; const json = parser.json; const textureDef = json.textures[ textureIndex ]; if ( ! textureDef.extensions || ! textureDef.extensions[ this.name ] ) { return null; } const extension = textureDef.extensions[ this.name ]; const loader = parser.options.ktx2Loader; if ( ! loader ) { if ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) { throw new Error( 'THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures' ); } else { // Assumes that the extension is optional and that a fallback texture is present return null; } } return parser.loadTextureImage( textureIndex, extension.source, loader ); } } /** * WebP Texture Extension * * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_webp */ class GLTFTextureWebPExtension { constructor( parser ) { this.parser = parser; this.name = EXTENSIONS.EXT_TEXTURE_WEBP; this.isSupported = null; } loadTexture( textureIndex ) { const name = this.name; const parser = this.parser; const json = parser.json; const textureDef = json.textures[ textureIndex ]; if ( ! textureDef.extensions || ! textureDef.extensions[ name ] ) { return null; } const extension = textureDef.extensions[ name ]; const source = json.images[ extension.source ]; let loader = parser.textureLoader; if ( source.uri ) { const handler = parser.options.manager.getHandler( source.uri ); if ( handler !== null ) loader = handler; } return this.detectSupport().then( function ( isSupported ) { if ( isSupported ) return parser.loadTextureImage( textureIndex, extension.source, loader ); if ( json.extensionsRequired && json.extensionsRequired.indexOf( name ) >= 0 ) { throw new Error( 'THREE.GLTFLoader: WebP required by asset but unsupported.' ); } // Fall back to PNG or JPEG. return parser.loadTexture( textureIndex ); } ); } detectSupport() { if ( ! this.isSupported ) { this.isSupported = new Promise( function ( resolve ) { const image = new Image(); // Lossy test image. Support for lossy images doesn't guarantee support for all // WebP images, unfortunately. image.src = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA'; image.onload = image.onerror = function () { resolve( image.height === 1 ); }; } ); } return this.isSupported; } } /** * AVIF Texture Extension * * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_avif */ class GLTFTextureAVIFExtension { constructor( parser ) { this.parser = parser; this.name = EXTENSIONS.EXT_TEXTURE_AVIF; this.isSupported = null; } loadTexture( textureIndex ) { const name = this.name; const parser = this.parser; const json = parser.json; const textureDef = json.textures[ textureIndex ]; if ( ! textureDef.extensions || ! textureDef.extensions[ name ] ) { return null; } const extension = textureDef.extensions[ name ]; const source = json.images[ extension.source ]; let loader = parser.textureLoader; if ( source.uri ) { const handler = parser.options.manager.getHandler( source.uri ); if ( handler !== null ) loader = handler; } return this.detectSupport().then( function ( isSupported ) { if ( isSupported ) return parser.loadTextureImage( textureIndex, extension.source, loader ); if ( json.extensionsRequired && json.extensionsRequired.indexOf( name ) >= 0 ) { throw new Error( 'THREE.GLTFLoader: AVIF required by asset but unsupported.' ); } // Fall back to PNG or JPEG. return parser.loadTexture( textureIndex ); } ); } detectSupport() { if ( ! this.isSupported ) { this.isSupported = new Promise( function ( resolve ) { const image = new Image(); // Lossy test image. image.src = 'data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI='; image.onload = image.onerror = function () { resolve( image.height === 1 ); }; } ); } return this.isSupported; } } /** * meshopt BufferView Compression Extension * * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_meshopt_compression */ class GLTFMeshoptCompression { constructor( parser ) { this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION; this.parser = parser; } loadBufferView( index ) { const json = this.parser.json; const bufferView = json.bufferViews[ index ]; if ( bufferView.extensions && bufferView.extensions[ this.name ] ) { const extensionDef = bufferView.extensions[ this.name ]; const buffer = this.parser.getDependency( 'buffer', extensionDef.buffer ); const decoder = this.parser.options.meshoptDecoder; if ( ! decoder || ! decoder.supported ) { if ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) { throw new Error( 'THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files' ); } else { // Assumes that the extension is optional and that fallback buffer data is present return null; } } return buffer.then( function ( res ) { const byteOffset = extensionDef.byteOffset || 0; const byteLength = extensionDef.byteLength || 0; const count = extensionDef.count; const stride = extensionDef.byteStride; const source = new Uint8Array( res, byteOffset, byteLength ); if ( decoder.decodeGltfBufferAsync ) { return decoder.decodeGltfBufferAsync( count, stride, source, extensionDef.mode, extensionDef.filter ).then( function ( res ) { return res.buffer; } ); } else { // Support for MeshoptDecoder 0.18 or earlier, without decodeGltfBufferAsync return decoder.ready.then( function () { const result = new ArrayBuffer( count * stride ); decoder.decodeGltfBuffer( new Uint8Array( result ), count, stride, source, extensionDef.mode, extensionDef.filter ); return result; } ); } } ); } else { return null; } } } /** * GPU Instancing Extension * * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_mesh_gpu_instancing * */ class GLTFMeshGpuInstancing { constructor( parser ) { this.name = EXTENSIONS.EXT_MESH_GPU_INSTANCING; this.parser = parser; } createNodeMesh( nodeIndex ) { const json = this.parser.json; const nodeDef = json.nodes[ nodeIndex ]; if ( ! nodeDef.extensions || ! nodeDef.extensions[ this.name ] || nodeDef.mesh === undefined ) { return null; } const meshDef = json.meshes[ nodeDef.mesh ]; // No Points or Lines + Instancing support yet for ( const primitive of meshDef.primitives ) { if ( primitive.mode !== WEBGL_CONSTANTS.TRIANGLES && primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_STRIP && primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_FAN && primitive.mode !== undefined ) { return null; } } const extensionDef = nodeDef.extensions[ this.name ]; const attributesDef = extensionDef.attributes; // @TODO: Can we support InstancedMesh + SkinnedMesh? const pending = []; const attributes = {}; for ( const key in attributesDef ) { pending.push( this.parser.getDependency( 'accessor', attributesDef[ key ] ).then( accessor => { attributes[ key ] = accessor; return attributes[ key ]; } ) ); } if ( pending.length < 1 ) { return null; } pending.push( this.parser.createNodeMesh( nodeIndex ) ); return Promise.all( pending ).then( results => { const nodeObject = results.pop(); const meshes = nodeObject.isGroup ? nodeObject.children : [ nodeObject ]; const count = results[ 0 ].count; // All attribute counts should be same const instancedMeshes = []; for ( const mesh of meshes ) { // Temporal variables const m = new Matrix4(); const p = new Vector3(); const q = new Quaternion(); const s = new Vector3( 1, 1, 1 ); const instancedMesh = new InstancedMesh( mesh.geometry, mesh.material, count ); for ( let i = 0; i < count; i ++ ) { if ( attributes.TRANSLATION ) { p.fromBufferAttribute( attributes.TRANSLATION, i ); } if ( attributes.ROTATION ) { q.fromBufferAttribute( attributes.ROTATION, i ); } if ( attributes.SCALE ) { s.fromBufferAttribute( attributes.SCALE, i ); } instancedMesh.setMatrixAt( i, m.compose( p, q, s ) ); } // Add instance attributes to the geometry, excluding TRS. for ( const attributeName in attributes ) { if ( attributeName !== 'TRANSLATION' && attributeName !== 'ROTATION' && attributeName !== 'SCALE' ) { mesh.geometry.setAttribute( attributeName, attributes[ attributeName ] ); } } // Just in case Object3D.prototype.copy.call( instancedMesh, mesh ); this.parser.assignFinalMaterial( instancedMesh ); instancedMeshes.push( instancedMesh ); } if ( nodeObject.isGroup ) { nodeObject.clear(); nodeObject.add( ... instancedMeshes ); return nodeObject; } return instancedMeshes[ 0 ]; } ); } } /* BINARY EXTENSION */ const BINARY_EXTENSION_HEADER_MAGIC = 'glTF'; const BINARY_EXTENSION_HEADER_LENGTH = 12; const BINARY_EXTENSION_CHUNK_TYPES = { JSON: 0x4E4F534A, BIN: 0x004E4942 }; class GLTFBinaryExtension { constructor( data ) { this.name = EXTENSIONS.KHR_BINARY_GLTF; this.content = null; this.body = null; const headerView = new DataView( data, 0, BINARY_EXTENSION_HEADER_LENGTH ); const textDecoder = new TextDecoder(); this.header = { magic: textDecoder.decode( new Uint8Array( data.slice( 0, 4 ) ) ), version: headerView.getUint32( 4, true ), length: headerView.getUint32( 8, true ) }; if ( this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC ) { throw new Error( 'THREE.GLTFLoader: Unsupported glTF-Binary header.' ); } else if ( this.header.version < 2.0 ) { throw new Error( 'THREE.GLTFLoader: Legacy binary file detected.' ); } const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH; const chunkView = new DataView( data, BINARY_EXTENSION_HEADER_LENGTH ); let chunkIndex = 0; while ( chunkIndex < chunkContentsLength ) { const chunkLength = chunkView.getUint32( chunkIndex, true ); chunkIndex += 4; const chunkType = chunkView.getUint32( chunkIndex, true ); chunkIndex += 4; if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON ) { const contentArray = new Uint8Array( data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength ); this.content = textDecoder.decode( contentArray ); } else if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN ) { const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex; this.body = data.slice( byteOffset, byteOffset + chunkLength ); } // Clients must ignore chunks with unknown types. chunkIndex += chunkLength; } if ( this.content === null ) { throw new Error( 'THREE.GLTFLoader: JSON content not found.' ); } } } /** * DRACO Mesh Compression Extension * * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression */ class GLTFDracoMeshCompressionExtension { constructor( json, dracoLoader ) { if ( ! dracoLoader ) { throw new Error( 'THREE.GLTFLoader: No DRACOLoader instance provided.' ); } this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION; this.json = json; this.dracoLoader = dracoLoader; this.dracoLoader.preload(); } decodePrimitive( primitive, parser ) { const json = this.json; const dracoLoader = this.dracoLoader; const bufferViewIndex = primitive.extensions[ this.name ].bufferView; const gltfAttributeMap = primitive.extensions[ this.name ].attributes; const threeAttributeMap = {}; const attributeNormalizedMap = {}; const attributeTypeMap = {}; for ( const attributeName in gltfAttributeMap ) { const threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase(); threeAttributeMap[ threeAttributeName ] = gltfAttributeMap[ attributeName ]; } for ( const attributeName in primitive.attributes ) { const threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase(); if ( gltfAttributeMap[ attributeName ] !== undefined ) { const accessorDef = json.accessors[ primitive.attributes[ attributeName ] ]; const componentType = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ]; attributeTypeMap[ threeAttributeName ] = componentType.name; attributeNormalizedMap[ threeAttributeName ] = accessorDef.normalized === true; } } return parser.getDependency( 'bufferView', bufferViewIndex ).then( function ( bufferView ) { return new Promise( function ( resolve ) { dracoLoader.decodeDracoFile( bufferView, function ( geometry ) { for ( const attributeName in geometry.attributes ) { const attribute = geometry.attributes[ attributeName ]; const normalized = attributeNormalizedMap[ attributeName ]; if ( normalized !== undefined ) attribute.normalized = normalized; } resolve( geometry ); }, threeAttributeMap, attributeTypeMap ); } ); } ); } } /** * Texture Transform Extension * * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform */ class GLTFTextureTransformExtension { constructor() { this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM; } extendTexture( texture, transform ) { if ( ( transform.texCoord === undefined || transform.texCoord === texture.channel ) && transform.offset === undefined && transform.rotation === undefined && transform.scale === undefined ) { // See https://github.com/mrdoob/three.js/issues/21819. return texture; } texture = texture.clone(); if ( transform.texCoord !== undefined ) { texture.channel = transform.texCoord; } if ( transform.offset !== undefined ) { texture.offset.fromArray( transform.offset ); } if ( transform.rotation !== undefined ) { texture.rotation = transform.rotation; } if ( transform.scale !== undefined ) { texture.repeat.fromArray( transform.scale ); } texture.needsUpdate = true; return texture; } } /** * Mesh Quantization Extension * * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization */ class GLTFMeshQuantizationExtension { constructor() { this.name = EXTENSIONS.KHR_MESH_QUANTIZATION; } } /*********************************/ /********** INTERPOLATION ********/ /*********************************/ // Spline Interpolation // Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation class GLTFCubicSplineInterpolant extends Interpolant { constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) { super( parameterPositions, sampleValues, sampleSize, resultBuffer ); } copySampleValue_( index ) { // Copies a sample value to the result buffer. See description of glTF // CUBICSPLINE values layout in interpolate_() function below. const result = this.resultBuffer, values = this.sampleValues, valueSize = this.valueSize, offset = index * valueSize * 3 + valueSize; for ( let i = 0; i !== valueSize; i ++ ) { result[ i ] = values[ offset + i ]; } return result; } interpolate_( i1, t0, t, t1 ) { const result = this.resultBuffer; const values = this.sampleValues; const stride = this.valueSize; const stride2 = stride * 2; const stride3 = stride * 3; const td = t1 - t0; const p = ( t - t0 ) / td; const pp = p * p; const ppp = pp * p; const offset1 = i1 * stride3; const offset0 = offset1 - stride3; const s2 = - 2 * ppp + 3 * pp; const s3 = ppp - pp; const s0 = 1 - s2; const s1 = s3 - pp + p; // Layout of keyframe output values for CUBICSPLINE animations: // [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ] for ( let i = 0; i !== stride; i ++ ) { const p0 = values[ offset0 + i + stride ]; // splineVertex_k const m0 = values[ offset0 + i + stride2 ] * td; // outTangent_k * (t_k+1 - t_k) const p1 = values[ offset1 + i + stride ]; // splineVertex_k+1 const m1 = values[ offset1 + i ] * td; // inTangent_k+1 * (t_k+1 - t_k) result[ i ] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1; } return result; } } const _q = new Quaternion(); class GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant { interpolate_( i1, t0, t, t1 ) { const result = super.interpolate_( i1, t0, t, t1 ); _q.fromArray( result ).normalize().toArray( result ); return result; } } /*********************************/ /********** INTERNALS ************/ /*********************************/ /* CONSTANTS */ const WEBGL_CONSTANTS = { FLOAT: 5126, //FLOAT_MAT2: 35674, FLOAT_MAT3: 35675, FLOAT_MAT4: 35676, FLOAT_VEC2: 35664, FLOAT_VEC3: 35665, FLOAT_VEC4: 35666, LINEAR: 9729, REPEAT: 10497, SAMPLER_2D: 35678, POINTS: 0, LINES: 1, LINE_LOOP: 2, LINE_STRIP: 3, TRIANGLES: 4, TRIANGLE_STRIP: 5, TRIANGLE_FAN: 6, UNSIGNED_BYTE: 5121, UNSIGNED_SHORT: 5123 }; const WEBGL_COMPONENT_TYPES = { 5120: Int8Array, 5121: Uint8Array, 5122: Int16Array, 5123: Uint16Array, 5125: Uint32Array, 5126: Float32Array }; const WEBGL_FILTERS = { 9728: NearestFilter, 9729: LinearFilter, 9984: NearestMipmapNearestFilter, 9985: LinearMipmapNearestFilter, 9986: NearestMipmapLinearFilter, 9987: LinearMipmapLinearFilter }; const WEBGL_WRAPPINGS = { 33071: ClampToEdgeWrapping, 33648: MirroredRepeatWrapping, 10497: RepeatWrapping }; const WEBGL_TYPE_SIZES = { 'SCALAR': 1, 'VEC2': 2, 'VEC3': 3, 'VEC4': 4, 'MAT2': 4, 'MAT3': 9, 'MAT4': 16 }; const ATTRIBUTES = { POSITION: 'position', NORMAL: 'normal', TANGENT: 'tangent', TEXCOORD_0: 'uv', TEXCOORD_1: 'uv1', TEXCOORD_2: 'uv2', TEXCOORD_3: 'uv3', COLOR_0: 'color', WEIGHTS_0: 'skinWeight', JOINTS_0: 'skinIndex', }; const PATH_PROPERTIES = { scale: 'scale', translation: 'position', rotation: 'quaternion', weights: 'morphTargetInfluences' }; const INTERPOLATION = { CUBICSPLINE: undefined, // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each // keyframe track will be initialized with a default interpolation type, then modified. LINEAR: InterpolateLinear, STEP: InterpolateDiscrete }; const ALPHA_MODES = { OPAQUE: 'OPAQUE', MASK: 'MASK', BLEND: 'BLEND' }; /** * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material */ function createDefaultMaterial( cache ) { if ( cache[ 'DefaultMaterial' ] === undefined ) { cache[ 'DefaultMaterial' ] = new MeshStandardMaterial( { color: 0xFFFFFF, emissive: 0x000000, metalness: 1, roughness: 1, transparent: false, depthTest: true, side: FrontSide } ); } return cache[ 'DefaultMaterial' ]; } function addUnknownExtensionsToUserData( knownExtensions, object, objectDef ) { // Add unknown glTF extensions to an object's userData. for ( const name in objectDef.extensions ) { if ( knownExtensions[ name ] === undefined ) { object.userData.gltfExtensions = object.userData.gltfExtensions || {}; object.userData.gltfExtensions[ name ] = objectDef.extensions[ name ]; } } } /** * @param {Object3D|Material|BufferGeometry} object * @param {GLTF.definition} gltfDef */ function assignExtrasToUserData( object, gltfDef ) { if ( gltfDef.extras !== undefined ) { if ( typeof gltfDef.extras === 'object' ) { Object.assign( object.userData, gltfDef.extras ); } else { console.warn( 'THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras ); } } } /** * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets * * @param {BufferGeometry} geometry * @param {Array} targets * @param {GLTFParser} parser * @return {Promise} */ function addMorphTargets( geometry, targets, parser ) { let hasMorphPosition = false; let hasMorphNormal = false; let hasMorphColor = false; for ( let i = 0, il = targets.length; i < il; i ++ ) { const target = targets[ i ]; if ( target.POSITION !== undefined ) hasMorphPosition = true; if ( target.NORMAL !== undefined ) hasMorphNormal = true; if ( target.COLOR_0 !== undefined ) hasMorphColor = true; if ( hasMorphPosition && hasMorphNormal && hasMorphColor ) break; } if ( ! hasMorphPosition && ! hasMorphNormal && ! hasMorphColor ) return Promise.resolve( geometry ); const pendingPositionAccessors = []; const pendingNormalAccessors = []; const pendingColorAccessors = []; for ( let i = 0, il = targets.length; i < il; i ++ ) { const target = targets[ i ]; if ( hasMorphPosition ) { const pendingAccessor = target.POSITION !== undefined ? parser.getDependency( 'accessor', target.POSITION ) : geometry.attributes.position; pendingPositionAccessors.push( pendingAccessor ); } if ( hasMorphNormal ) { const pendingAccessor = target.NORMAL !== undefined ? parser.getDependency( 'accessor', target.NORMAL ) : geometry.attributes.normal; pendingNormalAccessors.push( pendingAccessor ); } if ( hasMorphColor ) { const pendingAccessor = target.COLOR_0 !== undefined ? parser.getDependency( 'accessor', target.COLOR_0 ) : geometry.attributes.color; pendingColorAccessors.push( pendingAccessor ); } } return Promise.all( [ Promise.all( pendingPositionAccessors ), Promise.all( pendingNormalAccessors ), Promise.all( pendingColorAccessors ) ] ).then( function ( accessors ) { const morphPositions = accessors[ 0 ]; const morphNormals = accessors[ 1 ]; const morphColors = accessors[ 2 ]; if ( hasMorphPosition ) geometry.morphAttributes.position = morphPositions; if ( hasMorphNormal ) geometry.morphAttributes.normal = morphNormals; if ( hasMorphColor ) geometry.morphAttributes.color = morphColors; geometry.morphTargetsRelative = true; return geometry; } ); } /** * @param {Mesh} mesh * @param {GLTF.Mesh} meshDef */ function updateMorphTargets( mesh, meshDef ) { mesh.updateMorphTargets(); if ( meshDef.weights !== undefined ) { for ( let i = 0, il = meshDef.weights.length; i < il; i ++ ) { mesh.morphTargetInfluences[ i ] = meshDef.weights[ i ]; } } // .extras has user-defined data, so check that .extras.targetNames is an array. if ( meshDef.extras && Array.isArray( meshDef.extras.targetNames ) ) { const targetNames = meshDef.extras.targetNames; if ( mesh.morphTargetInfluences.length === targetNames.length ) { mesh.morphTargetDictionary = {}; for ( let i = 0, il = targetNames.length; i < il; i ++ ) { mesh.morphTargetDictionary[ targetNames[ i ] ] = i; } } else { console.warn( 'THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.' ); } } } function createPrimitiveKey( primitiveDef ) { let geometryKey; const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ]; if ( dracoExtension ) { geometryKey = 'draco:' + dracoExtension.bufferView + ':' + dracoExtension.indices + ':' + createAttributesKey( dracoExtension.attributes ); } else { geometryKey = primitiveDef.indices + ':' + createAttributesKey( primitiveDef.attributes ) + ':' + primitiveDef.mode; } if ( primitiveDef.targets !== undefined ) { for ( let i = 0, il = primitiveDef.targets.length; i < il; i ++ ) { geometryKey += ':' + createAttributesKey( primitiveDef.targets[ i ] ); } } return geometryKey; } function createAttributesKey( attributes ) { let attributesKey = ''; const keys = Object.keys( attributes ).sort(); for ( let i = 0, il = keys.length; i < il; i ++ ) { attributesKey += keys[ i ] + ':' + attributes[ keys[ i ] ] + ';'; } return attributesKey; } function getNormalizedComponentScale( constructor ) { // Reference: // https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization#encoding-quantized-data switch ( constructor ) { case Int8Array: return 1 / 127; case Uint8Array: return 1 / 255; case Int16Array: return 1 / 32767; case Uint16Array: return 1 / 65535; default: throw new Error( 'THREE.GLTFLoader: Unsupported normalized accessor component type.' ); } } function getImageURIMimeType( uri ) { if ( uri.search( /\\.jpe?g($|\\?)/i ) > 0 || uri.search( /^data\\:image\\/jpeg/ ) === 0 ) return 'image/jpeg'; if ( uri.search( /\\.webp($|\\?)/i ) > 0 || uri.search( /^data\\:image\\/webp/ ) === 0 ) return 'image/webp'; return 'image/png'; } const _identityMatrix = new Matrix4(); /* GLTF PARSER */ class GLTFParser { constructor( json = {}, options = {} ) { this.json = json; this.extensions = {}; this.plugins = {}; this.options = options; // loader object cache this.cache = new GLTFRegistry(); // associations between Three.js objects and glTF elements this.associations = new Map(); // BufferGeometry caching this.primitiveCache = {}; // Node cache this.nodeCache = {}; // Object3D instance caches this.meshCache = { refs: {}, uses: {} }; this.cameraCache = { refs: {}, uses: {} }; this.lightCache = { refs: {}, uses: {} }; this.sourceCache = {}; this.textureCache = {}; // Track node names, to ensure no duplicates this.nodeNamesUsed = {}; // Use an ImageBitmapLoader if imageBitmaps are supported. Moves much of the // expensive work of uploading a texture to the GPU off the main thread. let isSafari = false; let isFirefox = false; let firefoxVersion = - 1; if ( typeof navigator !== 'undefined' ) { isSafari = /^((?!chrome|android).)*safari/i.test( navigator.userAgent ) === true; isFirefox = navigator.userAgent.indexOf( 'Firefox' ) > - 1; firefoxVersion = isFirefox ? navigator.userAgent.match( /Firefox\\/([0-9]+)\\./ )[ 1 ] : - 1; } if ( typeof createImageBitmap === 'undefined' || isSafari || ( isFirefox && firefoxVersion < 98 ) ) { this.textureLoader = new TextureLoader( this.options.manager ); } else { this.textureLoader = new ImageBitmapLoader( this.options.manager ); } this.textureLoader.setCrossOrigin( this.options.crossOrigin ); this.textureLoader.setRequestHeader( this.options.requestHeader ); this.fileLoader = new FileLoader( this.options.manager ); this.fileLoader.setResponseType( 'arraybuffer' ); if ( this.options.crossOrigin === 'use-credentials' ) { this.fileLoader.setWithCredentials( true ); } } setExtensions( extensions ) { this.extensions = extensions; } setPlugins( plugins ) { this.plugins = plugins; } parse( onLoad, onError ) { const parser = this; const json = this.json; const extensions = this.extensions; // Clear the loader cache this.cache.removeAll(); this.nodeCache = {}; // Mark the special nodes/meshes in json for efficient parse this._invokeAll( function ( ext ) { return ext._markDefs && ext._markDefs(); } ); Promise.all( this._invokeAll( function ( ext ) { return ext.beforeRoot && ext.beforeRoot(); } ) ).then( function () { return Promise.all( [ parser.getDependencies( 'scene' ), parser.getDependencies( 'animation' ), parser.getDependencies( 'camera' ), ] ); } ).then( function ( dependencies ) { const result = { scene: dependencies[ 0 ][ json.scene || 0 ], scenes: dependencies[ 0 ], animations: dependencies[ 1 ], cameras: dependencies[ 2 ], asset: json.asset, parser: parser, userData: {} }; addUnknownExtensionsToUserData( extensions, result, json ); assignExtrasToUserData( result, json ); return Promise.all( parser._invokeAll( function ( ext ) { return ext.afterRoot && ext.afterRoot( result ); } ) ).then( function () { onLoad( result ); } ); } ).catch( onError ); } /** * Marks the special nodes/meshes in json for efficient parse. */ _markDefs() { const nodeDefs = this.json.nodes || []; const skinDefs = this.json.skins || []; const meshDefs = this.json.meshes || []; // Nothing in the node definition indicates whether it is a Bone or an // Object3D. Use the skins' joint references to mark bones. for ( let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex ++ ) { const joints = skinDefs[ skinIndex ].joints; for ( let i = 0, il = joints.length; i < il; i ++ ) { nodeDefs[ joints[ i ] ].isBone = true; } } // Iterate over all nodes, marking references to shared resources, // as well as skeleton joints. for ( let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) { const nodeDef = nodeDefs[ nodeIndex ]; if ( nodeDef.mesh !== undefined ) { this._addNodeRef( this.meshCache, nodeDef.mesh ); // Nothing in the mesh definition indicates whether it is // a SkinnedMesh or Mesh. Use the node's mesh reference // to mark SkinnedMesh if node has skin. if ( nodeDef.skin !== undefined ) { meshDefs[ nodeDef.mesh ].isSkinnedMesh = true; } } if ( nodeDef.camera !== undefined ) { this._addNodeRef( this.cameraCache, nodeDef.camera ); } } } /** * Counts references to shared node / Object3D resources. These resources * can be reused, or \"instantiated\", at multiple nodes in the scene * hierarchy. Mesh, Camera, and Light instances are instantiated and must * be marked. Non-scenegraph resources (like Materials, Geometries, and * Textures) can be reused directly and are not marked here. * * Example: CesiumMilkTruck sample model reuses \"Wheel\" meshes. */ _addNodeRef( cache, index ) { if ( index === undefined ) return; if ( cache.refs[ index ] === undefined ) { cache.refs[ index ] = cache.uses[ index ] = 0; } cache.refs[ index ] ++; } /** Returns a reference to a shared resource, cloning it if necessary. */ _getNodeRef( cache, index, object ) { if ( cache.refs[ index ] { const mappings = this.associations.get( original ); if ( mappings != null ) { this.associations.set( clone, mappings ); } for ( const [ i, child ] of original.children.entries() ) { updateMappings( child, clone.children[ i ] ); } }; updateMappings( object, ref ); ref.name += '_instance_' + ( cache.uses[ index ] ++ ); return ref; } _invokeOne( func ) { const extensions = Object.values( this.plugins ); extensions.push( this ); for ( let i = 0; i < extensions.length; i ++ ) { const result = func( extensions[ i ] ); if ( result ) return result; } return null; } _invokeAll( func ) { const extensions = Object.values( this.plugins ); extensions.unshift( this ); const pending = []; for ( let i = 0; i < extensions.length; i ++ ) { const result = func( extensions[ i ] ); if ( result ) pending.push( result ); } return pending; } /** * Requests the specified dependency asynchronously, with caching. * @param {string} type * @param {number} index * @return {Promise} */ getDependency( type, index ) { const cacheKey = type + ':' + index; let dependency = this.cache.get( cacheKey ); if ( ! dependency ) { switch ( type ) { case 'scene': dependency = this.loadScene( index ); break; case 'node': dependency = this._invokeOne( function ( ext ) { return ext.loadNode && ext.loadNode( index ); } ); break; case 'mesh': dependency = this._invokeOne( function ( ext ) { return ext.loadMesh && ext.loadMesh( index ); } ); break; case 'accessor': dependency = this.loadAccessor( index ); break; case 'bufferView': dependency = this._invokeOne( function ( ext ) { return ext.loadBufferView && ext.loadBufferView( index ); } ); break; case 'buffer': dependency = this.loadBuffer( index ); break; case 'material': dependency = this._invokeOne( function ( ext ) { return ext.loadMaterial && ext.loadMaterial( index ); } ); break; case 'texture': dependency = this._invokeOne( function ( ext ) { return ext.loadTexture && ext.loadTexture( index ); } ); break; case 'skin': dependency = this.loadSkin( index ); break; case 'animation': dependency = this._invokeOne( function ( ext ) { return ext.loadAnimation && ext.loadAnimation( index ); } ); break; case 'camera': dependency = this.loadCamera( index ); break; default: dependency = this._invokeOne( function ( ext ) { return ext != this && ext.getDependency && ext.getDependency( type, index ); } ); if ( ! dependency ) { throw new Error( 'Unknown type: ' + type ); } break; } this.cache.add( cacheKey, dependency ); } return dependency; } /** * Requests all dependencies of the specified type asynchronously, with caching. * @param {string} type * @return {Promise} */ getDependencies( type ) { let dependencies = this.cache.get( type ); if ( ! dependencies ) { const parser = this; const defs = this.json[ type + ( type === 'mesh' ? 'es' : 's' ) ] || []; dependencies = Promise.all( defs.map( function ( def, index ) { return parser.getDependency( type, index ); } ) ); this.cache.add( type, dependencies ); } return dependencies; } /** * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views * @param {number} bufferIndex * @return {Promise} */ loadBuffer( bufferIndex ) { const bufferDef = this.json.buffers[ bufferIndex ]; const loader = this.fileLoader; if ( bufferDef.type && bufferDef.type !== 'arraybuffer' ) { throw new Error( 'THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.' ); } // If present, GLB container is required to be the first buffer. if ( bufferDef.uri === undefined && bufferIndex === 0 ) { return Promise.resolve( this.extensions[ EXTENSIONS.KHR_BINARY_GLTF ].body ); } const options = this.options; return new Promise( function ( resolve, reject ) { loader.load( LoaderUtils.resolveURL( bufferDef.uri, options.path ), resolve, undefined, function () { reject( new Error( 'THREE.GLTFLoader: Failed to load buffer \"' + bufferDef.uri + '\".' ) ); } ); } ); } /** * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views * @param {number} bufferViewIndex * @return {Promise} */ loadBufferView( bufferViewIndex ) { const bufferViewDef = this.json.bufferViews[ bufferViewIndex ]; return this.getDependency( 'buffer', bufferViewDef.buffer ).then( function ( buffer ) { const byteLength = bufferViewDef.byteLength || 0; const byteOffset = bufferViewDef.byteOffset || 0; return buffer.slice( byteOffset, byteOffset + byteLength ); } ); } /** * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors * @param {number} accessorIndex * @return {Promise} */ loadAccessor( accessorIndex ) { const parser = this; const json = this.json; const accessorDef = this.json.accessors[ accessorIndex ]; if ( accessorDef.bufferView === undefined && accessorDef.sparse === undefined ) { const itemSize = WEBGL_TYPE_SIZES[ accessorDef.type ]; const TypedArray = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ]; const normalized = accessorDef.normalized === true; const array = new TypedArray( accessorDef.count * itemSize ); return Promise.resolve( new BufferAttribute( array, itemSize, normalized ) ); } const pendingBufferViews = []; if ( accessorDef.bufferView !== undefined ) { pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.bufferView ) ); } else { pendingBufferViews.push( null ); } if ( accessorDef.sparse !== undefined ) { pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.indices.bufferView ) ); pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.values.bufferView ) ); } return Promise.all( pendingBufferViews ).then( function ( bufferViews ) { const bufferView = bufferViews[ 0 ]; const itemSize = WEBGL_TYPE_SIZES[ accessorDef.type ]; const TypedArray = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ]; // For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12. const elementBytes = TypedArray.BYTES_PER_ELEMENT; const itemBytes = elementBytes * itemSize; const byteOffset = accessorDef.byteOffset || 0; const byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[ accessorDef.bufferView ].byteStride : undefined; const normalized = accessorDef.normalized === true; let array, bufferAttribute; // The buffer is not interleaved if the stride is the item size in bytes. if ( byteStride && byteStride !== itemBytes ) { // Each \"slice\" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer // This makes sure that IBA.count reflects accessor.count properly const ibSlice = Math.floor( byteOffset / byteStride ); const ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType + ':' + ibSlice + ':' + accessorDef.count; let ib = parser.cache.get( ibCacheKey ); if ( ! ib ) { array = new TypedArray( bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes ); // Integer parameters to IB/IBA are in array elements, not bytes. ib = new InterleavedBuffer( array, byteStride / elementBytes ); parser.cache.add( ibCacheKey, ib ); } bufferAttribute = new InterleavedBufferAttribute( ib, itemSize, ( byteOffset % byteStride ) / elementBytes, normalized ); } else { if ( bufferView === null ) { array = new TypedArray( accessorDef.count * itemSize ); } else { array = new TypedArray( bufferView, byteOffset, accessorDef.count * itemSize ); } bufferAttribute = new BufferAttribute( array, itemSize, normalized ); } // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors if ( accessorDef.sparse !== undefined ) { const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR; const TypedArrayIndices = WEBGL_COMPONENT_TYPES[ accessorDef.sparse.indices.componentType ]; const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0; const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0; const sparseIndices = new TypedArrayIndices( bufferViews[ 1 ], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices ); const sparseValues = new TypedArray( bufferViews[ 2 ], byteOffsetValues, accessorDef.sparse.count * itemSize ); if ( bufferView !== null ) { // Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes. bufferAttribute = new BufferAttribute( bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized ); } for ( let i = 0, il = sparseIndices.length; i < il; i ++ ) { const index = sparseIndices[ i ]; bufferAttribute.setX( index, sparseValues[ i * itemSize ] ); if ( itemSize >= 2 ) bufferAttribute.setY( index, sparseValues[ i * itemSize + 1 ] ); if ( itemSize >= 3 ) bufferAttribute.setZ( index, sparseValues[ i * itemSize + 2 ] ); if ( itemSize >= 4 ) bufferAttribute.setW( index, sparseValues[ i * itemSize + 3 ] ); if ( itemSize >= 5 ) throw new Error( 'THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.' ); } } return bufferAttribute; } ); } /** * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures * @param {number} textureIndex * @return {Promise} */ loadTexture( textureIndex ) { const json = this.json; const options = this.options; const textureDef = json.textures[ textureIndex ]; const sourceIndex = textureDef.source; const sourceDef = json.images[ sourceIndex ]; let loader = this.textureLoader; if ( sourceDef.uri ) { const handler = options.manager.getHandler( sourceDef.uri ); if ( handler !== null ) loader = handler; } return this.loadTextureImage( textureIndex, sourceIndex, loader ); } loadTextureImage( textureIndex, sourceIndex, loader ) { const parser = this; const json = this.json; const textureDef = json.textures[ textureIndex ]; const sourceDef = json.images[ sourceIndex ]; const cacheKey = ( sourceDef.uri || sourceDef.bufferView ) + ':' + textureDef.sampler; if ( this.textureCache[ cacheKey ] ) { // See https://github.com/mrdoob/three.js/issues/21559. return this.textureCache[ cacheKey ]; } const promise = this.loadImageSource( sourceIndex, loader ).then( function ( texture ) { texture.flipY = false; texture.name = textureDef.name || sourceDef.name || ''; if ( texture.name === '' && typeof sourceDef.uri === 'string' && sourceDef.uri.startsWith( 'data:image/' ) === false ) { texture.name = sourceDef.uri; } const samplers = json.samplers || {}; const sampler = samplers[ textureDef.sampler ] || {}; texture.magFilter = WEBGL_FILTERS[ sampler.magFilter ] || LinearFilter; texture.minFilter = WEBGL_FILTERS[ sampler.minFilter ] || LinearMipmapLinearFilter; texture.wrapS = WEBGL_WRAPPINGS[ sampler.wrapS ] || RepeatWrapping; texture.wrapT = WEBGL_WRAPPINGS[ sampler.wrapT ] || RepeatWrapping; parser.associations.set( texture, { textures: textureIndex } ); return texture; } ).catch( function () { return null; } ); this.textureCache[ cacheKey ] = promise; return promise; } loadImageSource( sourceIndex, loader ) { const parser = this; const json = this.json; const options = this.options; if ( this.sourceCache[ sourceIndex ] !== undefined ) { return this.sourceCache[ sourceIndex ].then( ( texture ) => texture.clone() ); } const sourceDef = json.images[ sourceIndex ]; const URL = self.URL || self.webkitURL; let sourceURI = sourceDef.uri || ''; let isObjectURL = false; if ( sourceDef.bufferView !== undefined ) { // Load binary image data from bufferView, if provided. sourceURI = parser.getDependency( 'bufferView', sourceDef.bufferView ).then( function ( bufferView ) { isObjectURL = true; const blob = new Blob( [ bufferView ], { type: sourceDef.mimeType } ); sourceURI = URL.createObjectURL( blob ); return sourceURI; } ); } else if ( sourceDef.uri === undefined ) { throw new Error( 'THREE.GLTFLoader: Image ' + sourceIndex + ' is missing URI and bufferView' ); } const promise = Promise.resolve( sourceURI ).then( function ( sourceURI ) { return new Promise( function ( resolve, reject ) { let onLoad = resolve; if ( loader.isImageBitmapLoader === true ) { onLoad = function ( imageBitmap ) { const texture = new Texture( imageBitmap ); texture.needsUpdate = true; resolve( texture ); }; } loader.load( LoaderUtils.resolveURL( sourceURI, options.path ), onLoad, undefined, reject ); } ); } ).then( function ( texture ) { // Clean up resources and configure Texture. if ( isObjectURL === true ) { URL.revokeObjectURL( sourceURI ); } texture.userData.mimeType = sourceDef.mimeType || getImageURIMimeType( sourceDef.uri ); return texture; } ).catch( function ( error ) { console.error( 'THREE.GLTFLoader: Couldn\\'t load texture', sourceURI ); throw error; } ); this.sourceCache[ sourceIndex ] = promise; return promise; } /** * Asynchronously assigns a texture to the given material parameters. * @param {Object} materialParams * @param {string} mapName * @param {Object} mapDef * @return {Promise} */ assignTexture( materialParams, mapName, mapDef, colorSpace ) { const parser = this; return this.getDependency( 'texture', mapDef.index ).then( function ( texture ) { if ( ! texture ) return null; if ( mapDef.texCoord !== undefined && mapDef.texCoord > 0 ) { texture = texture.clone(); texture.channel = mapDef.texCoord; } if ( parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] ) { const transform = mapDef.extensions !== undefined ? mapDef.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] : undefined; if ( transform ) { const gltfReference = parser.associations.get( texture ); texture = parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ].extendTexture( texture, transform ); parser.associations.set( texture, gltfReference ); } } if ( colorSpace !== undefined ) { texture.colorSpace = colorSpace; } materialParams[ mapName ] = texture; return texture; } ); } /** * Assigns final material to a Mesh, Line, or Points instance. The instance * already has a material (generated from the glTF material options alone) * but reuse of the same glTF material may require multiple threejs materials * to accommodate different primitive types, defines, etc. New materials will * be created if necessary, and reused from a cache. * @param {Object3D} mesh Mesh, Line, or Points instance. */ assignFinalMaterial( mesh ) { const geometry = mesh.geometry; let material = mesh.material; const useDerivativeTangents = geometry.attributes.tangent === undefined; const useVertexColors = geometry.attributes.color !== undefined; const useFlatShading = geometry.attributes.normal === undefined; if ( mesh.isPoints ) { const cacheKey = 'PointsMaterial:' + material.uuid; let pointsMaterial = this.cache.get( cacheKey ); if ( ! pointsMaterial ) { pointsMaterial = new PointsMaterial(); Material.prototype.copy.call( pointsMaterial, material ); pointsMaterial.color.copy( material.color ); pointsMaterial.map = material.map; pointsMaterial.sizeAttenuation = false; // glTF spec says points should be 1px this.cache.add( cacheKey, pointsMaterial ); } material = pointsMaterial; } else if ( mesh.isLine ) { const cacheKey = 'LineBasicMaterial:' + material.uuid; let lineMaterial = this.cache.get( cacheKey ); if ( ! lineMaterial ) { lineMaterial = new LineBasicMaterial(); Material.prototype.copy.call( lineMaterial, material ); lineMaterial.color.copy( material.color ); lineMaterial.map = material.map; this.cache.add( cacheKey, lineMaterial ); } material = lineMaterial; } // Clone the material if it will be modified if ( useDerivativeTangents || useVertexColors || useFlatShading ) { let cacheKey = 'ClonedMaterial:' + material.uuid + ':'; if ( useDerivativeTangents ) cacheKey += 'derivative-tangents:'; if ( useVertexColors ) cacheKey += 'vertex-colors:'; if ( useFlatShading ) cacheKey += 'flat-shading:'; let cachedMaterial = this.cache.get( cacheKey ); if ( ! cachedMaterial ) { cachedMaterial = material.clone(); if ( useVertexColors ) cachedMaterial.vertexColors = true; if ( useFlatShading ) cachedMaterial.flatShading = true; if ( useDerivativeTangents ) { // https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995 if ( cachedMaterial.normalScale ) cachedMaterial.normalScale.y *= - 1; if ( cachedMaterial.clearcoatNormalScale ) cachedMaterial.clearcoatNormalScale.y *= - 1; } this.cache.add( cacheKey, cachedMaterial ); this.associations.set( cachedMaterial, this.associations.get( material ) ); } material = cachedMaterial; } mesh.material = material; } getMaterialType( /* materialIndex */ ) { return MeshStandardMaterial; } /** * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials * @param {number} materialIndex * @return {Promise} */ loadMaterial( materialIndex ) { const parser = this; const json = this.json; const extensions = this.extensions; const materialDef = json.materials[ materialIndex ]; let materialType; const materialParams = {}; const materialExtensions = materialDef.extensions || {}; const pending = []; if ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ] ) { const kmuExtension = extensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ]; materialType = kmuExtension.getMaterialType(); pending.push( kmuExtension.extendParams( materialParams, materialDef, parser ) ); } else { // Specification: // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material const metallicRoughness = materialDef.pbrMetallicRoughness || {}; materialParams.color = new Color( 1.0, 1.0, 1.0 ); materialParams.opacity = 1.0; if ( Array.isArray( metallicRoughness.baseColorFactor ) ) { const array = metallicRoughness.baseColorFactor; materialParams.color.setRGB( array[ 0 ], array[ 1 ], array[ 2 ], LinearSRGBColorSpace ); materialParams.opacity = array[ 3 ]; } if ( metallicRoughness.baseColorTexture !== undefined ) { pending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture, SRGBColorSpace ) ); } materialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0; materialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0; if ( metallicRoughness.metallicRoughnessTexture !== undefined ) { pending.push( parser.assignTexture( materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture ) ); pending.push( parser.assignTexture( materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture ) ); } materialType = this._invokeOne( function ( ext ) { return ext.getMaterialType && ext.getMaterialType( materialIndex ); } ); pending.push( Promise.all( this._invokeAll( function ( ext ) { return ext.extendMaterialParams && ext.extendMaterialParams( materialIndex, materialParams ); } ) ) ); } if ( materialDef.doubleSided === true ) { materialParams.side = DoubleSide; } const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE; if ( alphaMode === ALPHA_MODES.BLEND ) { materialParams.transparent = true; // See: https://github.com/mrdoob/three.js/issues/17706 materialParams.depthWrite = false; } else { materialParams.transparent = false; if ( alphaMode === ALPHA_MODES.MASK ) { materialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5; } } if ( materialDef.normalTexture !== undefined && materialType !== MeshBasicMaterial ) { pending.push( parser.assignTexture( materialParams, 'normalMap', materialDef.normalTexture ) ); materialParams.normalScale = new Vector2( 1, 1 ); if ( materialDef.normalTexture.scale !== undefined ) { const scale = materialDef.normalTexture.scale; materialParams.normalScale.set( scale, scale ); } } if ( materialDef.occlusionTexture !== undefined && materialType !== MeshBasicMaterial ) { pending.push( parser.assignTexture( materialParams, 'aoMap', materialDef.occlusionTexture ) ); if ( materialDef.occlusionTexture.strength !== undefined ) { materialParams.aoMapIntensity = materialDef.occlusionTexture.strength; } } if ( materialDef.emissiveFactor !== undefined && materialType !== MeshBasicMaterial ) { const emissiveFactor = materialDef.emissiveFactor; materialParams.emissive = new Color().setRGB( emissiveFactor[ 0 ], emissiveFactor[ 1 ], emissiveFactor[ 2 ], LinearSRGBColorSpace ); } if ( materialDef.emissiveTexture !== undefined && materialType !== MeshBasicMaterial ) { pending.push( parser.assignTexture( materialParams, 'emissiveMap', materialDef.emissiveTexture, SRGBColorSpace ) ); } return Promise.all( pending ).then( function () { const material = new materialType( materialParams ); if ( materialDef.name ) material.name = materialDef.name; assignExtrasToUserData( material, materialDef ); parser.associations.set( material, { materials: materialIndex } ); if ( materialDef.extensions ) addUnknownExtensionsToUserData( extensions, material, materialDef ); return material; } ); } /** When Object3D instances are targeted by animation, they need unique names. */ createUniqueName( originalName ) { const sanitizedName = PropertyBinding.sanitizeNodeName( originalName || '' ); if ( sanitizedName in this.nodeNamesUsed ) { return sanitizedName + '_' + ( ++ this.nodeNamesUsed[ sanitizedName ] ); } else { this.nodeNamesUsed[ sanitizedName ] = 0; return sanitizedName; } } /** * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry * * Creates BufferGeometries from primitives. * * @param {Array} primitives * @return {Promise} */ loadGeometries( primitives ) { const parser = this; const extensions = this.extensions; const cache = this.primitiveCache; function createDracoPrimitive( primitive ) { return extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ] .decodePrimitive( primitive, parser ) .then( function ( geometry ) { return addPrimitiveAttributes( geometry, primitive, parser ); } ); } const pending = []; for ( let i = 0, il = primitives.length; i < il; i ++ ) { const primitive = primitives[ i ]; const cacheKey = createPrimitiveKey( primitive ); // See if we've already created this geometry const cached = cache[ cacheKey ]; if ( cached ) { // Use the cached geometry if it exists pending.push( cached.promise ); } else { let geometryPromise; if ( primitive.extensions && primitive.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ] ) { // Use DRACO geometry if available geometryPromise = createDracoPrimitive( primitive ); } else { // Otherwise create a new geometry geometryPromise = addPrimitiveAttributes( new BufferGeometry(), primitive, parser ); } // Cache this geometry cache[ cacheKey ] = { primitive: primitive, promise: geometryPromise }; pending.push( geometryPromise ); } } return Promise.all( pending ); } /** * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes * @param {number} meshIndex * @return {Promise} */ loadMesh( meshIndex ) { const parser = this; const json = this.json; const extensions = this.extensions; const meshDef = json.meshes[ meshIndex ]; const primitives = meshDef.primitives; const pending = []; for ( let i = 0, il = primitives.length; i < il; i ++ ) { const material = primitives[ i ].material === undefined ? createDefaultMaterial( this.cache ) : this.getDependency( 'material', primitives[ i ].material ); pending.push( material ); } pending.push( parser.loadGeometries( primitives ) ); return Promise.all( pending ).then( function ( results ) { const materials = results.slice( 0, results.length - 1 ); const geometries = results[ results.length - 1 ]; const meshes = []; for ( let i = 0, il = geometries.length; i < il; i ++ ) { const geometry = geometries[ i ]; const primitive = primitives[ i ]; // 1. create Mesh let mesh; const material = materials[ i ]; if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === undefined ) { // .isSkinnedMesh isn't in glTF spec. See ._markDefs() mesh = meshDef.isSkinnedMesh === true ? new SkinnedMesh( geometry, material ) : new Mesh( geometry, material ); if ( mesh.isSkinnedMesh === true ) { // normalize skin weights to fix malformed assets (see #15319) mesh.normalizeSkinWeights(); } if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ) { mesh.geometry = toTrianglesDrawMode( mesh.geometry, TriangleStripDrawMode ); } else if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ) { mesh.geometry = toTrianglesDrawMode( mesh.geometry, TriangleFanDrawMode ); } } else if ( primitive.mode === WEBGL_CONSTANTS.LINES ) { mesh = new LineSegments( geometry, material ); } else if ( primitive.mode === WEBGL_CONSTANTS.LINE_STRIP ) { mesh = new Line( geometry, material ); } else if ( primitive.mode === WEBGL_CONSTANTS.LINE_LOOP ) { mesh = new LineLoop( geometry, material ); } else if ( primitive.mode === WEBGL_CONSTANTS.POINTS ) { mesh = new Points( geometry, material ); } else { throw new Error( 'THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode ); } if ( Object.keys( mesh.geometry.morphAttributes ).length > 0 ) { updateMorphTargets( mesh, meshDef ); } mesh.name = parser.createUniqueName( meshDef.name || ( 'mesh_' + meshIndex ) ); assignExtrasToUserData( mesh, meshDef ); if ( primitive.extensions ) addUnknownExtensionsToUserData( extensions, mesh, primitive ); parser.assignFinalMaterial( mesh ); meshes.push( mesh ); } for ( let i = 0, il = meshes.length; i < il; i ++ ) { parser.associations.set( meshes[ i ], { meshes: meshIndex, primitives: i } ); } if ( meshes.length === 1 ) { if ( meshDef.extensions ) addUnknownExtensionsToUserData( extensions, meshes[ 0 ], meshDef ); return meshes[ 0 ]; } const group = new Group(); if ( meshDef.extensions ) addUnknownExtensionsToUserData( extensions, group, meshDef ); parser.associations.set( group, { meshes: meshIndex } ); for ( let i = 0, il = meshes.length; i < il; i ++ ) { group.add( meshes[ i ] ); } return group; } ); } /** * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras * @param {number} cameraIndex * @return {Promise} */ loadCamera( cameraIndex ) { let camera; const cameraDef = this.json.cameras[ cameraIndex ]; const params = cameraDef[ cameraDef.type ]; if ( ! params ) { console.warn( 'THREE.GLTFLoader: Missing camera parameters.' ); return; } if ( cameraDef.type === 'perspective' ) { camera = new PerspectiveCamera( MathUtils.radToDeg( params.yfov ), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6 ); } else if ( cameraDef.type === 'orthographic' ) { camera = new OrthographicCamera( - params.xmag, params.xmag, params.ymag, - params.ymag, params.znear, params.zfar ); } if ( cameraDef.name ) camera.name = this.createUniqueName( cameraDef.name ); assignExtrasToUserData( camera, cameraDef ); return Promise.resolve( camera ); } /** * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins * @param {number} skinIndex * @return {Promise} */ loadSkin( skinIndex ) { const skinDef = this.json.skins[ skinIndex ]; const pending = []; for ( let i = 0, il = skinDef.joints.length; i < il; i ++ ) { pending.push( this._loadNodeShallow( skinDef.joints[ i ] ) ); } if ( skinDef.inverseBindMatrices !== undefined ) { pending.push( this.getDependency( 'accessor', skinDef.inverseBindMatrices ) ); } else { pending.push( null ); } return Promise.all( pending ).then( function ( results ) { const inverseBindMatrices = results.pop(); const jointNodes = results; // Note that bones (joint nodes) may or may not be in the // scene graph at this time. const bones = []; const boneInverses = []; for ( let i = 0, il = jointNodes.length; i < il; i ++ ) { const jointNode = jointNodes[ i ]; if ( jointNode ) { bones.push( jointNode ); const mat = new Matrix4(); if ( inverseBindMatrices !== null ) { mat.fromArray( inverseBindMatrices.array, i * 16 ); } boneInverses.push( mat ); } else { console.warn( 'THREE.GLTFLoader: Joint \"%s\" could not be found.', skinDef.joints[ i ] ); } } return new Skeleton( bones, boneInverses ); } ); } /** * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations * @param {number} animationIndex * @return {Promise} */ loadAnimation( animationIndex ) { const json = this.json; const parser = this; const animationDef = json.animations[ animationIndex ]; const animationName = animationDef.name ? animationDef.name : 'animation_' + animationIndex; const pendingNodes = []; const pendingInputAccessors = []; const pendingOutputAccessors = []; const pendingSamplers = []; const pendingTargets = []; for ( let i = 0, il = animationDef.channels.length; i < il; i ++ ) { const channel = animationDef.channels[ i ]; const sampler = animationDef.samplers[ channel.sampler ]; const target = channel.target; const name = target.node; const input = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.input ] : sampler.input; const output = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.output ] : sampler.output; if ( target.node === undefined ) continue; pendingNodes.push( this.getDependency( 'node', name ) ); pendingInputAccessors.push( this.getDependency( 'accessor', input ) ); pendingOutputAccessors.push( this.getDependency( 'accessor', output ) ); pendingSamplers.push( sampler ); pendingTargets.push( target ); } return Promise.all( [ Promise.all( pendingNodes ), Promise.all( pendingInputAccessors ), Promise.all( pendingOutputAccessors ), Promise.all( pendingSamplers ), Promise.all( pendingTargets ) ] ).then( function ( dependencies ) { const nodes = dependencies[ 0 ]; const inputAccessors = dependencies[ 1 ]; const outputAccessors = dependencies[ 2 ]; const samplers = dependencies[ 3 ]; const targets = dependencies[ 4 ]; const tracks = []; for ( let i = 0, il = nodes.length; i < il; i ++ ) { const node = nodes[ i ]; const inputAccessor = inputAccessors[ i ]; const outputAccessor = outputAccessors[ i ]; const sampler = samplers[ i ]; const target = targets[ i ]; if ( node === undefined ) continue; if ( node.updateMatrix ) { node.updateMatrix(); } const createdTracks = parser._createAnimationTracks( node, inputAccessor, outputAccessor, sampler, target ); if ( createdTracks ) { for ( let k = 0; k < createdTracks.length; k ++ ) { tracks.push( createdTracks[ k ] ); } } } return new AnimationClip( animationName, undefined, tracks ); } ); } createNodeMesh( nodeIndex ) { const json = this.json; const parser = this; const nodeDef = json.nodes[ nodeIndex ]; if ( nodeDef.mesh === undefined ) return null; return parser.getDependency( 'mesh', nodeDef.mesh ).then( function ( mesh ) { const node = parser._getNodeRef( parser.meshCache, nodeDef.mesh, mesh ); // if weights are provided on the node, override weights on the mesh. if ( nodeDef.weights !== undefined ) { node.traverse( function ( o ) { if ( ! o.isMesh ) return; for ( let i = 0, il = nodeDef.weights.length; i < il; i ++ ) { o.morphTargetInfluences[ i ] = nodeDef.weights[ i ]; } } ); } return node; } ); } /** * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy * @param {number} nodeIndex * @return {Promise} */ loadNode( nodeIndex ) { const json = this.json; const parser = this; const nodeDef = json.nodes[ nodeIndex ]; const nodePending = parser._loadNodeShallow( nodeIndex ); const childPending = []; const childrenDef = nodeDef.children || []; for ( let i = 0, il = childrenDef.length; i < il; i ++ ) { childPending.push( parser.getDependency( 'node', childrenDef[ i ] ) ); } const skeletonPending = nodeDef.skin === undefined ? Promise.resolve( null ) : parser.getDependency( 'skin', nodeDef.skin ); return Promise.all( [ nodePending, Promise.all( childPending ), skeletonPending ] ).then( function ( results ) { const node = results[ 0 ]; const children = results[ 1 ]; const skeleton = results[ 2 ]; if ( skeleton !== null ) { // This full traverse should be fine because // child glTF nodes have not been added to this node yet. node.traverse( function ( mesh ) { if ( ! mesh.isSkinnedMesh ) return; mesh.bind( skeleton, _identityMatrix ); } ); } for ( let i = 0, il = children.length; i < il; i ++ ) { node.add( children[ i ] ); } return node; } ); } // ._loadNodeShallow() parses a single node. // skin and child nodes are created and added in .loadNode() (no '_' prefix). _loadNodeShallow( nodeIndex ) { const json = this.json; const extensions = this.extensions; const parser = this; // This method is called from .loadNode() and .loadSkin(). // Cache a node to avoid duplication. if ( this.nodeCache[ nodeIndex ] !== undefined ) { return this.nodeCache[ nodeIndex ]; } const nodeDef = json.nodes[ nodeIndex ]; // reserve node's name before its dependencies, so the root has the intended name. const nodeName = nodeDef.name ? parser.createUniqueName( nodeDef.name ) : ''; const pending = []; const meshPromise = parser._invokeOne( function ( ext ) { return ext.createNodeMesh && ext.createNodeMesh( nodeIndex ); } ); if ( meshPromise ) { pending.push( meshPromise ); } if ( nodeDef.camera !== undefined ) { pending.push( parser.getDependency( 'camera', nodeDef.camera ).then( function ( camera ) { return parser._getNodeRef( parser.cameraCache, nodeDef.camera, camera ); } ) ); } parser._invokeAll( function ( ext ) { return ext.createNodeAttachment && ext.createNodeAttachment( nodeIndex ); } ).forEach( function ( promise ) { pending.push( promise ); } ); this.nodeCache[ nodeIndex ] = Promise.all( pending ).then( function ( objects ) { let node; // .isBone isn't in glTF spec. See ._markDefs if ( nodeDef.isBone === true ) { node = new Bone(); } else if ( objects.length > 1 ) { node = new Group(); } else if ( objects.length === 1 ) { node = objects[ 0 ]; } else { node = new Object3D(); } if ( node !== objects[ 0 ] ) { for ( let i = 0, il = objects.length; i < il; i ++ ) { node.add( objects[ i ] ); } } if ( nodeDef.name ) { node.userData.name = nodeDef.name; node.name = nodeName; } assignExtrasToUserData( node, nodeDef ); if ( nodeDef.extensions ) addUnknownExtensionsToUserData( extensions, node, nodeDef ); if ( nodeDef.matrix !== undefined ) { const matrix = new Matrix4(); matrix.fromArray( nodeDef.matrix ); node.applyMatrix4( matrix ); } else { if ( nodeDef.translation !== undefined ) { node.position.fromArray( nodeDef.translation ); } if ( nodeDef.rotation !== undefined ) { node.quaternion.fromArray( nodeDef.rotation ); } if ( nodeDef.scale !== undefined ) { node.scale.fromArray( nodeDef.scale ); } } if ( ! parser.associations.has( node ) ) { parser.associations.set( node, {} ); } parser.associations.get( node ).nodes = nodeIndex; return node; } ); return this.nodeCache[ nodeIndex ]; } /** * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes * @param {number} sceneIndex * @return {Promise} */ loadScene( sceneIndex ) { const extensions = this.extensions; const sceneDef = this.json.scenes[ sceneIndex ]; const parser = this; // Loader returns Group, not Scene. // See: https://github.com/mrdoob/three.js/issues/18342#issuecomment-578981172 const scene = new Group(); if ( sceneDef.name ) scene.name = parser.createUniqueName( sceneDef.name ); assignExtrasToUserData( scene, sceneDef ); if ( sceneDef.extensions ) addUnknownExtensionsToUserData( extensions, scene, sceneDef ); const nodeIds = sceneDef.nodes || []; const pending = []; for ( let i = 0, il = nodeIds.length; i < il; i ++ ) { pending.push( parser.getDependency( 'node', nodeIds[ i ] ) ); } return Promise.all( pending ).then( function ( nodes ) { for ( let i = 0, il = nodes.length; i < il; i ++ ) { scene.add( nodes[ i ] ); } // Removes dangling associations, associations that reference a node that // didn't make it into the scene. const reduceAssociations = ( node ) => { const reducedAssociations = new Map(); for ( const [ key, value ] of parser.associations ) { if ( key instanceof Material || key instanceof Texture ) { reducedAssociations.set( key, value ); } } node.traverse( ( node ) => { const mappings = parser.associations.get( node ); if ( mappings != null ) { reducedAssociations.set( node, mappings ); } } ); return reducedAssociations; }; parser.associations = reduceAssociations( scene ); return scene; } ); } _createAnimationTracks( node, inputAccessor, outputAccessor, sampler, target ) { const tracks = []; const targetName = node.name ? node.name : node.uuid; const targetNames = []; if ( PATH_PROPERTIES[ target.path ] === PATH_PROPERTIES.weights ) { node.traverse( function ( object ) { if ( object.morphTargetInfluences ) { targetNames.push( object.name ? object.name : object.uuid ); } } ); } else { targetNames.push( targetName ); } let TypedKeyframeTrack; switch ( PATH_PROPERTIES[ target.path ] ) { case PATH_PROPERTIES.weights: TypedKeyframeTrack = NumberKeyframeTrack; break; case PATH_PROPERTIES.rotation: TypedKeyframeTrack = QuaternionKeyframeTrack; break; case PATH_PROPERTIES.position: case PATH_PROPERTIES.scale: TypedKeyframeTrack = VectorKeyframeTrack; break; default: switch ( outputAccessor.itemSize ) { case 1: TypedKeyframeTrack = NumberKeyframeTrack; break; case 2: case 3: default: TypedKeyframeTrack = VectorKeyframeTrack; break; } break; } const interpolation = sampler.interpolation !== undefined ? INTERPOLATION[ sampler.interpolation ] : InterpolateLinear; const outputArray = this._getArrayFromAccessor( outputAccessor ); for ( let j = 0, jl = targetNames.length; j < jl; j ++ ) { const track = new TypedKeyframeTrack( targetNames[ j ] + '.' + PATH_PROPERTIES[ target.path ], inputAccessor.array, outputArray, interpolation ); // Override interpolation with custom factory method. if ( sampler.interpolation === 'CUBICSPLINE' ) { this._createCubicSplineTrackInterpolant( track ); } tracks.push( track ); } return tracks; } _getArrayFromAccessor( accessor ) { let outputArray = accessor.array; if ( accessor.normalized ) { const scale = getNormalizedComponentScale( outputArray.constructor ); const scaled = new Float32Array( outputArray.length ); for ( let j = 0, jl = outputArray.length; j < jl; j ++ ) { scaled[ j ] = outputArray[ j ] * scale; } outputArray = scaled; } return outputArray; } _createCubicSplineTrackInterpolant( track ) { track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline( result ) { // A CUBICSPLINE keyframe in glTF has three output values for each input value, // representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize() // must be divided by three to get the interpolant's sampleSize argument. const interpolantType = ( this instanceof QuaternionKeyframeTrack ) ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant; return new interpolantType( this.times, this.values, this.getValueSize() / 3, result ); }; // Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants. track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true; } } /** * @param {BufferGeometry} geometry * @param {GLTF.Primitive} primitiveDef * @param {GLTFParser} parser */ function computeBounds( geometry, primitiveDef, parser ) { const attributes = primitiveDef.attributes; const box = new Box3(); if ( attributes.POSITION !== undefined ) { const accessor = parser.json.accessors[ attributes.POSITION ]; const min = accessor.min; const max = accessor.max; // glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement. if ( min !== undefined && max !== undefined ) { box.set( new Vector3( min[ 0 ], min[ 1 ], min[ 2 ] ), new Vector3( max[ 0 ], max[ 1 ], max[ 2 ] ) ); if ( accessor.normalized ) { const boxScale = getNormalizedComponentScale( WEBGL_COMPONENT_TYPES[ accessor.componentType ] ); box.min.multiplyScalar( boxScale ); box.max.multiplyScalar( boxScale ); } } else { console.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' ); return; } } else { return; } const targets = primitiveDef.targets; if ( targets !== undefined ) { const maxDisplacement = new Vector3(); const vector = new Vector3(); for ( let i = 0, il = targets.length; i < il; i ++ ) { const target = targets[ i ]; if ( target.POSITION !== undefined ) { const accessor = parser.json.accessors[ target.POSITION ]; const min = accessor.min; const max = accessor.max; // glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement. if ( min !== undefined && max !== undefined ) { // we need to get max of absolute components because target weight is [-1,1] vector.setX( Math.max( Math.abs( min[ 0 ] ), Math.abs( max[ 0 ] ) ) ); vector.setY( Math.max( Math.abs( min[ 1 ] ), Math.abs( max[ 1 ] ) ) ); vector.setZ( Math.max( Math.abs( min[ 2 ] ), Math.abs( max[ 2 ] ) ) ); if ( accessor.normalized ) { const boxScale = getNormalizedComponentScale( WEBGL_COMPONENT_TYPES[ accessor.componentType ] ); vector.multiplyScalar( boxScale ); } // Note: this assumes that the sum of all weights is at most 1. This isn't quite correct - it's more conservative // to assume that each target can have a max weight of 1. However, for some use cases - notably, when morph targets // are used to implement key-frame animations and as such only two are active at a time - this results in very large // boxes. So for now we make a box that's sometimes a touch too small but is hopefully mostly of reasonable size. maxDisplacement.max( vector ); } else { console.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' ); } } } // As per comment above this box isn't conservative, but has a reasonable size for a very large number of morph targets. box.expandByVector( maxDisplacement ); } geometry.boundingBox = box; const sphere = new Sphere(); box.getCenter( sphere.center ); sphere.radius = box.min.distanceTo( box.max ) / 2; geometry.boundingSphere = sphere; } /** * @param {BufferGeometry} geometry * @param {GLTF.Primitive} primitiveDef * @param {GLTFParser} parser * @return {Promise} */ function addPrimitiveAttributes( geometry, primitiveDef, parser ) { const attributes = primitiveDef.attributes; const pending = []; function assignAttributeAccessor( accessorIndex, attributeName ) { return parser.getDependency( 'accessor', accessorIndex ) .then( function ( accessor ) { geometry.setAttribute( attributeName, accessor ); } ); } for ( const gltfAttributeName in attributes ) { const threeAttributeName = ATTRIBUTES[ gltfAttributeName ] || gltfAttributeName.toLowerCase(); // Skip attributes already provided by e.g. Draco extension. if ( threeAttributeName in geometry.attributes ) continue; pending.push( assignAttributeAccessor( attributes[ gltfAttributeName ], threeAttributeName ) ); } if ( primitiveDef.indices !== undefined && ! geometry.index ) { const accessor = parser.getDependency( 'accessor', primitiveDef.indices ).then( function ( accessor ) { geometry.setIndex( accessor ); } ); pending.push( accessor ); } if ( ColorManagement.workingColorSpace !== LinearSRGBColorSpace && 'COLOR_0' in attributes ) { console.warn( `THREE.GLTFLoader: Converting vertex colors from \"srgb-linear\" to \"${ColorManagement.workingColorSpace}\" not supported.` ); } assignExtrasToUserData( geometry, primitiveDef ); computeBounds( geometry, primitiveDef, parser ); return Promise.all( pending ).then( function () { return primitiveDef.targets !== undefined ? addMorphTargets( geometry, primitiveDef.targets, parser ) : geometry; } ); } export { GLTFLoader };"},{"title":"","date":"2023-10-12T14:08:40.697Z","updated":"2023-10-12T14:08:40.697Z","comments":true,"path":"js/three/jsm/loaders/LottieLoader.js","permalink":"http://19999997.xyz/js/three/jsm/loaders/LottieLoader.js","excerpt":"","text":"import { FileLoader, Loader, CanvasTexture, NearestFilter, SRGBColorSpace } from 'three'; import lottie from '../libs/lottie_canvas.module.js'; class LottieLoader extends Loader { setQuality( value ) { this._quality = value; } load( url, onLoad, onProgress, onError ) { const quality = this._quality || 1; const texture = new CanvasTexture(); texture.minFilter = NearestFilter; texture.colorSpace = SRGBColorSpace; const loader = new FileLoader( this.manager ); loader.setPath( this.path ); loader.setWithCredentials( this.withCredentials ); loader.load( url, function ( text ) { const data = JSON.parse( text ); // lottie uses container.offetWidth and offsetHeight // to define width/height const container = document.createElement( 'div' ); container.style.width = data.w + 'px'; container.style.height = data.h + 'px'; document.body.appendChild( container ); const animation = lottie.loadAnimation( { container: container, animType: 'canvas', loop: true, autoplay: true, animationData: data, rendererSettings: { dpr: quality } } ); texture.animation = animation; texture.image = animation.container; animation.addEventListener( 'enterFrame', function () { texture.needsUpdate = true; } ); container.style.display = 'none'; if ( onLoad !== undefined ) { onLoad( texture ); } }, onProgress, onError ); return texture; } } export { LottieLoader };"},{"title":"","date":"2023-10-12T14:08:40.695Z","updated":"2023-10-12T14:08:40.695Z","comments":true,"path":"js/three/jsm/loaders/LogLuvLoader.js","permalink":"http://19999997.xyz/js/three/jsm/loaders/LogLuvLoader.js","excerpt":"","text":"import { DataUtils, DataTextureLoader, FloatType, HalfFloatType, RGBAFormat } from 'three'; class LogLuvLoader extends DataTextureLoader { constructor( manager ) { super( manager ); this.type = HalfFloatType; } parse( buffer ) { const ifds = UTIF.decode( buffer ); UTIF.decodeImage( buffer, ifds[ 0 ] ); const rgba = UTIF.toRGBA( ifds[ 0 ], this.type ); return { width: ifds[ 0 ].width, height: ifds[ 0 ].height, data: rgba, format: RGBAFormat, type: this.type, flipY: true }; } setDataType( value ) { this.type = value; return this; } } // from https://github.com/photopea/UTIF.js (MIT License) const UTIF = {}; UTIF.decode = function ( buff, prm ) { if ( prm == null ) prm = { parseMN: true, debug: false }; // read MakerNote, debug var data = new Uint8Array( buff ), offset = 0; var id = UTIF._binBE.readASCII( data, offset, 2 ); offset += 2; var bin = id == 'II' ? UTIF._binLE : UTIF._binBE; bin.readUshort( data, offset ); offset += 2; var ifdo = bin.readUint( data, offset ); var ifds = []; while ( true ) { var cnt = bin.readUshort( data, ifdo ), typ = bin.readUshort( data, ifdo + 4 ); if ( cnt != 0 ) if ( typ < 1 || 13 < typ ) { console.log( 'error in TIFF' ); break; } UTIF._readIFD( bin, data, ifdo, ifds, 0, prm ); ifdo = bin.readUint( data, ifdo + 2 + cnt * 12 ); if ( ifdo == 0 ) break; } return ifds; }; UTIF.decodeImage = function ( buff, img, ifds ) { if ( img.data ) return; var data = new Uint8Array( buff ); var id = UTIF._binBE.readASCII( data, 0, 2 ); if ( img[ 't256' ] == null ) return; // No width => probably not an image img.isLE = id == 'II'; img.width = img[ 't256' ][ 0 ]; //delete img[\"t256\"]; img.height = img[ 't257' ][ 0 ]; //delete img[\"t257\"]; var cmpr = img[ 't259' ] ? img[ 't259' ][ 0 ] : 1; //delete img[\"t259\"]; var fo = img[ 't266' ] ? img[ 't266' ][ 0 ] : 1; //delete img[\"t266\"]; if ( img[ 't284' ] && img[ 't284' ][ 0 ] == 2 ) console.log( 'PlanarConfiguration 2 should not be used!' ); if ( cmpr == 7 && img[ 't258' ] && img[ 't258' ].length > 3 ) img[ 't258' ] = img[ 't258' ].slice( 0, 3 ); var bipp; // bits per pixel if ( img[ 't258' ] ) bipp = Math.min( 32, img[ 't258' ][ 0 ] ) * img[ 't258' ].length; else bipp = ( img[ 't277' ] ? img[ 't277' ][ 0 ] : 1 ); // Some .NEF files have t258==14, even though they use 16 bits per pixel if ( cmpr == 1 && img[ 't279' ] != null && img[ 't278' ] && img[ 't262' ][ 0 ] == 32803 ) { bipp = Math.round( ( img[ 't279' ][ 0 ] * 8 ) / ( img.width * img[ 't278' ][ 0 ] ) ); } var bipl = Math.ceil( img.width * bipp / 8 ) * 8; var soff = img[ 't273' ]; if ( soff == null ) soff = img[ 't324' ]; var bcnt = img[ 't279' ]; if ( cmpr == 1 && soff.length == 1 ) bcnt = [ img.height * ( bipl >>> 3 ) ]; if ( bcnt == null ) bcnt = img[ 't325' ]; //bcnt[0] = Math.min(bcnt[0], data.length); // Hasselblad, \"RAW_HASSELBLAD_H3D39II.3FR\" var bytes = new Uint8Array( img.height * ( bipl >>> 3 ) ), bilen = 0; if ( img[ 't322' ] != null ) { var tw = img[ 't322' ][ 0 ], th = img[ 't323' ][ 0 ]; var tx = Math.floor( ( img.width + tw - 1 ) / tw ); var ty = Math.floor( ( img.height + th - 1 ) / th ); var tbuff = new Uint8Array( Math.ceil( tw * th * bipp / 8 ) | 0 ); for ( var y = 0; y < ty; y ++ ) for ( var x = 0; x < tx; x ++ ) { var i = y * tx + x; for ( var j = 0; j < tbuff.length; j ++ ) tbuff[ j ] = 0; UTIF.decode._decompress( img, ifds, data, soff[ i ], bcnt[ i ], cmpr, tbuff, 0, fo ); // Might be required for 7 too. Need to check if ( cmpr == 6 ) bytes = tbuff; else UTIF._copyTile( tbuff, Math.ceil( tw * bipp / 8 ) | 0, th, bytes, Math.ceil( img.width * bipp / 8 ) | 0, img.height, Math.ceil( x * tw * bipp / 8 ) | 0, y * th ); } bilen = bytes.length * 8; } else { var rps = img[ 't278' ] ? img[ 't278' ][ 0 ] : img.height; rps = Math.min( rps, img.height ); for ( var i = 0; i < soff.length; i ++ ) { UTIF.decode._decompress( img, ifds, data, soff[ i ], bcnt[ i ], cmpr, bytes, Math.ceil( bilen / 8 ) | 0, fo ); bilen += bipl * rps; } bilen = Math.min( bilen, bytes.length * 8 ); } img.data = new Uint8Array( bytes.buffer, 0, Math.ceil( bilen / 8 ) | 0 ); }; UTIF.decode._decompress = function ( img, ifds, data, off, len, cmpr, tgt, toff ) { //console.log(\"compression\", cmpr); //var time = Date.now(); if ( cmpr == 34676 ) UTIF.decode._decodeLogLuv32( img, data, off, len, tgt, toff ); else console.log( 'Unsupported compression', cmpr ); //console.log(Date.now()-time); var bps = ( img[ 't258' ] ? Math.min( 32, img[ 't258' ][ 0 ] ) : 1 ); var noc = ( img[ 't277' ] ? img[ 't277' ][ 0 ] : 1 ), bpp = ( bps * noc ) >>> 3, h = ( img[ 't278' ] ? img[ 't278' ][ 0 ] : img.height ), bpl = Math.ceil( bps * noc * img.width / 8 ); // convert to Little Endian /* if ( bps == 16 && ! img.isLE && img[ 't33422' ] == null ) // not DNG for ( var y = 0; y < h; y ++ ) { //console.log(\"fixing endianity\"); var roff = toff + y * bpl; for ( var x = 1; x < bpl; x += 2 ) { var t = tgt[ roff + x ]; tgt[ roff + x ] = tgt[ roff + x - 1 ]; tgt[ roff + x - 1 ] = t; } } //*/ if ( img[ 't317' ] && img[ 't317' ][ 0 ] == 2 ) { for ( var y = 0; y < h; y ++ ) { var ntoff = toff + y * bpl; if ( bps == 16 ) for ( var j = bpp; j < bpl; j += 2 ) { var nv = ( ( tgt[ ntoff + j + 1 ] < 8 ) | tgt[ ntoff + j ] ) + ( ( tgt[ ntoff + j - bpp + 1 ] < 8 ) | tgt[ ntoff + j - bpp ] ); tgt[ ntoff + j ] = nv & 255; tgt[ ntoff + j + 1 ] = ( nv >>> 8 ) & 255; } else if ( noc == 3 ) for ( var j = 3; j < bpl; j += 3 ) { tgt[ ntoff + j ] = ( tgt[ ntoff + j ] + tgt[ ntoff + j - 3 ] ) & 255; tgt[ ntoff + j + 1 ] = ( tgt[ ntoff + j + 1 ] + tgt[ ntoff + j - 2 ] ) & 255; tgt[ ntoff + j + 2 ] = ( tgt[ ntoff + j + 2 ] + tgt[ ntoff + j - 1 ] ) & 255; } else for ( var j = bpp; j < bpl; j ++ ) tgt[ ntoff + j ] = ( tgt[ ntoff + j ] + tgt[ ntoff + j - bpp ] ) & 255; } } }; UTIF.decode._decodeLogLuv32 = function ( img, data, off, len, tgt, toff ) { var w = img.width, qw = w * 4; var io = 0, out = new Uint8Array( qw ); while ( io < len ) { var oo = 0; while ( oo < qw ) { var c = data[ off + io ]; io ++; if ( c < 128 ) { for ( var j = 0; j < c; j ++ ) out[ oo + j ] = data[ off + io + j ]; oo += c; io += c; } else { c = c - 126; for ( var j = 0; j < c; j ++ ) out[ oo + j ] = data[ off + io ]; oo += c; io ++; } } for ( var x = 0; x < w; x ++ ) { tgt[ toff + 0 ] = out[ x ]; tgt[ toff + 1 ] = out[ x + w ]; tgt[ toff + 2 ] = out[ x + w * 2 ]; tgt[ toff + 4 ] = out[ x + w * 3 ]; toff += 6; } } }; UTIF.tags = {}; //UTIF.ttypes = { 256:3,257:3,258:3, 259:3, 262:3, 273:4, 274:3, 277:3,278:4,279:4, 282:5, 283:5, 284:3, 286:5,287:5, 296:3, 305:2, 306:2, 338:3, 513:4, 514:4, 34665:4 }; // start at tag 250 UTIF._types = function () { var main = new Array( 250 ); main.fill( 0 ); main = main.concat( [ 0, 0, 0, 0, 4, 3, 3, 3, 3, 3, 0, 0, 3, 0, 0, 0, 3, 0, 0, 2, 2, 2, 2, 4, 3, 0, 0, 3, 4, 4, 3, 3, 5, 5, 3, 2, 5, 5, 0, 0, 0, 0, 4, 4, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 3, 5, 5, 3, 0, 3, 3, 4, 4, 4, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ] ); var rest = { 33432: 2, 33434: 5, 33437: 5, 34665: 4, 34850: 3, 34853: 4, 34855: 3, 34864: 3, 34866: 4, 36864: 7, 36867: 2, 36868: 2, 37121: 7, 37377: 10, 37378: 5, 37380: 10, 37381: 5, 37383: 3, 37384: 3, 37385: 3, 37386: 5, 37510: 7, 37520: 2, 37521: 2, 37522: 2, 40960: 7, 40961: 3, 40962: 4, 40963: 4, 40965: 4, 41486: 5, 41487: 5, 41488: 3, 41985: 3, 41986: 3, 41987: 3, 41988: 5, 41989: 3, 41990: 3, 41993: 3, 41994: 3, 41995: 7, 41996: 3, 42032: 2, 42033: 2, 42034: 5, 42036: 2, 42037: 2, 59932: 7 }; return { basic: { main: main, rest: rest }, gps: { main: [ 1, 2, 5, 2, 5, 1, 5, 5, 0, 9 ], rest: { 18: 2, 29: 2 } } }; }(); UTIF._readIFD = function ( bin, data, offset, ifds, depth, prm ) { var cnt = bin.readUshort( data, offset ); offset += 2; var ifd = {}; if ( prm.debug ) console.log( ' '.repeat( depth ), ifds.length - 1, '>>>----------------' ); for ( var i = 0; i < cnt; i ++ ) { var tag = bin.readUshort( data, offset ); offset += 2; var type = bin.readUshort( data, offset ); offset += 2; var num = bin.readUint( data, offset ); offset += 4; var voff = bin.readUint( data, offset ); offset += 4; var arr = []; //ifd[\"t\"+tag+\"-\"+UTIF.tags[tag]] = arr; if ( type == 1 || type == 7 ) { arr = new Uint8Array( data.buffer, ( num < 5 ? offset - 4 : voff ), num ); } if ( type == 2 ) { var o0 = ( num < 5 ? offset - 4 : voff ), c = data[ o0 ], len = Math.max( 0, Math.min( num - 1, data.length - o0 ) ); if ( c < 128 || len == 0 ) arr.push( bin.readASCII( data, o0, len ) ); else arr = new Uint8Array( data.buffer, o0, len ); } if ( type == 3 ) { for ( var j = 0; j < num; j ++ ) arr.push( bin.readUshort( data, ( num < 3 ? offset - 4 : voff ) + 2 * j ) ); } if ( type == 4 || type == 13 ) { for ( var j = 0; j < num; j ++ ) arr.push( bin.readUint( data, ( num < 2 ? offset - 4 : voff ) + 4 * j ) ); } if ( type == 5 || type == 10 ) { var ri = type == 5 ? bin.readUint : bin.readInt; for ( var j = 0; j < num; j ++ ) arr.push( [ ri( data, voff + j * 8 ), ri( data, voff + j * 8 + 4 ) ] ); } if ( type == 8 ) { for ( var j = 0; j < num; j ++ ) arr.push( bin.readShort( data, ( num < 3 ? offset - 4 : voff ) + 2 * j ) ); } if ( type == 9 ) { for ( var j = 0; j < num; j ++ ) arr.push( bin.readInt( data, ( num < 2 ? offset - 4 : voff ) + 4 * j ) ); } if ( type == 11 ) { for ( var j = 0; j < num; j ++ ) arr.push( bin.readFloat( data, voff + j * 4 ) ); } if ( type == 12 ) { for ( var j = 0; j < num; j ++ ) arr.push( bin.readDouble( data, voff + j * 8 ) ); } if ( num != 0 && arr.length == 0 ) { console.log( tag, 'unknown TIFF tag type: ', type, 'num:', num ); if ( i == 0 ) return; continue; } if ( prm.debug ) console.log( ' '.repeat( depth ), tag, type, UTIF.tags[ tag ], arr ); ifd[ 't' + tag ] = arr; if ( tag == 330 || tag == 34665 || tag == 34853 || ( tag == 50740 && bin.readUshort( data, bin.readUint( arr, 0 ) ) < 300 ) || tag == 61440 ) { var oarr = tag == 50740 ? [ bin.readUint( arr, 0 ) ] : arr; var subfd = []; for ( var j = 0; j < oarr.length; j ++ ) UTIF._readIFD( bin, data, oarr[ j ], subfd, depth + 1, prm ); if ( tag == 330 ) ifd.subIFD = subfd; if ( tag == 34665 ) ifd.exifIFD = subfd[ 0 ]; if ( tag == 34853 ) ifd.gpsiIFD = subfd[ 0 ]; //console.log(\"gps\", subfd[0]); } if ( tag == 50740 ) ifd.dngPrvt = subfd[ 0 ]; if ( tag == 61440 ) ifd.fujiIFD = subfd[ 0 ]; } if ( tag == 37500 && prm.parseMN ) { var mn = arr; //console.log(bin.readASCII(mn,0,mn.length), mn); if ( bin.readASCII( mn, 0, 5 ) == 'Nikon' ) ifd.makerNote = UTIF[ 'decode' ]( mn.slice( 10 ).buffer )[ 0 ]; else if ( bin.readUshort( data, voff ) < 300 && bin.readUshort( data, voff + 4 ) 8 ) & 255; buff[ p + 2 ] = ( n >>> 16 ) & 255; buff[ p + 3 ] = ( n >>> 24 ) & 255; }, writeASCII: UTIF._binBE.writeASCII }; UTIF._copyTile = function ( tb, tw, th, b, w, h, xoff, yoff ) { //log(\"copyTile\", tw, th, w, h, xoff, yoff); var xlim = Math.min( tw, w - xoff ); var ylim = Math.min( th, h - yoff ); for ( var y = 0; y < ylim; y ++ ) { var tof = ( yoff + y ) * w + xoff; var sof = y * tw; for ( var x = 0; x < xlim; x ++ ) b[ tof + x ] = tb[ sof + x ]; } }; export { LogLuvLoader };"},{"title":"","date":"2023-10-12T14:08:40.702Z","updated":"2023-10-12T14:08:40.702Z","comments":true,"path":"js/three/jsm/loaders/MDDLoader.js","permalink":"http://19999997.xyz/js/three/jsm/loaders/MDDLoader.js","excerpt":"","text":"/** * MDD is a special format that stores a position for every vertex in a model for every frame in an animation. * Similar to BVH, it can be used to transfer animation data between different 3D applications or engines. * * MDD stores its data in binary format (big endian) in the following way: * * number of frames (a single uint32) * number of vertices (a single uint32) * time values for each frame (sequence of float32) * vertex data for each frame (sequence of float32) */ import { AnimationClip, BufferAttribute, FileLoader, Loader, NumberKeyframeTrack } from 'three'; class MDDLoader extends Loader { constructor( manager ) { super( manager ); } load( url, onLoad, onProgress, onError ) { const scope = this; const loader = new FileLoader( this.manager ); loader.setPath( this.path ); loader.setResponseType( 'arraybuffer' ); loader.load( url, function ( data ) { onLoad( scope.parse( data ) ); }, onProgress, onError ); } parse( data ) { const view = new DataView( data ); const totalFrames = view.getUint32( 0 ); const totalPoints = view.getUint32( 4 ); let offset = 8; // animation clip const times = new Float32Array( totalFrames ); const values = new Float32Array( totalFrames * totalFrames ).fill( 0 ); for ( let i = 0; i < totalFrames; i ++ ) { times[ i ] = view.getFloat32( offset ); offset += 4; values[ ( totalFrames * i ) + i ] = 1; } const track = new NumberKeyframeTrack( '.morphTargetInfluences', times, values ); const clip = new AnimationClip( 'default', times[ times.length - 1 ], [ track ] ); // morph targets const morphTargets = []; for ( let i = 0; i < totalFrames; i ++ ) { const morphTarget = new Float32Array( totalPoints * 3 ); for ( let j = 0; j < totalPoints; j ++ ) { const stride = ( j * 3 ); morphTarget[ stride + 0 ] = view.getFloat32( offset ); offset += 4; // x morphTarget[ stride + 1 ] = view.getFloat32( offset ); offset += 4; // y morphTarget[ stride + 2 ] = view.getFloat32( offset ); offset += 4; // z } const attribute = new BufferAttribute( morphTarget, 3 ); attribute.name = 'morph_' + i; morphTargets.push( attribute ); } return { morphTargets: morphTargets, clip: clip }; } } export { MDDLoader };"},{"title":"","date":"2023-10-12T14:08:40.708Z","updated":"2023-10-12T14:08:40.708Z","comments":true,"path":"js/three/jsm/loaders/MTLLoader.js","permalink":"http://19999997.xyz/js/three/jsm/loaders/MTLLoader.js","excerpt":"","text":"import { Color, DefaultLoadingManager, FileLoader, FrontSide, Loader, LoaderUtils, MeshPhongMaterial, RepeatWrapping, TextureLoader, Vector2, SRGBColorSpace } from 'three'; /** * Loads a Wavefront .mtl file specifying materials */ class MTLLoader extends Loader { constructor( manager ) { super( manager ); } /** * Loads and parses a MTL asset from a URL. * * @param {String} url - URL to the MTL file. * @param {Function} [onLoad] - Callback invoked with the loaded object. * @param {Function} [onProgress] - Callback for download progress. * @param {Function} [onError] - Callback for download errors. * * @see setPath setResourcePath * * @note In order for relative texture references to resolve correctly * you must call setResourcePath() explicitly prior to load. */ load( url, onLoad, onProgress, onError ) { const scope = this; const path = ( this.path === '' ) ? LoaderUtils.extractUrlBase( url ) : this.path; const loader = new FileLoader( this.manager ); loader.setPath( this.path ); loader.setRequestHeader( this.requestHeader ); loader.setWithCredentials( this.withCredentials ); loader.load( url, function ( text ) { try { onLoad( scope.parse( text, path ) ); } catch ( e ) { if ( onError ) { onError( e ); } else { console.error( e ); } scope.manager.itemError( url ); } }, onProgress, onError ); } setMaterialOptions( value ) { this.materialOptions = value; return this; } /** * Parses a MTL file. * * @param {String} text - Content of MTL file * @return {MaterialCreator} * * @see setPath setResourcePath * * @note In order for relative texture references to resolve correctly * you must call setResourcePath() explicitly prior to parse. */ parse( text, path ) { const lines = text.split( '\\n' ); let info = {}; const delimiter_pattern = /\\s+/; const materialsInfo = {}; for ( let i = 0; i < lines.length; i ++ ) { let line = lines[ i ]; line = line.trim(); if ( line.length === 0 || line.charAt( 0 ) === '#' ) { // Blank line or comment ignore continue; } const pos = line.indexOf( ' ' ); let key = ( pos >= 0 ) ? line.substring( 0, pos ) : line; key = key.toLowerCase(); let value = ( pos >= 0 ) ? line.substring( pos + 1 ) : ''; value = value.trim(); if ( key === 'newmtl' ) { // New material info = { name: value }; materialsInfo[ value ] = info; } else { if ( key === 'ka' || key === 'kd' || key === 'ks' || key === 'ke' ) { const ss = value.split( delimiter_pattern, 3 ); info[ key ] = [ parseFloat( ss[ 0 ] ), parseFloat( ss[ 1 ] ), parseFloat( ss[ 2 ] ) ]; } else { info[ key ] = value; } } } const materialCreator = new MaterialCreator( this.resourcePath || path, this.materialOptions ); materialCreator.setCrossOrigin( this.crossOrigin ); materialCreator.setManager( this.manager ); materialCreator.setMaterials( materialsInfo ); return materialCreator; } } /** * Create a new MTLLoader.MaterialCreator * @param baseUrl - Url relative to which textures are loaded * @param options - Set of options on how to construct the materials * side: Which side to apply the material * FrontSide (default), THREE.BackSide, THREE.DoubleSide * wrap: What type of wrapping to apply for textures * RepeatWrapping (default), THREE.ClampToEdgeWrapping, THREE.MirroredRepeatWrapping * normalizeRGB: RGBs need to be normalized to 0-1 from 0-255 * Default: false, assumed to be already normalized * ignoreZeroRGBs: Ignore values of RGBs (Ka,Kd,Ks) that are all 0's * Default: false * @constructor */ class MaterialCreator { constructor( baseUrl = '', options = {} ) { this.baseUrl = baseUrl; this.options = options; this.materialsInfo = {}; this.materials = {}; this.materialsArray = []; this.nameLookup = {}; this.crossOrigin = 'anonymous'; this.side = ( this.options.side !== undefined ) ? this.options.side : FrontSide; this.wrap = ( this.options.wrap !== undefined ) ? this.options.wrap : RepeatWrapping; } setCrossOrigin( value ) { this.crossOrigin = value; return this; } setManager( value ) { this.manager = value; } setMaterials( materialsInfo ) { this.materialsInfo = this.convert( materialsInfo ); this.materials = {}; this.materialsArray = []; this.nameLookup = {}; } convert( materialsInfo ) { if ( ! this.options ) return materialsInfo; const converted = {}; for ( const mn in materialsInfo ) { // Convert materials info into normalized form based on options const mat = materialsInfo[ mn ]; const covmat = {}; converted[ mn ] = covmat; for ( const prop in mat ) { let save = true; let value = mat[ prop ]; const lprop = prop.toLowerCase(); switch ( lprop ) { case 'kd': case 'ka': case 'ks': // Diffuse color (color under white light) using RGB values if ( this.options && this.options.normalizeRGB ) { value = [ value[ 0 ] / 255, value[ 1 ] / 255, value[ 2 ] / 255 ]; } if ( this.options && this.options.ignoreZeroRGBs ) { if ( value[ 0 ] === 0 && value[ 1 ] === 0 && value[ 2 ] === 0 ) { // ignore save = false; } } break; default: break; } if ( save ) { covmat[ lprop ] = value; } } } return converted; } preload() { for ( const mn in this.materialsInfo ) { this.create( mn ); } } getIndex( materialName ) { return this.nameLookup[ materialName ]; } getAsArray() { let index = 0; for ( const mn in this.materialsInfo ) { this.materialsArray[ index ] = this.create( mn ); this.nameLookup[ mn ] = index; index ++; } return this.materialsArray; } create( materialName ) { if ( this.materials[ materialName ] === undefined ) { this.createMaterial_( materialName ); } return this.materials[ materialName ]; } createMaterial_( materialName ) { // Create material const scope = this; const mat = this.materialsInfo[ materialName ]; const params = { name: materialName, side: this.side }; function resolveURL( baseUrl, url ) { if ( typeof url !== 'string' || url === '' ) return ''; // Absolute URL if ( /^https?:\\/\\//i.test( url ) ) return url; return baseUrl + url; } function setMapForType( mapType, value ) { if ( params[ mapType ] ) return; // Keep the first encountered texture const texParams = scope.getTextureParams( value, params ); const map = scope.loadTexture( resolveURL( scope.baseUrl, texParams.url ) ); map.repeat.copy( texParams.scale ); map.offset.copy( texParams.offset ); map.wrapS = scope.wrap; map.wrapT = scope.wrap; if ( mapType === 'map' || mapType === 'emissiveMap' ) { map.colorSpace = SRGBColorSpace; } params[ mapType ] = map; } for ( const prop in mat ) { const value = mat[ prop ]; let n; if ( value === '' ) continue; switch ( prop.toLowerCase() ) { // Ns is material specular exponent case 'kd': // Diffuse color (color under white light) using RGB values params.color = new Color().fromArray( value ).convertSRGBToLinear(); break; case 'ks': // Specular color (color when light is reflected from shiny surface) using RGB values params.specular = new Color().fromArray( value ).convertSRGBToLinear(); break; case 'ke': // Emissive using RGB values params.emissive = new Color().fromArray( value ).convertSRGBToLinear(); break; case 'map_kd': // Diffuse texture map setMapForType( 'map', value ); break; case 'map_ks': // Specular map setMapForType( 'specularMap', value ); break; case 'map_ke': // Emissive map setMapForType( 'emissiveMap', value ); break; case 'norm': setMapForType( 'normalMap', value ); break; case 'map_bump': case 'bump': // Bump texture map setMapForType( 'bumpMap', value ); break; case 'map_d': // Alpha map setMapForType( 'alphaMap', value ); params.transparent = true; break; case 'ns': // The specular exponent (defines the focus of the specular highlight) // A high exponent results in a tight, concentrated highlight. Ns values normally range from 0 to 1000. params.shininess = parseFloat( value ); break; case 'd': n = parseFloat( value ); if ( n < 1 ) { params.opacity = n; params.transparent = true; } break; case 'tr': n = parseFloat( value ); if ( this.options && this.options.invertTrProperty ) n = 1 - n; if ( n > 0 ) { params.opacity = 1 - n; params.transparent = true; } break; default: break; } } this.materials[ materialName ] = new MeshPhongMaterial( params ); return this.materials[ materialName ]; } getTextureParams( value, matParams ) { const texParams = { scale: new Vector2( 1, 1 ), offset: new Vector2( 0, 0 ) }; const items = value.split( /\\s+/ ); let pos; pos = items.indexOf( '-bm' ); if ( pos >= 0 ) { matParams.bumpScale = parseFloat( items[ pos + 1 ] ); items.splice( pos, 2 ); } pos = items.indexOf( '-s' ); if ( pos >= 0 ) { texParams.scale.set( parseFloat( items[ pos + 1 ] ), parseFloat( items[ pos + 2 ] ) ); items.splice( pos, 4 ); // we expect 3 parameters here! } pos = items.indexOf( '-o' ); if ( pos >= 0 ) { texParams.offset.set( parseFloat( items[ pos + 1 ] ), parseFloat( items[ pos + 2 ] ) ); items.splice( pos, 4 ); // we expect 3 parameters here! } texParams.url = items.join( ' ' ).trim(); return texParams; } loadTexture( url, mapping, onLoad, onProgress, onError ) { const manager = ( this.manager !== undefined ) ? this.manager : DefaultLoadingManager; let loader = manager.getHandler( url ); if ( loader === null ) { loader = new TextureLoader( manager ); } if ( loader.setCrossOrigin ) loader.setCrossOrigin( this.crossOrigin ); const texture = loader.load( url, onLoad, onProgress, onError ); if ( mapping !== undefined ) texture.mapping = mapping; return texture; } } export { MTLLoader };"},{"title":"","date":"2023-10-12T14:08:40.711Z","updated":"2023-10-12T14:08:40.711Z","comments":true,"path":"js/three/jsm/loaders/MaterialXLoader.js","permalink":"http://19999997.xyz/js/three/jsm/loaders/MaterialXLoader.js","excerpt":"","text":"import { FileLoader, Loader, TextureLoader, RepeatWrapping } from 'three'; import { MeshPhysicalNodeMaterial, float, bool, int, vec2, vec3, vec4, color, texture, positionLocal, add, sub, mul, div, mod, abs, sign, floor, ceil, round, pow, sin, cos, tan, asin, acos, atan2, sqrt, exp, clamp, min, max, normalize, length, dot, cross, normalMap, remap, smoothstep, luminance, mx_rgbtohsv, mx_hsvtorgb, mix, mx_ramplr, mx_ramptb, mx_splitlr, mx_splittb, mx_fractal_noise_float, mx_noise_float, mx_cell_noise_float, mx_worley_noise_float, mx_transform_uv, mx_safepower, mx_contrast, mx_srgb_texture_to_lin_rec709, saturation } from 'three/nodes'; const colorSpaceLib = { mx_srgb_texture_to_lin_rec709 }; class MtlXElement { constructor( name, nodeFunc, params = null ) { this.name = name; this.nodeFunc = nodeFunc; this.params = params; } } // Ref: https://github.com/mrdoob/three.js/issues/24674 const MtlXElements = [ // < Math >> new MtlXElement( 'add', add, [ 'in1', 'in2' ] ), new MtlXElement( 'subtract', sub, [ 'in1', 'in2' ] ), new MtlXElement( 'multiply', mul, [ 'in1', 'in2' ] ), new MtlXElement( 'divide', div, [ 'in1', 'in2' ] ), new MtlXElement( 'modulo', mod, [ 'in1', 'in2' ] ), new MtlXElement( 'absval', abs, [ 'in1', 'in2' ] ), new MtlXElement( 'sign', sign, [ 'in1', 'in2' ] ), new MtlXElement( 'floor', floor, [ 'in1', 'in2' ] ), new MtlXElement( 'ceil', ceil, [ 'in1', 'in2' ] ), new MtlXElement( 'round', round, [ 'in1', 'in2' ] ), new MtlXElement( 'power', pow, [ 'in1', 'in2' ] ), new MtlXElement( 'sin', sin, [ 'in' ] ), new MtlXElement( 'cos', cos, [ 'in' ] ), new MtlXElement( 'tan', tan, [ 'in' ] ), new MtlXElement( 'asin', asin, [ 'in' ] ), new MtlXElement( 'acos', acos, [ 'in' ] ), new MtlXElement( 'atan2', atan2, [ 'in1', 'in2' ] ), new MtlXElement( 'sqrt', sqrt, [ 'in' ] ), //new MtlXElement( 'ln', ... ), new MtlXElement( 'exp', exp, [ 'in' ] ), new MtlXElement( 'clamp', clamp, [ 'in', 'low', 'high' ] ), new MtlXElement( 'min', min, [ 'in1', 'in2' ] ), new MtlXElement( 'max', max, [ 'in1', 'in2' ] ), new MtlXElement( 'normalize', normalize, [ 'in' ] ), new MtlXElement( 'magnitude', length, [ 'in1', 'in2' ] ), new MtlXElement( 'dotproduct', dot, [ 'in1', 'in2' ] ), new MtlXElement( 'crossproduct', cross, [ 'in' ] ), //new MtlXElement( 'transformpoint', ... ), //new MtlXElement( 'transformvector', ... ), //new MtlXElement( 'transformnormal', ... ), //new MtlXElement( 'transformmatrix', ... ), new MtlXElement( 'normalmap', normalMap, [ 'in', 'scale' ] ), //new MtlXElement( 'transpose', ... ), //new MtlXElement( 'determinant', ... ), //new MtlXElement( 'invertmatrix', ... ), //new MtlXElement( 'rotate2d', rotateUV, [ 'in', radians( 'amount' )** ] ), //new MtlXElement( 'rotate3d', ... ), //new MtlXElement( 'arrayappend', ... ), //new MtlXElement( 'dot', ... ), // < Adjustment >> new MtlXElement( 'remap', remap, [ 'in', 'inlow', 'inhigh', 'outlow', 'outhigh' ] ), new MtlXElement( 'smoothstep', smoothstep, [ 'in', 'low', 'high' ] ), //new MtlXElement( 'curveadjust', ... ), //new MtlXElement( 'curvelookup', ... ), new MtlXElement( 'luminance', luminance, [ 'in', 'lumacoeffs' ] ), new MtlXElement( 'rgbtohsv', mx_rgbtohsv, [ 'in' ] ), new MtlXElement( 'hsvtorgb', mx_hsvtorgb, [ 'in' ] ), // < Mix >> new MtlXElement( 'mix', mix, [ 'bg', 'fg', 'mix' ] ), // < Channel >> new MtlXElement( 'combine2', vec2, [ 'in1', 'in2' ] ), new MtlXElement( 'combine3', vec3, [ 'in1', 'in2', 'in3' ] ), new MtlXElement( 'combine4', vec4, [ 'in1', 'in2', 'in3', 'in4' ] ), // < Procedural >> new MtlXElement( 'ramplr', mx_ramplr, [ 'valuel', 'valuer', 'texcoord' ] ), new MtlXElement( 'ramptb', mx_ramptb, [ 'valuet', 'valueb', 'texcoord' ] ), new MtlXElement( 'splitlr', mx_splitlr, [ 'valuel', 'valuer', 'texcoord' ] ), new MtlXElement( 'splittb', mx_splittb, [ 'valuet', 'valueb', 'texcoord' ] ), new MtlXElement( 'noise2d', mx_noise_float, [ 'texcoord', 'amplitude', 'pivot' ] ), new MtlXElement( 'noise3d', mx_noise_float, [ 'texcoord', 'amplitude', 'pivot' ] ), new MtlXElement( 'fractal3d', mx_fractal_noise_float, [ 'position', 'octaves', 'lacunarity', 'diminish', 'amplitude' ] ), new MtlXElement( 'cellnoise2d', mx_cell_noise_float, [ 'texcoord' ] ), new MtlXElement( 'cellnoise3d', mx_cell_noise_float, [ 'texcoord' ] ), new MtlXElement( 'worleynoise2d', mx_worley_noise_float, [ 'texcoord', 'jitter' ] ), new MtlXElement( 'worleynoise3d', mx_worley_noise_float, [ 'texcoord', 'jitter' ] ), // < Supplemental >> //new MtlXElement( 'tiledimage', ... ), //new MtlXElement( 'triplanarprojection', triplanarTextures, [ 'filex', 'filey', 'filez' ] ), //new MtlXElement( 'ramp4', ... ), //new MtlXElement( 'place2d', mx_place2d, [ 'texcoord', 'pivot', 'scale', 'rotate', 'offset' ] ), new MtlXElement( 'safepower', mx_safepower, [ 'in1', 'in2' ] ), new MtlXElement( 'contrast', mx_contrast, [ 'in', 'amount', 'pivot' ] ), //new MtlXElement( 'hsvadjust', ... ), new MtlXElement( 'saturate', saturation, [ 'in', 'amount' ] ), //new MtlXElement( 'extract', ... ), //new MtlXElement( 'separate2', ... ), //new MtlXElement( 'separate3', ... ), //new MtlXElement( 'separate4', ... ) ]; const MtlXLibrary = {}; MtlXElements.forEach( element => MtlXLibrary[ element.name ] = element ); class MaterialXLoader extends Loader { constructor( manager ) { super( manager ); } load( url, onLoad, onProgress, onError ) { new FileLoader( this.manager ) .setPath( this.path ) .load( url, async ( text ) => { try { onLoad( this.parse( text ) ); } catch ( e ) { onError( e ); } }, onProgress, onError ); return this; } parse( text ) { return new MaterialX( this.manager, this.path ).parse( text ); } } class MaterialXNode { constructor( materialX, nodeXML, nodePath = '' ) { this.materialX = materialX; this.nodeXML = nodeXML; this.nodePath = nodePath ? nodePath + '/' + this.name : this.name; this.parent = null; this.node = null; this.children = []; } get element() { return this.nodeXML.nodeName; } get nodeGraph() { return this.getAttribute( 'nodegraph' ); } get nodeName() { return this.getAttribute( 'nodename' ); } get interfaceName() { return this.getAttribute( 'interfacename' ); } get output() { return this.getAttribute( 'output' ); } get name() { return this.getAttribute( 'name' ); } get type() { return this.getAttribute( 'type' ); } get value() { return this.getAttribute( 'value' ); } getNodeGraph() { let nodeX = this; while ( nodeX !== null ) { if ( nodeX.element === 'nodegraph' ) { break; } nodeX = nodeX.parent; } return nodeX; } getRoot() { let nodeX = this; while ( nodeX.parent !== null ) { nodeX = nodeX.parent; } return nodeX; } get referencePath() { let referencePath = null; if ( this.nodeGraph !== null && this.output !== null ) { referencePath = this.nodeGraph + '/' + this.output; } else if ( this.nodeName !== null || this.interfaceName !== null ) { referencePath = this.getNodeGraph().nodePath + '/' + ( this.nodeName || this.interfaceName ); } return referencePath; } get hasReference() { return this.referencePath !== null; } get isConst() { return this.element === 'input' && this.value !== null && this.type !== 'filename'; } getColorSpaceNode() { const csSource = this.getAttribute( 'colorspace' ); const csTarget = this.getRoot().getAttribute( 'colorspace' ); const nodeName = `mx_${ csSource }_to_${ csTarget }`; return colorSpaceLib[ nodeName ]; } getTexture() { const filePrefix = this.getRecursiveAttribute( 'fileprefix' ) || ''; const texture = this.materialX.textureLoader.load( filePrefix + this.value ); texture.wrapS = texture.wrapT = RepeatWrapping; texture.flipY = false; return texture; } getClassFromType( type ) { let nodeClass = null; if ( type === 'integer' ) nodeClass = int; else if ( type === 'float' ) nodeClass = float; else if ( type === 'vector2' ) nodeClass = vec2; else if ( type === 'vector3' ) nodeClass = vec3; else if ( type === 'vector4' || type === 'color4' ) nodeClass = vec4; else if ( type === 'color3' ) nodeClass = color; else if ( type === 'boolean' ) nodeClass = bool; return nodeClass; } getNode() { let node = this.node; if ( node !== null ) { return node; } // const type = this.type; if ( this.isConst ) { const nodeClass = this.getClassFromType( type ); node = nodeClass( ...this.getVector() ); } else if ( this.hasReference ) { node = this.materialX.getMaterialXNode( this.referencePath ).getNode(); } else { const element = this.element; if ( element === 'convert' ) { const nodeClass = this.getClassFromType( type ); node = nodeClass( this.getNodeByName( 'in' ) ); } else if ( element === 'constant' ) { node = this.getNodeByName( 'value' ); } else if ( element === 'position' ) { node = positionLocal; } else if ( element === 'tiledimage' ) { const file = this.getChildByName( 'file' ); const textureFile = file.getTexture(); const uvTiling = mx_transform_uv( ...this.getNodesByNames( [ 'uvtiling', 'uvoffset' ] ) ); node = texture( textureFile, uvTiling ); const colorSpaceNode = file.getColorSpaceNode(); if ( colorSpaceNode ) { node = colorSpaceNode( node ); } } else if ( element === 'image' ) { const file = this.getChildByName( 'file' ); const uvNode = this.getNodeByName( 'texcoord' ); const textureFile = file.getTexture(); node = texture( textureFile, uvNode ); const colorSpaceNode = file.getColorSpaceNode(); if ( colorSpaceNode ) { node = colorSpaceNode( node ); } } else if ( MtlXLibrary[ element ] !== undefined ) { const nodeElement = MtlXLibrary[ element ]; node = nodeElement.nodeFunc( ...this.getNodesByNames( ...nodeElement.params ) ); } } // if ( node === null ) { console.warn( `THREE.MaterialXLoader: Unexpected node ${ new XMLSerializer().serializeToString( this.nodeXML ) }.` ); node = float( 0 ); } // const nodeToTypeClass = this.getClassFromType( type ); if ( nodeToTypeClass !== null ) { node = nodeToTypeClass( node ); } node.name = this.name; this.node = node; return node; } getChildByName( name ) { for ( const input of this.children ) { if ( input.name === name ) { return input; } } } getNodes() { const nodes = {}; for ( const input of this.children ) { const node = input.getNode(); nodes[ node.name ] = node; } return nodes; } getNodeByName( name ) { const child = this.getChildByName( name ); return child ? child.getNode() : undefined; } getNodesByNames( ...names ) { const nodes = []; for ( const name of names ) { const node = this.getNodeByName( name ); if ( node ) nodes.push( node ); } return nodes; } getValue() { return this.value.trim(); } getVector() { const vector = []; for ( const val of this.getValue().split( /[,|\\s]/ ) ) { if ( val !== '' ) { vector.push( Number( val.trim() ) ); } } return vector; } getAttribute( name ) { return this.nodeXML.getAttribute( name ); } getRecursiveAttribute( name ) { let attribute = this.nodeXML.getAttribute( name ); if ( attribute === null && this.parent !== null ) { attribute = this.parent.getRecursiveAttribute( name ); } return attribute; } setStandardSurfaceToGltfPBR( material ) { const inputs = this.getNodes(); // let colorNode = null; if ( inputs.base && inputs.base_color ) colorNode = mul( inputs.base, inputs.base_color ); else if ( inputs.base ) colorNode = inputs.base; else if ( inputs.base_color ) colorNode = inputs.base_color; // let roughnessNode = null; if ( inputs.specular_roughness ) roughnessNode = inputs.specular_roughness; // let metalnessNode = null; if ( inputs.metalness ) metalnessNode = inputs.metalness; // let clearcoatNode = null; let clearcoatRoughnessNode = null; if ( inputs.coat ) clearcoatNode = inputs.coat; if ( inputs.coat_roughness ) clearcoatRoughnessNode = inputs.coat_roughness; if ( inputs.coat_color ) { colorNode = colorNode ? mul( colorNode, inputs.coat_color ) : colorNode; } // material.colorNode = colorNode || color( 0.8, 0.8, 0.8 ); material.roughnessNode = roughnessNode || float( 0.2 ); material.metalnessNode = metalnessNode || float( 0 ); material.clearcoatNode = clearcoatNode || float( 0 ); material.clearcoatRoughnessNode = clearcoatRoughnessNode || float( 0 ); } /*setGltfPBR( material ) { const inputs = this.getNodes(); console.log( inputs ); }*/ setMaterial( material ) { const element = this.element; if ( element === 'gltf_pbr' ) { //this.setGltfPBR( material ); } else if ( element === 'standard_surface' ) { this.setStandardSurfaceToGltfPBR( material ); } } toMaterial() { const material = new MeshPhysicalNodeMaterial(); material.name = this.name; for ( const nodeX of this.children ) { const shaderProperties = this.materialX.getMaterialXNode( nodeX.nodeName ); shaderProperties.setMaterial( material ); } return material; } toMaterials() { const materials = {}; for ( const nodeX of this.children ) { if ( nodeX.element === 'surfacematerial' ) { const material = nodeX.toMaterial(); materials[ material.name ] = material; } } return materials; } add( materialXNode ) { materialXNode.parent = this; this.children.push( materialXNode ); } } class MaterialX { constructor( manager, path ) { this.manager = manager; this.path = path; this.resourcePath = ''; this.nodesXLib = new Map(); //this.nodesXRefLib = new WeakMap(); this.textureLoader = new TextureLoader( manager ); } addMaterialXNode( materialXNode ) { this.nodesXLib.set( materialXNode.nodePath, materialXNode ); } /*getMaterialXNodeFromXML( xmlNode ) { return this.nodesXRefLib.get( xmlNode ); }*/ getMaterialXNode( ...names ) { return this.nodesXLib.get( names.join( '/' ) ); } parseNode( nodeXML, nodePath = '' ) { const materialXNode = new MaterialXNode( this, nodeXML, nodePath ); if ( materialXNode.nodePath ) this.addMaterialXNode( materialXNode ); for ( const childNodeXML of nodeXML.children ) { const childMXNode = this.parseNode( childNodeXML, materialXNode.nodePath ); materialXNode.add( childMXNode ); } return materialXNode; } parse( text ) { const rootXML = new DOMParser().parseFromString( text, 'application/xml' ).documentElement; this.textureLoader.setPath( this.path ); // const materials = this.parseNode( rootXML ).toMaterials(); return { materials }; } } export { MaterialXLoader };"},{"title":"","date":"2023-10-12T14:08:40.705Z","updated":"2023-10-12T14:08:40.705Z","comments":true,"path":"js/three/jsm/loaders/MMDLoader.js","permalink":"http://19999997.xyz/js/three/jsm/loaders/MMDLoader.js","excerpt":"","text":"import { AddOperation, AnimationClip, Bone, BufferGeometry, Color, CustomBlending, TangentSpaceNormalMap, DoubleSide, DstAlphaFactor, Euler, FileLoader, Float32BufferAttribute, FrontSide, Interpolant, Loader, LoaderUtils, UniformsUtils, ShaderMaterial, MultiplyOperation, NearestFilter, NumberKeyframeTrack, OneMinusSrcAlphaFactor, Quaternion, QuaternionKeyframeTrack, RepeatWrapping, Skeleton, SkinnedMesh, SrcAlphaFactor, SRGBColorSpace, TextureLoader, Uint16BufferAttribute, Vector3, VectorKeyframeTrack, RGB_S3TC_DXT1_Format, RGB_PVRTC_4BPPV1_Format, RGB_PVRTC_2BPPV1_Format, RGB_ETC1_Format, RGB_ETC2_Format } from 'three'; import { MMDToonShader } from '../shaders/MMDToonShader.js'; import { TGALoader } from '../loaders/TGALoader.js'; import { MMDParser } from '../libs/mmdparser.module.js'; /** * Dependencies * - mmd-parser https://github.com/takahirox/mmd-parser * - TGALoader * - OutlineEffect * * MMDLoader creates Three.js Objects from MMD resources as * PMD, PMX, VMD, and VPD files. * * PMD/PMX is a model data format, VMD is a motion data format * VPD is a posing data format used in MMD(Miku Miku Dance). * * MMD official site * - https://sites.google.com/view/evpvp/ * * PMD, VMD format (in Japanese) * - http://blog.goo.ne.jp/torisu_tetosuki/e/209ad341d3ece2b1b4df24abf619d6e4 * * PMX format * - https://gist.github.com/felixjones/f8a06bd48f9da9a4539f * * TODO * - light motion in vmd support. * - SDEF support. * - uv/material/bone morphing support. * - more precise grant skinning support. * - shadow support. */ /** * @param {THREE.LoadingManager} manager */ class MMDLoader extends Loader { constructor( manager ) { super( manager ); this.loader = new FileLoader( this.manager ); this.parser = null; // lazy generation this.meshBuilder = new MeshBuilder( this.manager ); this.animationBuilder = new AnimationBuilder(); } /** * @param {string} animationPath * @return {MMDLoader} */ setAnimationPath( animationPath ) { this.animationPath = animationPath; return this; } // Load MMD assets as Three.js Object /** * Loads Model file (.pmd or .pmx) as a SkinnedMesh. * * @param {string} url - url to Model(.pmd or .pmx) file * @param {function} onLoad * @param {function} onProgress * @param {function} onError */ load( url, onLoad, onProgress, onError ) { const builder = this.meshBuilder.setCrossOrigin( this.crossOrigin ); // resource path let resourcePath; if ( this.resourcePath !== '' ) { resourcePath = this.resourcePath; } else if ( this.path !== '' ) { resourcePath = this.path; } else { resourcePath = LoaderUtils.extractUrlBase( url ); } const modelExtension = this._extractExtension( url ).toLowerCase(); // Should I detect by seeing header? if ( modelExtension !== 'pmd' && modelExtension !== 'pmx' ) { if ( onError ) onError( new Error( 'THREE.MMDLoader: Unknown model file extension .' + modelExtension + '.' ) ); return; } this[ modelExtension === 'pmd' ? 'loadPMD' : 'loadPMX' ]( url, function ( data ) { onLoad( builder.build( data, resourcePath, onProgress, onError ) ); }, onProgress, onError ); } /** * Loads Motion file(s) (.vmd) as a AnimationClip. * If two or more files are specified, they'll be merged. * * @param {string|Array} url - url(s) to animation(.vmd) file(s) * @param {SkinnedMesh|THREE.Camera} object - tracks will be fitting to this object * @param {function} onLoad * @param {function} onProgress * @param {function} onError */ loadAnimation( url, object, onLoad, onProgress, onError ) { const builder = this.animationBuilder; this.loadVMD( url, function ( vmd ) { onLoad( object.isCamera ? builder.buildCameraAnimation( vmd ) : builder.build( vmd, object ) ); }, onProgress, onError ); } /** * Loads mode file and motion file(s) as an object containing * a SkinnedMesh and a AnimationClip. * Tracks of AnimationClip are fitting to the model. * * @param {string} modelUrl - url to Model(.pmd or .pmx) file * @param {string|Array{string}} vmdUrl - url(s) to animation(.vmd) file * @param {function} onLoad * @param {function} onProgress * @param {function} onError */ loadWithAnimation( modelUrl, vmdUrl, onLoad, onProgress, onError ) { const scope = this; this.load( modelUrl, function ( mesh ) { scope.loadAnimation( vmdUrl, mesh, function ( animation ) { onLoad( { mesh: mesh, animation: animation } ); }, onProgress, onError ); }, onProgress, onError ); } // Load MMD assets as Object data parsed by MMDParser /** * Loads .pmd file as an Object. * * @param {string} url - url to .pmd file * @param {function} onLoad * @param {function} onProgress * @param {function} onError */ loadPMD( url, onLoad, onProgress, onError ) { const parser = this._getParser(); this.loader .setMimeType( undefined ) .setPath( this.path ) .setResponseType( 'arraybuffer' ) .setRequestHeader( this.requestHeader ) .setWithCredentials( this.withCredentials ) .load( url, function ( buffer ) { try { onLoad( parser.parsePmd( buffer, true ) ); } catch ( e ) { if ( onError ) onError( e ); } }, onProgress, onError ); } /** * Loads .pmx file as an Object. * * @param {string} url - url to .pmx file * @param {function} onLoad * @param {function} onProgress * @param {function} onError */ loadPMX( url, onLoad, onProgress, onError ) { const parser = this._getParser(); this.loader .setMimeType( undefined ) .setPath( this.path ) .setResponseType( 'arraybuffer' ) .setRequestHeader( this.requestHeader ) .setWithCredentials( this.withCredentials ) .load( url, function ( buffer ) { try { onLoad( parser.parsePmx( buffer, true ) ); } catch ( e ) { if ( onError ) onError( e ); } }, onProgress, onError ); } /** * Loads .vmd file as an Object. If two or more files are specified * they'll be merged. * * @param {string|Array} url - url(s) to .vmd file(s) * @param {function} onLoad * @param {function} onProgress * @param {function} onError */ loadVMD( url, onLoad, onProgress, onError ) { const urls = Array.isArray( url ) ? url : [ url ]; const vmds = []; const vmdNum = urls.length; const parser = this._getParser(); this.loader .setMimeType( undefined ) .setPath( this.animationPath ) .setResponseType( 'arraybuffer' ) .setRequestHeader( this.requestHeader ) .setWithCredentials( this.withCredentials ); for ( let i = 0, il = urls.length; i < il; i ++ ) { this.loader.load( urls[ i ], function ( buffer ) { try { vmds.push( parser.parseVmd( buffer, true ) ); if ( vmds.length === vmdNum ) onLoad( parser.mergeVmds( vmds ) ); } catch ( e ) { if ( onError ) onError( e ); } }, onProgress, onError ); } } /** * Loads .vpd file as an Object. * * @param {string} url - url to .vpd file * @param {boolean} isUnicode * @param {function} onLoad * @param {function} onProgress * @param {function} onError */ loadVPD( url, isUnicode, onLoad, onProgress, onError ) { const parser = this._getParser(); this.loader .setMimeType( isUnicode ? undefined : 'text/plain; charset=shift_jis' ) .setPath( this.animationPath ) .setResponseType( 'text' ) .setRequestHeader( this.requestHeader ) .setWithCredentials( this.withCredentials ) .load( url, function ( text ) { try { onLoad( parser.parseVpd( text, true ) ); } catch ( e ) { if ( onError ) onError( e ); } }, onProgress, onError ); } // private methods _extractExtension( url ) { const index = url.lastIndexOf( '.' ); return index < 0 ? '' : url.slice( index + 1 ); } _getParser() { if ( this.parser === null ) { this.parser = new MMDParser.Parser(); } return this.parser; } } // Utilities /* * base64 encoded defalut toon textures toon00.bmp - toon10.bmp. * We don't need to request external toon image files. */ const DEFAULT_TOON_TEXTURES = [ 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAN0lEQVRYR+3WQREAMBACsZ5/bWiiMvgEBTt5cW37hjsBBAgQIECAwFwgyfYPCCBAgAABAgTWAh8aBHZBl14e8wAAAABJRU5ErkJggg==', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAOUlEQVRYR+3WMREAMAwDsYY/yoDI7MLwIiP40+RJklfcCCBAgAABAgTqArfb/QMCCBAgQIAAgbbAB3z/e0F3js2cAAAAAElFTkSuQmCC', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAN0lEQVRYR+3WQREAMBACsZ5/B5ilMvgEBTt5cW37hjsBBAgQIECAwFwgyfYPCCBAgAABAgTWAh81dWyx0gFwKAAAAABJRU5ErkJggg==', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAOklEQVRYR+3WoREAMAwDsWb/UQtCy9wxTOQJ/oQ8SXKKGwEECBAgQIBAXeDt7f4BAQQIECBAgEBb4AOz8Hzx7WLY4wAAAABJRU5ErkJggg==', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABPUlEQVRYR+1XwW7CMAy1+f9fZOMysSEOEweEOPRNdm3HbdOyIhAcklPrOs/PLy9RygBALxzcCDQFmgJNgaZAU6Ap0BR4PwX8gsRMVLssMRH5HcpzJEaWL7EVg9F1IHRlyqQohgVr4FGUlUcMJSjcUlDw0zvjeun70cLWmneoyf7NgBTQSniBTQQSuJAZsOnnaczjIMb5hCiuHKxokCrJfVnrctyZL0PkJAJe1HMil4nxeyi3Ypfn1kX51jpPvo/JeCNC4PhVdHdJw2XjBR8brF8PEIhNVn12AgP7uHsTBguBn53MUZCqv7Lp07Pn5k1Ro+uWmUNn7D+M57rtk7aG0Vo73xyF/fbFf0bPJjDXngnGocDTdFhygZjwUQrMNrDcmZlQT50VJ/g/UwNyHpu778+yW+/ksOz/BFo54P4AsUXMfRq7XWsAAAAASUVORK5CYII=', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAACMElEQVRYR+2Xv4pTQRTGf2dubhLdICiii2KnYKHVolhauKWPoGAnNr6BD6CvIVaihYuI2i1ia0BY0MZGRHQXjZj/mSPnnskfNWiWZUlzJ5k7M2cm833nO5Mziej2DWWJRUoCpQKlAntSQCqgw39/iUWAGmh37jrRnVsKlgpiqmkoGVABA7E57fvY+pJDdgKqF6HzFCSADkDq+F6AHABtQ+UMVE5D7zXod7fFNhTEckTbj5XQgHzNN+5tQvc5NG7C6BNkp6D3EmpXHDR+dQAjFLchW3VS9rlw3JBh+B7ys5Cf9z0GW1C/7P32AyBAOAz1q4jGliIH3YPuBnSfQX4OGreTIgEYQb/pBDtPnEQ4CivXYPAWBk13oHrB54yA9QuSn2H4AcKRpEILDt0BUzj+RLR1V5EqjD66NPRBVpLcQwjHoHYJOhsQv6U4mnzmrIXJCFr4LDwm/xBUoboG9XX4cc9VKdYoSA2yk5NQLJaKDUjTBoveG3Z2TElTxwjNK4M3LEZgUdDdruvcXzKBpStgp2NPiWi3ks9ZXxIoFVi+AvHLdc9TqtjL3/aYjpPlrzOcEnK62Szhimdd7xX232zFDTgtxezOu3WNMRLjiKgjtOhHVMd1loynVHvOgjuIIJMaELEqhJAV/RCSLbWTcfPFakFgFlALTRRvx+ok6Hlp/Q+v3fmx90bMyUzaEAhmM3KvHlXTL5DxnbGf/1M8RNNACLL5MNtPxP/mypJAqcDSFfgFhpYqWUzhTEAAAAAASUVORK5CYII=', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=' ]; const NON_ALPHA_CHANNEL_FORMATS = [ RGB_S3TC_DXT1_Format, RGB_PVRTC_4BPPV1_Format, RGB_PVRTC_2BPPV1_Format, RGB_ETC1_Format, RGB_ETC2_Format ]; // Builders. They build Three.js object from Object data parsed by MMDParser. /** * @param {THREE.LoadingManager} manager */ class MeshBuilder { constructor( manager ) { this.crossOrigin = 'anonymous'; this.geometryBuilder = new GeometryBuilder(); this.materialBuilder = new MaterialBuilder( manager ); } /** * @param {string} crossOrigin * @return {MeshBuilder} */ setCrossOrigin( crossOrigin ) { this.crossOrigin = crossOrigin; return this; } /** * @param {Object} data - parsed PMD/PMX data * @param {string} resourcePath * @param {function} onProgress * @param {function} onError * @return {SkinnedMesh} */ build( data, resourcePath, onProgress, onError ) { const geometry = this.geometryBuilder.build( data ); const material = this.materialBuilder .setCrossOrigin( this.crossOrigin ) .setResourcePath( resourcePath ) .build( data, geometry, onProgress, onError ); const mesh = new SkinnedMesh( geometry, material ); const skeleton = new Skeleton( initBones( mesh ) ); mesh.bind( skeleton ); // console.log( mesh ); // for console debug return mesh; } } // TODO: Try to remove this function function initBones( mesh ) { const geometry = mesh.geometry; const bones = []; if ( geometry && geometry.bones !== undefined ) { // first, create array of 'Bone' objects from geometry data for ( let i = 0, il = geometry.bones.length; i < il; i ++ ) { const gbone = geometry.bones[ i ]; // create new 'Bone' object const bone = new Bone(); bones.push( bone ); // apply values bone.name = gbone.name; bone.position.fromArray( gbone.pos ); bone.quaternion.fromArray( gbone.rotq ); if ( gbone.scl !== undefined ) bone.scale.fromArray( gbone.scl ); } // second, create bone hierarchy for ( let i = 0, il = geometry.bones.length; i < il; i ++ ) { const gbone = geometry.bones[ i ]; if ( ( gbone.parent !== - 1 ) && ( gbone.parent !== null ) && ( bones[ gbone.parent ] !== undefined ) ) { // subsequent bones in the hierarchy bones[ gbone.parent ].add( bones[ i ] ); } else { // topmost bone, immediate child of the skinned mesh mesh.add( bones[ i ] ); } } } // now the bones are part of the scene graph and children of the skinned mesh. // let's update the corresponding matrices mesh.updateMatrixWorld( true ); return bones; } // class GeometryBuilder { /** * @param {Object} data - parsed PMD/PMX data * @return {BufferGeometry} */ build( data ) { // for geometry const positions = []; const uvs = []; const normals = []; const indices = []; const groups = []; const bones = []; const skinIndices = []; const skinWeights = []; const morphTargets = []; const morphPositions = []; const iks = []; const grants = []; const rigidBodies = []; const constraints = []; // for work let offset = 0; const boneTypeTable = {}; // positions, normals, uvs, skinIndices, skinWeights for ( let i = 0; i < data.metadata.vertexCount; i ++ ) { const v = data.vertices[ i ]; for ( let j = 0, jl = v.position.length; j < jl; j ++ ) { positions.push( v.position[ j ] ); } for ( let j = 0, jl = v.normal.length; j < jl; j ++ ) { normals.push( v.normal[ j ] ); } for ( let j = 0, jl = v.uv.length; j < jl; j ++ ) { uvs.push( v.uv[ j ] ); } for ( let j = 0; j < 4; j ++ ) { skinIndices.push( v.skinIndices.length - 1 >= j ? v.skinIndices[ j ] : 0.0 ); } for ( let j = 0; j < 4; j ++ ) { skinWeights.push( v.skinWeights.length - 1 >= j ? v.skinWeights[ j ] : 0.0 ); } } // indices for ( let i = 0; i < data.metadata.faceCount; i ++ ) { const face = data.faces[ i ]; for ( let j = 0, jl = face.indices.length; j < jl; j ++ ) { indices.push( face.indices[ j ] ); } } // groups for ( let i = 0; i < data.metadata.materialCount; i ++ ) { const material = data.materials[ i ]; groups.push( { offset: offset * 3, count: material.faceCount * 3 } ); offset += material.faceCount; } // bones for ( let i = 0; i < data.metadata.rigidBodyCount; i ++ ) { const body = data.rigidBodies[ i ]; let value = boneTypeTable[ body.boneIndex ]; // keeps greater number if already value is set without any special reasons value = value === undefined ? body.type : Math.max( body.type, value ); boneTypeTable[ body.boneIndex ] = value; } for ( let i = 0; i < data.metadata.boneCount; i ++ ) { const boneData = data.bones[ i ]; const bone = { index: i, transformationClass: boneData.transformationClass, parent: boneData.parentIndex, name: boneData.name, pos: boneData.position.slice( 0, 3 ), rotq: [ 0, 0, 0, 1 ], scl: [ 1, 1, 1 ], rigidBodyType: boneTypeTable[ i ] !== undefined ? boneTypeTable[ i ] : - 1 }; if ( bone.parent !== - 1 ) { bone.pos[ 0 ] -= data.bones[ bone.parent ].position[ 0 ]; bone.pos[ 1 ] -= data.bones[ bone.parent ].position[ 1 ]; bone.pos[ 2 ] -= data.bones[ bone.parent ].position[ 2 ]; } bones.push( bone ); } // iks // TODO: remove duplicated codes between PMD and PMX if ( data.metadata.format === 'pmd' ) { for ( let i = 0; i < data.metadata.ikCount; i ++ ) { const ik = data.iks[ i ]; const param = { target: ik.target, effector: ik.effector, iteration: ik.iteration, maxAngle: ik.maxAngle * 4, links: [] }; for ( let j = 0, jl = ik.links.length; j < jl; j ++ ) { const link = {}; link.index = ik.links[ j ].index; link.enabled = true; if ( data.bones[ link.index ].name.indexOf( 'ひざ' ) >= 0 ) { link.limitation = new Vector3( 1.0, 0.0, 0.0 ); } param.links.push( link ); } iks.push( param ); } } else { for ( let i = 0; i < data.metadata.boneCount; i ++ ) { const ik = data.bones[ i ].ik; if ( ik === undefined ) continue; const param = { target: i, effector: ik.effector, iteration: ik.iteration, maxAngle: ik.maxAngle, links: [] }; for ( let j = 0, jl = ik.links.length; j < jl; j ++ ) { const link = {}; link.index = ik.links[ j ].index; link.enabled = true; if ( ik.links[ j ].angleLimitation === 1 ) { // Revert if rotationMin/Max doesn't work well // link.limitation = new Vector3( 1.0, 0.0, 0.0 ); const rotationMin = ik.links[ j ].lowerLimitationAngle; const rotationMax = ik.links[ j ].upperLimitationAngle; // Convert Left to Right coordinate by myself because // MMDParser doesn't convert. It's a MMDParser's bug const tmp1 = - rotationMax[ 0 ]; const tmp2 = - rotationMax[ 1 ]; rotationMax[ 0 ] = - rotationMin[ 0 ]; rotationMax[ 1 ] = - rotationMin[ 1 ]; rotationMin[ 0 ] = tmp1; rotationMin[ 1 ] = tmp2; link.rotationMin = new Vector3().fromArray( rotationMin ); link.rotationMax = new Vector3().fromArray( rotationMax ); } param.links.push( link ); } iks.push( param ); // Save the reference even from bone data for efficiently // simulating PMX animation system bones[ i ].ik = param; } } // grants if ( data.metadata.format === 'pmx' ) { // bone index -> grant entry map const grantEntryMap = {}; for ( let i = 0; i < data.metadata.boneCount; i ++ ) { const boneData = data.bones[ i ]; const grant = boneData.grant; if ( grant === undefined ) continue; const param = { index: i, parentIndex: grant.parentIndex, ratio: grant.ratio, isLocal: grant.isLocal, affectRotation: grant.affectRotation, affectPosition: grant.affectPosition, transformationClass: boneData.transformationClass }; grantEntryMap[ i ] = { parent: null, children: [], param: param, visited: false }; } const rootEntry = { parent: null, children: [], param: null, visited: false }; // Build a tree representing grant hierarchy for ( const boneIndex in grantEntryMap ) { const grantEntry = grantEntryMap[ boneIndex ]; const parentGrantEntry = grantEntryMap[ grantEntry.parentIndex ] || rootEntry; grantEntry.parent = parentGrantEntry; parentGrantEntry.children.push( grantEntry ); } // Sort grant parameters from parents to children because // grant uses parent's transform that parent's grant is already applied // so grant should be applied in order from parents to children function traverse( entry ) { if ( entry.param ) { grants.push( entry.param ); // Save the reference even from bone data for efficiently // simulating PMX animation system bones[ entry.param.index ].grant = entry.param; } entry.visited = true; for ( let i = 0, il = entry.children.length; i < il; i ++ ) { const child = entry.children[ i ]; // Cut off a loop if exists. (Is a grant loop invalid?) if ( ! child.visited ) traverse( child ); } } traverse( rootEntry ); } // morph function updateAttributes( attribute, morph, ratio ) { for ( let i = 0; i < morph.elementCount; i ++ ) { const element = morph.elements[ i ]; let index; if ( data.metadata.format === 'pmd' ) { index = data.morphs[ 0 ].elements[ element.index ].index; } else { index = element.index; } attribute.array[ index * 3 + 0 ] += element.position[ 0 ] * ratio; attribute.array[ index * 3 + 1 ] += element.position[ 1 ] * ratio; attribute.array[ index * 3 + 2 ] += element.position[ 2 ] * ratio; } } for ( let i = 0; i < data.metadata.morphCount; i ++ ) { const morph = data.morphs[ i ]; const params = { name: morph.name }; const attribute = new Float32BufferAttribute( data.metadata.vertexCount * 3, 3 ); attribute.name = morph.name; for ( let j = 0; j < data.metadata.vertexCount * 3; j ++ ) { attribute.array[ j ] = positions[ j ]; } if ( data.metadata.format === 'pmd' ) { if ( i !== 0 ) { updateAttributes( attribute, morph, 1.0 ); } } else { if ( morph.type === 0 ) { // group for ( let j = 0; j < morph.elementCount; j ++ ) { const morph2 = data.morphs[ morph.elements[ j ].index ]; const ratio = morph.elements[ j ].ratio; if ( morph2.type === 1 ) { updateAttributes( attribute, morph2, ratio ); } else { // TODO: implement } } } else if ( morph.type === 1 ) { // vertex updateAttributes( attribute, morph, 1.0 ); } else if ( morph.type === 2 ) { // bone // TODO: implement } else if ( morph.type === 3 ) { // uv // TODO: implement } else if ( morph.type === 4 ) { // additional uv1 // TODO: implement } else if ( morph.type === 5 ) { // additional uv2 // TODO: implement } else if ( morph.type === 6 ) { // additional uv3 // TODO: implement } else if ( morph.type === 7 ) { // additional uv4 // TODO: implement } else if ( morph.type === 8 ) { // material // TODO: implement } } morphTargets.push( params ); morphPositions.push( attribute ); } // rigid bodies from rigidBodies field. for ( let i = 0; i < data.metadata.rigidBodyCount; i ++ ) { const rigidBody = data.rigidBodies[ i ]; const params = {}; for ( const key in rigidBody ) { params[ key ] = rigidBody[ key ]; } /* * RigidBody position parameter in PMX seems global position * while the one in PMD seems offset from corresponding bone. * So unify being offset. */ if ( data.metadata.format === 'pmx' ) { if ( params.boneIndex !== - 1 ) { const bone = data.bones[ params.boneIndex ]; params.position[ 0 ] -= bone.position[ 0 ]; params.position[ 1 ] -= bone.position[ 1 ]; params.position[ 2 ] -= bone.position[ 2 ]; } } rigidBodies.push( params ); } // constraints from constraints field. for ( let i = 0; i < data.metadata.constraintCount; i ++ ) { const constraint = data.constraints[ i ]; const params = {}; for ( const key in constraint ) { params[ key ] = constraint[ key ]; } const bodyA = rigidBodies[ params.rigidBodyIndex1 ]; const bodyB = rigidBodies[ params.rigidBodyIndex2 ]; // Refer to http://www20.atpages.jp/katwat/wp/?p=4135 if ( bodyA.type !== 0 && bodyB.type === 2 ) { if ( bodyA.boneIndex !== - 1 && bodyB.boneIndex !== - 1 && data.bones[ bodyB.boneIndex ].parentIndex === bodyA.boneIndex ) { bodyB.type = 1; } } constraints.push( params ); } // build BufferGeometry. const geometry = new BufferGeometry(); geometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) ); geometry.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) ); geometry.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) ); geometry.setAttribute( 'skinIndex', new Uint16BufferAttribute( skinIndices, 4 ) ); geometry.setAttribute( 'skinWeight', new Float32BufferAttribute( skinWeights, 4 ) ); geometry.setIndex( indices ); for ( let i = 0, il = groups.length; i < il; i ++ ) { geometry.addGroup( groups[ i ].offset, groups[ i ].count, i ); } geometry.bones = bones; geometry.morphTargets = morphTargets; geometry.morphAttributes.position = morphPositions; geometry.morphTargetsRelative = false; geometry.userData.MMD = { bones: bones, iks: iks, grants: grants, rigidBodies: rigidBodies, constraints: constraints, format: data.metadata.format }; geometry.computeBoundingSphere(); return geometry; } } // /** * @param {THREE.LoadingManager} manager */ class MaterialBuilder { constructor( manager ) { this.manager = manager; this.textureLoader = new TextureLoader( this.manager ); this.tgaLoader = null; // lazy generation this.crossOrigin = 'anonymous'; this.resourcePath = undefined; } /** * @param {string} crossOrigin * @return {MaterialBuilder} */ setCrossOrigin( crossOrigin ) { this.crossOrigin = crossOrigin; return this; } /** * @param {string} resourcePath * @return {MaterialBuilder} */ setResourcePath( resourcePath ) { this.resourcePath = resourcePath; return this; } /** * @param {Object} data - parsed PMD/PMX data * @param {BufferGeometry} geometry - some properties are dependend on geometry * @param {function} onProgress * @param {function} onError * @return {Array} */ build( data, geometry /*, onProgress, onError */ ) { const materials = []; const textures = {}; this.textureLoader.setCrossOrigin( this.crossOrigin ); // materials for ( let i = 0; i < data.metadata.materialCount; i ++ ) { const material = data.materials[ i ]; const params = { userData: { MMD: {} } }; if ( material.name !== undefined ) params.name = material.name; /* * Color * * MMD MMDToonMaterial * ambient - emissive * a * (a = 1.0 without map texture or 0.2 with map texture) * * MMDToonMaterial doesn't have ambient. Set it to emissive instead. * It'll be too bright if material has map texture so using coef 0.2. */ params.diffuse = new Color().setRGB( material.diffuse[ 0 ], material.diffuse[ 1 ], material.diffuse[ 2 ], SRGBColorSpace ); params.opacity = material.diffuse[ 3 ]; params.specular = new Color().setRGB( ...material.specular, SRGBColorSpace ); params.shininess = material.shininess; params.emissive = new Color().setRGB( ...material.ambient, SRGBColorSpace ); params.transparent = params.opacity !== 1.0; // params.fog = true; // blend params.blending = CustomBlending; params.blendSrc = SrcAlphaFactor; params.blendDst = OneMinusSrcAlphaFactor; params.blendSrcAlpha = SrcAlphaFactor; params.blendDstAlpha = DstAlphaFactor; // side if ( data.metadata.format === 'pmx' && ( material.flag & 0x1 ) === 1 ) { params.side = DoubleSide; } else { params.side = params.opacity === 1.0 ? FrontSide : DoubleSide; } if ( data.metadata.format === 'pmd' ) { // map, matcap if ( material.fileName ) { const fileName = material.fileName; const fileNames = fileName.split( '*' ); // fileNames[ 0 ]: mapFileName // fileNames[ 1 ]: matcapFileName( optional ) params.map = this._loadTexture( fileNames[ 0 ], textures ); if ( fileNames.length > 1 ) { const extension = fileNames[ 1 ].slice( - 4 ).toLowerCase(); params.matcap = this._loadTexture( fileNames[ 1 ], textures ); params.matcapCombine = extension === '.sph' ? MultiplyOperation : AddOperation; } } // gradientMap const toonFileName = ( material.toonIndex === - 1 ) ? 'toon00.bmp' : data.toonTextures[ material.toonIndex ].fileName; params.gradientMap = this._loadTexture( toonFileName, textures, { isToonTexture: true, isDefaultToonTexture: this._isDefaultToonTexture( toonFileName ) } ); // parameters for OutlineEffect params.userData.outlineParameters = { thickness: material.edgeFlag === 1 ? 0.003 : 0.0, color: [ 0, 0, 0 ], alpha: 1.0, visible: material.edgeFlag === 1 }; } else { // map if ( material.textureIndex !== - 1 ) { params.map = this._loadTexture( data.textures[ material.textureIndex ], textures ); // Since PMX spec don't have standard to list map files except color map and env map, // we need to save file name for further mapping, like matching normal map file names after model loaded. // ref: https://gist.github.com/felixjones/f8a06bd48f9da9a4539f#texture params.userData.MMD.mapFileName = data.textures[ material.textureIndex ]; } // matcap TODO: support m.envFlag === 3 if ( material.envTextureIndex !== - 1 && ( material.envFlag === 1 || material.envFlag == 2 ) ) { params.matcap = this._loadTexture( data.textures[ material.envTextureIndex ], textures ); // Same as color map above, keep file name in userData for further usage. params.userData.MMD.matcapFileName = data.textures[ material.envTextureIndex ]; params.matcapCombine = material.envFlag === 1 ? MultiplyOperation : AddOperation; } // gradientMap let toonFileName, isDefaultToon; if ( material.toonIndex === - 1 || material.toonFlag !== 0 ) { toonFileName = 'toon' + ( '0' + ( material.toonIndex + 1 ) ).slice( - 2 ) + '.bmp'; isDefaultToon = true; } else { toonFileName = data.textures[ material.toonIndex ]; isDefaultToon = false; } params.gradientMap = this._loadTexture( toonFileName, textures, { isToonTexture: true, isDefaultToonTexture: isDefaultToon } ); // parameters for OutlineEffect params.userData.outlineParameters = { thickness: material.edgeSize / 300, // TODO: better calculation? color: material.edgeColor.slice( 0, 3 ), alpha: material.edgeColor[ 3 ], visible: ( material.flag & 0x10 ) !== 0 && material.edgeSize > 0.0 }; } if ( params.map !== undefined ) { if ( ! params.transparent ) { this._checkImageTransparency( params.map, geometry, i ); } params.emissive.multiplyScalar( 0.2 ); } materials.push( new MMDToonMaterial( params ) ); } if ( data.metadata.format === 'pmx' ) { // set transparent true if alpha morph is defined. function checkAlphaMorph( elements, materials ) { for ( let i = 0, il = elements.length; i < il; i ++ ) { const element = elements[ i ]; if ( element.index === - 1 ) continue; const material = materials[ element.index ]; if ( material.opacity !== element.diffuse[ 3 ] ) { material.transparent = true; } } } for ( let i = 0, il = data.morphs.length; i < il; i ++ ) { const morph = data.morphs[ i ]; const elements = morph.elements; if ( morph.type === 0 ) { for ( let j = 0, jl = elements.length; j < jl; j ++ ) { const morph2 = data.morphs[ elements[ j ].index ]; if ( morph2.type !== 8 ) continue; checkAlphaMorph( morph2.elements, materials ); } } else if ( morph.type === 8 ) { checkAlphaMorph( elements, materials ); } } } return materials; } // private methods _getTGALoader() { if ( this.tgaLoader === null ) { if ( TGALoader === undefined ) { throw new Error( 'THREE.MMDLoader: Import TGALoader' ); } this.tgaLoader = new TGALoader( this.manager ); } return this.tgaLoader; } _isDefaultToonTexture( name ) { if ( name.length !== 10 ) return false; return /toon(10|0[0-9])\\.bmp/.test( name ); } _loadTexture( filePath, textures, params, onProgress, onError ) { params = params || {}; const scope = this; let fullPath; if ( params.isDefaultToonTexture === true ) { let index; try { index = parseInt( filePath.match( /toon([0-9]{2})\\.bmp$/ )[ 1 ] ); } catch ( e ) { console.warn( 'THREE.MMDLoader: ' + filePath + ' seems like a ' + 'not right default texture path. Using toon00.bmp instead.' ); index = 0; } fullPath = DEFAULT_TOON_TEXTURES[ index ]; } else { fullPath = this.resourcePath + filePath; } if ( textures[ fullPath ] !== undefined ) return textures[ fullPath ]; let loader = this.manager.getHandler( fullPath ); if ( loader === null ) { loader = ( filePath.slice( - 4 ).toLowerCase() === '.tga' ) ? this._getTGALoader() : this.textureLoader; } const texture = loader.load( fullPath, function ( t ) { // MMD toon texture is Axis-Y oriented // but Three.js gradient map is Axis-X oriented. // So here replaces the toon texture image with the rotated one. if ( params.isToonTexture === true ) { t.image = scope._getRotatedImage( t.image ); t.magFilter = NearestFilter; t.minFilter = NearestFilter; } t.flipY = false; t.wrapS = RepeatWrapping; t.wrapT = RepeatWrapping; t.colorSpace = SRGBColorSpace; for ( let i = 0; i < texture.readyCallbacks.length; i ++ ) { texture.readyCallbacks[ i ]( texture ); } delete texture.readyCallbacks; }, onProgress, onError ); texture.readyCallbacks = []; textures[ fullPath ] = texture; return texture; } _getRotatedImage( image ) { const canvas = document.createElement( 'canvas' ); const context = canvas.getContext( '2d' ); const width = image.width; const height = image.height; canvas.width = width; canvas.height = height; context.clearRect( 0, 0, width, height ); context.translate( width / 2.0, height / 2.0 ); context.rotate( 0.5 * Math.PI ); // 90.0 * Math.PI / 180.0 context.translate( - width / 2.0, - height / 2.0 ); context.drawImage( image, 0, 0 ); return context.getImageData( 0, 0, width, height ); } // Check if the partial image area used by the texture is transparent. _checkImageTransparency( map, geometry, groupIndex ) { map.readyCallbacks.push( function ( texture ) { // Is there any efficient ways? function createImageData( image ) { const canvas = document.createElement( 'canvas' ); canvas.width = image.width; canvas.height = image.height; const context = canvas.getContext( '2d' ); context.drawImage( image, 0, 0 ); return context.getImageData( 0, 0, canvas.width, canvas.height ); } function detectImageTransparency( image, uvs, indices ) { const width = image.width; const height = image.height; const data = image.data; const threshold = 253; if ( data.length / ( width * height ) !== 4 ) return false; for ( let i = 0; i < indices.length; i += 3 ) { const centerUV = { x: 0.0, y: 0.0 }; for ( let j = 0; j < 3; j ++ ) { const index = indices[ i * 3 + j ]; const uv = { x: uvs[ index * 2 + 0 ], y: uvs[ index * 2 + 1 ] }; if ( getAlphaByUv( image, uv ) < threshold ) return true; centerUV.x += uv.x; centerUV.y += uv.y; } centerUV.x /= 3; centerUV.y /= 3; if ( getAlphaByUv( image, centerUV ) < threshold ) return true; } return false; } /* * This method expects * texture.flipY = false * texture.wrapS = RepeatWrapping * texture.wrapT = RepeatWrapping * TODO: more precise */ function getAlphaByUv( image, uv ) { const width = image.width; const height = image.height; let x = Math.round( uv.x * width ) % width; let y = Math.round( uv.y * height ) % height; if ( x < 0 ) x += width; if ( y < 0 ) y += height; const index = y * width + x; return image.data[ index * 4 + 3 ]; } if ( texture.isCompressedTexture === true ) { if ( NON_ALPHA_CHANNEL_FORMATS.includes( texture.format ) ) { map.transparent = false; } else { // any other way to check transparency of CompressedTexture? map.transparent = true; } return; } const imageData = texture.image.data !== undefined ? texture.image : createImageData( texture.image ); const group = geometry.groups[ groupIndex ]; if ( detectImageTransparency( imageData, geometry.attributes.uv.array, geometry.index.array.slice( group.start, group.start + group.count ) ) ) { map.transparent = true; } } ); } } // class AnimationBuilder { /** * @param {Object} vmd - parsed VMD data * @param {SkinnedMesh} mesh - tracks will be fitting to mesh * @return {AnimationClip} */ build( vmd, mesh ) { // combine skeletal and morph animations const tracks = this.buildSkeletalAnimation( vmd, mesh ).tracks; const tracks2 = this.buildMorphAnimation( vmd, mesh ).tracks; for ( let i = 0, il = tracks2.length; i < il; i ++ ) { tracks.push( tracks2[ i ] ); } return new AnimationClip( '', - 1, tracks ); } /** * @param {Object} vmd - parsed VMD data * @param {SkinnedMesh} mesh - tracks will be fitting to mesh * @return {AnimationClip} */ buildSkeletalAnimation( vmd, mesh ) { function pushInterpolation( array, interpolation, index ) { array.push( interpolation[ index + 0 ] / 127 ); // x1 array.push( interpolation[ index + 8 ] / 127 ); // x2 array.push( interpolation[ index + 4 ] / 127 ); // y1 array.push( interpolation[ index + 12 ] / 127 ); // y2 } const tracks = []; const motions = {}; const bones = mesh.skeleton.bones; const boneNameDictionary = {}; for ( let i = 0, il = bones.length; i < il; i ++ ) { boneNameDictionary[ bones[ i ].name ] = true; } for ( let i = 0; i < vmd.metadata.motionCount; i ++ ) { const motion = vmd.motions[ i ]; const boneName = motion.boneName; if ( boneNameDictionary[ boneName ] === undefined ) continue; motions[ boneName ] = motions[ boneName ] || []; motions[ boneName ].push( motion ); } for ( const key in motions ) { const array = motions[ key ]; array.sort( function ( a, b ) { return a.frameNum - b.frameNum; } ); const times = []; const positions = []; const rotations = []; const pInterpolations = []; const rInterpolations = []; const basePosition = mesh.skeleton.getBoneByName( key ).position.toArray(); for ( let i = 0, il = array.length; i < il; i ++ ) { const time = array[ i ].frameNum / 30; const position = array[ i ].position; const rotation = array[ i ].rotation; const interpolation = array[ i ].interpolation; times.push( time ); for ( let j = 0; j < 3; j ++ ) positions.push( basePosition[ j ] + position[ j ] ); for ( let j = 0; j < 4; j ++ ) rotations.push( rotation[ j ] ); for ( let j = 0; j < 3; j ++ ) pushInterpolation( pInterpolations, interpolation, j ); pushInterpolation( rInterpolations, interpolation, 3 ); } const targetName = '.bones[' + key + ']'; tracks.push( this._createTrack( targetName + '.position', VectorKeyframeTrack, times, positions, pInterpolations ) ); tracks.push( this._createTrack( targetName + '.quaternion', QuaternionKeyframeTrack, times, rotations, rInterpolations ) ); } return new AnimationClip( '', - 1, tracks ); } /** * @param {Object} vmd - parsed VMD data * @param {SkinnedMesh} mesh - tracks will be fitting to mesh * @return {AnimationClip} */ buildMorphAnimation( vmd, mesh ) { const tracks = []; const morphs = {}; const morphTargetDictionary = mesh.morphTargetDictionary; for ( let i = 0; i < vmd.metadata.morphCount; i ++ ) { const morph = vmd.morphs[ i ]; const morphName = morph.morphName; if ( morphTargetDictionary[ morphName ] === undefined ) continue; morphs[ morphName ] = morphs[ morphName ] || []; morphs[ morphName ].push( morph ); } for ( const key in morphs ) { const array = morphs[ key ]; array.sort( function ( a, b ) { return a.frameNum - b.frameNum; } ); const times = []; const values = []; for ( let i = 0, il = array.length; i < il; i ++ ) { times.push( array[ i ].frameNum / 30 ); values.push( array[ i ].weight ); } tracks.push( new NumberKeyframeTrack( '.morphTargetInfluences[' + morphTargetDictionary[ key ] + ']', times, values ) ); } return new AnimationClip( '', - 1, tracks ); } /** * @param {Object} vmd - parsed VMD data * @return {AnimationClip} */ buildCameraAnimation( vmd ) { function pushVector3( array, vec ) { array.push( vec.x ); array.push( vec.y ); array.push( vec.z ); } function pushQuaternion( array, q ) { array.push( q.x ); array.push( q.y ); array.push( q.z ); array.push( q.w ); } function pushInterpolation( array, interpolation, index ) { array.push( interpolation[ index * 4 + 0 ] / 127 ); // x1 array.push( interpolation[ index * 4 + 1 ] / 127 ); // x2 array.push( interpolation[ index * 4 + 2 ] / 127 ); // y1 array.push( interpolation[ index * 4 + 3 ] / 127 ); // y2 } const cameras = vmd.cameras === undefined ? [] : vmd.cameras.slice(); cameras.sort( function ( a, b ) { return a.frameNum - b.frameNum; } ); const times = []; const centers = []; const quaternions = []; const positions = []; const fovs = []; const cInterpolations = []; const qInterpolations = []; const pInterpolations = []; const fInterpolations = []; const quaternion = new Quaternion(); const euler = new Euler(); const position = new Vector3(); const center = new Vector3(); for ( let i = 0, il = cameras.length; i < il; i ++ ) { const motion = cameras[ i ]; const time = motion.frameNum / 30; const pos = motion.position; const rot = motion.rotation; const distance = motion.distance; const fov = motion.fov; const interpolation = motion.interpolation; times.push( time ); position.set( 0, 0, - distance ); center.set( pos[ 0 ], pos[ 1 ], pos[ 2 ] ); euler.set( - rot[ 0 ], - rot[ 1 ], - rot[ 2 ] ); quaternion.setFromEuler( euler ); position.add( center ); position.applyQuaternion( quaternion ); pushVector3( centers, center ); pushQuaternion( quaternions, quaternion ); pushVector3( positions, position ); fovs.push( fov ); for ( let j = 0; j < 3; j ++ ) { pushInterpolation( cInterpolations, interpolation, j ); } pushInterpolation( qInterpolations, interpolation, 3 ); // use the same parameter for x, y, z axis. for ( let j = 0; j < 3; j ++ ) { pushInterpolation( pInterpolations, interpolation, 4 ); } pushInterpolation( fInterpolations, interpolation, 5 ); } const tracks = []; // I expect an object whose name 'target' exists under THREE.Camera tracks.push( this._createTrack( 'target.position', VectorKeyframeTrack, times, centers, cInterpolations ) ); tracks.push( this._createTrack( '.quaternion', QuaternionKeyframeTrack, times, quaternions, qInterpolations ) ); tracks.push( this._createTrack( '.position', VectorKeyframeTrack, times, positions, pInterpolations ) ); tracks.push( this._createTrack( '.fov', NumberKeyframeTrack, times, fovs, fInterpolations ) ); return new AnimationClip( '', - 1, tracks ); } // private method _createTrack( node, typedKeyframeTrack, times, values, interpolations ) { /* * optimizes here not to let KeyframeTrackPrototype optimize * because KeyframeTrackPrototype optimizes times and values but * doesn't optimize interpolations. */ if ( times.length > 2 ) { times = times.slice(); values = values.slice(); interpolations = interpolations.slice(); const stride = values.length / times.length; const interpolateStride = interpolations.length / times.length; let index = 1; for ( let aheadIndex = 2, endIndex = times.length; aheadIndex < endIndex; aheadIndex ++ ) { for ( let i = 0; i < stride; i ++ ) { if ( values[ index * stride + i ] !== values[ ( index - 1 ) * stride + i ] || values[ index * stride + i ] !== values[ aheadIndex * stride + i ] ) { index ++; break; } } if ( aheadIndex > index ) { times[ index ] = times[ aheadIndex ]; for ( let i = 0; i < stride; i ++ ) { values[ index * stride + i ] = values[ aheadIndex * stride + i ]; } for ( let i = 0; i < interpolateStride; i ++ ) { interpolations[ index * interpolateStride + i ] = interpolations[ aheadIndex * interpolateStride + i ]; } } } times.length = index + 1; values.length = ( index + 1 ) * stride; interpolations.length = ( index + 1 ) * interpolateStride; } const track = new typedKeyframeTrack( node, times, values ); track.createInterpolant = function InterpolantFactoryMethodCubicBezier( result ) { return new CubicBezierInterpolation( this.times, this.values, this.getValueSize(), result, new Float32Array( interpolations ) ); }; return track; } } // interpolation class CubicBezierInterpolation extends Interpolant { constructor( parameterPositions, sampleValues, sampleSize, resultBuffer, params ) { super( parameterPositions, sampleValues, sampleSize, resultBuffer ); this.interpolationParams = params; } interpolate_( i1, t0, t, t1 ) { const result = this.resultBuffer; const values = this.sampleValues; const stride = this.valueSize; const params = this.interpolationParams; const offset1 = i1 * stride; const offset0 = offset1 - stride; // No interpolation if next key frame is in one frame in 30fps. // This is from MMD animation spec. // '1.5' is for precision loss. times are Float32 in Three.js Animation system. const weight1 = ( ( t1 - t0 ) < 1 / 30 * 1.5 ) ? 0.0 : ( t - t0 ) / ( t1 - t0 ); if ( stride === 4 ) { // Quaternion const x1 = params[ i1 * 4 + 0 ]; const x2 = params[ i1 * 4 + 1 ]; const y1 = params[ i1 * 4 + 2 ]; const y2 = params[ i1 * 4 + 3 ]; const ratio = this._calculate( x1, x2, y1, y2, weight1 ); Quaternion.slerpFlat( result, 0, values, offset0, values, offset1, ratio ); } else if ( stride === 3 ) { // Vector3 for ( let i = 0; i !== stride; ++ i ) { const x1 = params[ i1 * 12 + i * 4 + 0 ]; const x2 = params[ i1 * 12 + i * 4 + 1 ]; const y1 = params[ i1 * 12 + i * 4 + 2 ]; const y2 = params[ i1 * 12 + i * 4 + 3 ]; const ratio = this._calculate( x1, x2, y1, y2, weight1 ); result[ i ] = values[ offset0 + i ] * ( 1 - ratio ) + values[ offset1 + i ] * ratio; } } else { // Number const x1 = params[ i1 * 4 + 0 ]; const x2 = params[ i1 * 4 + 1 ]; const y1 = params[ i1 * 4 + 2 ]; const y2 = params[ i1 * 4 + 3 ]; const ratio = this._calculate( x1, x2, y1, y2, weight1 ); result[ 0 ] = values[ offset0 ] * ( 1 - ratio ) + values[ offset1 ] * ratio; } return result; } _calculate( x1, x2, y1, y2, x ) { /* * Cubic Bezier curves * https://en.wikipedia.org/wiki/B%C3%A9zier_curve#Cubic_B.C3.A9zier_curves * * B(t) = ( 1 - t ) ^ 3 * P0 * + 3 * ( 1 - t ) ^ 2 * t * P1 * + 3 * ( 1 - t ) * t^2 * P2 * + t ^ 3 * P3 * ( 0"},{"title":"","date":"2023-10-12T14:08:40.713Z","updated":"2023-10-12T14:08:40.713Z","comments":true,"path":"js/three/jsm/loaders/NRRDLoader.js","permalink":"http://19999997.xyz/js/three/jsm/loaders/NRRDLoader.js","excerpt":"","text":"import { FileLoader, Loader, Matrix4, Vector3 } from 'three'; import * as fflate from '../libs/fflate.module.js'; import { Volume } from '../misc/Volume.js'; class NRRDLoader extends Loader { constructor( manager ) { super( manager ); } load( url, onLoad, onProgress, onError ) { const scope = this; const loader = new FileLoader( scope.manager ); loader.setPath( scope.path ); loader.setResponseType( 'arraybuffer' ); loader.setRequestHeader( scope.requestHeader ); loader.setWithCredentials( scope.withCredentials ); loader.load( url, function ( data ) { try { onLoad( scope.parse( data ) ); } catch ( e ) { if ( onError ) { onError( e ); } else { console.error( e ); } scope.manager.itemError( url ); } }, onProgress, onError ); } /** * * @param {boolean} segmentation is a option for user to choose */ setSegmentation( segmentation ) { this.segmentation = segmentation; } parse( data ) { // this parser is largely inspired from the XTK NRRD parser : https://github.com/xtk/X let _data = data; let _dataPointer = 0; const _nativeLittleEndian = new Int8Array( new Int16Array( [ 1 ] ).buffer )[ 0 ] > 0; const _littleEndian = true; const headerObject = {}; function scan( type, chunks ) { if ( chunks === undefined || chunks === null ) { chunks = 1; } let _chunkSize = 1; let _array_type = Uint8Array; switch ( type ) { // 1 byte data types case 'uchar': break; case 'schar': _array_type = Int8Array; break; // 2 byte data types case 'ushort': _array_type = Uint16Array; _chunkSize = 2; break; case 'sshort': _array_type = Int16Array; _chunkSize = 2; break; // 4 byte data types case 'uint': _array_type = Uint32Array; _chunkSize = 4; break; case 'sint': _array_type = Int32Array; _chunkSize = 4; break; case 'float': _array_type = Float32Array; _chunkSize = 4; break; case 'complex': _array_type = Float64Array; _chunkSize = 8; break; case 'double': _array_type = Float64Array; _chunkSize = 8; break; } // increase the data pointer in-place let _bytes = new _array_type( _data.slice( _dataPointer, _dataPointer += chunks * _chunkSize ) ); // if required, flip the endianness of the bytes if ( _nativeLittleEndian != _littleEndian ) { // we need to flip here since the format doesn't match the native endianness _bytes = flipEndianness( _bytes, _chunkSize ); } if ( chunks == 1 ) { // if only one chunk was requested, just return one value return _bytes[ 0 ]; } // return the byte array return _bytes; } //Flips typed array endianness in-place. Based on https://github.com/kig/DataStream.js/blob/master/DataStream.js. function flipEndianness( array, chunkSize ) { const u8 = new Uint8Array( array.buffer, array.byteOffset, array.byteLength ); for ( let i = 0; i < array.byteLength; i += chunkSize ) { for ( let j = i + chunkSize - 1, k = i; j > k; j --, k ++ ) { const tmp = u8[ k ]; u8[ k ] = u8[ j ]; u8[ j ] = tmp; } } return array; } //parse the header function parseHeader( header ) { let data, field, fn, i, l, m, _i, _len; const lines = header.split( /\\r?\\n/ ); for ( _i = 0, _len = lines.length; _i < _len; _i ++ ) { l = lines[ _i ]; if ( l.match( /NRRD\\d+/ ) ) { headerObject.isNrrd = true; } else if ( ! l.match( /^#/ ) && ( m = l.match( /(.*):(.*)/ ) ) ) { field = m[ 1 ].trim(); data = m[ 2 ].trim(); fn = _fieldFunctions[ field ]; if ( fn ) { fn.call( headerObject, data ); } else { headerObject[ field ] = data; } } } if ( ! headerObject.isNrrd ) { throw new Error( 'Not an NRRD file' ); } if ( headerObject.encoding === 'bz2' || headerObject.encoding === 'bzip2' ) { throw new Error( 'Bzip is not supported' ); } if ( ! headerObject.vectors ) { //if no space direction is set, let's use the identity headerObject.vectors = [ ]; headerObject.vectors.push( [ 1, 0, 0 ] ); headerObject.vectors.push( [ 0, 1, 0 ] ); headerObject.vectors.push( [ 0, 0, 1 ] ); //apply spacing if defined if ( headerObject.spacings ) { for ( i = 0; i"},{"title":"","date":"2023-10-12T14:08:40.720Z","updated":"2023-10-12T14:08:40.720Z","comments":true,"path":"js/three/jsm/loaders/PDBLoader.js","permalink":"http://19999997.xyz/js/three/jsm/loaders/PDBLoader.js","excerpt":"","text":"import { BufferGeometry, FileLoader, Float32BufferAttribute, Loader, Color } from 'three'; class PDBLoader extends Loader { constructor( manager ) { super( manager ); } load( url, onLoad, onProgress, onError ) { const scope = this; const loader = new FileLoader( scope.manager ); loader.setPath( scope.path ); loader.setRequestHeader( scope.requestHeader ); loader.setWithCredentials( scope.withCredentials ); loader.load( url, function ( text ) { try { onLoad( scope.parse( text ) ); } catch ( e ) { if ( onError ) { onError( e ); } else { console.error( e ); } scope.manager.itemError( url ); } }, onProgress, onError ); } // Based on CanvasMol PDB parser parse( text ) { function trim( text ) { return text.replace( /^\\s\\s*/, '' ).replace( /\\s\\s*$/, '' ); } function capitalize( text ) { return text.charAt( 0 ).toUpperCase() + text.slice( 1 ).toLowerCase(); } function hash( s, e ) { return 's' + Math.min( s, e ) + 'e' + Math.max( s, e ); } function parseBond( start, length, satom, i ) { const eatom = parseInt( lines[ i ].slice( start, start + length ) ); if ( eatom ) { const h = hash( satom, eatom ); if ( _bhash[ h ] === undefined ) { _bonds.push( [ satom - 1, eatom - 1, 1 ] ); _bhash[ h ] = _bonds.length - 1; } else { // doesn't really work as almost all PDBs // have just normal bonds appearing multiple // times instead of being double/triple bonds // bonds[bhash[h]][2] += 1; } } } function buildGeometry() { const build = { geometryAtoms: new BufferGeometry(), geometryBonds: new BufferGeometry(), json: { atoms: atoms } }; const geometryAtoms = build.geometryAtoms; const geometryBonds = build.geometryBonds; const verticesAtoms = []; const colorsAtoms = []; const verticesBonds = []; // atoms const c = new Color(); for ( let i = 0, l = atoms.length; i < l; i ++ ) { const atom = atoms[ i ]; const x = atom[ 0 ]; const y = atom[ 1 ]; const z = atom[ 2 ]; verticesAtoms.push( x, y, z ); const r = atom[ 3 ][ 0 ] / 255; const g = atom[ 3 ][ 1 ] / 255; const b = atom[ 3 ][ 2 ] / 255; c.set( r, g, b ).convertSRGBToLinear(); colorsAtoms.push( c.r, c.g, c.b ); } // bonds for ( let i = 0, l = _bonds.length; i < l; i ++ ) { const bond = _bonds[ i ]; const start = bond[ 0 ]; const end = bond[ 1 ]; const startAtom = _atomMap[ start ]; const endAtom = _atomMap[ end ]; let x = startAtom[ 0 ]; let y = startAtom[ 1 ]; let z = startAtom[ 2 ]; verticesBonds.push( x, y, z ); x = endAtom[ 0 ]; y = endAtom[ 1 ]; z = endAtom[ 2 ]; verticesBonds.push( x, y, z ); } // build geometry geometryAtoms.setAttribute( 'position', new Float32BufferAttribute( verticesAtoms, 3 ) ); geometryAtoms.setAttribute( 'color', new Float32BufferAttribute( colorsAtoms, 3 ) ); geometryBonds.setAttribute( 'position', new Float32BufferAttribute( verticesBonds, 3 ) ); return build; } const CPK = { h: [ 255, 255, 255 ], he: [ 217, 255, 255 ], li: [ 204, 128, 255 ], be: [ 194, 255, 0 ], b: [ 255, 181, 181 ], c: [ 144, 144, 144 ], n: [ 48, 80, 248 ], o: [ 255, 13, 13 ], f: [ 144, 224, 80 ], ne: [ 179, 227, 245 ], na: [ 171, 92, 242 ], mg: [ 138, 255, 0 ], al: [ 191, 166, 166 ], si: [ 240, 200, 160 ], p: [ 255, 128, 0 ], s: [ 255, 255, 48 ], cl: [ 31, 240, 31 ], ar: [ 128, 209, 227 ], k: [ 143, 64, 212 ], ca: [ 61, 255, 0 ], sc: [ 230, 230, 230 ], ti: [ 191, 194, 199 ], v: [ 166, 166, 171 ], cr: [ 138, 153, 199 ], mn: [ 156, 122, 199 ], fe: [ 224, 102, 51 ], co: [ 240, 144, 160 ], ni: [ 80, 208, 80 ], cu: [ 200, 128, 51 ], zn: [ 125, 128, 176 ], ga: [ 194, 143, 143 ], ge: [ 102, 143, 143 ], as: [ 189, 128, 227 ], se: [ 255, 161, 0 ], br: [ 166, 41, 41 ], kr: [ 92, 184, 209 ], rb: [ 112, 46, 176 ], sr: [ 0, 255, 0 ], y: [ 148, 255, 255 ], zr: [ 148, 224, 224 ], nb: [ 115, 194, 201 ], mo: [ 84, 181, 181 ], tc: [ 59, 158, 158 ], ru: [ 36, 143, 143 ], rh: [ 10, 125, 140 ], pd: [ 0, 105, 133 ], ag: [ 192, 192, 192 ], cd: [ 255, 217, 143 ], in: [ 166, 117, 115 ], sn: [ 102, 128, 128 ], sb: [ 158, 99, 181 ], te: [ 212, 122, 0 ], i: [ 148, 0, 148 ], xe: [ 66, 158, 176 ], cs: [ 87, 23, 143 ], ba: [ 0, 201, 0 ], la: [ 112, 212, 255 ], ce: [ 255, 255, 199 ], pr: [ 217, 255, 199 ], nd: [ 199, 255, 199 ], pm: [ 163, 255, 199 ], sm: [ 143, 255, 199 ], eu: [ 97, 255, 199 ], gd: [ 69, 255, 199 ], tb: [ 48, 255, 199 ], dy: [ 31, 255, 199 ], ho: [ 0, 255, 156 ], er: [ 0, 230, 117 ], tm: [ 0, 212, 82 ], yb: [ 0, 191, 56 ], lu: [ 0, 171, 36 ], hf: [ 77, 194, 255 ], ta: [ 77, 166, 255 ], w: [ 33, 148, 214 ], re: [ 38, 125, 171 ], os: [ 38, 102, 150 ], ir: [ 23, 84, 135 ], pt: [ 208, 208, 224 ], au: [ 255, 209, 35 ], hg: [ 184, 184, 208 ], tl: [ 166, 84, 77 ], pb: [ 87, 89, 97 ], bi: [ 158, 79, 181 ], po: [ 171, 92, 0 ], at: [ 117, 79, 69 ], rn: [ 66, 130, 150 ], fr: [ 66, 0, 102 ], ra: [ 0, 125, 0 ], ac: [ 112, 171, 250 ], th: [ 0, 186, 255 ], pa: [ 0, 161, 255 ], u: [ 0, 143, 255 ], np: [ 0, 128, 255 ], pu: [ 0, 107, 255 ], am: [ 84, 92, 242 ], cm: [ 120, 92, 227 ], bk: [ 138, 79, 227 ], cf: [ 161, 54, 212 ], es: [ 179, 31, 212 ], fm: [ 179, 31, 186 ], md: [ 179, 13, 166 ], no: [ 189, 13, 135 ], lr: [ 199, 0, 102 ], rf: [ 204, 0, 89 ], db: [ 209, 0, 79 ], sg: [ 217, 0, 69 ], bh: [ 224, 0, 56 ], hs: [ 230, 0, 46 ], mt: [ 235, 0, 38 ], ds: [ 235, 0, 38 ], rg: [ 235, 0, 38 ], cn: [ 235, 0, 38 ], uut: [ 235, 0, 38 ], uuq: [ 235, 0, 38 ], uup: [ 235, 0, 38 ], uuh: [ 235, 0, 38 ], uus: [ 235, 0, 38 ], uuo: [ 235, 0, 38 ] }; const atoms = []; const _bonds = []; const _bhash = {}; const _atomMap = {}; // parse const lines = text.split( '\\n' ); for ( let i = 0, l = lines.length; i < l; i ++ ) { if ( lines[ i ].slice( 0, 4 ) === 'ATOM' || lines[ i ].slice( 0, 6 ) === 'HETATM' ) { const x = parseFloat( lines[ i ].slice( 30, 37 ) ); const y = parseFloat( lines[ i ].slice( 38, 45 ) ); const z = parseFloat( lines[ i ].slice( 46, 53 ) ); const index = parseInt( lines[ i ].slice( 6, 11 ) ) - 1; let e = trim( lines[ i ].slice( 76, 78 ) ).toLowerCase(); if ( e === '' ) { e = trim( lines[ i ].slice( 12, 14 ) ).toLowerCase(); } const atomData = [ x, y, z, CPK[ e ], capitalize( e ) ]; atoms.push( atomData ); _atomMap[ index ] = atomData; } else if ( lines[ i ].slice( 0, 6 ) === 'CONECT' ) { const satom = parseInt( lines[ i ].slice( 6, 11 ) ); parseBond( 11, 5, satom, i ); parseBond( 16, 5, satom, i ); parseBond( 21, 5, satom, i ); parseBond( 26, 5, satom, i ); } } // build and return geometry return buildGeometry(); } } export { PDBLoader };"},{"title":"","date":"2023-10-12T14:08:40.718Z","updated":"2023-10-12T14:08:40.718Z","comments":true,"path":"js/three/jsm/loaders/PCDLoader.js","permalink":"http://19999997.xyz/js/three/jsm/loaders/PCDLoader.js","excerpt":"","text":"import { BufferGeometry, Color, FileLoader, Float32BufferAttribute, Int32BufferAttribute, Loader, Points, PointsMaterial } from 'three'; class PCDLoader extends Loader { constructor( manager ) { super( manager ); this.littleEndian = true; } load( url, onLoad, onProgress, onError ) { const scope = this; const loader = new FileLoader( scope.manager ); loader.setPath( scope.path ); loader.setResponseType( 'arraybuffer' ); loader.setRequestHeader( scope.requestHeader ); loader.setWithCredentials( scope.withCredentials ); loader.load( url, function ( data ) { try { onLoad( scope.parse( data ) ); } catch ( e ) { if ( onError ) { onError( e ); } else { console.error( e ); } scope.manager.itemError( url ); } }, onProgress, onError ); } parse( data ) { // from https://gitlab.com/taketwo/three-pcd-loader/blob/master/decompress-lzf.js function decompressLZF( inData, outLength ) { const inLength = inData.length; const outData = new Uint8Array( outLength ); let inPtr = 0; let outPtr = 0; let ctrl; let len; let ref; do { ctrl = inData[ inPtr ++ ]; if ( ctrl < ( 1 < 5 ) ) { ctrl ++; if ( outPtr + ctrl > outLength ) throw new Error( 'Output buffer is not large enough' ); if ( inPtr + ctrl > inLength ) throw new Error( 'Invalid compressed data' ); do { outData[ outPtr ++ ] = inData[ inPtr ++ ]; } while ( -- ctrl ); } else { len = ctrl >> 5; ref = outPtr - ( ( ctrl & 0x1f ) < 8 ) - 1; if ( inPtr >= inLength ) throw new Error( 'Invalid compressed data' ); if ( len === 7 ) { len += inData[ inPtr ++ ]; if ( inPtr >= inLength ) throw new Error( 'Invalid compressed data' ); } ref -= inData[ inPtr ++ ]; if ( outPtr + len + 2 > outLength ) throw new Error( 'Output buffer is not large enough' ); if ( ref < 0 ) throw new Error( 'Invalid compressed data' ); if ( ref >= outPtr ) throw new Error( 'Invalid compressed data' ); do { outData[ outPtr ++ ] = outData[ ref ++ ]; } while ( -- len + 2 ); } } while ( inPtr < inLength ); return outData; } function parseHeader( data ) { const PCDheader = {}; const result1 = data.search( /[\\r\\n]DATA\\s(\\S*)\\s/i ); const result2 = /[\\r\\n]DATA\\s(\\S*)\\s/i.exec( data.slice( result1 - 1 ) ); PCDheader.data = result2[ 1 ]; PCDheader.headerLen = result2[ 0 ].length + result1; PCDheader.str = data.slice( 0, PCDheader.headerLen ); // remove comments PCDheader.str = PCDheader.str.replace( /#.*/gi, '' ); // parse PCDheader.version = /VERSION (.*)/i.exec( PCDheader.str ); PCDheader.fields = /FIELDS (.*)/i.exec( PCDheader.str ); PCDheader.size = /SIZE (.*)/i.exec( PCDheader.str ); PCDheader.type = /TYPE (.*)/i.exec( PCDheader.str ); PCDheader.count = /COUNT (.*)/i.exec( PCDheader.str ); PCDheader.width = /WIDTH (.*)/i.exec( PCDheader.str ); PCDheader.height = /HEIGHT (.*)/i.exec( PCDheader.str ); PCDheader.viewpoint = /VIEWPOINT (.*)/i.exec( PCDheader.str ); PCDheader.points = /POINTS (.*)/i.exec( PCDheader.str ); // evaluate if ( PCDheader.version !== null ) PCDheader.version = parseFloat( PCDheader.version[ 1 ] ); PCDheader.fields = ( PCDheader.fields !== null ) ? PCDheader.fields[ 1 ].split( ' ' ) : []; if ( PCDheader.type !== null ) PCDheader.type = PCDheader.type[ 1 ].split( ' ' ); if ( PCDheader.width !== null ) PCDheader.width = parseInt( PCDheader.width[ 1 ] ); if ( PCDheader.height !== null ) PCDheader.height = parseInt( PCDheader.height[ 1 ] ); if ( PCDheader.viewpoint !== null ) PCDheader.viewpoint = PCDheader.viewpoint[ 1 ]; if ( PCDheader.points !== null ) PCDheader.points = parseInt( PCDheader.points[ 1 ], 10 ); if ( PCDheader.points === null ) PCDheader.points = PCDheader.width * PCDheader.height; if ( PCDheader.size !== null ) { PCDheader.size = PCDheader.size[ 1 ].split( ' ' ).map( function ( x ) { return parseInt( x, 10 ); } ); } if ( PCDheader.count !== null ) { PCDheader.count = PCDheader.count[ 1 ].split( ' ' ).map( function ( x ) { return parseInt( x, 10 ); } ); } else { PCDheader.count = []; for ( let i = 0, l = PCDheader.fields.length; i < l; i ++ ) { PCDheader.count.push( 1 ); } } PCDheader.offset = {}; let sizeSum = 0; for ( let i = 0, l = PCDheader.fields.length; i < l; i ++ ) { if ( PCDheader.data === 'ascii' ) { PCDheader.offset[ PCDheader.fields[ i ] ] = i; } else { PCDheader.offset[ PCDheader.fields[ i ] ] = sizeSum; sizeSum += PCDheader.size[ i ] * PCDheader.count[ i ]; } } // for binary only PCDheader.rowSize = sizeSum; return PCDheader; } const textData = new TextDecoder().decode( data ); // parse header (always ascii format) const PCDheader = parseHeader( textData ); // parse data const position = []; const normal = []; const color = []; const intensity = []; const label = []; const c = new Color(); // ascii if ( PCDheader.data === 'ascii' ) { const offset = PCDheader.offset; const pcdData = textData.slice( PCDheader.headerLen ); const lines = pcdData.split( '\\n' ); for ( let i = 0, l = lines.length; i < l; i ++ ) { if ( lines[ i ] === '' ) continue; const line = lines[ i ].split( ' ' ); if ( offset.x !== undefined ) { position.push( parseFloat( line[ offset.x ] ) ); position.push( parseFloat( line[ offset.y ] ) ); position.push( parseFloat( line[ offset.z ] ) ); } if ( offset.rgb !== undefined ) { const rgb_field_index = PCDheader.fields.findIndex( ( field ) => field === 'rgb' ); const rgb_type = PCDheader.type[ rgb_field_index ]; const float = parseFloat( line[ offset.rgb ] ); let rgb = float; if ( rgb_type === 'F' ) { // treat float values as int // https://github.com/daavoo/pyntcloud/pull/204/commits/7b4205e64d5ed09abe708b2e91b615690c24d518 const farr = new Float32Array( 1 ); farr[ 0 ] = float; rgb = new Int32Array( farr.buffer )[ 0 ]; } const r = ( ( rgb >> 16 ) & 0x0000ff ) / 255; const g = ( ( rgb >> 8 ) & 0x0000ff ) / 255; const b = ( ( rgb >> 0 ) & 0x0000ff ) / 255; c.set( r, g, b ).convertSRGBToLinear(); color.push( c.r, c.g, c.b ); } if ( offset.normal_x !== undefined ) { normal.push( parseFloat( line[ offset.normal_x ] ) ); normal.push( parseFloat( line[ offset.normal_y ] ) ); normal.push( parseFloat( line[ offset.normal_z ] ) ); } if ( offset.intensity !== undefined ) { intensity.push( parseFloat( line[ offset.intensity ] ) ); } if ( offset.label !== undefined ) { label.push( parseInt( line[ offset.label ] ) ); } } } // binary-compressed // normally data in PCD files are organized as array of structures: XYZRGBXYZRGB // binary compressed PCD files organize their data as structure of arrays: XXYYZZRGBRGB // that requires a totally different parsing approach compared to non-compressed data if ( PCDheader.data === 'binary_compressed' ) { const sizes = new Uint32Array( data.slice( PCDheader.headerLen, PCDheader.headerLen + 8 ) ); const compressedSize = sizes[ 0 ]; const decompressedSize = sizes[ 1 ]; const decompressed = decompressLZF( new Uint8Array( data, PCDheader.headerLen + 8, compressedSize ), decompressedSize ); const dataview = new DataView( decompressed.buffer ); const offset = PCDheader.offset; for ( let i = 0; i < PCDheader.points; i ++ ) { if ( offset.x !== undefined ) { const xIndex = PCDheader.fields.indexOf( 'x' ); const yIndex = PCDheader.fields.indexOf( 'y' ); const zIndex = PCDheader.fields.indexOf( 'z' ); position.push( dataview.getFloat32( ( PCDheader.points * offset.x ) + PCDheader.size[ xIndex ] * i, this.littleEndian ) ); position.push( dataview.getFloat32( ( PCDheader.points * offset.y ) + PCDheader.size[ yIndex ] * i, this.littleEndian ) ); position.push( dataview.getFloat32( ( PCDheader.points * offset.z ) + PCDheader.size[ zIndex ] * i, this.littleEndian ) ); } if ( offset.rgb !== undefined ) { const rgbIndex = PCDheader.fields.indexOf( 'rgb' ); const r = dataview.getUint8( ( PCDheader.points * offset.rgb ) + PCDheader.size[ rgbIndex ] * i + 2 ) / 255.0; const g = dataview.getUint8( ( PCDheader.points * offset.rgb ) + PCDheader.size[ rgbIndex ] * i + 1 ) / 255.0; const b = dataview.getUint8( ( PCDheader.points * offset.rgb ) + PCDheader.size[ rgbIndex ] * i + 0 ) / 255.0; c.set( r, g, b ).convertSRGBToLinear(); color.push( c.r, c.g, c.b ); } if ( offset.normal_x !== undefined ) { const xIndex = PCDheader.fields.indexOf( 'normal_x' ); const yIndex = PCDheader.fields.indexOf( 'normal_y' ); const zIndex = PCDheader.fields.indexOf( 'normal_z' ); normal.push( dataview.getFloat32( ( PCDheader.points * offset.normal_x ) + PCDheader.size[ xIndex ] * i, this.littleEndian ) ); normal.push( dataview.getFloat32( ( PCDheader.points * offset.normal_y ) + PCDheader.size[ yIndex ] * i, this.littleEndian ) ); normal.push( dataview.getFloat32( ( PCDheader.points * offset.normal_z ) + PCDheader.size[ zIndex ] * i, this.littleEndian ) ); } if ( offset.intensity !== undefined ) { const intensityIndex = PCDheader.fields.indexOf( 'intensity' ); intensity.push( dataview.getFloat32( ( PCDheader.points * offset.intensity ) + PCDheader.size[ intensityIndex ] * i, this.littleEndian ) ); } if ( offset.label !== undefined ) { const labelIndex = PCDheader.fields.indexOf( 'label' ); label.push( dataview.getInt32( ( PCDheader.points * offset.label ) + PCDheader.size[ labelIndex ] * i, this.littleEndian ) ); } } } // binary if ( PCDheader.data === 'binary' ) { const dataview = new DataView( data, PCDheader.headerLen ); const offset = PCDheader.offset; for ( let i = 0, row = 0; i < PCDheader.points; i ++, row += PCDheader.rowSize ) { if ( offset.x !== undefined ) { position.push( dataview.getFloat32( row + offset.x, this.littleEndian ) ); position.push( dataview.getFloat32( row + offset.y, this.littleEndian ) ); position.push( dataview.getFloat32( row + offset.z, this.littleEndian ) ); } if ( offset.rgb !== undefined ) { const r = dataview.getUint8( row + offset.rgb + 2 ) / 255.0; const g = dataview.getUint8( row + offset.rgb + 1 ) / 255.0; const b = dataview.getUint8( row + offset.rgb + 0 ) / 255.0; c.set( r, g, b ).convertSRGBToLinear(); color.push( c.r, c.g, c.b ); } if ( offset.normal_x !== undefined ) { normal.push( dataview.getFloat32( row + offset.normal_x, this.littleEndian ) ); normal.push( dataview.getFloat32( row + offset.normal_y, this.littleEndian ) ); normal.push( dataview.getFloat32( row + offset.normal_z, this.littleEndian ) ); } if ( offset.intensity !== undefined ) { intensity.push( dataview.getFloat32( row + offset.intensity, this.littleEndian ) ); } if ( offset.label !== undefined ) { label.push( dataview.getInt32( row + offset.label, this.littleEndian ) ); } } } // build geometry const geometry = new BufferGeometry(); if ( position.length > 0 ) geometry.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) ); if ( normal.length > 0 ) geometry.setAttribute( 'normal', new Float32BufferAttribute( normal, 3 ) ); if ( color.length > 0 ) geometry.setAttribute( 'color', new Float32BufferAttribute( color, 3 ) ); if ( intensity.length > 0 ) geometry.setAttribute( 'intensity', new Float32BufferAttribute( intensity, 1 ) ); if ( label.length > 0 ) geometry.setAttribute( 'label', new Int32BufferAttribute( label, 1 ) ); geometry.computeBoundingSphere(); // build material const material = new PointsMaterial( { size: 0.005 } ); if ( color.length > 0 ) { material.vertexColors = true; } // build point cloud return new Points( geometry, material ); } } export { PCDLoader };"},{"title":"","date":"2023-10-12T14:08:40.700Z","updated":"2023-10-12T14:08:40.700Z","comments":true,"path":"js/three/jsm/loaders/MD2Loader.js","permalink":"http://19999997.xyz/js/three/jsm/loaders/MD2Loader.js","excerpt":"","text":"import { AnimationClip, BufferGeometry, FileLoader, Float32BufferAttribute, Loader, Vector3 } from 'three'; const _normalData = [ [ - 0.525731, 0.000000, 0.850651 ], [ - 0.442863, 0.238856, 0.864188 ], [ - 0.295242, 0.000000, 0.955423 ], [ - 0.309017, 0.500000, 0.809017 ], [ - 0.162460, 0.262866, 0.951056 ], [ 0.000000, 0.000000, 1.000000 ], [ 0.000000, 0.850651, 0.525731 ], [ - 0.147621, 0.716567, 0.681718 ], [ 0.147621, 0.716567, 0.681718 ], [ 0.000000, 0.525731, 0.850651 ], [ 0.309017, 0.500000, 0.809017 ], [ 0.525731, 0.000000, 0.850651 ], [ 0.295242, 0.000000, 0.955423 ], [ 0.442863, 0.238856, 0.864188 ], [ 0.162460, 0.262866, 0.951056 ], [ - 0.681718, 0.147621, 0.716567 ], [ - 0.809017, 0.309017, 0.500000 ], [ - 0.587785, 0.425325, 0.688191 ], [ - 0.850651, 0.525731, 0.000000 ], [ - 0.864188, 0.442863, 0.238856 ], [ - 0.716567, 0.681718, 0.147621 ], [ - 0.688191, 0.587785, 0.425325 ], [ - 0.500000, 0.809017, 0.309017 ], [ - 0.238856, 0.864188, 0.442863 ], [ - 0.425325, 0.688191, 0.587785 ], [ - 0.716567, 0.681718, - 0.147621 ], [ - 0.500000, 0.809017, - 0.309017 ], [ - 0.525731, 0.850651, 0.000000 ], [ 0.000000, 0.850651, - 0.525731 ], [ - 0.238856, 0.864188, - 0.442863 ], [ 0.000000, 0.955423, - 0.295242 ], [ - 0.262866, 0.951056, - 0.162460 ], [ 0.000000, 1.000000, 0.000000 ], [ 0.000000, 0.955423, 0.295242 ], [ - 0.262866, 0.951056, 0.162460 ], [ 0.238856, 0.864188, 0.442863 ], [ 0.262866, 0.951056, 0.162460 ], [ 0.500000, 0.809017, 0.309017 ], [ 0.238856, 0.864188, - 0.442863 ], [ 0.262866, 0.951056, - 0.162460 ], [ 0.500000, 0.809017, - 0.309017 ], [ 0.850651, 0.525731, 0.000000 ], [ 0.716567, 0.681718, 0.147621 ], [ 0.716567, 0.681718, - 0.147621 ], [ 0.525731, 0.850651, 0.000000 ], [ 0.425325, 0.688191, 0.587785 ], [ 0.864188, 0.442863, 0.238856 ], [ 0.688191, 0.587785, 0.425325 ], [ 0.809017, 0.309017, 0.500000 ], [ 0.681718, 0.147621, 0.716567 ], [ 0.587785, 0.425325, 0.688191 ], [ 0.955423, 0.295242, 0.000000 ], [ 1.000000, 0.000000, 0.000000 ], [ 0.951056, 0.162460, 0.262866 ], [ 0.850651, - 0.525731, 0.000000 ], [ 0.955423, - 0.295242, 0.000000 ], [ 0.864188, - 0.442863, 0.238856 ], [ 0.951056, - 0.162460, 0.262866 ], [ 0.809017, - 0.309017, 0.500000 ], [ 0.681718, - 0.147621, 0.716567 ], [ 0.850651, 0.000000, 0.525731 ], [ 0.864188, 0.442863, - 0.238856 ], [ 0.809017, 0.309017, - 0.500000 ], [ 0.951056, 0.162460, - 0.262866 ], [ 0.525731, 0.000000, - 0.850651 ], [ 0.681718, 0.147621, - 0.716567 ], [ 0.681718, - 0.147621, - 0.716567 ], [ 0.850651, 0.000000, - 0.525731 ], [ 0.809017, - 0.309017, - 0.500000 ], [ 0.864188, - 0.442863, - 0.238856 ], [ 0.951056, - 0.162460, - 0.262866 ], [ 0.147621, 0.716567, - 0.681718 ], [ 0.309017, 0.500000, - 0.809017 ], [ 0.425325, 0.688191, - 0.587785 ], [ 0.442863, 0.238856, - 0.864188 ], [ 0.587785, 0.425325, - 0.688191 ], [ 0.688191, 0.587785, - 0.425325 ], [ - 0.147621, 0.716567, - 0.681718 ], [ - 0.309017, 0.500000, - 0.809017 ], [ 0.000000, 0.525731, - 0.850651 ], [ - 0.525731, 0.000000, - 0.850651 ], [ - 0.442863, 0.238856, - 0.864188 ], [ - 0.295242, 0.000000, - 0.955423 ], [ - 0.162460, 0.262866, - 0.951056 ], [ 0.000000, 0.000000, - 1.000000 ], [ 0.295242, 0.000000, - 0.955423 ], [ 0.162460, 0.262866, - 0.951056 ], [ - 0.442863, - 0.238856, - 0.864188 ], [ - 0.309017, - 0.500000, - 0.809017 ], [ - 0.162460, - 0.262866, - 0.951056 ], [ 0.000000, - 0.850651, - 0.525731 ], [ - 0.147621, - 0.716567, - 0.681718 ], [ 0.147621, - 0.716567, - 0.681718 ], [ 0.000000, - 0.525731, - 0.850651 ], [ 0.309017, - 0.500000, - 0.809017 ], [ 0.442863, - 0.238856, - 0.864188 ], [ 0.162460, - 0.262866, - 0.951056 ], [ 0.238856, - 0.864188, - 0.442863 ], [ 0.500000, - 0.809017, - 0.309017 ], [ 0.425325, - 0.688191, - 0.587785 ], [ 0.716567, - 0.681718, - 0.147621 ], [ 0.688191, - 0.587785, - 0.425325 ], [ 0.587785, - 0.425325, - 0.688191 ], [ 0.000000, - 0.955423, - 0.295242 ], [ 0.000000, - 1.000000, 0.000000 ], [ 0.262866, - 0.951056, - 0.162460 ], [ 0.000000, - 0.850651, 0.525731 ], [ 0.000000, - 0.955423, 0.295242 ], [ 0.238856, - 0.864188, 0.442863 ], [ 0.262866, - 0.951056, 0.162460 ], [ 0.500000, - 0.809017, 0.309017 ], [ 0.716567, - 0.681718, 0.147621 ], [ 0.525731, - 0.850651, 0.000000 ], [ - 0.238856, - 0.864188, - 0.442863 ], [ - 0.500000, - 0.809017, - 0.309017 ], [ - 0.262866, - 0.951056, - 0.162460 ], [ - 0.850651, - 0.525731, 0.000000 ], [ - 0.716567, - 0.681718, - 0.147621 ], [ - 0.716567, - 0.681718, 0.147621 ], [ - 0.525731, - 0.850651, 0.000000 ], [ - 0.500000, - 0.809017, 0.309017 ], [ - 0.238856, - 0.864188, 0.442863 ], [ - 0.262866, - 0.951056, 0.162460 ], [ - 0.864188, - 0.442863, 0.238856 ], [ - 0.809017, - 0.309017, 0.500000 ], [ - 0.688191, - 0.587785, 0.425325 ], [ - 0.681718, - 0.147621, 0.716567 ], [ - 0.442863, - 0.238856, 0.864188 ], [ - 0.587785, - 0.425325, 0.688191 ], [ - 0.309017, - 0.500000, 0.809017 ], [ - 0.147621, - 0.716567, 0.681718 ], [ - 0.425325, - 0.688191, 0.587785 ], [ - 0.162460, - 0.262866, 0.951056 ], [ 0.442863, - 0.238856, 0.864188 ], [ 0.162460, - 0.262866, 0.951056 ], [ 0.309017, - 0.500000, 0.809017 ], [ 0.147621, - 0.716567, 0.681718 ], [ 0.000000, - 0.525731, 0.850651 ], [ 0.425325, - 0.688191, 0.587785 ], [ 0.587785, - 0.425325, 0.688191 ], [ 0.688191, - 0.587785, 0.425325 ], [ - 0.955423, 0.295242, 0.000000 ], [ - 0.951056, 0.162460, 0.262866 ], [ - 1.000000, 0.000000, 0.000000 ], [ - 0.850651, 0.000000, 0.525731 ], [ - 0.955423, - 0.295242, 0.000000 ], [ - 0.951056, - 0.162460, 0.262866 ], [ - 0.864188, 0.442863, - 0.238856 ], [ - 0.951056, 0.162460, - 0.262866 ], [ - 0.809017, 0.309017, - 0.500000 ], [ - 0.864188, - 0.442863, - 0.238856 ], [ - 0.951056, - 0.162460, - 0.262866 ], [ - 0.809017, - 0.309017, - 0.500000 ], [ - 0.681718, 0.147621, - 0.716567 ], [ - 0.681718, - 0.147621, - 0.716567 ], [ - 0.850651, 0.000000, - 0.525731 ], [ - 0.688191, 0.587785, - 0.425325 ], [ - 0.587785, 0.425325, - 0.688191 ], [ - 0.425325, 0.688191, - 0.587785 ], [ - 0.425325, - 0.688191, - 0.587785 ], [ - 0.587785, - 0.425325, - 0.688191 ], [ - 0.688191, - 0.587785, - 0.425325 ] ]; class MD2Loader extends Loader { constructor( manager ) { super( manager ); } load( url, onLoad, onProgress, onError ) { const scope = this; const loader = new FileLoader( scope.manager ); loader.setPath( scope.path ); loader.setResponseType( 'arraybuffer' ); loader.setRequestHeader( scope.requestHeader ); loader.setWithCredentials( scope.withCredentials ); loader.load( url, function ( buffer ) { try { onLoad( scope.parse( buffer ) ); } catch ( e ) { if ( onError ) { onError( e ); } else { console.error( e ); } scope.manager.itemError( url ); } }, onProgress, onError ); } parse( buffer ) { const data = new DataView( buffer ); // http://tfc.duke.free.fr/coding/md2-specs-en.html const header = {}; const headerNames = [ 'ident', 'version', 'skinwidth', 'skinheight', 'framesize', 'num_skins', 'num_vertices', 'num_st', 'num_tris', 'num_glcmds', 'num_frames', 'offset_skins', 'offset_st', 'offset_tris', 'offset_frames', 'offset_glcmds', 'offset_end' ]; for ( let i = 0; i < headerNames.length; i ++ ) { header[ headerNames[ i ] ] = data.getInt32( i * 4, true ); } if ( header.ident !== 844121161 || header.version !== 8 ) { console.error( 'Not a valid MD2 file' ); return; } if ( header.offset_end !== data.byteLength ) { console.error( 'Corrupted MD2 file' ); return; } // const geometry = new BufferGeometry(); // uvs const uvsTemp = []; let offset = header.offset_st; for ( let i = 0, l = header.num_st; i < l; i ++ ) { const u = data.getInt16( offset + 0, true ); const v = data.getInt16( offset + 2, true ); uvsTemp.push( u / header.skinwidth, 1 - ( v / header.skinheight ) ); offset += 4; } // triangles offset = header.offset_tris; const vertexIndices = []; const uvIndices = []; for ( let i = 0, l = header.num_tris; i < l; i ++ ) { vertexIndices.push( data.getUint16( offset + 0, true ), data.getUint16( offset + 2, true ), data.getUint16( offset + 4, true ) ); uvIndices.push( data.getUint16( offset + 6, true ), data.getUint16( offset + 8, true ), data.getUint16( offset + 10, true ) ); offset += 12; } // frames const translation = new Vector3(); const scale = new Vector3(); const frames = []; offset = header.offset_frames; for ( let i = 0, l = header.num_frames; i < l; i ++ ) { scale.set( data.getFloat32( offset + 0, true ), data.getFloat32( offset + 4, true ), data.getFloat32( offset + 8, true ) ); translation.set( data.getFloat32( offset + 12, true ), data.getFloat32( offset + 16, true ), data.getFloat32( offset + 20, true ) ); offset += 24; const string = []; for ( let j = 0; j < 16; j ++ ) { const character = data.getUint8( offset + j ); if ( character === 0 ) break; string[ j ] = character; } const frame = { name: String.fromCharCode.apply( null, string ), vertices: [], normals: [] }; offset += 16; for ( let j = 0; j < header.num_vertices; j ++ ) { let x = data.getUint8( offset ++ ); let y = data.getUint8( offset ++ ); let z = data.getUint8( offset ++ ); const n = _normalData[ data.getUint8( offset ++ ) ]; x = x * scale.x + translation.x; y = y * scale.y + translation.y; z = z * scale.z + translation.z; frame.vertices.push( x, z, y ); // convert to Y-up frame.normals.push( n[ 0 ], n[ 2 ], n[ 1 ] ); // convert to Y-up } frames.push( frame ); } // static const positions = []; const normals = []; const uvs = []; const verticesTemp = frames[ 0 ].vertices; const normalsTemp = frames[ 0 ].normals; for ( let i = 0, l = vertexIndices.length; i < l; i ++ ) { const vertexIndex = vertexIndices[ i ]; let stride = vertexIndex * 3; // const x = verticesTemp[ stride ]; const y = verticesTemp[ stride + 1 ]; const z = verticesTemp[ stride + 2 ]; positions.push( x, y, z ); // const nx = normalsTemp[ stride ]; const ny = normalsTemp[ stride + 1 ]; const nz = normalsTemp[ stride + 2 ]; normals.push( nx, ny, nz ); // const uvIndex = uvIndices[ i ]; stride = uvIndex * 2; const u = uvsTemp[ stride ]; const v = uvsTemp[ stride + 1 ]; uvs.push( u, v ); } geometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) ); geometry.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) ); geometry.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) ); // animation const morphPositions = []; const morphNormals = []; for ( let i = 0, l = frames.length; i < l; i ++ ) { const frame = frames[ i ]; const attributeName = frame.name; if ( frame.vertices.length > 0 ) { const positions = []; for ( let j = 0, jl = vertexIndices.length; j < jl; j ++ ) { const vertexIndex = vertexIndices[ j ]; const stride = vertexIndex * 3; const x = frame.vertices[ stride ]; const y = frame.vertices[ stride + 1 ]; const z = frame.vertices[ stride + 2 ]; positions.push( x, y, z ); } const positionAttribute = new Float32BufferAttribute( positions, 3 ); positionAttribute.name = attributeName; morphPositions.push( positionAttribute ); } if ( frame.normals.length > 0 ) { const normals = []; for ( let j = 0, jl = vertexIndices.length; j < jl; j ++ ) { const vertexIndex = vertexIndices[ j ]; const stride = vertexIndex * 3; const nx = frame.normals[ stride ]; const ny = frame.normals[ stride + 1 ]; const nz = frame.normals[ stride + 2 ]; normals.push( nx, ny, nz ); } const normalAttribute = new Float32BufferAttribute( normals, 3 ); normalAttribute.name = attributeName; morphNormals.push( normalAttribute ); } } geometry.morphAttributes.position = morphPositions; geometry.morphAttributes.normal = morphNormals; geometry.morphTargetsRelative = false; geometry.animations = AnimationClip.CreateClipsFromMorphTargetSequences( frames, 10 ); return geometry; } } export { MD2Loader };"},{"title":"","date":"2023-10-12T14:08:40.716Z","updated":"2023-10-12T14:08:40.716Z","comments":true,"path":"js/three/jsm/loaders/OBJLoader.js","permalink":"http://19999997.xyz/js/three/jsm/loaders/OBJLoader.js","excerpt":"","text":"import { BufferGeometry, FileLoader, Float32BufferAttribute, Group, LineBasicMaterial, LineSegments, Loader, Material, Mesh, MeshPhongMaterial, Points, PointsMaterial, Vector3, Color } from 'three'; // o object_name | g group_name const _object_pattern = /^[og]\\s*(.+)?/; // mtllib file_reference const _material_library_pattern = /^mtllib /; // usemtl material_name const _material_use_pattern = /^usemtl /; // usemap map_name const _map_use_pattern = /^usemap /; const _face_vertex_data_separator_pattern = /\\s+/; const _vA = new Vector3(); const _vB = new Vector3(); const _vC = new Vector3(); const _ab = new Vector3(); const _cb = new Vector3(); const _color = new Color(); function ParserState() { const state = { objects: [], object: {}, vertices: [], normals: [], colors: [], uvs: [], materials: {}, materialLibraries: [], startObject: function ( name, fromDeclaration ) { // If the current object (initial from reset) is not from a g/o declaration in the parsed // file. We need to use it for the first parsed g/o to keep things in sync. if ( this.object && this.object.fromDeclaration === false ) { this.object.name = name; this.object.fromDeclaration = ( fromDeclaration !== false ); return; } const previousMaterial = ( this.object && typeof this.object.currentMaterial === 'function' ? this.object.currentMaterial() : undefined ); if ( this.object && typeof this.object._finalize === 'function' ) { this.object._finalize( true ); } this.object = { name: name || '', fromDeclaration: ( fromDeclaration !== false ), geometry: { vertices: [], normals: [], colors: [], uvs: [], hasUVIndices: false }, materials: [], smooth: true, startMaterial: function ( name, libraries ) { const previous = this._finalize( false ); // New usemtl declaration overwrites an inherited material, except if faces were declared // after the material, then it must be preserved for proper MultiMaterial continuation. if ( previous && ( previous.inherited || previous.groupCount 0 ? libraries[ libraries.length - 1 ] : '' ), smooth: ( previous !== undefined ? previous.smooth : this.smooth ), groupStart: ( previous !== undefined ? previous.groupEnd : 0 ), groupEnd: - 1, groupCount: - 1, inherited: false, clone: function ( index ) { const cloned = { index: ( typeof index === 'number' ? index : this.index ), name: this.name, mtllib: this.mtllib, smooth: this.smooth, groupStart: 0, groupEnd: - 1, groupCount: - 1, inherited: false }; cloned.clone = this.clone.bind( cloned ); return cloned; } }; this.materials.push( material ); return material; }, currentMaterial: function () { if ( this.materials.length > 0 ) { return this.materials[ this.materials.length - 1 ]; } return undefined; }, _finalize: function ( end ) { const lastMultiMaterial = this.currentMaterial(); if ( lastMultiMaterial && lastMultiMaterial.groupEnd === - 1 ) { lastMultiMaterial.groupEnd = this.geometry.vertices.length / 3; lastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart; lastMultiMaterial.inherited = false; } // Ignore objects tail materials if no face declarations followed them before a new o/g started. if ( end && this.materials.length > 1 ) { for ( let mi = this.materials.length - 1; mi >= 0; mi -- ) { if ( this.materials[ mi ].groupCount = 0 ? index - 1 : index + len / 3 ) * 3; }, parseNormalIndex: function ( value, len ) { const index = parseInt( value, 10 ); return ( index >= 0 ? index - 1 : index + len / 3 ) * 3; }, parseUVIndex: function ( value, len ) { const index = parseInt( value, 10 ); return ( index >= 0 ? index - 1 : index + len / 2 ) * 2; }, addVertex: function ( a, b, c ) { const src = this.vertices; const dst = this.object.geometry.vertices; dst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] ); dst.push( src[ b + 0 ], src[ b + 1 ], src[ b + 2 ] ); dst.push( src[ c + 0 ], src[ c + 1 ], src[ c + 2 ] ); }, addVertexPoint: function ( a ) { const src = this.vertices; const dst = this.object.geometry.vertices; dst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] ); }, addVertexLine: function ( a ) { const src = this.vertices; const dst = this.object.geometry.vertices; dst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] ); }, addNormal: function ( a, b, c ) { const src = this.normals; const dst = this.object.geometry.normals; dst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] ); dst.push( src[ b + 0 ], src[ b + 1 ], src[ b + 2 ] ); dst.push( src[ c + 0 ], src[ c + 1 ], src[ c + 2 ] ); }, addFaceNormal: function ( a, b, c ) { const src = this.vertices; const dst = this.object.geometry.normals; _vA.fromArray( src, a ); _vB.fromArray( src, b ); _vC.fromArray( src, c ); _cb.subVectors( _vC, _vB ); _ab.subVectors( _vA, _vB ); _cb.cross( _ab ); _cb.normalize(); dst.push( _cb.x, _cb.y, _cb.z ); dst.push( _cb.x, _cb.y, _cb.z ); dst.push( _cb.x, _cb.y, _cb.z ); }, addColor: function ( a, b, c ) { const src = this.colors; const dst = this.object.geometry.colors; if ( src[ a ] !== undefined ) dst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] ); if ( src[ b ] !== undefined ) dst.push( src[ b + 0 ], src[ b + 1 ], src[ b + 2 ] ); if ( src[ c ] !== undefined ) dst.push( src[ c + 0 ], src[ c + 1 ], src[ c + 2 ] ); }, addUV: function ( a, b, c ) { const src = this.uvs; const dst = this.object.geometry.uvs; dst.push( src[ a + 0 ], src[ a + 1 ] ); dst.push( src[ b + 0 ], src[ b + 1 ] ); dst.push( src[ c + 0 ], src[ c + 1 ] ); }, addDefaultUV: function () { const dst = this.object.geometry.uvs; dst.push( 0, 0 ); dst.push( 0, 0 ); dst.push( 0, 0 ); }, addUVLine: function ( a ) { const src = this.uvs; const dst = this.object.geometry.uvs; dst.push( src[ a + 0 ], src[ a + 1 ] ); }, addFace: function ( a, b, c, ua, ub, uc, na, nb, nc ) { const vLen = this.vertices.length; let ia = this.parseVertexIndex( a, vLen ); let ib = this.parseVertexIndex( b, vLen ); let ic = this.parseVertexIndex( c, vLen ); this.addVertex( ia, ib, ic ); this.addColor( ia, ib, ic ); // normals if ( na !== undefined && na !== '' ) { const nLen = this.normals.length; ia = this.parseNormalIndex( na, nLen ); ib = this.parseNormalIndex( nb, nLen ); ic = this.parseNormalIndex( nc, nLen ); this.addNormal( ia, ib, ic ); } else { this.addFaceNormal( ia, ib, ic ); } // uvs if ( ua !== undefined && ua !== '' ) { const uvLen = this.uvs.length; ia = this.parseUVIndex( ua, uvLen ); ib = this.parseUVIndex( ub, uvLen ); ic = this.parseUVIndex( uc, uvLen ); this.addUV( ia, ib, ic ); this.object.geometry.hasUVIndices = true; } else { // add placeholder values (for inconsistent face definitions) this.addDefaultUV(); } }, addPointGeometry: function ( vertices ) { this.object.geometry.type = 'Points'; const vLen = this.vertices.length; for ( let vi = 0, l = vertices.length; vi < l; vi ++ ) { const index = this.parseVertexIndex( vertices[ vi ], vLen ); this.addVertexPoint( index ); this.addColor( index ); } }, addLineGeometry: function ( vertices, uvs ) { this.object.geometry.type = 'Line'; const vLen = this.vertices.length; const uvLen = this.uvs.length; for ( let vi = 0, l = vertices.length; vi < l; vi ++ ) { this.addVertexLine( this.parseVertexIndex( vertices[ vi ], vLen ) ); } for ( let uvi = 0, l = uvs.length; uvi < l; uvi ++ ) { this.addUVLine( this.parseUVIndex( uvs[ uvi ], uvLen ) ); } } }; state.startObject( '', false ); return state; } // class OBJLoader extends Loader { constructor( manager ) { super( manager ); this.materials = null; } load( url, onLoad, onProgress, onError ) { const scope = this; const loader = new FileLoader( this.manager ); loader.setPath( this.path ); loader.setRequestHeader( this.requestHeader ); loader.setWithCredentials( this.withCredentials ); loader.load( url, function ( text ) { try { onLoad( scope.parse( text ) ); } catch ( e ) { if ( onError ) { onError( e ); } else { console.error( e ); } scope.manager.itemError( url ); } }, onProgress, onError ); } setMaterials( materials ) { this.materials = materials; return this; } parse( text ) { const state = new ParserState(); if ( text.indexOf( '\\r\\n' ) !== - 1 ) { // This is faster than String.split with regex that splits on both text = text.replace( /\\r\\n/g, '\\n' ); } if ( text.indexOf( '\\\\\\n' ) !== - 1 ) { // join lines separated by a line continuation character (\\) text = text.replace( /\\\\\\n/g, '' ); } const lines = text.split( '\\n' ); let result = []; for ( let i = 0, l = lines.length; i < l; i ++ ) { const line = lines[ i ].trimStart(); if ( line.length === 0 ) continue; const lineFirstChar = line.charAt( 0 ); // @todo invoke passed in handler if any if ( lineFirstChar === '#' ) continue; // skip comments if ( lineFirstChar === 'v' ) { const data = line.split( _face_vertex_data_separator_pattern ); switch ( data[ 0 ] ) { case 'v': state.vertices.push( parseFloat( data[ 1 ] ), parseFloat( data[ 2 ] ), parseFloat( data[ 3 ] ) ); if ( data.length >= 7 ) { _color.setRGB( parseFloat( data[ 4 ] ), parseFloat( data[ 5 ] ), parseFloat( data[ 6 ] ) ).convertSRGBToLinear(); state.colors.push( _color.r, _color.g, _color.b ); } else { // if no colors are defined, add placeholders so color and vertex indices match state.colors.push( undefined, undefined, undefined ); } break; case 'vn': state.normals.push( parseFloat( data[ 1 ] ), parseFloat( data[ 2 ] ), parseFloat( data[ 3 ] ) ); break; case 'vt': state.uvs.push( parseFloat( data[ 1 ] ), parseFloat( data[ 2 ] ) ); break; } } else if ( lineFirstChar === 'f' ) { const lineData = line.slice( 1 ).trim(); const vertexData = lineData.split( _face_vertex_data_separator_pattern ); const faceVertices = []; // Parse the face vertex data into an easy to work with format for ( let j = 0, jl = vertexData.length; j < jl; j ++ ) { const vertex = vertexData[ j ]; if ( vertex.length > 0 ) { const vertexParts = vertex.split( '/' ); faceVertices.push( vertexParts ); } } // Draw an edge between the first vertex and all subsequent vertices to form an n-gon const v1 = faceVertices[ 0 ]; for ( let j = 1, jl = faceVertices.length - 1; j < jl; j ++ ) { const v2 = faceVertices[ j ]; const v3 = faceVertices[ j + 1 ]; state.addFace( v1[ 0 ], v2[ 0 ], v3[ 0 ], v1[ 1 ], v2[ 1 ], v3[ 1 ], v1[ 2 ], v2[ 2 ], v3[ 2 ] ); } } else if ( lineFirstChar === 'l' ) { const lineParts = line.substring( 1 ).trim().split( ' ' ); let lineVertices = []; const lineUVs = []; if ( line.indexOf( '/' ) === - 1 ) { lineVertices = lineParts; } else { for ( let li = 0, llen = lineParts.length; li < llen; li ++ ) { const parts = lineParts[ li ].split( '/' ); if ( parts[ 0 ] !== '' ) lineVertices.push( parts[ 0 ] ); if ( parts[ 1 ] !== '' ) lineUVs.push( parts[ 1 ] ); } } state.addLineGeometry( lineVertices, lineUVs ); } else if ( lineFirstChar === 'p' ) { const lineData = line.slice( 1 ).trim(); const pointData = lineData.split( ' ' ); state.addPointGeometry( pointData ); } else if ( ( result = _object_pattern.exec( line ) ) !== null ) { // o object_name // or // g group_name // WORKAROUND: https://bugs.chromium.org/p/v8/issues/detail?id=2869 // let name = result[ 0 ].slice( 1 ).trim(); const name = ( ' ' + result[ 0 ].slice( 1 ).trim() ).slice( 1 ); state.startObject( name ); } else if ( _material_use_pattern.test( line ) ) { // material state.object.startMaterial( line.substring( 7 ).trim(), state.materialLibraries ); } else if ( _material_library_pattern.test( line ) ) { // mtl file state.materialLibraries.push( line.substring( 7 ).trim() ); } else if ( _map_use_pattern.test( line ) ) { // the line is parsed but ignored since the loader assumes textures are defined MTL files // (according to https://www.okino.com/conv/imp_wave.htm, 'usemap' is the old-style Wavefront texture reference method) console.warn( 'THREE.OBJLoader: Rendering identifier \"usemap\" not supported. Textures must be defined in MTL files.' ); } else if ( lineFirstChar === 's' ) { result = line.split( ' ' ); // smooth shading // @todo Handle files that have varying smooth values for a set of faces inside one geometry, // but does not define a usemtl for each face set. // This should be detected and a dummy material created (later MultiMaterial and geometry groups). // This requires some care to not create extra material on each smooth value for \"normal\" obj files. // where explicit usemtl defines geometry groups. // Example asset: examples/models/obj/cerberus/Cerberus.obj /* * http://paulbourke.net/dataformats/obj/ * * From chapter \"Grouping\" Syntax explanation \"s group_number\": * \"group_number is the smoothing group number. To turn off smoothing groups, use a value of 0 or off. * Polygonal elements use group numbers to put elements in different smoothing groups. For free-form * surfaces, smoothing groups are either turned on or off; there is no difference between values greater * than 0.\" */ if ( result.length > 1 ) { const value = result[ 1 ].trim().toLowerCase(); state.object.smooth = ( value !== '0' && value !== 'off' ); } else { // ZBrush can produce \"s\" lines #11707 state.object.smooth = true; } const material = state.object.currentMaterial(); if ( material ) material.smooth = state.object.smooth; } else { // Handle null terminated files without exception if ( line === '\\0' ) continue; console.warn( 'THREE.OBJLoader: Unexpected line: \"' + line + '\"' ); } } state.finalize(); const container = new Group(); container.materialLibraries = [].concat( state.materialLibraries ); const hasPrimitives = ! ( state.objects.length === 1 && state.objects[ 0 ].geometry.vertices.length === 0 ); if ( hasPrimitives === true ) { for ( let i = 0, l = state.objects.length; i < l; i ++ ) { const object = state.objects[ i ]; const geometry = object.geometry; const materials = object.materials; const isLine = ( geometry.type === 'Line' ); const isPoints = ( geometry.type === 'Points' ); let hasVertexColors = false; // Skip o/g line declarations that did not follow with any faces if ( geometry.vertices.length === 0 ) continue; const buffergeometry = new BufferGeometry(); buffergeometry.setAttribute( 'position', new Float32BufferAttribute( geometry.vertices, 3 ) ); if ( geometry.normals.length > 0 ) { buffergeometry.setAttribute( 'normal', new Float32BufferAttribute( geometry.normals, 3 ) ); } if ( geometry.colors.length > 0 ) { hasVertexColors = true; buffergeometry.setAttribute( 'color', new Float32BufferAttribute( geometry.colors, 3 ) ); } if ( geometry.hasUVIndices === true ) { buffergeometry.setAttribute( 'uv', new Float32BufferAttribute( geometry.uvs, 2 ) ); } // Create materials const createdMaterials = []; for ( let mi = 0, miLen = materials.length; mi < miLen; mi ++ ) { const sourceMaterial = materials[ mi ]; const materialHash = sourceMaterial.name + '_' + sourceMaterial.smooth + '_' + hasVertexColors; let material = state.materials[ materialHash ]; if ( this.materials !== null ) { material = this.materials.create( sourceMaterial.name ); // mtl etc. loaders probably can't create line materials correctly, copy properties to a line material. if ( isLine && material && ! ( material instanceof LineBasicMaterial ) ) { const materialLine = new LineBasicMaterial(); Material.prototype.copy.call( materialLine, material ); materialLine.color.copy( material.color ); material = materialLine; } else if ( isPoints && material && ! ( material instanceof PointsMaterial ) ) { const materialPoints = new PointsMaterial( { size: 10, sizeAttenuation: false } ); Material.prototype.copy.call( materialPoints, material ); materialPoints.color.copy( material.color ); materialPoints.map = material.map; material = materialPoints; } } if ( material === undefined ) { if ( isLine ) { material = new LineBasicMaterial(); } else if ( isPoints ) { material = new PointsMaterial( { size: 1, sizeAttenuation: false } ); } else { material = new MeshPhongMaterial(); } material.name = sourceMaterial.name; material.flatShading = sourceMaterial.smooth ? false : true; material.vertexColors = hasVertexColors; state.materials[ materialHash ] = material; } createdMaterials.push( material ); } // Create mesh let mesh; if ( createdMaterials.length > 1 ) { for ( let mi = 0, miLen = materials.length; mi < miLen; mi ++ ) { const sourceMaterial = materials[ mi ]; buffergeometry.addGroup( sourceMaterial.groupStart, sourceMaterial.groupCount, mi ); } if ( isLine ) { mesh = new LineSegments( buffergeometry, createdMaterials ); } else if ( isPoints ) { mesh = new Points( buffergeometry, createdMaterials ); } else { mesh = new Mesh( buffergeometry, createdMaterials ); } } else { if ( isLine ) { mesh = new LineSegments( buffergeometry, createdMaterials[ 0 ] ); } else if ( isPoints ) { mesh = new Points( buffergeometry, createdMaterials[ 0 ] ); } else { mesh = new Mesh( buffergeometry, createdMaterials[ 0 ] ); } } mesh.name = object.name; container.add( mesh ); } } else { // if there is only the default parser state object with no geometry data, interpret data as point cloud if ( state.vertices.length > 0 ) { const material = new PointsMaterial( { size: 1, sizeAttenuation: false } ); const buffergeometry = new BufferGeometry(); buffergeometry.setAttribute( 'position', new Float32BufferAttribute( state.vertices, 3 ) ); if ( state.colors.length > 0 && state.colors[ 0 ] !== undefined ) { buffergeometry.setAttribute( 'color', new Float32BufferAttribute( state.colors, 3 ) ); material.vertexColors = true; } const points = new Points( buffergeometry, material ); container.add( points ); } } return container; } } export { OBJLoader };"},{"title":"","date":"2023-10-12T14:08:40.725Z","updated":"2023-10-12T14:08:40.725Z","comments":true,"path":"js/three/jsm/loaders/PVRLoader.js","permalink":"http://19999997.xyz/js/three/jsm/loaders/PVRLoader.js","excerpt":"","text":"import { CompressedTextureLoader, RGBA_PVRTC_2BPPV1_Format, RGBA_PVRTC_4BPPV1_Format, RGB_PVRTC_2BPPV1_Format, RGB_PVRTC_4BPPV1_Format } from 'three'; /* * PVR v2 (legacy) parser * TODO : Add Support for PVR v3 format * TODO : implement loadMipmaps option */ class PVRLoader extends CompressedTextureLoader { constructor( manager ) { super( manager ); } parse( buffer, loadMipmaps ) { const headerLengthInt = 13; const header = new Uint32Array( buffer, 0, headerLengthInt ); const pvrDatas = { buffer: buffer, header: header, loadMipmaps: loadMipmaps }; if ( header[ 0 ] === 0x03525650 ) { // PVR v3 return _parseV3( pvrDatas ); } else if ( header[ 11 ] === 0x21525650 ) { // PVR v2 return _parseV2( pvrDatas ); } else { console.error( 'THREE.PVRLoader: Unknown PVR format.' ); } } } function _parseV3( pvrDatas ) { const header = pvrDatas.header; let bpp, format; const metaLen = header[ 12 ], pixelFormat = header[ 2 ], height = header[ 6 ], width = header[ 7 ], // numSurfs = header[ 9 ], numFaces = header[ 10 ], numMipmaps = header[ 11 ]; switch ( pixelFormat ) { case 0 : // PVRTC 2bpp RGB bpp = 2; format = RGB_PVRTC_2BPPV1_Format; break; case 1 : // PVRTC 2bpp RGBA bpp = 2; format = RGBA_PVRTC_2BPPV1_Format; break; case 2 : // PVRTC 4bpp RGB bpp = 4; format = RGB_PVRTC_4BPPV1_Format; break; case 3 : // PVRTC 4bpp RGBA bpp = 4; format = RGBA_PVRTC_4BPPV1_Format; break; default : console.error( 'THREE.PVRLoader: Unsupported PVR format:', pixelFormat ); } pvrDatas.dataPtr = 52 + metaLen; pvrDatas.bpp = bpp; pvrDatas.format = format; pvrDatas.width = width; pvrDatas.height = height; pvrDatas.numSurfaces = numFaces; pvrDatas.numMipmaps = numMipmaps; pvrDatas.isCubemap = ( numFaces === 6 ); return _extract( pvrDatas ); } function _parseV2( pvrDatas ) { const header = pvrDatas.header; const headerLength = header[ 0 ], height = header[ 1 ], width = header[ 2 ], numMipmaps = header[ 3 ], flags = header[ 4 ], // dataLength = header[ 5 ], // bpp = header[ 6 ], // bitmaskRed = header[ 7 ], // bitmaskGreen = header[ 8 ], // bitmaskBlue = header[ 9 ], bitmaskAlpha = header[ 10 ], // pvrTag = header[ 11 ], numSurfs = header[ 12 ]; const TYPE_MASK = 0xff; const PVRTC_2 = 24, PVRTC_4 = 25; const formatFlags = flags & TYPE_MASK; let bpp, format; const _hasAlpha = bitmaskAlpha > 0; if ( formatFlags === PVRTC_4 ) { format = _hasAlpha ? RGBA_PVRTC_4BPPV1_Format : RGB_PVRTC_4BPPV1_Format; bpp = 4; } else if ( formatFlags === PVRTC_2 ) { format = _hasAlpha ? RGBA_PVRTC_2BPPV1_Format : RGB_PVRTC_2BPPV1_Format; bpp = 2; } else { console.error( 'THREE.PVRLoader: Unknown PVR format:', formatFlags ); } pvrDatas.dataPtr = headerLength; pvrDatas.bpp = bpp; pvrDatas.format = format; pvrDatas.width = width; pvrDatas.height = height; pvrDatas.numSurfaces = numSurfs; pvrDatas.numMipmaps = numMipmaps + 1; // guess cubemap type seems tricky in v2 // it juste a pvr containing 6 surface (no explicit cubemap type) pvrDatas.isCubemap = ( numSurfs === 6 ); return _extract( pvrDatas ); } function _extract( pvrDatas ) { const pvr = { mipmaps: [], width: pvrDatas.width, height: pvrDatas.height, format: pvrDatas.format, mipmapCount: pvrDatas.numMipmaps, isCubemap: pvrDatas.isCubemap }; const buffer = pvrDatas.buffer; let dataOffset = pvrDatas.dataPtr, dataSize = 0, blockSize = 0, blockWidth = 0, blockHeight = 0, widthBlocks = 0, heightBlocks = 0; const bpp = pvrDatas.bpp, numSurfs = pvrDatas.numSurfaces; if ( bpp === 2 ) { blockWidth = 8; blockHeight = 4; } else { blockWidth = 4; blockHeight = 4; } blockSize = ( blockWidth * blockHeight ) * bpp / 8; pvr.mipmaps.length = pvrDatas.numMipmaps * numSurfs; let mipLevel = 0; while ( mipLevel < pvrDatas.numMipmaps ) { const sWidth = pvrDatas.width >> mipLevel, sHeight = pvrDatas.height >> mipLevel; widthBlocks = sWidth / blockWidth; heightBlocks = sHeight / blockHeight; // Clamp to minimum number of blocks if ( widthBlocks < 2 ) widthBlocks = 2; if ( heightBlocks < 2 ) heightBlocks = 2; dataSize = widthBlocks * heightBlocks * blockSize; for ( let surfIndex = 0; surfIndex < numSurfs; surfIndex ++ ) { const byteArray = new Uint8Array( buffer, dataOffset, dataSize ); const mipmap = { data: byteArray, width: sWidth, height: sHeight }; pvr.mipmaps[ surfIndex * pvrDatas.numMipmaps + mipLevel ] = mipmap; dataOffset += dataSize; } mipLevel ++; } return pvr; } export { PVRLoader };"},{"title":"","date":"2023-10-12T14:08:40.723Z","updated":"2023-10-12T14:08:40.723Z","comments":true,"path":"js/three/jsm/loaders/PLYLoader.js","permalink":"http://19999997.xyz/js/three/jsm/loaders/PLYLoader.js","excerpt":"","text":"import { BufferGeometry, FileLoader, Float32BufferAttribute, Loader, Color } from 'three'; /** * Description: A THREE loader for PLY ASCII files (known as the Polygon * File Format or the Stanford Triangle Format). * * Limitations: ASCII decoding assumes file is UTF-8. * * Usage: * const loader = new PLYLoader(); * loader.load('./models/ply/ascii/dolphins.ply', function (geometry) { * * scene.add( new THREE.Mesh( geometry ) ); * * } ); * * If the PLY file uses non standard property names, they can be mapped while * loading. For example, the following maps the properties * “diffuse_(red|green|blue)” in the file to standard color names. * * loader.setPropertyNameMapping( { * diffuse_red: 'red', * diffuse_green: 'green', * diffuse_blue: 'blue' * } ); * * Custom properties outside of the defaults for position, uv, normal * and color attributes can be added using the setCustomPropertyNameMapping method. * For example, the following maps the element properties “custom_property_a” * and “custom_property_b” to an attribute “customAttribute” with an item size of 2. * Attribute item sizes are set from the number of element properties in the property array. * * loader.setCustomPropertyNameMapping( { * customAttribute: ['custom_property_a', 'custom_property_b'], * } ); * */ const _color = new Color(); class PLYLoader extends Loader { constructor( manager ) { super( manager ); this.propertyNameMapping = {}; this.customPropertyMapping = {}; } load( url, onLoad, onProgress, onError ) { const scope = this; const loader = new FileLoader( this.manager ); loader.setPath( this.path ); loader.setResponseType( 'arraybuffer' ); loader.setRequestHeader( this.requestHeader ); loader.setWithCredentials( this.withCredentials ); loader.load( url, function ( text ) { try { onLoad( scope.parse( text ) ); } catch ( e ) { if ( onError ) { onError( e ); } else { console.error( e ); } scope.manager.itemError( url ); } }, onProgress, onError ); } setPropertyNameMapping( mapping ) { this.propertyNameMapping = mapping; } setCustomPropertyNameMapping( mapping ) { this.customPropertyMapping = mapping; } parse( data ) { function parseHeader( data, headerLength = 0 ) { const patternHeader = /^ply([\\s\\S]*)end_header(\\r\\n|\\r|\\n)/; let headerText = ''; const result = patternHeader.exec( data ); if ( result !== null ) { headerText = result[ 1 ]; } const header = { comments: [], elements: [], headerLength: headerLength, objInfo: '' }; const lines = headerText.split( /\\r\\n|\\r|\\n/ ); let currentElement; function make_ply_element_property( propertValues, propertyNameMapping ) { const property = { type: propertValues[ 0 ] }; if ( property.type === 'list' ) { property.name = propertValues[ 3 ]; property.countType = propertValues[ 1 ]; property.itemType = propertValues[ 2 ]; } else { property.name = propertValues[ 1 ]; } if ( property.name in propertyNameMapping ) { property.name = propertyNameMapping[ property.name ]; } return property; } for ( let i = 0; i < lines.length; i ++ ) { let line = lines[ i ]; line = line.trim(); if ( line === '' ) continue; const lineValues = line.split( /\\s+/ ); const lineType = lineValues.shift(); line = lineValues.join( ' ' ); switch ( lineType ) { case 'format': header.format = lineValues[ 0 ]; header.version = lineValues[ 1 ]; break; case 'comment': header.comments.push( line ); break; case 'element': if ( currentElement !== undefined ) { header.elements.push( currentElement ); } currentElement = {}; currentElement.name = lineValues[ 0 ]; currentElement.count = parseInt( lineValues[ 1 ] ); currentElement.properties = []; break; case 'property': currentElement.properties.push( make_ply_element_property( lineValues, scope.propertyNameMapping ) ); break; case 'obj_info': header.objInfo = line; break; default: console.log( 'unhandled', lineType, lineValues ); } } if ( currentElement !== undefined ) { header.elements.push( currentElement ); } return header; } function parseASCIINumber( n, type ) { switch ( type ) { case 'char': case 'uchar': case 'short': case 'ushort': case 'int': case 'uint': case 'int8': case 'uint8': case 'int16': case 'uint16': case 'int32': case 'uint32': return parseInt( n ); case 'float': case 'double': case 'float32': case 'float64': return parseFloat( n ); } } function parseASCIIElement( properties, tokens ) { const element = {}; for ( let i = 0; i < properties.length; i ++ ) { if ( tokens.empty() ) return null; if ( properties[ i ].type === 'list' ) { const list = []; const n = parseASCIINumber( tokens.next(), properties[ i ].countType ); for ( let j = 0; j < n; j ++ ) { if ( tokens.empty() ) return null; list.push( parseASCIINumber( tokens.next(), properties[ i ].itemType ) ); } element[ properties[ i ].name ] = list; } else { element[ properties[ i ].name ] = parseASCIINumber( tokens.next(), properties[ i ].type ); } } return element; } function createBuffer() { const buffer = { indices: [], vertices: [], normals: [], uvs: [], faceVertexUvs: [], colors: [], faceVertexColors: [] }; for ( const customProperty of Object.keys( scope.customPropertyMapping ) ) { buffer[ customProperty ] = []; } return buffer; } function mapElementAttributes( properties ) { const elementNames = properties.map( property => { return property.name; } ); function findAttrName( names ) { for ( let i = 0, l = names.length; i < l; i ++ ) { const name = names[ i ]; if ( elementNames.includes( name ) ) return name; } return null; } return { attrX: findAttrName( [ 'x', 'px', 'posx' ] ) || 'x', attrY: findAttrName( [ 'y', 'py', 'posy' ] ) || 'y', attrZ: findAttrName( [ 'z', 'pz', 'posz' ] ) || 'z', attrNX: findAttrName( [ 'nx', 'normalx' ] ), attrNY: findAttrName( [ 'ny', 'normaly' ] ), attrNZ: findAttrName( [ 'nz', 'normalz' ] ), attrS: findAttrName( [ 's', 'u', 'texture_u', 'tx' ] ), attrT: findAttrName( [ 't', 'v', 'texture_v', 'ty' ] ), attrR: findAttrName( [ 'red', 'diffuse_red', 'r', 'diffuse_r' ] ), attrG: findAttrName( [ 'green', 'diffuse_green', 'g', 'diffuse_g' ] ), attrB: findAttrName( [ 'blue', 'diffuse_blue', 'b', 'diffuse_b' ] ), }; } function parseASCII( data, header ) { // PLY ascii format specification, as per http://en.wikipedia.org/wiki/PLY_(file_format) const buffer = createBuffer(); const patternBody = /end_header\\s+(\\S[\\s\\S]*\\S|\\S)\\s*$/; let body, matches; if ( ( matches = patternBody.exec( data ) ) !== null ) { body = matches[ 1 ].split( /\\s+/ ); } else { body = [ ]; } const tokens = new ArrayStream( body ); loop: for ( let i = 0; i < header.elements.length; i ++ ) { const elementDesc = header.elements[ i ]; const attributeMap = mapElementAttributes( elementDesc.properties ); for ( let j = 0; j < elementDesc.count; j ++ ) { const element = parseASCIIElement( elementDesc.properties, tokens ); if ( ! element ) break loop; handleElement( buffer, elementDesc.name, element, attributeMap ); } } return postProcess( buffer ); } function postProcess( buffer ) { let geometry = new BufferGeometry(); // mandatory buffer data if ( buffer.indices.length > 0 ) { geometry.setIndex( buffer.indices ); } geometry.setAttribute( 'position', new Float32BufferAttribute( buffer.vertices, 3 ) ); // optional buffer data if ( buffer.normals.length > 0 ) { geometry.setAttribute( 'normal', new Float32BufferAttribute( buffer.normals, 3 ) ); } if ( buffer.uvs.length > 0 ) { geometry.setAttribute( 'uv', new Float32BufferAttribute( buffer.uvs, 2 ) ); } if ( buffer.colors.length > 0 ) { geometry.setAttribute( 'color', new Float32BufferAttribute( buffer.colors, 3 ) ); } if ( buffer.faceVertexUvs.length > 0 || buffer.faceVertexColors.length > 0 ) { geometry = geometry.toNonIndexed(); if ( buffer.faceVertexUvs.length > 0 ) geometry.setAttribute( 'uv', new Float32BufferAttribute( buffer.faceVertexUvs, 2 ) ); if ( buffer.faceVertexColors.length > 0 ) geometry.setAttribute( 'color', new Float32BufferAttribute( buffer.faceVertexColors, 3 ) ); } // custom buffer data for ( const customProperty of Object.keys( scope.customPropertyMapping ) ) { if ( buffer[ customProperty ].length > 0 ) { geometry.setAttribute( customProperty, new Float32BufferAttribute( buffer[ customProperty ], scope.customPropertyMapping[ customProperty ].length ) ); } } geometry.computeBoundingSphere(); return geometry; } function handleElement( buffer, elementName, element, cacheEntry ) { if ( elementName === 'vertex' ) { buffer.vertices.push( element[ cacheEntry.attrX ], element[ cacheEntry.attrY ], element[ cacheEntry.attrZ ] ); if ( cacheEntry.attrNX !== null && cacheEntry.attrNY !== null && cacheEntry.attrNZ !== null ) { buffer.normals.push( element[ cacheEntry.attrNX ], element[ cacheEntry.attrNY ], element[ cacheEntry.attrNZ ] ); } if ( cacheEntry.attrS !== null && cacheEntry.attrT !== null ) { buffer.uvs.push( element[ cacheEntry.attrS ], element[ cacheEntry.attrT ] ); } if ( cacheEntry.attrR !== null && cacheEntry.attrG !== null && cacheEntry.attrB !== null ) { _color.setRGB( element[ cacheEntry.attrR ] / 255.0, element[ cacheEntry.attrG ] / 255.0, element[ cacheEntry.attrB ] / 255.0 ).convertSRGBToLinear(); buffer.colors.push( _color.r, _color.g, _color.b ); } for ( const customProperty of Object.keys( scope.customPropertyMapping ) ) { for ( const elementProperty of scope.customPropertyMapping[ customProperty ] ) { buffer[ customProperty ].push( element[ elementProperty ] ); } } } else if ( elementName === 'face' ) { const vertex_indices = element.vertex_indices || element.vertex_index; // issue #9338 const texcoord = element.texcoord; if ( vertex_indices.length === 3 ) { buffer.indices.push( vertex_indices[ 0 ], vertex_indices[ 1 ], vertex_indices[ 2 ] ); if ( texcoord && texcoord.length === 6 ) { buffer.faceVertexUvs.push( texcoord[ 0 ], texcoord[ 1 ] ); buffer.faceVertexUvs.push( texcoord[ 2 ], texcoord[ 3 ] ); buffer.faceVertexUvs.push( texcoord[ 4 ], texcoord[ 5 ] ); } } else if ( vertex_indices.length === 4 ) { buffer.indices.push( vertex_indices[ 0 ], vertex_indices[ 1 ], vertex_indices[ 3 ] ); buffer.indices.push( vertex_indices[ 1 ], vertex_indices[ 2 ], vertex_indices[ 3 ] ); } // face colors if ( cacheEntry.attrR !== null && cacheEntry.attrG !== null && cacheEntry.attrB !== null ) { _color.setRGB( element[ cacheEntry.attrR ] / 255.0, element[ cacheEntry.attrG ] / 255.0, element[ cacheEntry.attrB ] / 255.0 ).convertSRGBToLinear(); buffer.faceVertexColors.push( _color.r, _color.g, _color.b ); buffer.faceVertexColors.push( _color.r, _color.g, _color.b ); buffer.faceVertexColors.push( _color.r, _color.g, _color.b ); } } } function binaryReadElement( at, properties ) { const element = {}; let read = 0; for ( let i = 0; i < properties.length; i ++ ) { const property = properties[ i ]; const valueReader = property.valueReader; if ( property.type === 'list' ) { const list = []; const n = property.countReader.read( at + read ); read += property.countReader.size; for ( let j = 0; j < n; j ++ ) { list.push( valueReader.read( at + read ) ); read += valueReader.size; } element[ property.name ] = list; } else { element[ property.name ] = valueReader.read( at + read ); read += valueReader.size; } } return [ element, read ]; } function setPropertyBinaryReaders( properties, body, little_endian ) { function getBinaryReader( dataview, type, little_endian ) { switch ( type ) { // corespondences for non-specific length types here match rply: case 'int8': case 'char': return { read: ( at ) => { return dataview.getInt8( at ); }, size: 1 }; case 'uint8': case 'uchar': return { read: ( at ) => { return dataview.getUint8( at ); }, size: 1 }; case 'int16': case 'short': return { read: ( at ) => { return dataview.getInt16( at, little_endian ); }, size: 2 }; case 'uint16': case 'ushort': return { read: ( at ) => { return dataview.getUint16( at, little_endian ); }, size: 2 }; case 'int32': case 'int': return { read: ( at ) => { return dataview.getInt32( at, little_endian ); }, size: 4 }; case 'uint32': case 'uint': return { read: ( at ) => { return dataview.getUint32( at, little_endian ); }, size: 4 }; case 'float32': case 'float': return { read: ( at ) => { return dataview.getFloat32( at, little_endian ); }, size: 4 }; case 'float64': case 'double': return { read: ( at ) => { return dataview.getFloat64( at, little_endian ); }, size: 8 }; } } for ( let i = 0, l = properties.length; i < l; i ++ ) { const property = properties[ i ]; if ( property.type === 'list' ) { property.countReader = getBinaryReader( body, property.countType, little_endian ); property.valueReader = getBinaryReader( body, property.itemType, little_endian ); } else { property.valueReader = getBinaryReader( body, property.type, little_endian ); } } } function parseBinary( data, header ) { const buffer = createBuffer(); const little_endian = ( header.format === 'binary_little_endian' ); const body = new DataView( data, header.headerLength ); let result, loc = 0; for ( let currentElement = 0; currentElement < header.elements.length; currentElement ++ ) { const elementDesc = header.elements[ currentElement ]; const properties = elementDesc.properties; const attributeMap = mapElementAttributes( properties ); setPropertyBinaryReaders( properties, body, little_endian ); for ( let currentElementCount = 0; currentElementCount < elementDesc.count; currentElementCount ++ ) { result = binaryReadElement( loc, properties ); loc += result[ 1 ]; const element = result[ 0 ]; handleElement( buffer, elementDesc.name, element, attributeMap ); } } return postProcess( buffer ); } function extractHeaderText( bytes ) { let i = 0; let cont = true; let line = ''; const lines = []; const startLine = new TextDecoder().decode( bytes.subarray( 0, 5 ) ); const hasCRNL = /^ply\\r\\n/.test( startLine ); do { const c = String.fromCharCode( bytes[ i ++ ] ); if ( c !== '\\n' && c !== '\\r' ) { line += c; } else { if ( line === 'end_header' ) cont = false; if ( line !== '' ) { lines.push( line ); line = ''; } } } while ( cont && i < bytes.length ); // ascii section using \\r\\n as line endings if ( hasCRNL === true ) i ++; return { headerText: lines.join( '\\r' ) + '\\r', headerLength: i }; } // let geometry; const scope = this; if ( data instanceof ArrayBuffer ) { const bytes = new Uint8Array( data ); const { headerText, headerLength } = extractHeaderText( bytes ); const header = parseHeader( headerText, headerLength ); if ( header.format === 'ascii' ) { const text = new TextDecoder().decode( bytes ); geometry = parseASCII( text, header ); } else { geometry = parseBinary( data, header ); } } else { geometry = parseASCII( data, parseHeader( data ) ); } return geometry; } } class ArrayStream { constructor( arr ) { this.arr = arr; this.i = 0; } empty() { return this.i >= this.arr.length; } next() { return this.arr[ this.i ++ ]; } } export { PLYLoader };"},{"title":"","date":"2023-10-12T14:08:40.728Z","updated":"2023-10-12T14:08:40.728Z","comments":true,"path":"js/three/jsm/loaders/RGBELoader.js","permalink":"http://19999997.xyz/js/three/jsm/loaders/RGBELoader.js","excerpt":"","text":"import { DataTextureLoader, DataUtils, FloatType, HalfFloatType, LinearFilter, LinearSRGBColorSpace } from 'three'; // https://github.com/mrdoob/three.js/issues/5552 // http://en.wikipedia.org/wiki/RGBE_image_format class RGBELoader extends DataTextureLoader { constructor( manager ) { super( manager ); this.type = HalfFloatType; } // adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html parse( buffer ) { const /* default error routine. change this to change error handling */ rgbe_read_error = 1, rgbe_write_error = 2, rgbe_format_error = 3, rgbe_memory_error = 4, rgbe_error = function ( rgbe_error_code, msg ) { switch ( rgbe_error_code ) { case rgbe_read_error: throw new Error( 'THREE.RGBELoader: Read Error: ' + ( msg || '' ) ); case rgbe_write_error: throw new Error( 'THREE.RGBELoader: Write Error: ' + ( msg || '' ) ); case rgbe_format_error: throw new Error( 'THREE.RGBELoader: Bad File Format: ' + ( msg || '' ) ); default: case rgbe_memory_error: throw new Error( 'THREE.RGBELoader: Memory Error: ' + ( msg || '' ) ); } }, /* offsets to red, green, and blue components in a data (float) pixel */ //RGBE_DATA_RED = 0, //RGBE_DATA_GREEN = 1, //RGBE_DATA_BLUE = 2, /* number of floats per pixel, use 4 since stored in rgba image format */ //RGBE_DATA_SIZE = 4, /* flags indicating which fields in an rgbe_header_info are valid */ RGBE_VALID_PROGRAMTYPE = 1, RGBE_VALID_FORMAT = 2, RGBE_VALID_DIMENSIONS = 4, NEWLINE = '\\n', fgets = function ( buffer, lineLimit, consume ) { const chunkSize = 128; lineLimit = ! lineLimit ? 1024 : lineLimit; let p = buffer.pos, i = - 1, len = 0, s = '', chunk = String.fromCharCode.apply( null, new Uint16Array( buffer.subarray( p, p + chunkSize ) ) ); while ( ( 0 > ( i = chunk.indexOf( NEWLINE ) ) ) && ( len < lineLimit ) && ( p < buffer.byteLength ) ) { s += chunk; len += chunk.length; p += chunkSize; chunk += String.fromCharCode.apply( null, new Uint16Array( buffer.subarray( p, p + chunkSize ) ) ); } if ( - 1 < i ) { /*for (i=l-1; i>=0; i--) { byteCode = m.charCodeAt(i); if (byteCode > 0x7f && byteCode 0x7ff && byteCode = 0xDC00 && byteCode = buffer.byteLength || ! ( line = fgets( buffer ) ) ) { rgbe_error( rgbe_read_error, 'no header found' ); } /* if you want to require the magic token then uncomment the next line */ if ( ! ( match = line.match( magic_token_re ) ) ) { rgbe_error( rgbe_format_error, 'bad initial token' ); } header.valid |= RGBE_VALID_PROGRAMTYPE; header.programtype = match[ 1 ]; header.string += line + '\\n'; while ( true ) { line = fgets( buffer ); if ( false === line ) break; header.string += line + '\\n'; if ( '#' === line.charAt( 0 ) ) { header.comments += line + '\\n'; continue; // comment line } if ( match = line.match( gamma_re ) ) { header.gamma = parseFloat( match[ 1 ] ); } if ( match = line.match( exposure_re ) ) { header.exposure = parseFloat( match[ 1 ] ); } if ( match = line.match( format_re ) ) { header.valid |= RGBE_VALID_FORMAT; header.format = match[ 1 ];//'32-bit_rle_rgbe'; } if ( match = line.match( dimensions_re ) ) { header.valid |= RGBE_VALID_DIMENSIONS; header.height = parseInt( match[ 1 ], 10 ); header.width = parseInt( match[ 2 ], 10 ); } if ( ( header.valid & RGBE_VALID_FORMAT ) && ( header.valid & RGBE_VALID_DIMENSIONS ) ) break; } if ( ! ( header.valid & RGBE_VALID_FORMAT ) ) { rgbe_error( rgbe_format_error, 'missing format specifier' ); } if ( ! ( header.valid & RGBE_VALID_DIMENSIONS ) ) { rgbe_error( rgbe_format_error, 'missing image size specifier' ); } return header; }, RGBE_ReadPixels_RLE = function ( buffer, w, h ) { const scanline_width = w; if ( // run length encoding is not allowed so read flat ( ( scanline_width < 8 ) || ( scanline_width > 0x7fff ) ) || // this file is not run length encoded ( ( 2 !== buffer[ 0 ] ) || ( 2 !== buffer[ 1 ] ) || ( buffer[ 2 ] & 0x80 ) ) ) { // return the flat buffer return new Uint8Array( buffer ); } if ( scanline_width !== ( ( buffer[ 2 ] < 8 ) | buffer[ 3 ] ) ) { rgbe_error( rgbe_format_error, 'wrong scanline width' ); } const data_rgba = new Uint8Array( 4 * w * h ); if ( ! data_rgba.length ) { rgbe_error( rgbe_memory_error, 'unable to allocate buffer space' ); } let offset = 0, pos = 0; const ptr_end = 4 * scanline_width; const rgbeStart = new Uint8Array( 4 ); const scanline_buffer = new Uint8Array( ptr_end ); let num_scanlines = h; // read in each successive scanline while ( ( num_scanlines > 0 ) && ( pos < buffer.byteLength ) ) { if ( pos + 4 > buffer.byteLength ) { rgbe_error( rgbe_read_error ); } rgbeStart[ 0 ] = buffer[ pos ++ ]; rgbeStart[ 1 ] = buffer[ pos ++ ]; rgbeStart[ 2 ] = buffer[ pos ++ ]; rgbeStart[ 3 ] = buffer[ pos ++ ]; if ( ( 2 != rgbeStart[ 0 ] ) || ( 2 != rgbeStart[ 1 ] ) || ( ( ( rgbeStart[ 2 ] < 8 ) | rgbeStart[ 3 ] ) != scanline_width ) ) { rgbe_error( rgbe_format_error, 'bad rgbe scanline format' ); } // read each of the four channels for the scanline into the buffer // first red, then green, then blue, then exponent let ptr = 0, count; while ( ( ptr < ptr_end ) && ( pos < buffer.byteLength ) ) { count = buffer[ pos ++ ]; const isEncodedRun = count > 128; if ( isEncodedRun ) count -= 128; if ( ( 0 === count ) || ( ptr + count > ptr_end ) ) { rgbe_error( rgbe_format_error, 'bad scanline data' ); } if ( isEncodedRun ) { // a (encoded) run of the same value const byteValue = buffer[ pos ++ ]; for ( let i = 0; i < count; i ++ ) { scanline_buffer[ ptr ++ ] = byteValue; } //ptr += count; } else { // a literal-run scanline_buffer.set( buffer.subarray( pos, pos + count ), ptr ); ptr += count; pos += count; } } // now convert data from buffer into rgba // first red, then green, then blue, then exponent (alpha) const l = scanline_width; //scanline_buffer.byteLength; for ( let i = 0; i < l; i ++ ) { let off = 0; data_rgba[ offset ] = scanline_buffer[ i + off ]; off += scanline_width; //1; data_rgba[ offset + 1 ] = scanline_buffer[ i + off ]; off += scanline_width; //1; data_rgba[ offset + 2 ] = scanline_buffer[ i + off ]; off += scanline_width; //1; data_rgba[ offset + 3 ] = scanline_buffer[ i + off ]; offset += 4; } num_scanlines --; } return data_rgba; }; const RGBEByteToRGBFloat = function ( sourceArray, sourceOffset, destArray, destOffset ) { const e = sourceArray[ sourceOffset + 3 ]; const scale = Math.pow( 2.0, e - 128.0 ) / 255.0; destArray[ destOffset + 0 ] = sourceArray[ sourceOffset + 0 ] * scale; destArray[ destOffset + 1 ] = sourceArray[ sourceOffset + 1 ] * scale; destArray[ destOffset + 2 ] = sourceArray[ sourceOffset + 2 ] * scale; destArray[ destOffset + 3 ] = 1; }; const RGBEByteToRGBHalf = function ( sourceArray, sourceOffset, destArray, destOffset ) { const e = sourceArray[ sourceOffset + 3 ]; const scale = Math.pow( 2.0, e - 128.0 ) / 255.0; // clamping to 65504, the maximum representable value in float16 destArray[ destOffset + 0 ] = DataUtils.toHalfFloat( Math.min( sourceArray[ sourceOffset + 0 ] * scale, 65504 ) ); destArray[ destOffset + 1 ] = DataUtils.toHalfFloat( Math.min( sourceArray[ sourceOffset + 1 ] * scale, 65504 ) ); destArray[ destOffset + 2 ] = DataUtils.toHalfFloat( Math.min( sourceArray[ sourceOffset + 2 ] * scale, 65504 ) ); destArray[ destOffset + 3 ] = DataUtils.toHalfFloat( 1 ); }; const byteArray = new Uint8Array( buffer ); byteArray.pos = 0; const rgbe_header_info = RGBE_ReadHeader( byteArray ); const w = rgbe_header_info.width, h = rgbe_header_info.height, image_rgba_data = RGBE_ReadPixels_RLE( byteArray.subarray( byteArray.pos ), w, h ); let data, type; let numElements; switch ( this.type ) { case FloatType: numElements = image_rgba_data.length / 4; const floatArray = new Float32Array( numElements * 4 ); for ( let j = 0; j < numElements; j ++ ) { RGBEByteToRGBFloat( image_rgba_data, j * 4, floatArray, j * 4 ); } data = floatArray; type = FloatType; break; case HalfFloatType: numElements = image_rgba_data.length / 4; const halfArray = new Uint16Array( numElements * 4 ); for ( let j = 0; j < numElements; j ++ ) { RGBEByteToRGBHalf( image_rgba_data, j * 4, halfArray, j * 4 ); } data = halfArray; type = HalfFloatType; break; default: throw new Error( 'THREE.RGBELoader: Unsupported type: ' + this.type ); break; } return { width: w, height: h, data: data, header: rgbe_header_info.string, gamma: rgbe_header_info.gamma, exposure: rgbe_header_info.exposure, type: type }; } setDataType( value ) { this.type = value; return this; } load( url, onLoad, onProgress, onError ) { function onLoadCallback( texture, texData ) { switch ( texture.type ) { case FloatType: case HalfFloatType: texture.colorSpace = LinearSRGBColorSpace; texture.minFilter = LinearFilter; texture.magFilter = LinearFilter; texture.generateMipmaps = false; texture.flipY = true; break; } if ( onLoad ) onLoad( texture, texData ); } return super.load( url, onLoadCallback, onProgress, onError ); } } export { RGBELoader };"},{"title":"","date":"2023-10-12T14:08:40.734Z","updated":"2023-10-12T14:08:40.734Z","comments":true,"path":"js/three/jsm/loaders/STLLoader.js","permalink":"http://19999997.xyz/js/three/jsm/loaders/STLLoader.js","excerpt":"","text":"import { BufferAttribute, BufferGeometry, Color, FileLoader, Float32BufferAttribute, Loader, Vector3 } from 'three'; /** * Description: A THREE loader for STL ASCII files, as created by Solidworks and other CAD programs. * * Supports both binary and ASCII encoded files, with automatic detection of type. * * The loader returns a non-indexed buffer geometry. * * Limitations: * Binary decoding supports \"Magics\" color format (http://en.wikipedia.org/wiki/STL_(file_format)#Color_in_binary_STL). * There is perhaps some question as to how valid it is to always assume little-endian-ness. * ASCII decoding assumes file is UTF-8. * * Usage: * const loader = new STLLoader(); * loader.load( './models/stl/slotted_disk.stl', function ( geometry ) { * scene.add( new THREE.Mesh( geometry ) ); * }); * * For binary STLs geometry might contain colors for vertices. To use it: * // use the same code to load STL as above * if (geometry.hasColors) { * material = new THREE.MeshPhongMaterial({ opacity: geometry.alpha, vertexColors: true }); * } else { .... } * const mesh = new THREE.Mesh( geometry, material ); * * For ASCII STLs containing multiple solids, each solid is assigned to a different group. * Groups can be used to assign a different color by defining an array of materials with the same length of * geometry.groups and passing it to the Mesh constructor: * * const mesh = new THREE.Mesh( geometry, material ); * * For example: * * const materials = []; * const nGeometryGroups = geometry.groups.length; * * const colorMap = ...; // Some logic to index colors. * * for (let i = 0; i < nGeometryGroups; i++) { * * const material = new THREE.MeshPhongMaterial({ * color: colorMap[i], * wireframe: false * }); * * } * * materials.push(material); * const mesh = new THREE.Mesh(geometry, materials); */ class STLLoader extends Loader { constructor( manager ) { super( manager ); } load( url, onLoad, onProgress, onError ) { const scope = this; const loader = new FileLoader( this.manager ); loader.setPath( this.path ); loader.setResponseType( 'arraybuffer' ); loader.setRequestHeader( this.requestHeader ); loader.setWithCredentials( this.withCredentials ); loader.load( url, function ( text ) { try { onLoad( scope.parse( text ) ); } catch ( e ) { if ( onError ) { onError( e ); } else { console.error( e ); } scope.manager.itemError( url ); } }, onProgress, onError ); } parse( data ) { function isBinary( data ) { const reader = new DataView( data ); const face_size = ( 32 / 8 * 3 ) + ( ( 32 / 8 * 3 ) * 3 ) + ( 16 / 8 ); const n_faces = reader.getUint32( 80, true ); const expect = 80 + ( 32 / 8 ) + ( n_faces * face_size ); if ( expect === reader.byteLength ) { return true; } // An ASCII STL data must begin with 'solid ' as the first six bytes. // However, ASCII STLs lacking the SPACE after the 'd' are known to be // plentiful. So, check the first 5 bytes for 'solid'. // Several encodings, such as UTF-8, precede the text with up to 5 bytes: // https://en.wikipedia.org/wiki/Byte_order_mark#Byte_order_marks_by_encoding // Search for \"solid\" to start anywhere after those prefixes. // US-ASCII ordinal values for 's', 'o', 'l', 'i', 'd' const solid = [ 115, 111, 108, 105, 100 ]; for ( let off = 0; off < 5; off ++ ) { // If \"solid\" text is matched to the current offset, declare it to be an ASCII STL. if ( matchDataViewAt( solid, reader, off ) ) return false; } // Couldn't find \"solid\" text at the beginning; it is binary STL. return true; } function matchDataViewAt( query, reader, offset ) { // Check if each byte in query matches the corresponding byte from the current offset for ( let i = 0, il = query.length; i < il; i ++ ) { if ( query[ i ] !== reader.getUint8( offset + i ) ) return false; } return true; } function parseBinary( data ) { const reader = new DataView( data ); const faces = reader.getUint32( 80, true ); let r, g, b, hasColors = false, colors; let defaultR, defaultG, defaultB, alpha; // process STL header // check for default color in header (\"COLOR=rgba\" sequence). for ( let index = 0; index < 80 - 10; index ++ ) { if ( ( reader.getUint32( index, false ) == 0x434F4C4F /*COLO*/ ) && ( reader.getUint8( index + 4 ) == 0x52 /*'R'*/ ) && ( reader.getUint8( index + 5 ) == 0x3D /*'='*/ ) ) { hasColors = true; colors = new Float32Array( faces * 3 * 3 ); defaultR = reader.getUint8( index + 6 ) / 255; defaultG = reader.getUint8( index + 7 ) / 255; defaultB = reader.getUint8( index + 8 ) / 255; alpha = reader.getUint8( index + 9 ) / 255; } } const dataOffset = 84; const faceLength = 12 * 4 + 2; const geometry = new BufferGeometry(); const vertices = new Float32Array( faces * 3 * 3 ); const normals = new Float32Array( faces * 3 * 3 ); const color = new Color(); for ( let face = 0; face < faces; face ++ ) { const start = dataOffset + face * faceLength; const normalX = reader.getFloat32( start, true ); const normalY = reader.getFloat32( start + 4, true ); const normalZ = reader.getFloat32( start + 8, true ); if ( hasColors ) { const packedColor = reader.getUint16( start + 48, true ); if ( ( packedColor & 0x8000 ) === 0 ) { // facet has its own unique color r = ( packedColor & 0x1F ) / 31; g = ( ( packedColor >> 5 ) & 0x1F ) / 31; b = ( ( packedColor >> 10 ) & 0x1F ) / 31; } else { r = defaultR; g = defaultG; b = defaultB; } } for ( let i = 1; i"},{"title":"","date":"2023-10-12T14:08:40.732Z","updated":"2023-10-12T14:08:40.732Z","comments":true,"path":"js/three/jsm/loaders/RGBMLoader.js","permalink":"http://19999997.xyz/js/three/jsm/loaders/RGBMLoader.js","excerpt":"","text":"import { DataTextureLoader, RGBAFormat, LinearFilter, CubeTexture, HalfFloatType, DataUtils } from 'three'; class RGBMLoader extends DataTextureLoader { constructor( manager ) { super( manager ); this.type = HalfFloatType; this.maxRange = 7; // more information about this property at https://iwasbeingirony.blogspot.com/2010/06/difference-between-rgbm-and-rgbd.html } setDataType( value ) { this.type = value; return this; } setMaxRange( value ) { this.maxRange = value; return this; } loadCubemap( urls, onLoad, onProgress, onError ) { const texture = new CubeTexture(); let loaded = 0; const scope = this; function loadTexture( i ) { scope.load( urls[ i ], function ( image ) { texture.images[ i ] = image; loaded ++; if ( loaded === 6 ) { texture.needsUpdate = true; if ( onLoad ) onLoad( texture ); } }, undefined, onError ); } for ( let i = 0; i < urls.length; ++ i ) { loadTexture( i ); } texture.type = this.type; texture.format = RGBAFormat; texture.minFilter = LinearFilter; texture.generateMipmaps = false; return texture; } parse( buffer ) { const img = UPNG.decode( buffer ); const rgba = UPNG.toRGBA8( img )[ 0 ]; const data = new Uint8Array( rgba ); const size = img.width * img.height * 4; const output = ( this.type === HalfFloatType ) ? new Uint16Array( size ) : new Float32Array( size ); // decode RGBM for ( let i = 0; i < data.length; i += 4 ) { const r = data[ i + 0 ] / 255; const g = data[ i + 1 ] / 255; const b = data[ i + 2 ] / 255; const a = data[ i + 3 ] / 255; if ( this.type === HalfFloatType ) { output[ i + 0 ] = DataUtils.toHalfFloat( Math.min( r * a * this.maxRange, 65504 ) ); output[ i + 1 ] = DataUtils.toHalfFloat( Math.min( g * a * this.maxRange, 65504 ) ); output[ i + 2 ] = DataUtils.toHalfFloat( Math.min( b * a * this.maxRange, 65504 ) ); output[ i + 3 ] = DataUtils.toHalfFloat( 1 ); } else { output[ i + 0 ] = r * a * this.maxRange; output[ i + 1 ] = g * a * this.maxRange; output[ i + 2 ] = b * a * this.maxRange; output[ i + 3 ] = 1; } } return { width: img.width, height: img.height, data: output, format: RGBAFormat, type: this.type, flipY: true }; } } // from https://github.com/photopea/UPNG.js (MIT License) var UPNG = {}; UPNG.toRGBA8 = function ( out ) { var w = out.width, h = out.height; if ( out.tabs.acTL == null ) return [ UPNG.toRGBA8.decodeImage( out.data, w, h, out ).buffer ]; var frms = []; if ( out.frames[ 0 ].data == null ) out.frames[ 0 ].data = out.data; var len = w * h * 4, img = new Uint8Array( len ), empty = new Uint8Array( len ), prev = new Uint8Array( len ); for ( var i = 0; i < out.frames.length; i ++ ) { var frm = out.frames[ i ]; var fx = frm.rect.x, fy = frm.rect.y, fw = frm.rect.width, fh = frm.rect.height; var fdata = UPNG.toRGBA8.decodeImage( frm.data, fw, fh, out ); if ( i != 0 ) for ( var j = 0; j < len; j ++ ) prev[ j ] = img[ j ]; if ( frm.blend == 0 ) UPNG._copyTile( fdata, fw, fh, img, w, h, fx, fy, 0 ); else if ( frm.blend == 1 ) UPNG._copyTile( fdata, fw, fh, img, w, h, fx, fy, 1 ); frms.push( img.buffer.slice( 0 ) ); if ( frm.dispose == 1 ) UPNG._copyTile( empty, fw, fh, img, w, h, fx, fy, 0 ); else if ( frm.dispose == 2 ) for ( var j = 0; j < len; j ++ ) img[ j ] = prev[ j ]; } return frms; }; UPNG.toRGBA8.decodeImage = function ( data, w, h, out ) { var area = w * h, bpp = UPNG.decode._getBPP( out ); var bpl = Math.ceil( w * bpp / 8 ); // bytes per line var bf = new Uint8Array( area * 4 ), bf32 = new Uint32Array( bf.buffer ); var ctype = out.ctype, depth = out.depth; var rs = UPNG._bin.readUshort; if ( ctype == 6 ) { // RGB + alpha var qarea = area < 2; if ( depth == 8 ) for ( var i = 0; i < qarea; i += 4 ) { bf[ i ] = data[ i ]; bf[ i + 1 ] = data[ i + 1 ]; bf[ i + 2 ] = data[ i + 2 ]; bf[ i + 3 ] = data[ i + 3 ]; } if ( depth == 16 ) for ( var i = 0; i < qarea; i ++ ) { bf[ i ] = data[ i < 1 ]; } } else if ( ctype == 2 ) { // RGB var ts = out.tabs[ 'tRNS' ]; if ( ts == null ) { if ( depth == 8 ) for ( var i = 0; i < area; i ++ ) { var ti = i * 3; bf32[ i ] = ( 255 < 24 ) | ( data[ ti + 2 ] < 16 ) | ( data[ ti + 1 ] < 8 ) | data[ ti ]; } if ( depth == 16 ) for ( var i = 0; i < area; i ++ ) { var ti = i * 6; bf32[ i ] = ( 255 < 24 ) | ( data[ ti + 4 ] < 16 ) | ( data[ ti + 2 ] < 8 ) | data[ ti ]; } } else { var tr = ts[ 0 ], tg = ts[ 1 ], tb = ts[ 2 ]; if ( depth == 8 ) for ( var i = 0; i < area; i ++ ) { var qi = i < 2, ti = i * 3; bf32[ i ] = ( 255 < 24 ) | ( data[ ti + 2 ] < 16 ) | ( data[ ti + 1 ] < 8 ) | data[ ti ]; if ( data[ ti ] == tr && data[ ti + 1 ] == tg && data[ ti + 2 ] == tb ) bf[ qi + 3 ] = 0; } if ( depth == 16 ) for ( var i = 0; i < area; i ++ ) { var qi = i < 2, ti = i * 6; bf32[ i ] = ( 255 < 24 ) | ( data[ ti + 4 ] < 16 ) | ( data[ ti + 2 ] < 8 ) | data[ ti ]; if ( rs( data, ti ) == tr && rs( data, ti + 2 ) == tg && rs( data, ti + 4 ) == tb ) bf[ qi + 3 ] = 0; } } } else if ( ctype == 3 ) { // palette var p = out.tabs[ 'PLTE' ], ap = out.tabs[ 'tRNS' ], tl = ap ? ap.length : 0; //console.log(p, ap); if ( depth == 1 ) for ( var y = 0; y < h; y ++ ) { var s0 = y * bpl, t0 = y * w; for ( var i = 0; i < w; i ++ ) { var qi = ( t0 + i ) < 2, j = ( ( data[ s0 + ( i >> 3 ) ] >> ( 7 - ( ( i & 7 ) < 0 ) ) ) & 1 ), cj = 3 * j; bf[ qi ] = p[ cj ]; bf[ qi + 1 ] = p[ cj + 1 ]; bf[ qi + 2 ] = p[ cj + 2 ]; bf[ qi + 3 ] = ( j < tl ) ? ap[ j ] : 255; } } if ( depth == 2 ) for ( var y = 0; y < h; y ++ ) { var s0 = y * bpl, t0 = y * w; for ( var i = 0; i < w; i ++ ) { var qi = ( t0 + i ) < 2, j = ( ( data[ s0 + ( i >> 2 ) ] >> ( 6 - ( ( i & 3 ) < 1 ) ) ) & 3 ), cj = 3 * j; bf[ qi ] = p[ cj ]; bf[ qi + 1 ] = p[ cj + 1 ]; bf[ qi + 2 ] = p[ cj + 2 ]; bf[ qi + 3 ] = ( j < tl ) ? ap[ j ] : 255; } } if ( depth == 4 ) for ( var y = 0; y < h; y ++ ) { var s0 = y * bpl, t0 = y * w; for ( var i = 0; i < w; i ++ ) { var qi = ( t0 + i ) < 2, j = ( ( data[ s0 + ( i >> 1 ) ] >> ( 4 - ( ( i & 1 ) < 2 ) ) ) & 15 ), cj = 3 * j; bf[ qi ] = p[ cj ]; bf[ qi + 1 ] = p[ cj + 1 ]; bf[ qi + 2 ] = p[ cj + 2 ]; bf[ qi + 3 ] = ( j < tl ) ? ap[ j ] : 255; } } if ( depth == 8 ) for ( var i = 0; i < area; i ++ ) { var qi = i < 2, j = data[ i ], cj = 3 * j; bf[ qi ] = p[ cj ]; bf[ qi + 1 ] = p[ cj + 1 ]; bf[ qi + 2 ] = p[ cj + 2 ]; bf[ qi + 3 ] = ( j < tl ) ? ap[ j ] : 255; } } else if ( ctype == 4 ) { // gray + alpha if ( depth == 8 ) for ( var i = 0; i < area; i ++ ) { var qi = i < 2, di = i < 1, gr = data[ di ]; bf[ qi ] = gr; bf[ qi + 1 ] = gr; bf[ qi + 2 ] = gr; bf[ qi + 3 ] = data[ di + 1 ]; } if ( depth == 16 ) for ( var i = 0; i < area; i ++ ) { var qi = i < 2, di = i < 2, gr = data[ di ]; bf[ qi ] = gr; bf[ qi + 1 ] = gr; bf[ qi + 2 ] = gr; bf[ qi + 3 ] = data[ di + 2 ]; } } else if ( ctype == 0 ) { // gray var tr = out.tabs[ 'tRNS' ] ? out.tabs[ 'tRNS' ] : - 1; for ( var y = 0; y < h; y ++ ) { var off = y * bpl, to = y * w; if ( depth == 1 ) for ( var x = 0; x < w; x ++ ) { var gr = 255 * ( ( data[ off + ( x >>> 3 ) ] >>> ( 7 - ( x & 7 ) ) ) & 1 ), al = ( gr == tr * 255 ) ? 0 : 255; bf32[ to + x ] = ( al < 24 ) | ( gr < 16 ) | ( gr < 8 ) | gr; } else if ( depth == 2 ) for ( var x = 0; x < w; x ++ ) { var gr = 85 * ( ( data[ off + ( x >>> 2 ) ] >>> ( 6 - ( ( x & 3 ) < 1 ) ) ) & 3 ), al = ( gr == tr * 85 ) ? 0 : 255; bf32[ to + x ] = ( al < 24 ) | ( gr < 16 ) | ( gr < 8 ) | gr; } else if ( depth == 4 ) for ( var x = 0; x < w; x ++ ) { var gr = 17 * ( ( data[ off + ( x >>> 1 ) ] >>> ( 4 - ( ( x & 1 ) < 2 ) ) ) & 15 ), al = ( gr == tr * 17 ) ? 0 : 255; bf32[ to + x ] = ( al < 24 ) | ( gr < 16 ) | ( gr < 8 ) | gr; } else if ( depth == 8 ) for ( var x = 0; x < w; x ++ ) { var gr = data[ off + x ], al = ( gr == tr ) ? 0 : 255; bf32[ to + x ] = ( al < 24 ) | ( gr < 16 ) | ( gr < 8 ) | gr; } else if ( depth == 16 ) for ( var x = 0; x < w; x ++ ) { var gr = data[ off + ( x < 1 ) ], al = ( rs( data, off + ( x < 1 ) ) == tr ) ? 0 : 255; bf32[ to + x ] = ( al < 24 ) | ( gr < 16 ) | ( gr < 8 ) | gr; } } } //console.log(Date.now()-time); return bf; }; UPNG.decode = function ( buff ) { var data = new Uint8Array( buff ), offset = 8, bin = UPNG._bin, rUs = bin.readUshort, rUi = bin.readUint; var out = { tabs: {}, frames: [] }; var dd = new Uint8Array( data.length ), doff = 0; // put all IDAT data into it var fd, foff = 0; // frames var text, keyw, bfr; var mgck = [ 0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a ]; for ( var i = 0; i < 8; i ++ ) if ( data[ i ] != mgck[ i ] ) throw new Error( 'The input is not a PNG file!' ); while ( offset < data.length ) { var len = bin.readUint( data, offset ); offset += 4; var type = bin.readASCII( data, offset, 4 ); offset += 4; //console.log(type,len); if ( type == 'IHDR' ) { UPNG.decode._IHDR( data, offset, out ); } else if ( type == 'CgBI' ) { out.tabs[ type ] = data.slice( offset, offset + 4 ); } else if ( type == 'IDAT' ) { for ( var i = 0; i < len; i ++ ) dd[ doff + i ] = data[ offset + i ]; doff += len; } else if ( type == 'acTL' ) { out.tabs[ type ] = { num_frames: rUi( data, offset ), num_plays: rUi( data, offset + 4 ) }; fd = new Uint8Array( data.length ); } else if ( type == 'fcTL' ) { if ( foff != 0 ) { var fr = out.frames[ out.frames.length - 1 ]; fr.data = UPNG.decode._decompress( out, fd.slice( 0, foff ), fr.rect.width, fr.rect.height ); foff = 0; } var rct = { x: rUi( data, offset + 12 ), y: rUi( data, offset + 16 ), width: rUi( data, offset + 4 ), height: rUi( data, offset + 8 ) }; var del = rUs( data, offset + 22 ); del = rUs( data, offset + 20 ) / ( del == 0 ? 100 : del ); var frm = { rect: rct, delay: Math.round( del * 1000 ), dispose: data[ offset + 24 ], blend: data[ offset + 25 ] }; //console.log(frm); out.frames.push( frm ); } else if ( type == 'fdAT' ) { for ( var i = 0; i < len - 4; i ++ ) fd[ foff + i ] = data[ offset + i + 4 ]; foff += len - 4; } else if ( type == 'pHYs' ) { out.tabs[ type ] = [ bin.readUint( data, offset ), bin.readUint( data, offset + 4 ), data[ offset + 8 ] ]; } else if ( type == 'cHRM' ) { out.tabs[ type ] = []; for ( var i = 0; i < 8; i ++ ) out.tabs[ type ].push( bin.readUint( data, offset + i * 4 ) ); } else if ( type == 'tEXt' || type == 'zTXt' ) { if ( out.tabs[ type ] == null ) out.tabs[ type ] = {}; var nz = bin.nextZero( data, offset ); keyw = bin.readASCII( data, offset, nz - offset ); var tl = offset + len - nz - 1; if ( type == 'tEXt' ) text = bin.readASCII( data, nz + 1, tl ); else { bfr = UPNG.decode._inflate( data.slice( nz + 2, nz + 2 + tl ) ); text = bin.readUTF8( bfr, 0, bfr.length ); } out.tabs[ type ][ keyw ] = text; } else if ( type == 'iTXt' ) { if ( out.tabs[ type ] == null ) out.tabs[ type ] = {}; var nz = 0, off = offset; nz = bin.nextZero( data, off ); keyw = bin.readASCII( data, off, nz - off ); off = nz + 1; var cflag = data[ off ]; off += 2; nz = bin.nextZero( data, off ); bin.readASCII( data, off, nz - off ); off = nz + 1; nz = bin.nextZero( data, off ); bin.readUTF8( data, off, nz - off ); off = nz + 1; var tl = len - ( off - offset ); if ( cflag == 0 ) text = bin.readUTF8( data, off, tl ); else { bfr = UPNG.decode._inflate( data.slice( off, off + tl ) ); text = bin.readUTF8( bfr, 0, bfr.length ); } out.tabs[ type ][ keyw ] = text; } else if ( type == 'PLTE' ) { out.tabs[ type ] = bin.readBytes( data, offset, len ); } else if ( type == 'hIST' ) { var pl = out.tabs[ 'PLTE' ].length / 3; out.tabs[ type ] = []; for ( var i = 0; i < pl; i ++ ) out.tabs[ type ].push( rUs( data, offset + i * 2 ) ); } else if ( type == 'tRNS' ) { if ( out.ctype == 3 ) out.tabs[ type ] = bin.readBytes( data, offset, len ); else if ( out.ctype == 0 ) out.tabs[ type ] = rUs( data, offset ); else if ( out.ctype == 2 ) out.tabs[ type ] = [ rUs( data, offset ), rUs( data, offset + 2 ), rUs( data, offset + 4 ) ]; //else console.log(\"tRNS for unsupported color type\",out.ctype, len); } else if ( type == 'gAMA' ) out.tabs[ type ] = bin.readUint( data, offset ) / 100000; else if ( type == 'sRGB' ) out.tabs[ type ] = data[ offset ]; else if ( type == 'bKGD' ) { if ( out.ctype == 0 || out.ctype == 4 ) out.tabs[ type ] = [ rUs( data, offset ) ]; else if ( out.ctype == 2 || out.ctype == 6 ) out.tabs[ type ] = [ rUs( data, offset ), rUs( data, offset + 2 ), rUs( data, offset + 4 ) ]; else if ( out.ctype == 3 ) out.tabs[ type ] = data[ offset ]; } else if ( type == 'IEND' ) { break; } //else { console.log(\"unknown chunk type\", type, len); out.tabs[type]=data.slice(offset,offset+len); } offset += len; bin.readUint( data, offset ); offset += 4; } if ( foff != 0 ) { var fr = out.frames[ out.frames.length - 1 ]; fr.data = UPNG.decode._decompress( out, fd.slice( 0, foff ), fr.rect.width, fr.rect.height ); } out.data = UPNG.decode._decompress( out, dd, out.width, out.height ); delete out.compress; delete out.interlace; delete out.filter; return out; }; UPNG.decode._decompress = function ( out, dd, w, h ) { var bpp = UPNG.decode._getBPP( out ), bpl = Math.ceil( w * bpp / 8 ), buff = new Uint8Array( ( bpl + 1 + out.interlace ) * h ); if ( out.tabs[ 'CgBI' ] ) dd = UPNG.inflateRaw( dd, buff ); else dd = UPNG.decode._inflate( dd, buff ); if ( out.interlace == 0 ) dd = UPNG.decode._filterZero( dd, out, 0, w, h ); else if ( out.interlace == 1 ) dd = UPNG.decode._readInterlace( dd, out ); return dd; }; UPNG.decode._inflate = function ( data, buff ) { var out = UPNG[ 'inflateRaw' ]( new Uint8Array( data.buffer, 2, data.length - 6 ), buff ); return out; }; UPNG.inflateRaw = function () { var H = {}; H.H = {}; H.H.N = function ( N, W ) { var R = Uint8Array, i = 0, m = 0, J = 0, h = 0, Q = 0, X = 0, u = 0, w = 0, d = 0, v, C; if ( N[ 0 ] == 3 && N[ 1 ] == 0 ) return W ? W : new R( 0 ); var V = H.H, n = V.b, A = V.e, l = V.R, M = V.n, I = V.A, e = V.Z, b = V.m, Z = W == null; if ( Z )W = new R( N.length >>> 2 < 5 ); while ( i == 0 ) { i = n( N, d, 1 ); m = n( N, d + 1, 2 ); d += 3; if ( m == 0 ) { if ( ( d & 7 ) != 0 )d += 8 - ( d & 7 ); var D = ( d >>> 3 ) + 4, q = N[ D - 4 ] | N[ D - 3 ] < 8; if ( Z )W = H.H.W( W, w + q ); W.set( new R( N.buffer, N.byteOffset + D, q ), w ); d = D + q < 3; w += q; continue ; } if ( Z )W = H.H.W( W, w + ( 1 < 17 ) ); if ( m == 1 ) { v = b.J; C = b.h; X = ( 1 < 9 ) - 1; u = ( 1 < 5 ) - 1; } if ( m == 2 ) { J = A( N, d, 5 ) + 257; h = A( N, d + 5, 5 ) + 1; Q = A( N, d + 10, 4 ) + 4; d += 14; var j = 1; for ( var c = 0; c < 38; c += 2 ) { b.Q[ c ] = 0; b.Q[ c + 1 ] = 0; } for ( var c = 0; c < Q; c ++ ) { var K = A( N, d + c * 3, 3 ); b.Q[ ( b.X[ c ] < 1 ) + 1 ] = K; if ( K > j )j = K ; } d += 3 * Q; M( b.Q, j ); I( b.Q, j, b.u ); v = b.w; C = b.d; d = l( b.u, ( 1 < j ) - 1, J + h, N, d, b.v ); var r = V.V( b.v, 0, J, b.C ); X = ( 1 < r ) - 1; var S = V.V( b.v, J, h, b.D ); u = ( 1 < S ) - 1; M( b.C, r ); I( b.C, r, v ); M( b.D, S ); I( b.D, S, C ) ; } while ( ! 0 ) { var T = v[ e( N, d ) & X ]; d += T & 15; var p = T >>> 4; if ( p >>> 8 == 0 ) { W[ w ++ ] = p; } else if ( p == 256 ) { break; } else { var z = w + p - 254; if ( p > 264 ) { var _ = b.q[ p - 257 ]; z = w + ( _ >>> 3 ) + A( N, d, _ & 7 ); d += _ & 7; } var $ = C[ e( N, d ) & u ]; d += $ & 15; var s = $ >>> 4, Y = b.c[ s ], a = ( Y >>> 4 ) + n( N, d, Y & 15 ); d += Y & 15; while ( w < z ) { W[ w ] = W[ w ++ - a ]; W[ w ] = W[ w ++ - a ]; W[ w ] = W[ w ++ - a ]; W[ w ] = W[ w ++ - a ]; } w = z ; } } } return W.length == w ? W : W.slice( 0, w ) ; }; H.H.W = function ( N, W ) { var R = N.length; if ( W"},{"title":"","date":"2023-10-12T14:08:40.747Z","updated":"2023-10-12T14:08:40.747Z","comments":true,"path":"js/three/jsm/loaders/TIFFLoader.js","permalink":"http://19999997.xyz/js/three/jsm/loaders/TIFFLoader.js","excerpt":"","text":"import { DataTextureLoader, LinearFilter, LinearMipmapLinearFilter } from 'three'; import UTIF from '../libs/utif.module.js'; class TIFFLoader extends DataTextureLoader { constructor( manager ) { super( manager ); } parse( buffer ) { const ifds = UTIF.decode( buffer ); UTIF.decodeImage( buffer, ifds[ 0 ] ); const rgba = UTIF.toRGBA8( ifds[ 0 ] ); return { width: ifds[ 0 ].width, height: ifds[ 0 ].height, data: rgba, flipY: true, magFilter: LinearFilter, minFilter: LinearMipmapLinearFilter }; } } export { TIFFLoader };"},{"title":"","date":"2023-10-12T14:08:40.739Z","updated":"2023-10-12T14:08:40.739Z","comments":true,"path":"js/three/jsm/loaders/SVGLoader.js","permalink":"http://19999997.xyz/js/three/jsm/loaders/SVGLoader.js","excerpt":"","text":"import { Box2, BufferGeometry, FileLoader, Float32BufferAttribute, Loader, Matrix3, Path, Shape, ShapePath, ShapeUtils, SRGBColorSpace, Vector2, Vector3 } from 'three'; const COLOR_SPACE_SVG = SRGBColorSpace; class SVGLoader extends Loader { constructor( manager ) { super( manager ); // Default dots per inch this.defaultDPI = 90; // Accepted units: 'mm', 'cm', 'in', 'pt', 'pc', 'px' this.defaultUnit = 'px'; } load( url, onLoad, onProgress, onError ) { const scope = this; const loader = new FileLoader( scope.manager ); loader.setPath( scope.path ); loader.setRequestHeader( scope.requestHeader ); loader.setWithCredentials( scope.withCredentials ); loader.load( url, function ( text ) { try { onLoad( scope.parse( text ) ); } catch ( e ) { if ( onError ) { onError( e ); } else { console.error( e ); } scope.manager.itemError( url ); } }, onProgress, onError ); } parse( text ) { const scope = this; function parseNode( node, style ) { if ( node.nodeType !== 1 ) return; const transform = getNodeTransform( node ); let isDefsNode = false; let path = null; switch ( node.nodeName ) { case 'svg': style = parseStyle( node, style ); break; case 'style': parseCSSStylesheet( node ); break; case 'g': style = parseStyle( node, style ); break; case 'path': style = parseStyle( node, style ); if ( node.hasAttribute( 'd' ) ) path = parsePathNode( node ); break; case 'rect': style = parseStyle( node, style ); path = parseRectNode( node ); break; case 'polygon': style = parseStyle( node, style ); path = parsePolygonNode( node ); break; case 'polyline': style = parseStyle( node, style ); path = parsePolylineNode( node ); break; case 'circle': style = parseStyle( node, style ); path = parseCircleNode( node ); break; case 'ellipse': style = parseStyle( node, style ); path = parseEllipseNode( node ); break; case 'line': style = parseStyle( node, style ); path = parseLineNode( node ); break; case 'defs': isDefsNode = true; break; case 'use': style = parseStyle( node, style ); const href = node.getAttributeNS( 'http://www.w3.org/1999/xlink', 'href' ) || ''; const usedNodeId = href.substring( 1 ); const usedNode = node.viewportElement.getElementById( usedNodeId ); if ( usedNode ) { parseNode( usedNode, style ); } else { console.warn( 'SVGLoader: \\'use node\\' references non-existent node id: ' + usedNodeId ); } break; default: // console.log( node ); } if ( path ) { if ( style.fill !== undefined && style.fill !== 'none' ) { path.color.setStyle( style.fill, COLOR_SPACE_SVG ); } transformPath( path, currentTransform ); paths.push( path ); path.userData = { node: node, style: style }; } const childNodes = node.childNodes; for ( let i = 0; i < childNodes.length; i ++ ) { const node = childNodes[ i ]; if ( isDefsNode && node.nodeName !== 'style' && node.nodeName !== 'defs' ) { // Ignore everything in defs except CSS style definitions // and nested defs, because it is OK by the standard to have // there. continue; } parseNode( node, style ); } if ( transform ) { transformStack.pop(); if ( transformStack.length > 0 ) { currentTransform.copy( transformStack[ transformStack.length - 1 ] ); } else { currentTransform.identity(); } } } function parsePathNode( node ) { const path = new ShapePath(); const point = new Vector2(); const control = new Vector2(); const firstPoint = new Vector2(); let isFirstPoint = true; let doSetFirstPoint = false; const d = node.getAttribute( 'd' ); if ( d === '' || d === 'none' ) return null; // console.log( d ); const commands = d.match( /[a-df-z][^a-df-z]*/ig ); for ( let i = 0, l = commands.length; i < l; i ++ ) { const command = commands[ i ]; const type = command.charAt( 0 ); const data = command.slice( 1 ).trim(); if ( isFirstPoint === true ) { doSetFirstPoint = true; isFirstPoint = false; } let numbers; switch ( type ) { case 'M': numbers = parseFloats( data ); for ( let j = 0, jl = numbers.length; j < jl; j += 2 ) { point.x = numbers[ j + 0 ]; point.y = numbers[ j + 1 ]; control.x = point.x; control.y = point.y; if ( j === 0 ) { path.moveTo( point.x, point.y ); } else { path.lineTo( point.x, point.y ); } if ( j === 0 ) firstPoint.copy( point ); } break; case 'H': numbers = parseFloats( data ); for ( let j = 0, jl = numbers.length; j < jl; j ++ ) { point.x = numbers[ j ]; control.x = point.x; control.y = point.y; path.lineTo( point.x, point.y ); if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point ); } break; case 'V': numbers = parseFloats( data ); for ( let j = 0, jl = numbers.length; j < jl; j ++ ) { point.y = numbers[ j ]; control.x = point.x; control.y = point.y; path.lineTo( point.x, point.y ); if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point ); } break; case 'L': numbers = parseFloats( data ); for ( let j = 0, jl = numbers.length; j < jl; j += 2 ) { point.x = numbers[ j + 0 ]; point.y = numbers[ j + 1 ]; control.x = point.x; control.y = point.y; path.lineTo( point.x, point.y ); if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point ); } break; case 'C': numbers = parseFloats( data ); for ( let j = 0, jl = numbers.length; j < jl; j += 6 ) { path.bezierCurveTo( numbers[ j + 0 ], numbers[ j + 1 ], numbers[ j + 2 ], numbers[ j + 3 ], numbers[ j + 4 ], numbers[ j + 5 ] ); control.x = numbers[ j + 2 ]; control.y = numbers[ j + 3 ]; point.x = numbers[ j + 4 ]; point.y = numbers[ j + 5 ]; if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point ); } break; case 'S': numbers = parseFloats( data ); for ( let j = 0, jl = numbers.length; j < jl; j += 4 ) { path.bezierCurveTo( getReflection( point.x, control.x ), getReflection( point.y, control.y ), numbers[ j + 0 ], numbers[ j + 1 ], numbers[ j + 2 ], numbers[ j + 3 ] ); control.x = numbers[ j + 0 ]; control.y = numbers[ j + 1 ]; point.x = numbers[ j + 2 ]; point.y = numbers[ j + 3 ]; if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point ); } break; case 'Q': numbers = parseFloats( data ); for ( let j = 0, jl = numbers.length; j < jl; j += 4 ) { path.quadraticCurveTo( numbers[ j + 0 ], numbers[ j + 1 ], numbers[ j + 2 ], numbers[ j + 3 ] ); control.x = numbers[ j + 0 ]; control.y = numbers[ j + 1 ]; point.x = numbers[ j + 2 ]; point.y = numbers[ j + 3 ]; if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point ); } break; case 'T': numbers = parseFloats( data ); for ( let j = 0, jl = numbers.length; j < jl; j += 2 ) { const rx = getReflection( point.x, control.x ); const ry = getReflection( point.y, control.y ); path.quadraticCurveTo( rx, ry, numbers[ j + 0 ], numbers[ j + 1 ] ); control.x = rx; control.y = ry; point.x = numbers[ j + 0 ]; point.y = numbers[ j + 1 ]; if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point ); } break; case 'A': numbers = parseFloats( data, [ 3, 4 ], 7 ); for ( let j = 0, jl = numbers.length; j < jl; j += 7 ) { // skip command if start point == end point if ( numbers[ j + 5 ] == point.x && numbers[ j + 6 ] == point.y ) continue; const start = point.clone(); point.x = numbers[ j + 5 ]; point.y = numbers[ j + 6 ]; control.x = point.x; control.y = point.y; parseArcCommand( path, numbers[ j ], numbers[ j + 1 ], numbers[ j + 2 ], numbers[ j + 3 ], numbers[ j + 4 ], start, point ); if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point ); } break; case 'm': numbers = parseFloats( data ); for ( let j = 0, jl = numbers.length; j < jl; j += 2 ) { point.x += numbers[ j + 0 ]; point.y += numbers[ j + 1 ]; control.x = point.x; control.y = point.y; if ( j === 0 ) { path.moveTo( point.x, point.y ); } else { path.lineTo( point.x, point.y ); } if ( j === 0 ) firstPoint.copy( point ); } break; case 'h': numbers = parseFloats( data ); for ( let j = 0, jl = numbers.length; j < jl; j ++ ) { point.x += numbers[ j ]; control.x = point.x; control.y = point.y; path.lineTo( point.x, point.y ); if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point ); } break; case 'v': numbers = parseFloats( data ); for ( let j = 0, jl = numbers.length; j < jl; j ++ ) { point.y += numbers[ j ]; control.x = point.x; control.y = point.y; path.lineTo( point.x, point.y ); if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point ); } break; case 'l': numbers = parseFloats( data ); for ( let j = 0, jl = numbers.length; j < jl; j += 2 ) { point.x += numbers[ j + 0 ]; point.y += numbers[ j + 1 ]; control.x = point.x; control.y = point.y; path.lineTo( point.x, point.y ); if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point ); } break; case 'c': numbers = parseFloats( data ); for ( let j = 0, jl = numbers.length; j < jl; j += 6 ) { path.bezierCurveTo( point.x + numbers[ j + 0 ], point.y + numbers[ j + 1 ], point.x + numbers[ j + 2 ], point.y + numbers[ j + 3 ], point.x + numbers[ j + 4 ], point.y + numbers[ j + 5 ] ); control.x = point.x + numbers[ j + 2 ]; control.y = point.y + numbers[ j + 3 ]; point.x += numbers[ j + 4 ]; point.y += numbers[ j + 5 ]; if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point ); } break; case 's': numbers = parseFloats( data ); for ( let j = 0, jl = numbers.length; j < jl; j += 4 ) { path.bezierCurveTo( getReflection( point.x, control.x ), getReflection( point.y, control.y ), point.x + numbers[ j + 0 ], point.y + numbers[ j + 1 ], point.x + numbers[ j + 2 ], point.y + numbers[ j + 3 ] ); control.x = point.x + numbers[ j + 0 ]; control.y = point.y + numbers[ j + 1 ]; point.x += numbers[ j + 2 ]; point.y += numbers[ j + 3 ]; if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point ); } break; case 'q': numbers = parseFloats( data ); for ( let j = 0, jl = numbers.length; j < jl; j += 4 ) { path.quadraticCurveTo( point.x + numbers[ j + 0 ], point.y + numbers[ j + 1 ], point.x + numbers[ j + 2 ], point.y + numbers[ j + 3 ] ); control.x = point.x + numbers[ j + 0 ]; control.y = point.y + numbers[ j + 1 ]; point.x += numbers[ j + 2 ]; point.y += numbers[ j + 3 ]; if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point ); } break; case 't': numbers = parseFloats( data ); for ( let j = 0, jl = numbers.length; j < jl; j += 2 ) { const rx = getReflection( point.x, control.x ); const ry = getReflection( point.y, control.y ); path.quadraticCurveTo( rx, ry, point.x + numbers[ j + 0 ], point.y + numbers[ j + 1 ] ); control.x = rx; control.y = ry; point.x = point.x + numbers[ j + 0 ]; point.y = point.y + numbers[ j + 1 ]; if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point ); } break; case 'a': numbers = parseFloats( data, [ 3, 4 ], 7 ); for ( let j = 0, jl = numbers.length; j < jl; j += 7 ) { // skip command if no displacement if ( numbers[ j + 5 ] == 0 && numbers[ j + 6 ] == 0 ) continue; const start = point.clone(); point.x += numbers[ j + 5 ]; point.y += numbers[ j + 6 ]; control.x = point.x; control.y = point.y; parseArcCommand( path, numbers[ j ], numbers[ j + 1 ], numbers[ j + 2 ], numbers[ j + 3 ], numbers[ j + 4 ], start, point ); if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point ); } break; case 'Z': case 'z': path.currentPath.autoClose = true; if ( path.currentPath.curves.length > 0 ) { // Reset point to beginning of Path point.copy( firstPoint ); path.currentPath.currentPoint.copy( point ); isFirstPoint = true; } break; default: console.warn( command ); } // console.log( type, parseFloats( data ), parseFloats( data ).length ) doSetFirstPoint = false; } return path; } function parseCSSStylesheet( node ) { if ( ! node.sheet || ! node.sheet.cssRules || ! node.sheet.cssRules.length ) return; for ( let i = 0; i < node.sheet.cssRules.length; i ++ ) { const stylesheet = node.sheet.cssRules[ i ]; if ( stylesheet.type !== 1 ) continue; const selectorList = stylesheet.selectorText .split( /,/gm ) .filter( Boolean ) .map( i => i.trim() ); for ( let j = 0; j < selectorList.length; j ++ ) { // Remove empty rules const definitions = Object.fromEntries( Object.entries( stylesheet.style ).filter( ( [ , v ] ) => v !== '' ) ); stylesheets[ selectorList[ j ] ] = Object.assign( stylesheets[ selectorList[ j ] ] || {}, definitions ); } } } /** * https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes * https://mortoray.com/2017/02/16/rendering-an-svg-elliptical-arc-as-bezier-curves/ Appendix: Endpoint to center arc conversion * From * rx ry x-axis-rotation large-arc-flag sweep-flag x y * To * aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation */ function parseArcCommand( path, rx, ry, x_axis_rotation, large_arc_flag, sweep_flag, start, end ) { if ( rx == 0 || ry == 0 ) { // draw a line if either of the radii == 0 path.lineTo( end.x, end.y ); return; } x_axis_rotation = x_axis_rotation * Math.PI / 180; // Ensure radii are positive rx = Math.abs( rx ); ry = Math.abs( ry ); // Compute (x1', y1') const dx2 = ( start.x - end.x ) / 2.0; const dy2 = ( start.y - end.y ) / 2.0; const x1p = Math.cos( x_axis_rotation ) * dx2 + Math.sin( x_axis_rotation ) * dy2; const y1p = - Math.sin( x_axis_rotation ) * dx2 + Math.cos( x_axis_rotation ) * dy2; // Compute (cx', cy') let rxs = rx * rx; let rys = ry * ry; const x1ps = x1p * x1p; const y1ps = y1p * y1p; // Ensure radii are large enough const cr = x1ps / rxs + y1ps / rys; if ( cr > 1 ) { // scale up rx,ry equally so cr == 1 const s = Math.sqrt( cr ); rx = s * rx; ry = s * ry; rxs = rx * rx; rys = ry * ry; } const dq = ( rxs * y1ps + rys * x1ps ); const pq = ( rxs * rys - dq ) / dq; let q = Math.sqrt( Math.max( 0, pq ) ); if ( large_arc_flag === sweep_flag ) q = - q; const cxp = q * rx * y1p / ry; const cyp = - q * ry * x1p / rx; // Step 3: Compute (cx, cy) from (cx', cy') const cx = Math.cos( x_axis_rotation ) * cxp - Math.sin( x_axis_rotation ) * cyp + ( start.x + end.x ) / 2; const cy = Math.sin( x_axis_rotation ) * cxp + Math.cos( x_axis_rotation ) * cyp + ( start.y + end.y ) / 2; // Step 4: Compute θ1 and Δθ const theta = svgAngle( 1, 0, ( x1p - cxp ) / rx, ( y1p - cyp ) / ry ); const delta = svgAngle( ( x1p - cxp ) / rx, ( y1p - cyp ) / ry, ( - x1p - cxp ) / rx, ( - y1p - cyp ) / ry ) % ( Math.PI * 2 ); path.currentPath.absellipse( cx, cy, rx, ry, theta, theta + delta, sweep_flag === 0, x_axis_rotation ); } function svgAngle( ux, uy, vx, vy ) { const dot = ux * vx + uy * vy; const len = Math.sqrt( ux * ux + uy * uy ) * Math.sqrt( vx * vx + vy * vy ); let ang = Math.acos( Math.max( - 1, Math.min( 1, dot / len ) ) ); // floating point precision, slightly over values appear if ( ( ux * vy - uy * vx ) < 0 ) ang = - ang; return ang; } /* * According to https://www.w3.org/TR/SVG/shapes.html#RectElementRXAttribute * rounded corner should be rendered to elliptical arc, but bezier curve does the job well enough */ function parseRectNode( node ) { const x = parseFloatWithUnits( node.getAttribute( 'x' ) || 0 ); const y = parseFloatWithUnits( node.getAttribute( 'y' ) || 0 ); const rx = parseFloatWithUnits( node.getAttribute( 'rx' ) || node.getAttribute( 'ry' ) || 0 ); const ry = parseFloatWithUnits( node.getAttribute( 'ry' ) || node.getAttribute( 'rx' ) || 0 ); const w = parseFloatWithUnits( node.getAttribute( 'width' ) ); const h = parseFloatWithUnits( node.getAttribute( 'height' ) ); // Ellipse arc to Bezier approximation Coefficient (Inversed). See: // https://spencermortensen.com/articles/bezier-circle/ const bci = 1 - 0.551915024494; const path = new ShapePath(); // top left path.moveTo( x + rx, y ); // top right path.lineTo( x + w - rx, y ); if ( rx !== 0 || ry !== 0 ) { path.bezierCurveTo( x + w - rx * bci, y, x + w, y + ry * bci, x + w, y + ry ); } // bottom right path.lineTo( x + w, y + h - ry ); if ( rx !== 0 || ry !== 0 ) { path.bezierCurveTo( x + w, y + h - ry * bci, x + w - rx * bci, y + h, x + w - rx, y + h ); } // bottom left path.lineTo( x + rx, y + h ); if ( rx !== 0 || ry !== 0 ) { path.bezierCurveTo( x + rx * bci, y + h, x, y + h - ry * bci, x, y + h - ry ); } // back to top left path.lineTo( x, y + ry ); if ( rx !== 0 || ry !== 0 ) { path.bezierCurveTo( x, y + ry * bci, x + rx * bci, y, x + rx, y ); } return path; } function parsePolygonNode( node ) { function iterator( match, a, b ) { const x = parseFloatWithUnits( a ); const y = parseFloatWithUnits( b ); if ( index === 0 ) { path.moveTo( x, y ); } else { path.lineTo( x, y ); } index ++; } const regex = /([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)(?:,|\\s)([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)/g; const path = new ShapePath(); let index = 0; node.getAttribute( 'points' ).replace( regex, iterator ); path.currentPath.autoClose = true; return path; } function parsePolylineNode( node ) { function iterator( match, a, b ) { const x = parseFloatWithUnits( a ); const y = parseFloatWithUnits( b ); if ( index === 0 ) { path.moveTo( x, y ); } else { path.lineTo( x, y ); } index ++; } const regex = /([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)(?:,|\\s)([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)/g; const path = new ShapePath(); let index = 0; node.getAttribute( 'points' ).replace( regex, iterator ); path.currentPath.autoClose = false; return path; } function parseCircleNode( node ) { const x = parseFloatWithUnits( node.getAttribute( 'cx' ) || 0 ); const y = parseFloatWithUnits( node.getAttribute( 'cy' ) || 0 ); const r = parseFloatWithUnits( node.getAttribute( 'r' ) || 0 ); const subpath = new Path(); subpath.absarc( x, y, r, 0, Math.PI * 2 ); const path = new ShapePath(); path.subPaths.push( subpath ); return path; } function parseEllipseNode( node ) { const x = parseFloatWithUnits( node.getAttribute( 'cx' ) || 0 ); const y = parseFloatWithUnits( node.getAttribute( 'cy' ) || 0 ); const rx = parseFloatWithUnits( node.getAttribute( 'rx' ) || 0 ); const ry = parseFloatWithUnits( node.getAttribute( 'ry' ) || 0 ); const subpath = new Path(); subpath.absellipse( x, y, rx, ry, 0, Math.PI * 2 ); const path = new ShapePath(); path.subPaths.push( subpath ); return path; } function parseLineNode( node ) { const x1 = parseFloatWithUnits( node.getAttribute( 'x1' ) || 0 ); const y1 = parseFloatWithUnits( node.getAttribute( 'y1' ) || 0 ); const x2 = parseFloatWithUnits( node.getAttribute( 'x2' ) || 0 ); const y2 = parseFloatWithUnits( node.getAttribute( 'y2' ) || 0 ); const path = new ShapePath(); path.moveTo( x1, y1 ); path.lineTo( x2, y2 ); path.currentPath.autoClose = false; return path; } // function parseStyle( node, style ) { style = Object.assign( {}, style ); // clone style let stylesheetStyles = {}; if ( node.hasAttribute( 'class' ) ) { const classSelectors = node.getAttribute( 'class' ) .split( /\\s/ ) .filter( Boolean ) .map( i => i.trim() ); for ( let i = 0; i < classSelectors.length; i ++ ) { stylesheetStyles = Object.assign( stylesheetStyles, stylesheets[ '.' + classSelectors[ i ] ] ); } } if ( node.hasAttribute( 'id' ) ) { stylesheetStyles = Object.assign( stylesheetStyles, stylesheets[ '#' + node.getAttribute( 'id' ) ] ); } function addStyle( svgName, jsName, adjustFunction ) { if ( adjustFunction === undefined ) adjustFunction = function copy( v ) { if ( v.startsWith( 'url' ) ) console.warn( 'SVGLoader: url access in attributes is not implemented.' ); return v; }; if ( node.hasAttribute( svgName ) ) style[ jsName ] = adjustFunction( node.getAttribute( svgName ) ); if ( stylesheetStyles[ svgName ] ) style[ jsName ] = adjustFunction( stylesheetStyles[ svgName ] ); if ( node.style && node.style[ svgName ] !== '' ) style[ jsName ] = adjustFunction( node.style[ svgName ] ); } function clamp( v ) { return Math.max( 0, Math.min( 1, parseFloatWithUnits( v ) ) ); } function positive( v ) { return Math.max( 0, parseFloatWithUnits( v ) ); } addStyle( 'fill', 'fill' ); addStyle( 'fill-opacity', 'fillOpacity', clamp ); addStyle( 'fill-rule', 'fillRule' ); addStyle( 'opacity', 'opacity', clamp ); addStyle( 'stroke', 'stroke' ); addStyle( 'stroke-opacity', 'strokeOpacity', clamp ); addStyle( 'stroke-width', 'strokeWidth', positive ); addStyle( 'stroke-linejoin', 'strokeLineJoin' ); addStyle( 'stroke-linecap', 'strokeLineCap' ); addStyle( 'stroke-miterlimit', 'strokeMiterLimit', positive ); addStyle( 'visibility', 'visibility' ); return style; } // http://www.w3.org/TR/SVG11/implnote.html#PathElementImplementationNotes function getReflection( a, b ) { return a - ( b - a ); } // from https://github.com/ppvg/svg-numbers (MIT License) function parseFloats( input, flags, stride ) { if ( typeof input !== 'string' ) { throw new TypeError( 'Invalid input: ' + typeof input ); } // Character groups const RE = { SEPARATOR: /[ \\t\\r\\n\\,.\\-+]/, WHITESPACE: /[ \\t\\r\\n]/, DIGIT: /[\\d]/, SIGN: /[-+]/, POINT: /\\./, COMMA: /,/, EXP: /e/i, FLAGS: /[01]/ }; // States const SEP = 0; const INT = 1; const FLOAT = 2; const EXP = 3; let state = SEP; let seenComma = true; let number = '', exponent = ''; const result = []; function throwSyntaxError( current, i, partial ) { const error = new SyntaxError( 'Unexpected character \"' + current + '\" at index ' + i + '.' ); error.partial = partial; throw error; } function newNumber() { if ( number !== '' ) { if ( exponent === '' ) result.push( Number( number ) ); else result.push( Number( number ) * Math.pow( 10, Number( exponent ) ) ); } number = ''; exponent = ''; } let current; const length = input.length; for ( let i = 0; i < length; i ++ ) { current = input[ i ]; // check for flags if ( Array.isArray( flags ) && flags.includes( result.length % stride ) && RE.FLAGS.test( current ) ) { state = INT; number = current; newNumber(); continue; } // parse until next number if ( state === SEP ) { // eat whitespace if ( RE.WHITESPACE.test( current ) ) { continue; } // start new number if ( RE.DIGIT.test( current ) || RE.SIGN.test( current ) ) { state = INT; number = current; continue; } if ( RE.POINT.test( current ) ) { state = FLOAT; number = current; continue; } // throw on double commas (e.g. \"1, , 2\") if ( RE.COMMA.test( current ) ) { if ( seenComma ) { throwSyntaxError( current, i, result ); } seenComma = true; } } // parse integer part if ( state === INT ) { if ( RE.DIGIT.test( current ) ) { number += current; continue; } if ( RE.POINT.test( current ) ) { number += current; state = FLOAT; continue; } if ( RE.EXP.test( current ) ) { state = EXP; continue; } // throw on double signs (\"-+1\"), but not on sign as separator (\"-1-2\") if ( RE.SIGN.test( current ) && number.length === 1 && RE.SIGN.test( number[ 0 ] ) ) { throwSyntaxError( current, i, result ); } } // parse decimal part if ( state === FLOAT ) { if ( RE.DIGIT.test( current ) ) { number += current; continue; } if ( RE.EXP.test( current ) ) { state = EXP; continue; } // throw on double decimal points (e.g. \"1..2\") if ( RE.POINT.test( current ) && number[ number.length - 1 ] === '.' ) { throwSyntaxError( current, i, result ); } } // parse exponent part if ( state === EXP ) { if ( RE.DIGIT.test( current ) ) { exponent += current; continue; } if ( RE.SIGN.test( current ) ) { if ( exponent === '' ) { exponent += current; continue; } if ( exponent.length === 1 && RE.SIGN.test( exponent ) ) { throwSyntaxError( current, i, result ); } } } // end of number if ( RE.WHITESPACE.test( current ) ) { newNumber(); state = SEP; seenComma = false; } else if ( RE.COMMA.test( current ) ) { newNumber(); state = SEP; seenComma = true; } else if ( RE.SIGN.test( current ) ) { newNumber(); state = INT; number = current; } else if ( RE.POINT.test( current ) ) { newNumber(); state = FLOAT; number = current; } else { throwSyntaxError( current, i, result ); } } // add the last number found (if any) newNumber(); return result; } // Units const units = [ 'mm', 'cm', 'in', 'pt', 'pc', 'px' ]; // Conversion: [ fromUnit ][ toUnit ] (-1 means dpi dependent) const unitConversion = { 'mm': { 'mm': 1, 'cm': 0.1, 'in': 1 / 25.4, 'pt': 72 / 25.4, 'pc': 6 / 25.4, 'px': - 1 }, 'cm': { 'mm': 10, 'cm': 1, 'in': 1 / 2.54, 'pt': 72 / 2.54, 'pc': 6 / 2.54, 'px': - 1 }, 'in': { 'mm': 25.4, 'cm': 2.54, 'in': 1, 'pt': 72, 'pc': 6, 'px': - 1 }, 'pt': { 'mm': 25.4 / 72, 'cm': 2.54 / 72, 'in': 1 / 72, 'pt': 1, 'pc': 6 / 72, 'px': - 1 }, 'pc': { 'mm': 25.4 / 6, 'cm': 2.54 / 6, 'in': 1 / 6, 'pt': 72 / 6, 'pc': 1, 'px': - 1 }, 'px': { 'px': 1 } }; function parseFloatWithUnits( string ) { let theUnit = 'px'; if ( typeof string === 'string' || string instanceof String ) { for ( let i = 0, n = units.length; i < n; i ++ ) { const u = units[ i ]; if ( string.endsWith( u ) ) { theUnit = u; string = string.substring( 0, string.length - u.length ); break; } } } let scale = undefined; if ( theUnit === 'px' && scope.defaultUnit !== 'px' ) { // Conversion scale from pixels to inches, then to default units scale = unitConversion[ 'in' ][ scope.defaultUnit ] / scope.defaultDPI; } else { scale = unitConversion[ theUnit ][ scope.defaultUnit ]; if ( scale < 0 ) { // Conversion scale to pixels scale = unitConversion[ theUnit ][ 'in' ] * scope.defaultDPI; } } return scale * parseFloat( string ); } // Transforms function getNodeTransform( node ) { if ( ! ( node.hasAttribute( 'transform' ) || ( node.nodeName === 'use' && ( node.hasAttribute( 'x' ) || node.hasAttribute( 'y' ) ) ) ) ) { return null; } const transform = parseNodeTransform( node ); if ( transformStack.length > 0 ) { transform.premultiply( transformStack[ transformStack.length - 1 ] ); } currentTransform.copy( transform ); transformStack.push( transform ); return transform; } function parseNodeTransform( node ) { const transform = new Matrix3(); const currentTransform = tempTransform0; if ( node.nodeName === 'use' && ( node.hasAttribute( 'x' ) || node.hasAttribute( 'y' ) ) ) { const tx = parseFloatWithUnits( node.getAttribute( 'x' ) ); const ty = parseFloatWithUnits( node.getAttribute( 'y' ) ); transform.translate( tx, ty ); } if ( node.hasAttribute( 'transform' ) ) { const transformsTexts = node.getAttribute( 'transform' ).split( ')' ); for ( let tIndex = transformsTexts.length - 1; tIndex >= 0; tIndex -- ) { const transformText = transformsTexts[ tIndex ].trim(); if ( transformText === '' ) continue; const openParPos = transformText.indexOf( '(' ); const closeParPos = transformText.length; if ( openParPos > 0 && openParPos < closeParPos ) { const transformType = transformText.slice( 0, openParPos ); const array = parseFloats( transformText.slice( openParPos + 1 ) ); currentTransform.identity(); switch ( transformType ) { case 'translate': if ( array.length >= 1 ) { const tx = array[ 0 ]; let ty = 0; if ( array.length >= 2 ) { ty = array[ 1 ]; } currentTransform.translate( tx, ty ); } break; case 'rotate': if ( array.length >= 1 ) { let angle = 0; let cx = 0; let cy = 0; // Angle angle = array[ 0 ] * Math.PI / 180; if ( array.length >= 3 ) { // Center x, y cx = array[ 1 ]; cy = array[ 2 ]; } // Rotate around center (cx, cy) tempTransform1.makeTranslation( - cx, - cy ); tempTransform2.makeRotation( angle ); tempTransform3.multiplyMatrices( tempTransform2, tempTransform1 ); tempTransform1.makeTranslation( cx, cy ); currentTransform.multiplyMatrices( tempTransform1, tempTransform3 ); } break; case 'scale': if ( array.length >= 1 ) { const scaleX = array[ 0 ]; let scaleY = scaleX; if ( array.length >= 2 ) { scaleY = array[ 1 ]; } currentTransform.scale( scaleX, scaleY ); } break; case 'skewX': if ( array.length === 1 ) { currentTransform.set( 1, Math.tan( array[ 0 ] * Math.PI / 180 ), 0, 0, 1, 0, 0, 0, 1 ); } break; case 'skewY': if ( array.length === 1 ) { currentTransform.set( 1, 0, 0, Math.tan( array[ 0 ] * Math.PI / 180 ), 1, 0, 0, 0, 1 ); } break; case 'matrix': if ( array.length === 6 ) { currentTransform.set( array[ 0 ], array[ 2 ], array[ 4 ], array[ 1 ], array[ 3 ], array[ 5 ], 0, 0, 1 ); } break; } } transform.premultiply( currentTransform ); } } return transform; } function transformPath( path, m ) { function transfVec2( v2 ) { tempV3.set( v2.x, v2.y, 1 ).applyMatrix3( m ); v2.set( tempV3.x, tempV3.y ); } function transfEllipseGeneric( curve ) { // For math description see: // https://math.stackexchange.com/questions/4544164 const a = curve.xRadius; const b = curve.yRadius; const cosTheta = Math.cos( curve.aRotation ); const sinTheta = Math.sin( curve.aRotation ); const v1 = new Vector3( a * cosTheta, a * sinTheta, 0 ); const v2 = new Vector3( - b * sinTheta, b * cosTheta, 0 ); const f1 = v1.applyMatrix3( m ); const f2 = v2.applyMatrix3( m ); const mF = tempTransform0.set( f1.x, f2.x, 0, f1.y, f2.y, 0, 0, 0, 1, ); const mFInv = tempTransform1.copy( mF ).invert(); const mFInvT = tempTransform2.copy( mFInv ).transpose(); const mQ = mFInvT.multiply( mFInv ); const mQe = mQ.elements; const ed = eigenDecomposition( mQe[ 0 ], mQe[ 1 ], mQe[ 4 ] ); const rt1sqrt = Math.sqrt( ed.rt1 ); const rt2sqrt = Math.sqrt( ed.rt2 ); curve.xRadius = 1 / rt1sqrt; curve.yRadius = 1 / rt2sqrt; curve.aRotation = Math.atan2( ed.sn, ed.cs ); const isFullEllipse = ( curve.aEndAngle - curve.aStartAngle ) % ( 2 * Math.PI ) < Number.EPSILON; // Do not touch angles of a full ellipse because after transformation they // would converge to a sinle value effectively removing the whole curve if ( ! isFullEllipse ) { const mDsqrt = tempTransform1.set( rt1sqrt, 0, 0, 0, rt2sqrt, 0, 0, 0, 1, ); const mRT = tempTransform2.set( ed.cs, ed.sn, 0, - ed.sn, ed.cs, 0, 0, 0, 1, ); const mDRF = mDsqrt.multiply( mRT ).multiply( mF ); const transformAngle = phi => { const { x: cosR, y: sinR } = new Vector3( Math.cos( phi ), Math.sin( phi ), 0 ).applyMatrix3( mDRF ); return Math.atan2( sinR, cosR ); }; curve.aStartAngle = transformAngle( curve.aStartAngle ); curve.aEndAngle = transformAngle( curve.aEndAngle ); if ( isTransformFlipped( m ) ) { curve.aClockwise = ! curve.aClockwise; } } } function transfEllipseNoSkew( curve ) { // Faster shortcut if no skew is applied // (e.g, a euclidean transform of a group containing the ellipse) const sx = getTransformScaleX( m ); const sy = getTransformScaleY( m ); curve.xRadius *= sx; curve.yRadius *= sy; // Extract rotation angle from the matrix of form: // // | cosθ sx -sinθ sy | // | sinθ sx cosθ sy | // // Remembering that tanθ = sinθ / cosθ; and that // `sx`, `sy`, or both might be zero. const theta = sx > Number.EPSILON ? Math.atan2( m.elements[ 1 ], m.elements[ 0 ] ) : Math.atan2( - m.elements[ 3 ], m.elements[ 4 ] ); curve.aRotation += theta; if ( isTransformFlipped( m ) ) { curve.aStartAngle *= - 1; curve.aEndAngle *= - 1; curve.aClockwise = ! curve.aClockwise; } } const subPaths = path.subPaths; for ( let i = 0, n = subPaths.length; i < n; i ++ ) { const subPath = subPaths[ i ]; const curves = subPath.curves; for ( let j = 0; j < curves.length; j ++ ) { const curve = curves[ j ]; if ( curve.isLineCurve ) { transfVec2( curve.v1 ); transfVec2( curve.v2 ); } else if ( curve.isCubicBezierCurve ) { transfVec2( curve.v0 ); transfVec2( curve.v1 ); transfVec2( curve.v2 ); transfVec2( curve.v3 ); } else if ( curve.isQuadraticBezierCurve ) { transfVec2( curve.v0 ); transfVec2( curve.v1 ); transfVec2( curve.v2 ); } else if ( curve.isEllipseCurve ) { // Transform ellipse center point tempV2.set( curve.aX, curve.aY ); transfVec2( tempV2 ); curve.aX = tempV2.x; curve.aY = tempV2.y; // Transform ellipse shape parameters if ( isTransformSkewed( m ) ) { transfEllipseGeneric( curve ); } else { transfEllipseNoSkew( curve ); } } } } } function isTransformFlipped( m ) { const te = m.elements; return te[ 0 ] * te[ 4 ] - te[ 1 ] * te[ 3 ] < 0; } function isTransformSkewed( m ) { const te = m.elements; const basisDot = te[ 0 ] * te[ 3 ] + te[ 1 ] * te[ 4 ]; // Shortcut for trivial rotations and transformations if ( basisDot === 0 ) return false; const sx = getTransformScaleX( m ); const sy = getTransformScaleY( m ); return Math.abs( basisDot / ( sx * sy ) ) > Number.EPSILON; } function getTransformScaleX( m ) { const te = m.elements; return Math.sqrt( te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] ); } function getTransformScaleY( m ) { const te = m.elements; return Math.sqrt( te[ 3 ] * te[ 3 ] + te[ 4 ] * te[ 4 ] ); } // Calculates the eigensystem of a real symmetric 2x2 matrix // [ A B ] // [ B C ] // in the form // [ A B ] = [ cs -sn ] [ rt1 0 ] [ cs sn ] // [ B C ] [ sn cs ] [ 0 rt2 ] [ -sn cs ] // where rt1 >= rt2. // // Adapted from: https://www.mpi-hd.mpg.de/personalhomes/globes/3x3/index.html // -> Algorithms for real symmetric matrices -> Analytical (2x2 symmetric) function eigenDecomposition( A, B, C ) { let rt1, rt2, cs, sn, t; const sm = A + C; const df = A - C; const rt = Math.sqrt( df * df + 4 * B * B ); if ( sm > 0 ) { rt1 = 0.5 * ( sm + rt ); t = 1 / rt1; rt2 = A * t * C - B * t * B; } else if ( sm < 0 ) { rt2 = 0.5 * ( sm - rt ); } else { // This case needs to be treated separately to avoid div by 0 rt1 = 0.5 * rt; rt2 = - 0.5 * rt; } // Calculate eigenvectors if ( df > 0 ) { cs = df + rt; } else { cs = df - rt; } if ( Math.abs( cs ) > 2 * Math.abs( B ) ) { t = - 2 * B / cs; sn = 1 / Math.sqrt( 1 + t * t ); cs = t * sn; } else if ( Math.abs( B ) === 0 ) { cs = 1; sn = 0; } else { t = - 0.5 * cs / B; cs = 1 / Math.sqrt( 1 + t * t ); sn = t * cs; } if ( df > 0 ) { t = cs; cs = - sn; sn = t; } return { rt1, rt2, cs, sn }; } // const paths = []; const stylesheets = {}; const transformStack = []; const tempTransform0 = new Matrix3(); const tempTransform1 = new Matrix3(); const tempTransform2 = new Matrix3(); const tempTransform3 = new Matrix3(); const tempV2 = new Vector2(); const tempV3 = new Vector3(); const currentTransform = new Matrix3(); const xml = new DOMParser().parseFromString( text, 'image/svg+xml' ); // application/xml parseNode( xml.documentElement, { fill: '#000', fillOpacity: 1, strokeOpacity: 1, strokeWidth: 1, strokeLineJoin: 'miter', strokeLineCap: 'butt', strokeMiterLimit: 4 } ); const data = { paths: paths, xml: xml.documentElement }; // console.log( paths ); return data; } static createShapes( shapePath ) { // Param shapePath: a shapepath as returned by the parse function of this class // Returns Shape object const BIGNUMBER = 999999999; const IntersectionLocationType = { ORIGIN: 0, DESTINATION: 1, BETWEEN: 2, LEFT: 3, RIGHT: 4, BEHIND: 5, BEYOND: 6 }; const classifyResult = { loc: IntersectionLocationType.ORIGIN, t: 0 }; function findEdgeIntersection( a0, a1, b0, b1 ) { const x1 = a0.x; const x2 = a1.x; const x3 = b0.x; const x4 = b1.x; const y1 = a0.y; const y2 = a1.y; const y3 = b0.y; const y4 = b1.y; const nom1 = ( x4 - x3 ) * ( y1 - y3 ) - ( y4 - y3 ) * ( x1 - x3 ); const nom2 = ( x2 - x1 ) * ( y1 - y3 ) - ( y2 - y1 ) * ( x1 - x3 ); const denom = ( y4 - y3 ) * ( x2 - x1 ) - ( x4 - x3 ) * ( y2 - y1 ); const t1 = nom1 / denom; const t2 = nom2 / denom; if ( ( ( denom === 0 ) && ( nom1 !== 0 ) ) || ( t1 = 1 ) || ( t2 < 0 ) || ( t2 > 1 ) ) { //1. lines are parallel or edges don't intersect return null; } else if ( ( nom1 === 0 ) && ( denom === 0 ) ) { //2. lines are colinear //check if endpoints of edge2 (b0-b1) lies on edge1 (a0-a1) for ( let i = 0; i < 2; i ++ ) { classifyPoint( i === 0 ? b0 : b1, a0, a1 ); //find position of this endpoints relatively to edge1 if ( classifyResult.loc == IntersectionLocationType.ORIGIN ) { const point = ( i === 0 ? b0 : b1 ); return { x: point.x, y: point.y, t: classifyResult.t }; } else if ( classifyResult.loc == IntersectionLocationType.BETWEEN ) { const x = + ( ( x1 + classifyResult.t * ( x2 - x1 ) ).toPrecision( 10 ) ); const y = + ( ( y1 + classifyResult.t * ( y2 - y1 ) ).toPrecision( 10 ) ); return { x: x, y: y, t: classifyResult.t, }; } } return null; } else { //3. edges intersect for ( let i = 0; i < 2; i ++ ) { classifyPoint( i === 0 ? b0 : b1, a0, a1 ); if ( classifyResult.loc == IntersectionLocationType.ORIGIN ) { const point = ( i === 0 ? b0 : b1 ); return { x: point.x, y: point.y, t: classifyResult.t }; } } const x = + ( ( x1 + t1 * ( x2 - x1 ) ).toPrecision( 10 ) ); const y = + ( ( y1 + t1 * ( y2 - y1 ) ).toPrecision( 10 ) ); return { x: x, y: y, t: t1 }; } } function classifyPoint( p, edgeStart, edgeEnd ) { const ax = edgeEnd.x - edgeStart.x; const ay = edgeEnd.y - edgeStart.y; const bx = p.x - edgeStart.x; const by = p.y - edgeStart.y; const sa = ax * by - bx * ay; if ( ( p.x === edgeStart.x ) && ( p.y === edgeStart.y ) ) { classifyResult.loc = IntersectionLocationType.ORIGIN; classifyResult.t = 0; return; } if ( ( p.x === edgeEnd.x ) && ( p.y === edgeEnd.y ) ) { classifyResult.loc = IntersectionLocationType.DESTINATION; classifyResult.t = 1; return; } if ( sa < - Number.EPSILON ) { classifyResult.loc = IntersectionLocationType.LEFT; return; } if ( sa > Number.EPSILON ) { classifyResult.loc = IntersectionLocationType.RIGHT; return; } if ( ( ( ax * bx ) < 0 ) || ( ( ay * by ) < 0 ) ) { classifyResult.loc = IntersectionLocationType.BEHIND; return; } if ( ( Math.sqrt( ax * ax + ay * ay ) ) < ( Math.sqrt( bx * bx + by * by ) ) ) { classifyResult.loc = IntersectionLocationType.BEYOND; return; } let t; if ( ax !== 0 ) { t = bx / ax; } else { t = by / ay; } classifyResult.loc = IntersectionLocationType.BETWEEN; classifyResult.t = t; } function getIntersections( path1, path2 ) { const intersectionsRaw = []; const intersections = []; for ( let index = 1; index < path1.length; index ++ ) { const path1EdgeStart = path1[ index - 1 ]; const path1EdgeEnd = path1[ index ]; for ( let index2 = 1; index2 < path2.length; index2 ++ ) { const path2EdgeStart = path2[ index2 - 1 ]; const path2EdgeEnd = path2[ index2 ]; const intersection = findEdgeIntersection( path1EdgeStart, path1EdgeEnd, path2EdgeStart, path2EdgeEnd ); if ( intersection !== null && intersectionsRaw.find( i => i.t = intersection.t - Number.EPSILON ) === undefined ) { intersectionsRaw.push( intersection ); intersections.push( new Vector2( intersection.x, intersection.y ) ); } } } return intersections; } function getScanlineIntersections( scanline, boundingBox, paths ) { const center = new Vector2(); boundingBox.getCenter( center ); const allIntersections = []; paths.forEach( path => { // check if the center of the bounding box is in the bounding box of the paths. // this is a pruning method to limit the search of intersections in paths that can't envelop of the current path. // if a path envelops another path. The center of that oter path, has to be inside the bounding box of the enveloping path. if ( path.boundingBox.containsPoint( center ) ) { const intersections = getIntersections( scanline, path.points ); intersections.forEach( p => { allIntersections.push( { identifier: path.identifier, isCW: path.isCW, point: p } ); } ); } } ); allIntersections.sort( ( i1, i2 ) => { return i1.point.x - i2.point.x; } ); return allIntersections; } function isHoleTo( simplePath, allPaths, scanlineMinX, scanlineMaxX, _fillRule ) { if ( _fillRule === null || _fillRule === undefined || _fillRule === '' ) { _fillRule = 'nonzero'; } const centerBoundingBox = new Vector2(); simplePath.boundingBox.getCenter( centerBoundingBox ); const scanline = [ new Vector2( scanlineMinX, centerBoundingBox.y ), new Vector2( scanlineMaxX, centerBoundingBox.y ) ]; const scanlineIntersections = getScanlineIntersections( scanline, simplePath.boundingBox, allPaths ); scanlineIntersections.sort( ( i1, i2 ) => { return i1.point.x - i2.point.x; } ); const baseIntersections = []; const otherIntersections = []; scanlineIntersections.forEach( i => { if ( i.identifier === simplePath.identifier ) { baseIntersections.push( i ); } else { otherIntersections.push( i ); } } ); const firstXOfPath = baseIntersections[ 0 ].point.x; // build up the path hierarchy const stack = []; let i = 0; while ( i < otherIntersections.length && otherIntersections[ i ].point.x < firstXOfPath ) { if ( stack.length > 0 && stack[ stack.length - 1 ] === otherIntersections[ i ].identifier ) { stack.pop(); } else { stack.push( otherIntersections[ i ].identifier ); } i ++; } stack.push( simplePath.identifier ); if ( _fillRule === 'evenodd' ) { const isHole = stack.length % 2 === 0 ? true : false; const isHoleFor = stack[ stack.length - 2 ]; return { identifier: simplePath.identifier, isHole: isHole, for: isHoleFor }; } else if ( _fillRule === 'nonzero' ) { // check if path is a hole by counting the amount of paths with alternating rotations it has to cross. let isHole = true; let isHoleFor = null; let lastCWValue = null; for ( let i = 0; i < stack.length; i ++ ) { const identifier = stack[ i ]; if ( isHole ) { lastCWValue = allPaths[ identifier ].isCW; isHole = false; isHoleFor = identifier; } else if ( lastCWValue !== allPaths[ identifier ].isCW ) { lastCWValue = allPaths[ identifier ].isCW; isHole = true; } } return { identifier: simplePath.identifier, isHole: isHole, for: isHoleFor }; } else { console.warn( 'fill-rule: \"' + _fillRule + '\" is currently not implemented.' ); } } // check for self intersecting paths // TODO // check intersecting paths // TODO // prepare paths for hole detection let scanlineMinX = BIGNUMBER; let scanlineMaxX = - BIGNUMBER; let simplePaths = shapePath.subPaths.map( p => { const points = p.getPoints(); let maxY = - BIGNUMBER; let minY = BIGNUMBER; let maxX = - BIGNUMBER; let minX = BIGNUMBER; //points.forEach(p => p.y *= -1); for ( let i = 0; i < points.length; i ++ ) { const p = points[ i ]; if ( p.y > maxY ) { maxY = p.y; } if ( p.y < minY ) { minY = p.y; } if ( p.x > maxX ) { maxX = p.x; } if ( p.x < minX ) { minX = p.x; } } // if ( scanlineMaxX = minX ) { scanlineMinX = minX - 1; } return { curves: p.curves, points: points, isCW: ShapeUtils.isClockWise( points ), identifier: - 1, boundingBox: new Box2( new Vector2( minX, minY ), new Vector2( maxX, maxY ) ) }; } ); simplePaths = simplePaths.filter( sp => sp.points.length > 1 ); for ( let identifier = 0; identifier < simplePaths.length; identifier ++ ) { simplePaths[ identifier ].identifier = identifier; } // check if path is solid or a hole const isAHole = simplePaths.map( p => isHoleTo( p, simplePaths, scanlineMinX, scanlineMaxX, ( shapePath.userData ? shapePath.userData.style.fillRule : undefined ) ) ); const shapesToReturn = []; simplePaths.forEach( p => { const amIAHole = isAHole[ p.identifier ]; if ( ! amIAHole.isHole ) { const shape = new Shape(); shape.curves = p.curves; const holes = isAHole.filter( h => h.isHole && h.for === p.identifier ); holes.forEach( h => { const hole = simplePaths[ h.identifier ]; const path = new Path(); path.curves = hole.curves; shape.holes.push( path ); } ); shapesToReturn.push( shape ); } } ); return shapesToReturn; } static getStrokeStyle( width, color, lineJoin, lineCap, miterLimit ) { // Param width: Stroke width // Param color: As returned by THREE.Color.getStyle() // Param lineJoin: One of \"round\", \"bevel\", \"miter\" or \"miter-limit\" // Param lineCap: One of \"round\", \"square\" or \"butt\" // Param miterLimit: Maximum join length, in multiples of the \"width\" parameter (join is truncated if it exceeds that distance) // Returns style object width = width !== undefined ? width : 1; color = color !== undefined ? color : '#000'; lineJoin = lineJoin !== undefined ? lineJoin : 'miter'; lineCap = lineCap !== undefined ? lineCap : 'butt'; miterLimit = miterLimit !== undefined ? miterLimit : 4; return { strokeColor: color, strokeWidth: width, strokeLineJoin: lineJoin, strokeLineCap: lineCap, strokeMiterLimit: miterLimit }; } static pointsToStroke( points, style, arcDivisions, minDistance ) { // Generates a stroke with some width around the given path. // The path can be open or closed (last point equals to first point) // Param points: Array of Vector2D (the path). Minimum 2 points. // Param style: Object with SVG properties as returned by SVGLoader.getStrokeStyle(), or SVGLoader.parse() in the path.userData.style object // Params arcDivisions: Arc divisions for round joins and endcaps. (Optional) // Param minDistance: Points closer to this distance will be merged. (Optional) // Returns BufferGeometry with stroke triangles (In plane z = 0). UV coordinates are generated ('u' along path. 'v' across it, from left to right) const vertices = []; const normals = []; const uvs = []; if ( SVGLoader.pointsToStrokeWithBuffers( points, style, arcDivisions, minDistance, vertices, normals, uvs ) === 0 ) { return null; } const geometry = new BufferGeometry(); geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) ); geometry.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) ); geometry.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) ); return geometry; } static pointsToStrokeWithBuffers( points, style, arcDivisions, minDistance, vertices, normals, uvs, vertexOffset ) { // This function can be called to update existing arrays or buffers. // Accepts same parameters as pointsToStroke, plus the buffers and optional offset. // Param vertexOffset: Offset vertices to start writing in the buffers (3 elements/vertex for vertices and normals, and 2 elements/vertex for uvs) // Returns number of written vertices / normals / uvs pairs // if 'vertices' parameter is undefined no triangles will be generated, but the returned vertices count will still be valid (useful to preallocate the buffers) // 'normals' and 'uvs' buffers are optional const tempV2_1 = new Vector2(); const tempV2_2 = new Vector2(); const tempV2_3 = new Vector2(); const tempV2_4 = new Vector2(); const tempV2_5 = new Vector2(); const tempV2_6 = new Vector2(); const tempV2_7 = new Vector2(); const lastPointL = new Vector2(); const lastPointR = new Vector2(); const point0L = new Vector2(); const point0R = new Vector2(); const currentPointL = new Vector2(); const currentPointR = new Vector2(); const nextPointL = new Vector2(); const nextPointR = new Vector2(); const innerPoint = new Vector2(); const outerPoint = new Vector2(); arcDivisions = arcDivisions !== undefined ? arcDivisions : 12; minDistance = minDistance !== undefined ? minDistance : 0.001; vertexOffset = vertexOffset !== undefined ? vertexOffset : 0; // First ensure there are no duplicated points points = removeDuplicatedPoints( points ); const numPoints = points.length; if ( numPoints < 2 ) return 0; const isClosed = points[ 0 ].equals( points[ numPoints - 1 ] ); let currentPoint; let previousPoint = points[ 0 ]; let nextPoint; const strokeWidth2 = style.strokeWidth / 2; const deltaU = 1 / ( numPoints - 1 ); let u0 = 0, u1; let innerSideModified; let joinIsOnLeftSide; let isMiter; let initialJoinIsOnLeftSide = false; let numVertices = 0; let currentCoordinate = vertexOffset * 3; let currentCoordinateUV = vertexOffset * 2; // Get initial left and right stroke points getNormal( points[ 0 ], points[ 1 ], tempV2_1 ).multiplyScalar( strokeWidth2 ); lastPointL.copy( points[ 0 ] ).sub( tempV2_1 ); lastPointR.copy( points[ 0 ] ).add( tempV2_1 ); point0L.copy( lastPointL ); point0R.copy( lastPointR ); for ( let iPoint = 1; iPoint < numPoints; iPoint ++ ) { currentPoint = points[ iPoint ]; // Get next point if ( iPoint === numPoints - 1 ) { if ( isClosed ) { // Skip duplicated initial point nextPoint = points[ 1 ]; } else nextPoint = undefined; } else { nextPoint = points[ iPoint + 1 ]; } // Normal of previous segment in tempV2_1 const normal1 = tempV2_1; getNormal( previousPoint, currentPoint, normal1 ); tempV2_3.copy( normal1 ).multiplyScalar( strokeWidth2 ); currentPointL.copy( currentPoint ).sub( tempV2_3 ); currentPointR.copy( currentPoint ).add( tempV2_3 ); u1 = u0 + deltaU; innerSideModified = false; if ( nextPoint !== undefined ) { // Normal of next segment in tempV2_2 getNormal( currentPoint, nextPoint, tempV2_2 ); tempV2_3.copy( tempV2_2 ).multiplyScalar( strokeWidth2 ); nextPointL.copy( currentPoint ).sub( tempV2_3 ); nextPointR.copy( currentPoint ).add( tempV2_3 ); joinIsOnLeftSide = true; tempV2_3.subVectors( nextPoint, previousPoint ); if ( normal1.dot( tempV2_3 ) < 0 ) { joinIsOnLeftSide = false; } if ( iPoint === 1 ) initialJoinIsOnLeftSide = joinIsOnLeftSide; tempV2_3.subVectors( nextPoint, currentPoint ); tempV2_3.normalize(); const dot = Math.abs( normal1.dot( tempV2_3 ) ); // If path is straight, don't create join if ( dot > Number.EPSILON ) { // Compute inner and outer segment intersections const miterSide = strokeWidth2 / dot; tempV2_3.multiplyScalar( - miterSide ); tempV2_4.subVectors( currentPoint, previousPoint ); tempV2_5.copy( tempV2_4 ).setLength( miterSide ).add( tempV2_3 ); innerPoint.copy( tempV2_5 ).negate(); const miterLength2 = tempV2_5.length(); const segmentLengthPrev = tempV2_4.length(); tempV2_4.divideScalar( segmentLengthPrev ); tempV2_6.subVectors( nextPoint, currentPoint ); const segmentLengthNext = tempV2_6.length(); tempV2_6.divideScalar( segmentLengthNext ); // Check that previous and next segments doesn't overlap with the innerPoint of intersection if ( tempV2_4.dot( innerPoint ) < segmentLengthPrev && tempV2_6.dot( innerPoint ) < segmentLengthNext ) { innerSideModified = true; } outerPoint.copy( tempV2_5 ).add( currentPoint ); innerPoint.add( currentPoint ); isMiter = false; if ( innerSideModified ) { if ( joinIsOnLeftSide ) { nextPointR.copy( innerPoint ); currentPointR.copy( innerPoint ); } else { nextPointL.copy( innerPoint ); currentPointL.copy( innerPoint ); } } else { // The segment triangles are generated here if there was overlapping makeSegmentTriangles(); } switch ( style.strokeLineJoin ) { case 'bevel': makeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u1 ); break; case 'round': // Segment triangles createSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified ); // Join triangles if ( joinIsOnLeftSide ) { makeCircularSector( currentPoint, currentPointL, nextPointL, u1, 0 ); } else { makeCircularSector( currentPoint, nextPointR, currentPointR, u1, 1 ); } break; case 'miter': case 'miter-clip': default: const miterFraction = ( strokeWidth2 * style.strokeMiterLimit ) / miterLength2; if ( miterFraction < 1 ) { // The join miter length exceeds the miter limit if ( style.strokeLineJoin !== 'miter-clip' ) { makeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u1 ); break; } else { // Segment triangles createSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified ); // Miter-clip join triangles if ( joinIsOnLeftSide ) { tempV2_6.subVectors( outerPoint, currentPointL ).multiplyScalar( miterFraction ).add( currentPointL ); tempV2_7.subVectors( outerPoint, nextPointL ).multiplyScalar( miterFraction ).add( nextPointL ); addVertex( currentPointL, u1, 0 ); addVertex( tempV2_6, u1, 0 ); addVertex( currentPoint, u1, 0.5 ); addVertex( currentPoint, u1, 0.5 ); addVertex( tempV2_6, u1, 0 ); addVertex( tempV2_7, u1, 0 ); addVertex( currentPoint, u1, 0.5 ); addVertex( tempV2_7, u1, 0 ); addVertex( nextPointL, u1, 0 ); } else { tempV2_6.subVectors( outerPoint, currentPointR ).multiplyScalar( miterFraction ).add( currentPointR ); tempV2_7.subVectors( outerPoint, nextPointR ).multiplyScalar( miterFraction ).add( nextPointR ); addVertex( currentPointR, u1, 1 ); addVertex( tempV2_6, u1, 1 ); addVertex( currentPoint, u1, 0.5 ); addVertex( currentPoint, u1, 0.5 ); addVertex( tempV2_6, u1, 1 ); addVertex( tempV2_7, u1, 1 ); addVertex( currentPoint, u1, 0.5 ); addVertex( tempV2_7, u1, 1 ); addVertex( nextPointR, u1, 1 ); } } } else { // Miter join segment triangles if ( innerSideModified ) { // Optimized segment + join triangles if ( joinIsOnLeftSide ) { addVertex( lastPointR, u0, 1 ); addVertex( lastPointL, u0, 0 ); addVertex( outerPoint, u1, 0 ); addVertex( lastPointR, u0, 1 ); addVertex( outerPoint, u1, 0 ); addVertex( innerPoint, u1, 1 ); } else { addVertex( lastPointR, u0, 1 ); addVertex( lastPointL, u0, 0 ); addVertex( outerPoint, u1, 1 ); addVertex( lastPointL, u0, 0 ); addVertex( innerPoint, u1, 0 ); addVertex( outerPoint, u1, 1 ); } if ( joinIsOnLeftSide ) { nextPointL.copy( outerPoint ); } else { nextPointR.copy( outerPoint ); } } else { // Add extra miter join triangles if ( joinIsOnLeftSide ) { addVertex( currentPointL, u1, 0 ); addVertex( outerPoint, u1, 0 ); addVertex( currentPoint, u1, 0.5 ); addVertex( currentPoint, u1, 0.5 ); addVertex( outerPoint, u1, 0 ); addVertex( nextPointL, u1, 0 ); } else { addVertex( currentPointR, u1, 1 ); addVertex( outerPoint, u1, 1 ); addVertex( currentPoint, u1, 0.5 ); addVertex( currentPoint, u1, 0.5 ); addVertex( outerPoint, u1, 1 ); addVertex( nextPointR, u1, 1 ); } } isMiter = true; } break; } } else { // The segment triangles are generated here when two consecutive points are collinear makeSegmentTriangles(); } } else { // The segment triangles are generated here if it is the ending segment makeSegmentTriangles(); } if ( ! isClosed && iPoint === numPoints - 1 ) { // Start line endcap addCapGeometry( points[ 0 ], point0L, point0R, joinIsOnLeftSide, true, u0 ); } // Increment loop variables u0 = u1; previousPoint = currentPoint; lastPointL.copy( nextPointL ); lastPointR.copy( nextPointR ); } if ( ! isClosed ) { // Ending line endcap addCapGeometry( currentPoint, currentPointL, currentPointR, joinIsOnLeftSide, false, u1 ); } else if ( innerSideModified && vertices ) { // Modify path first segment vertices to adjust to the segments inner and outer intersections let lastOuter = outerPoint; let lastInner = innerPoint; if ( initialJoinIsOnLeftSide !== joinIsOnLeftSide ) { lastOuter = innerPoint; lastInner = outerPoint; } if ( joinIsOnLeftSide ) { if ( isMiter || initialJoinIsOnLeftSide ) { lastInner.toArray( vertices, 0 * 3 ); lastInner.toArray( vertices, 3 * 3 ); if ( isMiter ) { lastOuter.toArray( vertices, 1 * 3 ); } } } else { if ( isMiter || ! initialJoinIsOnLeftSide ) { lastInner.toArray( vertices, 1 * 3 ); lastInner.toArray( vertices, 3 * 3 ); if ( isMiter ) { lastOuter.toArray( vertices, 0 * 3 ); } } } } return numVertices; // -- End of algorithm // -- Functions function getNormal( p1, p2, result ) { result.subVectors( p2, p1 ); return result.set( - result.y, result.x ).normalize(); } function addVertex( position, u, v ) { if ( vertices ) { vertices[ currentCoordinate ] = position.x; vertices[ currentCoordinate + 1 ] = position.y; vertices[ currentCoordinate + 2 ] = 0; if ( normals ) { normals[ currentCoordinate ] = 0; normals[ currentCoordinate + 1 ] = 0; normals[ currentCoordinate + 2 ] = 1; } currentCoordinate += 3; if ( uvs ) { uvs[ currentCoordinateUV ] = u; uvs[ currentCoordinateUV + 1 ] = v; currentCoordinateUV += 2; } } numVertices += 3; } function makeCircularSector( center, p1, p2, u, v ) { // param p1, p2: Points in the circle arc. // p1 and p2 are in clockwise direction. tempV2_1.copy( p1 ).sub( center ).normalize(); tempV2_2.copy( p2 ).sub( center ).normalize(); let angle = Math.PI; const dot = tempV2_1.dot( tempV2_2 ); if ( Math.abs( dot ) < 1 ) angle = Math.abs( Math.acos( dot ) ); angle /= arcDivisions; tempV2_3.copy( p1 ); for ( let i = 0, il = arcDivisions - 1; i < il; i ++ ) { tempV2_4.copy( tempV2_3 ).rotateAround( center, angle ); addVertex( tempV2_3, u, v ); addVertex( tempV2_4, u, v ); addVertex( center, u, 0.5 ); tempV2_3.copy( tempV2_4 ); } addVertex( tempV2_4, u, v ); addVertex( p2, u, v ); addVertex( center, u, 0.5 ); } function makeSegmentTriangles() { addVertex( lastPointR, u0, 1 ); addVertex( lastPointL, u0, 0 ); addVertex( currentPointL, u1, 0 ); addVertex( lastPointR, u0, 1 ); addVertex( currentPointL, u1, 1 ); addVertex( currentPointR, u1, 0 ); } function makeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u ) { if ( innerSideModified ) { // Optimized segment + bevel triangles if ( joinIsOnLeftSide ) { // Path segments triangles addVertex( lastPointR, u0, 1 ); addVertex( lastPointL, u0, 0 ); addVertex( currentPointL, u1, 0 ); addVertex( lastPointR, u0, 1 ); addVertex( currentPointL, u1, 0 ); addVertex( innerPoint, u1, 1 ); // Bevel join triangle addVertex( currentPointL, u, 0 ); addVertex( nextPointL, u, 0 ); addVertex( innerPoint, u, 0.5 ); } else { // Path segments triangles addVertex( lastPointR, u0, 1 ); addVertex( lastPointL, u0, 0 ); addVertex( currentPointR, u1, 1 ); addVertex( lastPointL, u0, 0 ); addVertex( innerPoint, u1, 0 ); addVertex( currentPointR, u1, 1 ); // Bevel join triangle addVertex( currentPointR, u, 1 ); addVertex( nextPointR, u, 0 ); addVertex( innerPoint, u, 0.5 ); } } else { // Bevel join triangle. The segment triangles are done in the main loop if ( joinIsOnLeftSide ) { addVertex( currentPointL, u, 0 ); addVertex( nextPointL, u, 0 ); addVertex( currentPoint, u, 0.5 ); } else { addVertex( currentPointR, u, 1 ); addVertex( nextPointR, u, 0 ); addVertex( currentPoint, u, 0.5 ); } } } function createSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified ) { if ( innerSideModified ) { if ( joinIsOnLeftSide ) { addVertex( lastPointR, u0, 1 ); addVertex( lastPointL, u0, 0 ); addVertex( currentPointL, u1, 0 ); addVertex( lastPointR, u0, 1 ); addVertex( currentPointL, u1, 0 ); addVertex( innerPoint, u1, 1 ); addVertex( currentPointL, u0, 0 ); addVertex( currentPoint, u1, 0.5 ); addVertex( innerPoint, u1, 1 ); addVertex( currentPoint, u1, 0.5 ); addVertex( nextPointL, u0, 0 ); addVertex( innerPoint, u1, 1 ); } else { addVertex( lastPointR, u0, 1 ); addVertex( lastPointL, u0, 0 ); addVertex( currentPointR, u1, 1 ); addVertex( lastPointL, u0, 0 ); addVertex( innerPoint, u1, 0 ); addVertex( currentPointR, u1, 1 ); addVertex( currentPointR, u0, 1 ); addVertex( innerPoint, u1, 0 ); addVertex( currentPoint, u1, 0.5 ); addVertex( currentPoint, u1, 0.5 ); addVertex( innerPoint, u1, 0 ); addVertex( nextPointR, u0, 1 ); } } } function addCapGeometry( center, p1, p2, joinIsOnLeftSide, start, u ) { // param center: End point of the path // param p1, p2: Left and right cap points switch ( style.strokeLineCap ) { case 'round': if ( start ) { makeCircularSector( center, p2, p1, u, 0.5 ); } else { makeCircularSector( center, p1, p2, u, 0.5 ); } break; case 'square': if ( start ) { tempV2_1.subVectors( p1, center ); tempV2_2.set( tempV2_1.y, - tempV2_1.x ); tempV2_3.addVectors( tempV2_1, tempV2_2 ).add( center ); tempV2_4.subVectors( tempV2_2, tempV2_1 ).add( center ); // Modify already existing vertices if ( joinIsOnLeftSide ) { tempV2_3.toArray( vertices, 1 * 3 ); tempV2_4.toArray( vertices, 0 * 3 ); tempV2_4.toArray( vertices, 3 * 3 ); } else { tempV2_3.toArray( vertices, 1 * 3 ); tempV2_3.toArray( vertices, 3 * 3 ); tempV2_4.toArray( vertices, 0 * 3 ); } } else { tempV2_1.subVectors( p2, center ); tempV2_2.set( tempV2_1.y, - tempV2_1.x ); tempV2_3.addVectors( tempV2_1, tempV2_2 ).add( center ); tempV2_4.subVectors( tempV2_2, tempV2_1 ).add( center ); const vl = vertices.length; // Modify already existing vertices if ( joinIsOnLeftSide ) { tempV2_3.toArray( vertices, vl - 1 * 3 ); tempV2_4.toArray( vertices, vl - 2 * 3 ); tempV2_4.toArray( vertices, vl - 4 * 3 ); } else { tempV2_3.toArray( vertices, vl - 2 * 3 ); tempV2_4.toArray( vertices, vl - 1 * 3 ); tempV2_4.toArray( vertices, vl - 4 * 3 ); } } break; case 'butt': default: // Nothing to do here break; } } function removeDuplicatedPoints( points ) { // Creates a new array if necessary with duplicated points removed. // This does not remove duplicated initial and ending points of a closed path. let dupPoints = false; for ( let i = 1, n = points.length - 1; i < n; i ++ ) { if ( points[ i ].distanceTo( points[ i + 1 ] ) < minDistance ) { dupPoints = true; break; } } if ( ! dupPoints ) return points; const newPoints = []; newPoints.push( points[ 0 ] ); for ( let i = 1, n = points.length - 1; i < n; i ++ ) { if ( points[ i ].distanceTo( points[ i + 1 ] ) >= minDistance ) { newPoints.push( points[ i ] ); } } newPoints.push( points[ points.length - 1 ] ); return newPoints; } } } export { SVGLoader };"},{"title":"","date":"2023-10-12T14:08:40.742Z","updated":"2023-10-12T14:08:40.742Z","comments":true,"path":"js/three/jsm/loaders/TDSLoader.js","permalink":"http://19999997.xyz/js/three/jsm/loaders/TDSLoader.js","excerpt":"","text":"import { AdditiveBlending, BufferGeometry, Color, DoubleSide, FileLoader, Float32BufferAttribute, Group, Loader, LoaderUtils, Matrix4, Mesh, MeshPhongMaterial, TextureLoader } from 'three'; /** * Autodesk 3DS three.js file loader, based on lib3ds. * * Loads geometry with uv and materials basic properties with texture support. * * @class TDSLoader * @constructor */ class TDSLoader extends Loader { constructor( manager ) { super( manager ); this.debug = false; this.group = null; this.materials = []; this.meshes = []; } /** * Load 3ds file from url. * * @method load * @param {[type]} url URL for the file. * @param {Function} onLoad onLoad callback, receives group Object3D as argument. * @param {Function} onProgress onProgress callback. * @param {Function} onError onError callback. */ load( url, onLoad, onProgress, onError ) { const scope = this; const path = ( this.path === '' ) ? LoaderUtils.extractUrlBase( url ) : this.path; const loader = new FileLoader( this.manager ); loader.setPath( this.path ); loader.setResponseType( 'arraybuffer' ); loader.setRequestHeader( this.requestHeader ); loader.setWithCredentials( this.withCredentials ); loader.load( url, function ( data ) { try { onLoad( scope.parse( data, path ) ); } catch ( e ) { if ( onError ) { onError( e ); } else { console.error( e ); } scope.manager.itemError( url ); } }, onProgress, onError ); } /** * Parse arraybuffer data and load 3ds file. * * @method parse * @param {ArrayBuffer} arraybuffer Arraybuffer data to be loaded. * @param {String} path Path for external resources. * @return {Group} Group loaded from 3ds file. */ parse( arraybuffer, path ) { this.group = new Group(); this.materials = []; this.meshes = []; this.readFile( arraybuffer, path ); for ( let i = 0; i < this.meshes.length; i ++ ) { this.group.add( this.meshes[ i ] ); } return this.group; } /** * Decode file content to read 3ds data. * * @method readFile * @param {ArrayBuffer} arraybuffer Arraybuffer data to be loaded. * @param {String} path Path for external resources. */ readFile( arraybuffer, path ) { const data = new DataView( arraybuffer ); const chunk = new Chunk( data, 0, this.debugMessage ); if ( chunk.id === MLIBMAGIC || chunk.id === CMAGIC || chunk.id === M3DMAGIC ) { let next = chunk.readChunk(); while ( next ) { if ( next.id === M3D_VERSION ) { const version = next.readDWord(); this.debugMessage( '3DS file version: ' + version ); } else if ( next.id === MDATA ) { this.readMeshData( next, path ); } else { this.debugMessage( 'Unknown main chunk: ' + next.hexId ); } next = chunk.readChunk(); } } this.debugMessage( 'Parsed ' + this.meshes.length + ' meshes' ); } /** * Read mesh data chunk. * * @method readMeshData * @param {Chunk} chunk to read mesh from * @param {String} path Path for external resources. */ readMeshData( chunk, path ) { let next = chunk.readChunk(); while ( next ) { if ( next.id === MESH_VERSION ) { const version = + next.readDWord(); this.debugMessage( 'Mesh Version: ' + version ); } else if ( next.id === MASTER_SCALE ) { const scale = next.readFloat(); this.debugMessage( 'Master scale: ' + scale ); this.group.scale.set( scale, scale, scale ); } else if ( next.id === NAMED_OBJECT ) { this.debugMessage( 'Named Object' ); this.readNamedObject( next ); } else if ( next.id === MAT_ENTRY ) { this.debugMessage( 'Material' ); this.readMaterialEntry( next, path ); } else { this.debugMessage( 'Unknown MDATA chunk: ' + next.hexId ); } next = chunk.readChunk(); } } /** * Read named object chunk. * * @method readNamedObject * @param {Chunk} chunk Chunk in use. */ readNamedObject( chunk ) { const name = chunk.readString(); let next = chunk.readChunk(); while ( next ) { if ( next.id === N_TRI_OBJECT ) { const mesh = this.readMesh( next ); mesh.name = name; this.meshes.push( mesh ); } else { this.debugMessage( 'Unknown named object chunk: ' + next.hexId ); } next = chunk.readChunk( ); } } /** * Read material data chunk and add it to the material list. * * @method readMaterialEntry * @param {Chunk} chunk Chunk in use. * @param {String} path Path for external resources. */ readMaterialEntry( chunk, path ) { let next = chunk.readChunk(); const material = new MeshPhongMaterial(); while ( next ) { if ( next.id === MAT_NAME ) { material.name = next.readString(); this.debugMessage( ' Name: ' + material.name ); } else if ( next.id === MAT_WIRE ) { this.debugMessage( ' Wireframe' ); material.wireframe = true; } else if ( next.id === MAT_WIRE_SIZE ) { const value = next.readByte(); material.wireframeLinewidth = value; this.debugMessage( ' Wireframe Thickness: ' + value ); } else if ( next.id === MAT_TWO_SIDE ) { material.side = DoubleSide; this.debugMessage( ' DoubleSided' ); } else if ( next.id === MAT_ADDITIVE ) { this.debugMessage( ' Additive Blending' ); material.blending = AdditiveBlending; } else if ( next.id === MAT_DIFFUSE ) { this.debugMessage( ' Diffuse Color' ); material.color = this.readColor( next ); } else if ( next.id === MAT_SPECULAR ) { this.debugMessage( ' Specular Color' ); material.specular = this.readColor( next ); } else if ( next.id === MAT_AMBIENT ) { this.debugMessage( ' Ambient color' ); material.color = this.readColor( next ); } else if ( next.id === MAT_SHININESS ) { const shininess = this.readPercentage( next ); material.shininess = shininess * 100; this.debugMessage( ' Shininess : ' + shininess ); } else if ( next.id === MAT_TRANSPARENCY ) { const transparency = this.readPercentage( next ); material.opacity = 1 - transparency; this.debugMessage( ' Transparency : ' + transparency ); material.transparent = material.opacity < 1 ? true : false; } else if ( next.id === MAT_TEXMAP ) { this.debugMessage( ' ColorMap' ); material.map = this.readMap( next, path ); } else if ( next.id === MAT_BUMPMAP ) { this.debugMessage( ' BumpMap' ); material.bumpMap = this.readMap( next, path ); } else if ( next.id === MAT_OPACMAP ) { this.debugMessage( ' OpacityMap' ); material.alphaMap = this.readMap( next, path ); } else if ( next.id === MAT_SPECMAP ) { this.debugMessage( ' SpecularMap' ); material.specularMap = this.readMap( next, path ); } else { this.debugMessage( ' Unknown material chunk: ' + next.hexId ); } next = chunk.readChunk(); } this.materials[ material.name ] = material; } /** * Read mesh data chunk. * * @method readMesh * @param {Chunk} chunk Chunk in use. * @return {Mesh} The parsed mesh. */ readMesh( chunk ) { let next = chunk.readChunk( ); const geometry = new BufferGeometry(); const material = new MeshPhongMaterial(); const mesh = new Mesh( geometry, material ); mesh.name = 'mesh'; while ( next ) { if ( next.id === POINT_ARRAY ) { const points = next.readWord( ); this.debugMessage( ' Vertex: ' + points ); //BufferGeometry const vertices = []; for ( let i = 0; i < points; i ++ ) { vertices.push( next.readFloat( ) ); vertices.push( next.readFloat( ) ); vertices.push( next.readFloat( ) ); } geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) ); } else if ( next.id === FACE_ARRAY ) { this.readFaceArray( next, mesh ); } else if ( next.id === TEX_VERTS ) { const texels = next.readWord( ); this.debugMessage( ' UV: ' + texels ); //BufferGeometry const uvs = []; for ( let i = 0; i < texels; i ++ ) { uvs.push( next.readFloat( ) ); uvs.push( next.readFloat( ) ); } geometry.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) ); } else if ( next.id === MESH_MATRIX ) { this.debugMessage( ' Tranformation Matrix (TODO)' ); const values = []; for ( let i = 0; i < 12; i ++ ) { values[ i ] = next.readFloat( ); } const matrix = new Matrix4(); //X Line matrix.elements[ 0 ] = values[ 0 ]; matrix.elements[ 1 ] = values[ 6 ]; matrix.elements[ 2 ] = values[ 3 ]; matrix.elements[ 3 ] = values[ 9 ]; //Y Line matrix.elements[ 4 ] = values[ 2 ]; matrix.elements[ 5 ] = values[ 8 ]; matrix.elements[ 6 ] = values[ 5 ]; matrix.elements[ 7 ] = values[ 11 ]; //Z Line matrix.elements[ 8 ] = values[ 1 ]; matrix.elements[ 9 ] = values[ 7 ]; matrix.elements[ 10 ] = values[ 4 ]; matrix.elements[ 11 ] = values[ 10 ]; //W Line matrix.elements[ 12 ] = 0; matrix.elements[ 13 ] = 0; matrix.elements[ 14 ] = 0; matrix.elements[ 15 ] = 1; matrix.transpose(); const inverse = new Matrix4(); inverse.copy( matrix ).invert(); geometry.applyMatrix4( inverse ); matrix.decompose( mesh.position, mesh.quaternion, mesh.scale ); } else { this.debugMessage( ' Unknown mesh chunk: ' + next.hexId ); } next = chunk.readChunk( ); } geometry.computeVertexNormals(); return mesh; } /** * Read face array data chunk. * * @method readFaceArray * @param {Chunk} chunk Chunk in use. * @param {Mesh} mesh Mesh to be filled with the data read. */ readFaceArray( chunk, mesh ) { const faces = chunk.readWord( ); this.debugMessage( ' Faces: ' + faces ); const index = []; for ( let i = 0; i < faces; ++ i ) { index.push( chunk.readWord( ), chunk.readWord( ), chunk.readWord( ) ); chunk.readWord( ); // visibility } mesh.geometry.setIndex( index ); //The rest of the FACE_ARRAY chunk is subchunks let materialIndex = 0; let start = 0; while ( ! chunk.endOfChunk ) { const subchunk = chunk.readChunk( ); if ( subchunk.id === MSH_MAT_GROUP ) { this.debugMessage( ' Material Group' ); const group = this.readMaterialGroup( subchunk ); const count = group.index.length * 3; // assuming successive indices mesh.geometry.addGroup( start, count, materialIndex ); start += count; materialIndex ++; const material = this.materials[ group.name ]; if ( Array.isArray( mesh.material ) === false ) mesh.material = []; if ( material !== undefined ) { mesh.material.push( material ); } } else { this.debugMessage( ' Unknown face array chunk: ' + subchunk.hexId ); } } if ( mesh.material.length === 1 ) mesh.material = mesh.material[ 0 ]; // for backwards compatibility } /** * Read texture map data chunk. * * @method readMap * @param {Chunk} chunk Chunk in use. * @param {String} path Path for external resources. * @return {Texture} Texture read from this data chunk. */ readMap( chunk, path ) { let next = chunk.readChunk( ); let texture = {}; const loader = new TextureLoader( this.manager ); loader.setPath( this.resourcePath || path ).setCrossOrigin( this.crossOrigin ); while ( next ) { if ( next.id === MAT_MAPNAME ) { const name = next.readString(); texture = loader.load( name ); this.debugMessage( ' File: ' + path + name ); } else if ( next.id === MAT_MAP_UOFFSET ) { texture.offset.x = next.readFloat( ); this.debugMessage( ' OffsetX: ' + texture.offset.x ); } else if ( next.id === MAT_MAP_VOFFSET ) { texture.offset.y = next.readFloat( ); this.debugMessage( ' OffsetY: ' + texture.offset.y ); } else if ( next.id === MAT_MAP_USCALE ) { texture.repeat.x = next.readFloat( ); this.debugMessage( ' RepeatX: ' + texture.repeat.x ); } else if ( next.id === MAT_MAP_VSCALE ) { texture.repeat.y = next.readFloat( ); this.debugMessage( ' RepeatY: ' + texture.repeat.y ); } else { this.debugMessage( ' Unknown map chunk: ' + next.hexId ); } next = chunk.readChunk( ); } return texture; } /** * Read material group data chunk. * * @method readMaterialGroup * @param {Chunk} chunk Chunk in use. * @return {Object} Object with name and index of the object. */ readMaterialGroup( chunk ) { const name = chunk.readString(); const numFaces = chunk.readWord(); this.debugMessage( ' Name: ' + name ); this.debugMessage( ' Faces: ' + numFaces ); const index = []; for ( let i = 0; i < numFaces; ++ i ) { index.push( chunk.readWord( ) ); } return { name: name, index: index }; } /** * Read a color value. * * @method readColor * @param {Chunk} chunk Chunk. * @return {Color} Color value read.. */ readColor( chunk ) { const subChunk = chunk.readChunk( ); const color = new Color(); if ( subChunk.id === COLOR_24 || subChunk.id === LIN_COLOR_24 ) { const r = subChunk.readByte( ); const g = subChunk.readByte( ); const b = subChunk.readByte( ); color.setRGB( r / 255, g / 255, b / 255 ); this.debugMessage( ' Color: ' + color.r + ', ' + color.g + ', ' + color.b ); } else if ( subChunk.id === COLOR_F || subChunk.id === LIN_COLOR_F ) { const r = subChunk.readFloat( ); const g = subChunk.readFloat( ); const b = subChunk.readFloat( ); color.setRGB( r, g, b ); this.debugMessage( ' Color: ' + color.r + ', ' + color.g + ', ' + color.b ); } else { this.debugMessage( ' Unknown color chunk: ' + subChunk.hexId ); } return color; } /** * Read percentage value. * * @method readPercentage * @param {Chunk} chunk Chunk to read data from. * @return {Number} Data read from the dataview. */ readPercentage( chunk ) { const subChunk = chunk.readChunk( ); switch ( subChunk.id ) { case INT_PERCENTAGE: return ( subChunk.readShort( ) / 100 ); break; case FLOAT_PERCENTAGE: return subChunk.readFloat( ); break; default: this.debugMessage( ' Unknown percentage chunk: ' + subChunk.hexId ); return 0; } } /** * Print debug message to the console. * * Is controlled by a flag to show or hide debug messages. * * @method debugMessage * @param {Object} message Debug message to print to the console. */ debugMessage( message ) { if ( this.debug ) { console.log( message ); } } } /** Read data/sub-chunks from chunk */ class Chunk { /** * Create a new chunk * * @class Chunk * @param {DataView} data DataView to read from. * @param {Number} position in data. * @param {Function} debugMessage logging callback. */ constructor( data, position, debugMessage ) { this.data = data; // the offset to the begin of this chunk this.offset = position; // the current reading position this.position = position; this.debugMessage = debugMessage; if ( this.debugMessage instanceof Function ) { this.debugMessage = function () {}; } this.id = this.readWord(); this.size = this.readDWord(); this.end = this.offset + this.size; if ( this.end > data.byteLength ) { this.debugMessage( 'Bad chunk size for chunk at ' + position ); } } /** * read a sub cchunk. * * @method readChunk * @return {Chunk | null} next sub chunk */ readChunk() { if ( this.endOfChunk ) { return null; } try { const next = new Chunk( this.data, this.position, this.debugMessage ); this.position += next.size; return next; } catch ( e ) { this.debugMessage( 'Unable to read chunk at ' + this.position ); return null; } } /** * return the ID of this chunk as Hex * * @method idToString * @return {String} hex-string of id */ get hexId() { return this.id.toString( 16 ); } get endOfChunk() { return this.position >= this.end; } /** * Read byte value. * * @method readByte * @return {Number} Data read from the dataview. */ readByte() { const v = this.data.getUint8( this.position, true ); this.position += 1; return v; } /** * Read 32 bit float value. * * @method readFloat * @return {Number} Data read from the dataview. */ readFloat() { try { const v = this.data.getFloat32( this.position, true ); this.position += 4; return v; } catch ( e ) { this.debugMessage( e + ' ' + this.position + ' ' + this.data.byteLength ); return 0; } } /** * Read 32 bit signed integer value. * * @method readInt * @return {Number} Data read from the dataview. */ readInt() { const v = this.data.getInt32( this.position, true ); this.position += 4; return v; } /** * Read 16 bit signed integer value. * * @method readShort * @return {Number} Data read from the dataview. */ readShort() { const v = this.data.getInt16( this.position, true ); this.position += 2; return v; } /** * Read 64 bit unsigned integer value. * * @method readDWord * @return {Number} Data read from the dataview. */ readDWord() { const v = this.data.getUint32( this.position, true ); this.position += 4; return v; } /** * Read 32 bit unsigned integer value. * * @method readWord * @return {Number} Data read from the dataview. */ readWord() { const v = this.data.getUint16( this.position, true ); this.position += 2; return v; } /** * Read NULL terminated ASCII string value from chunk-pos. * * @method readString * @return {String} Data read from the dataview. */ readString() { let s = ''; let c = this.readByte(); while ( c ) { s += String.fromCharCode( c ); c = this.readByte(); } return s; } } // const NULL_CHUNK = 0x0000; const M3DMAGIC = 0x4D4D; // const SMAGIC = 0x2D2D; // const LMAGIC = 0x2D3D; const MLIBMAGIC = 0x3DAA; // const MATMAGIC = 0x3DFF; const CMAGIC = 0xC23D; const M3D_VERSION = 0x0002; // const M3D_KFVERSION = 0x0005; const COLOR_F = 0x0010; const COLOR_24 = 0x0011; const LIN_COLOR_24 = 0x0012; const LIN_COLOR_F = 0x0013; const INT_PERCENTAGE = 0x0030; const FLOAT_PERCENTAGE = 0x0031; const MDATA = 0x3D3D; const MESH_VERSION = 0x3D3E; const MASTER_SCALE = 0x0100; // const LO_SHADOW_BIAS = 0x1400; // const HI_SHADOW_BIAS = 0x1410; // const SHADOW_MAP_SIZE = 0x1420; // const SHADOW_SAMPLES = 0x1430; // const SHADOW_RANGE = 0x1440; // const SHADOW_FILTER = 0x1450; // const RAY_BIAS = 0x1460; // const O_CONSTS = 0x1500; // const AMBIENT_LIGHT = 0x2100; // const BIT_MAP = 0x1100; // const SOLID_BGND = 0x1200; // const V_GRADIENT = 0x1300; // const USE_BIT_MAP = 0x1101; // const USE_SOLID_BGND = 0x1201; // const USE_V_GRADIENT = 0x1301; // const FOG = 0x2200; // const FOG_BGND = 0x2210; // const LAYER_FOG = 0x2302; // const DISTANCE_CUE = 0x2300; // const DCUE_BGND = 0x2310; // const USE_FOG = 0x2201; // const USE_LAYER_FOG = 0x2303; // const USE_DISTANCE_CUE = 0x2301; const MAT_ENTRY = 0xAFFF; const MAT_NAME = 0xA000; const MAT_AMBIENT = 0xA010; const MAT_DIFFUSE = 0xA020; const MAT_SPECULAR = 0xA030; const MAT_SHININESS = 0xA040; // const MAT_SHIN2PCT = 0xA041; const MAT_TRANSPARENCY = 0xA050; // const MAT_XPFALL = 0xA052; // const MAT_USE_XPFALL = 0xA240; // const MAT_REFBLUR = 0xA053; // const MAT_SHADING = 0xA100; // const MAT_USE_REFBLUR = 0xA250; // const MAT_SELF_ILLUM = 0xA084; const MAT_TWO_SIDE = 0xA081; // const MAT_DECAL = 0xA082; const MAT_ADDITIVE = 0xA083; const MAT_WIRE = 0xA085; // const MAT_FACEMAP = 0xA088; // const MAT_TRANSFALLOFF_IN = 0xA08A; // const MAT_PHONGSOFT = 0xA08C; // const MAT_WIREABS = 0xA08E; const MAT_WIRE_SIZE = 0xA087; const MAT_TEXMAP = 0xA200; // const MAT_SXP_TEXT_DATA = 0xA320; // const MAT_TEXMASK = 0xA33E; // const MAT_SXP_TEXTMASK_DATA = 0xA32A; // const MAT_TEX2MAP = 0xA33A; // const MAT_SXP_TEXT2_DATA = 0xA321; // const MAT_TEX2MASK = 0xA340; // const MAT_SXP_TEXT2MASK_DATA = 0xA32C; const MAT_OPACMAP = 0xA210; // const MAT_SXP_OPAC_DATA = 0xA322; // const MAT_OPACMASK = 0xA342; // const MAT_SXP_OPACMASK_DATA = 0xA32E; const MAT_BUMPMAP = 0xA230; // const MAT_SXP_BUMP_DATA = 0xA324; // const MAT_BUMPMASK = 0xA344; // const MAT_SXP_BUMPMASK_DATA = 0xA330; const MAT_SPECMAP = 0xA204; // const MAT_SXP_SPEC_DATA = 0xA325; // const MAT_SPECMASK = 0xA348; // const MAT_SXP_SPECMASK_DATA = 0xA332; // const MAT_SHINMAP = 0xA33C; // const MAT_SXP_SHIN_DATA = 0xA326; // const MAT_SHINMASK = 0xA346; // const MAT_SXP_SHINMASK_DATA = 0xA334; // const MAT_SELFIMAP = 0xA33D; // const MAT_SXP_SELFI_DATA = 0xA328; // const MAT_SELFIMASK = 0xA34A; // const MAT_SXP_SELFIMASK_DATA = 0xA336; // const MAT_REFLMAP = 0xA220; // const MAT_REFLMASK = 0xA34C; // const MAT_SXP_REFLMASK_DATA = 0xA338; // const MAT_ACUBIC = 0xA310; const MAT_MAPNAME = 0xA300; // const MAT_MAP_TILING = 0xA351; // const MAT_MAP_TEXBLUR = 0xA353; const MAT_MAP_USCALE = 0xA354; const MAT_MAP_VSCALE = 0xA356; const MAT_MAP_UOFFSET = 0xA358; const MAT_MAP_VOFFSET = 0xA35A; // const MAT_MAP_ANG = 0xA35C; // const MAT_MAP_COL1 = 0xA360; // const MAT_MAP_COL2 = 0xA362; // const MAT_MAP_RCOL = 0xA364; // const MAT_MAP_GCOL = 0xA366; // const MAT_MAP_BCOL = 0xA368; const NAMED_OBJECT = 0x4000; // const N_DIRECT_LIGHT = 0x4600; // const DL_OFF = 0x4620; // const DL_OUTER_RANGE = 0x465A; // const DL_INNER_RANGE = 0x4659; // const DL_MULTIPLIER = 0x465B; // const DL_EXCLUDE = 0x4654; // const DL_ATTENUATE = 0x4625; // const DL_SPOTLIGHT = 0x4610; // const DL_SPOT_ROLL = 0x4656; // const DL_SHADOWED = 0x4630; // const DL_LOCAL_SHADOW2 = 0x4641; // const DL_SEE_CONE = 0x4650; // const DL_SPOT_RECTANGULAR = 0x4651; // const DL_SPOT_ASPECT = 0x4657; // const DL_SPOT_PROJECTOR = 0x4653; // const DL_SPOT_OVERSHOOT = 0x4652; // const DL_RAY_BIAS = 0x4658; // const DL_RAYSHAD = 0x4627; // const N_CAMERA = 0x4700; // const CAM_SEE_CONE = 0x4710; // const CAM_RANGES = 0x4720; // const OBJ_HIDDEN = 0x4010; // const OBJ_VIS_LOFTER = 0x4011; // const OBJ_DOESNT_CAST = 0x4012; // const OBJ_DONT_RECVSHADOW = 0x4017; // const OBJ_MATTE = 0x4013; // const OBJ_FAST = 0x4014; // const OBJ_PROCEDURAL = 0x4015; // const OBJ_FROZEN = 0x4016; const N_TRI_OBJECT = 0x4100; const POINT_ARRAY = 0x4110; // const POINT_FLAG_ARRAY = 0x4111; const FACE_ARRAY = 0x4120; const MSH_MAT_GROUP = 0x4130; // const SMOOTH_GROUP = 0x4150; // const MSH_BOXMAP = 0x4190; const TEX_VERTS = 0x4140; const MESH_MATRIX = 0x4160; // const MESH_COLOR = 0x4165; // const MESH_TEXTURE_INFO = 0x4170; // const KFDATA = 0xB000; // const KFHDR = 0xB00A; // const KFSEG = 0xB008; // const KFCURTIME = 0xB009; // const AMBIENT_NODE_TAG = 0xB001; // const OBJECT_NODE_TAG = 0xB002; // const CAMERA_NODE_TAG = 0xB003; // const TARGET_NODE_TAG = 0xB004; // const LIGHT_NODE_TAG = 0xB005; // const L_TARGET_NODE_TAG = 0xB006; // const SPOTLIGHT_NODE_TAG = 0xB007; // const NODE_ID = 0xB030; // const NODE_HDR = 0xB010; // const PIVOT = 0xB013; // const INSTANCE_NAME = 0xB011; // const MORPH_SMOOTH = 0xB015; // const BOUNDBOX = 0xB014; // const POS_TRACK_TAG = 0xB020; // const COL_TRACK_TAG = 0xB025; // const ROT_TRACK_TAG = 0xB021; // const SCL_TRACK_TAG = 0xB022; // const MORPH_TRACK_TAG = 0xB026; // const FOV_TRACK_TAG = 0xB023; // const ROLL_TRACK_TAG = 0xB024; // const HOT_TRACK_TAG = 0xB027; // const FALL_TRACK_TAG = 0xB028; // const HIDE_TRACK_TAG = 0xB029; // const POLY_2D = 0x5000; // const SHAPE_OK = 0x5010; // const SHAPE_NOT_OK = 0x5011; // const SHAPE_HOOK = 0x5020; // const PATH_3D = 0x6000; // const PATH_MATRIX = 0x6005; // const SHAPE_2D = 0x6010; // const M_SCALE = 0x6020; // const M_TWIST = 0x6030; // const M_TEETER = 0x6040; // const M_FIT = 0x6050; // const M_BEVEL = 0x6060; // const XZ_CURVE = 0x6070; // const YZ_CURVE = 0x6080; // const INTERPCT = 0x6090; // const DEFORM_LIMIT = 0x60A0; // const USE_CONTOUR = 0x6100; // const USE_TWEEN = 0x6110; // const USE_SCALE = 0x6120; // const USE_TWIST = 0x6130; // const USE_TEETER = 0x6140; // const USE_FIT = 0x6150; // const USE_BEVEL = 0x6160; // const DEFAULT_VIEW = 0x3000; // const VIEW_TOP = 0x3010; // const VIEW_BOTTOM = 0x3020; // const VIEW_LEFT = 0x3030; // const VIEW_RIGHT = 0x3040; // const VIEW_FRONT = 0x3050; // const VIEW_BACK = 0x3060; // const VIEW_USER = 0x3070; // const VIEW_CAMERA = 0x3080; // const VIEW_WINDOW = 0x3090; // const VIEWPORT_LAYOUT_OLD = 0x7000; // const VIEWPORT_DATA_OLD = 0x7010; // const VIEWPORT_LAYOUT = 0x7001; // const VIEWPORT_DATA = 0x7011; // const VIEWPORT_DATA_3 = 0x7012; // const VIEWPORT_SIZE = 0x7020; // const NETWORK_VIEW = 0x7030; export { TDSLoader };"},{"title":"","date":"2023-10-12T14:08:40.745Z","updated":"2023-10-12T14:08:40.745Z","comments":true,"path":"js/three/jsm/loaders/TGALoader.js","permalink":"http://19999997.xyz/js/three/jsm/loaders/TGALoader.js","excerpt":"","text":"import { DataTextureLoader, LinearMipmapLinearFilter } from 'three'; class TGALoader extends DataTextureLoader { constructor( manager ) { super( manager ); } parse( buffer ) { // reference from vthibault, https://github.com/vthibault/roBrowser/blob/master/src/Loaders/Targa.js function tgaCheckHeader( header ) { switch ( header.image_type ) { // check indexed type case TGA_TYPE_INDEXED: case TGA_TYPE_RLE_INDEXED: if ( header.colormap_length > 256 || header.colormap_size !== 24 || header.colormap_type !== 1 ) { throw new Error( 'THREE.TGALoader: Invalid type colormap data for indexed type.' ); } break; // check colormap type case TGA_TYPE_RGB: case TGA_TYPE_GREY: case TGA_TYPE_RLE_RGB: case TGA_TYPE_RLE_GREY: if ( header.colormap_type ) { throw new Error( 'THREE.TGALoader: Invalid type colormap data for colormap type.' ); } break; // What the need of a file without data ? case TGA_TYPE_NO_DATA: throw new Error( 'THREE.TGALoader: No data.' ); // Invalid type ? default: throw new Error( 'THREE.TGALoader: Invalid type ' + header.image_type ); } // check image width and height if ( header.width 3; const pixel_total = header.width * header.height * pixel_size; // read palettes if ( use_pal ) { palettes = data.subarray( offset, offset += header.colormap_length * ( header.colormap_size >> 3 ) ); } // read RLE if ( use_rle ) { pixel_data = new Uint8Array( pixel_total ); let c, count, i; let shift = 0; const pixels = new Uint8Array( pixel_size ); while ( shift < pixel_total ) { c = data[ offset ++ ]; count = ( c & 0x7f ) + 1; // RLE pixels if ( c & 0x80 ) { // bind pixel tmp array for ( i = 0; i < pixel_size; ++ i ) { pixels[ i ] = data[ offset ++ ]; } // copy pixel array for ( i = 0; i < count; ++ i ) { pixel_data.set( pixels, shift + i * pixel_size ); } shift += pixel_size * count; } else { // raw pixels count *= pixel_size; for ( i = 0; i < count; ++ i ) { pixel_data[ shift + i ] = data[ offset ++ ]; } shift += count; } } } else { // raw pixels pixel_data = data.subarray( offset, offset += ( use_pal ? header.width * header.height : pixel_total ) ); } return { pixel_data: pixel_data, palettes: palettes }; } function tgaGetImageData8bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image, palettes ) { const colormap = palettes; let color, i = 0, x, y; const width = header.width; for ( y = y_start; y !== y_end; y += y_step ) { for ( x = x_start; x !== x_end; x += x_step, i ++ ) { color = image[ i ]; imageData[ ( x + width * y ) * 4 + 3 ] = 255; imageData[ ( x + width * y ) * 4 + 2 ] = colormap[ ( color * 3 ) + 0 ]; imageData[ ( x + width * y ) * 4 + 1 ] = colormap[ ( color * 3 ) + 1 ]; imageData[ ( x + width * y ) * 4 + 0 ] = colormap[ ( color * 3 ) + 2 ]; } } return imageData; } function tgaGetImageData16bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) { let color, i = 0, x, y; const width = header.width; for ( y = y_start; y !== y_end; y += y_step ) { for ( x = x_start; x !== x_end; x += x_step, i += 2 ) { color = image[ i + 0 ] + ( image[ i + 1 ] < 8 ); imageData[ ( x + width * y ) * 4 + 0 ] = ( color & 0x7C00 ) >> 7; imageData[ ( x + width * y ) * 4 + 1 ] = ( color & 0x03E0 ) >> 2; imageData[ ( x + width * y ) * 4 + 2 ] = ( color & 0x001F ) < 3; imageData[ ( x + width * y ) * 4 + 3 ] = ( color & 0x8000 ) ? 0 : 255; } } return imageData; } function tgaGetImageData24bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) { let i = 0, x, y; const width = header.width; for ( y = y_start; y !== y_end; y += y_step ) { for ( x = x_start; x !== x_end; x += x_step, i += 3 ) { imageData[ ( x + width * y ) * 4 + 3 ] = 255; imageData[ ( x + width * y ) * 4 + 2 ] = image[ i + 0 ]; imageData[ ( x + width * y ) * 4 + 1 ] = image[ i + 1 ]; imageData[ ( x + width * y ) * 4 + 0 ] = image[ i + 2 ]; } } return imageData; } function tgaGetImageData32bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) { let i = 0, x, y; const width = header.width; for ( y = y_start; y !== y_end; y += y_step ) { for ( x = x_start; x !== x_end; x += x_step, i += 4 ) { imageData[ ( x + width * y ) * 4 + 2 ] = image[ i + 0 ]; imageData[ ( x + width * y ) * 4 + 1 ] = image[ i + 1 ]; imageData[ ( x + width * y ) * 4 + 0 ] = image[ i + 2 ]; imageData[ ( x + width * y ) * 4 + 3 ] = image[ i + 3 ]; } } return imageData; } function tgaGetImageDataGrey8bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) { let color, i = 0, x, y; const width = header.width; for ( y = y_start; y !== y_end; y += y_step ) { for ( x = x_start; x !== x_end; x += x_step, i ++ ) { color = image[ i ]; imageData[ ( x + width * y ) * 4 + 0 ] = color; imageData[ ( x + width * y ) * 4 + 1 ] = color; imageData[ ( x + width * y ) * 4 + 2 ] = color; imageData[ ( x + width * y ) * 4 + 3 ] = 255; } } return imageData; } function tgaGetImageDataGrey16bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) { let i = 0, x, y; const width = header.width; for ( y = y_start; y !== y_end; y += y_step ) { for ( x = x_start; x !== x_end; x += x_step, i += 2 ) { imageData[ ( x + width * y ) * 4 + 0 ] = image[ i + 0 ]; imageData[ ( x + width * y ) * 4 + 1 ] = image[ i + 0 ]; imageData[ ( x + width * y ) * 4 + 2 ] = image[ i + 0 ]; imageData[ ( x + width * y ) * 4 + 3 ] = image[ i + 1 ]; } } return imageData; } function getTgaRGBA( data, width, height, image, palette ) { let x_start, y_start, x_step, y_step, x_end, y_end; switch ( ( header.flags & TGA_ORIGIN_MASK ) >> TGA_ORIGIN_SHIFT ) { default: case TGA_ORIGIN_UL: x_start = 0; x_step = 1; x_end = width; y_start = 0; y_step = 1; y_end = height; break; case TGA_ORIGIN_BL: x_start = 0; x_step = 1; x_end = width; y_start = height - 1; y_step = - 1; y_end = - 1; break; case TGA_ORIGIN_UR: x_start = width - 1; x_step = - 1; x_end = - 1; y_start = 0; y_step = 1; y_end = height; break; case TGA_ORIGIN_BR: x_start = width - 1; x_step = - 1; x_end = - 1; y_start = height - 1; y_step = - 1; y_end = - 1; break; } if ( use_grey ) { switch ( header.pixel_size ) { case 8: tgaGetImageDataGrey8bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image ); break; case 16: tgaGetImageDataGrey16bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image ); break; default: throw new Error( 'THREE.TGALoader: Format not supported.' ); break; } } else { switch ( header.pixel_size ) { case 8: tgaGetImageData8bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image, palette ); break; case 16: tgaGetImageData16bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image ); break; case 24: tgaGetImageData24bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image ); break; case 32: tgaGetImageData32bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image ); break; default: throw new Error( 'THREE.TGALoader: Format not supported.' ); break; } } // Load image data according to specific method // let func = 'tgaGetImageData' + (use_grey ? 'Grey' : '') + (header.pixel_size) + 'bits'; // func(data, y_start, y_step, y_end, x_start, x_step, x_end, width, image, palette ); return data; } // TGA constants const TGA_TYPE_NO_DATA = 0, TGA_TYPE_INDEXED = 1, TGA_TYPE_RGB = 2, TGA_TYPE_GREY = 3, TGA_TYPE_RLE_INDEXED = 9, TGA_TYPE_RLE_RGB = 10, TGA_TYPE_RLE_GREY = 11, TGA_ORIGIN_MASK = 0x30, TGA_ORIGIN_SHIFT = 0x04, TGA_ORIGIN_BL = 0x00, TGA_ORIGIN_BR = 0x01, TGA_ORIGIN_UL = 0x02, TGA_ORIGIN_UR = 0x03; if ( buffer.length < 19 ) throw new Error( 'THREE.TGALoader: Not enough data to contain header.' ); let offset = 0; const content = new Uint8Array( buffer ), header = { id_length: content[ offset ++ ], colormap_type: content[ offset ++ ], image_type: content[ offset ++ ], colormap_index: content[ offset ++ ] | content[ offset ++ ] < 8, colormap_length: content[ offset ++ ] | content[ offset ++ ] < 8, colormap_size: content[ offset ++ ], origin: [ content[ offset ++ ] | content[ offset ++ ] < 8, content[ offset ++ ] | content[ offset ++ ] < 8 ], width: content[ offset ++ ] | content[ offset ++ ] < 8, height: content[ offset ++ ] | content[ offset ++ ] < 8, pixel_size: content[ offset ++ ], flags: content[ offset ++ ] }; // check tga if it is valid format tgaCheckHeader( header ); if ( header.id_length + offset > buffer.length ) { throw new Error( 'THREE.TGALoader: No data.' ); } // skip the needn't data offset += header.id_length; // get targa information about RLE compression and palette let use_rle = false, use_pal = false, use_grey = false; switch ( header.image_type ) { case TGA_TYPE_RLE_INDEXED: use_rle = true; use_pal = true; break; case TGA_TYPE_INDEXED: use_pal = true; break; case TGA_TYPE_RLE_RGB: use_rle = true; break; case TGA_TYPE_RGB: break; case TGA_TYPE_RLE_GREY: use_rle = true; use_grey = true; break; case TGA_TYPE_GREY: use_grey = true; break; } // const imageData = new Uint8Array( header.width * header.height * 4 ); const result = tgaParse( use_rle, use_pal, header, offset, content ); getTgaRGBA( imageData, header.width, header.height, result.pixel_data, result.palettes ); return { data: imageData, width: header.width, height: header.height, flipY: true, generateMipmaps: true, minFilter: LinearMipmapLinearFilter, }; } } export { TGALoader };"},{"title":"","date":"2023-10-12T14:08:40.750Z","updated":"2023-10-12T14:08:40.750Z","comments":true,"path":"js/three/jsm/loaders/TTFLoader.js","permalink":"http://19999997.xyz/js/three/jsm/loaders/TTFLoader.js","excerpt":"","text":"import { FileLoader, Loader } from 'three'; import opentype from '../libs/opentype.module.js'; /** * Requires opentype.js to be included in the project. * Loads TTF files and converts them into typeface JSON that can be used directly * to create THREE.Font objects. */ class TTFLoader extends Loader { constructor( manager ) { super( manager ); this.reversed = false; } load( url, onLoad, onProgress, onError ) { const scope = this; const loader = new FileLoader( this.manager ); loader.setPath( this.path ); loader.setResponseType( 'arraybuffer' ); loader.setRequestHeader( this.requestHeader ); loader.setWithCredentials( this.withCredentials ); loader.load( url, function ( buffer ) { try { onLoad( scope.parse( buffer ) ); } catch ( e ) { if ( onError ) { onError( e ); } else { console.error( e ); } scope.manager.itemError( url ); } }, onProgress, onError ); } parse( arraybuffer ) { function convert( font, reversed ) { const round = Math.round; const glyphs = {}; const scale = ( 100000 ) / ( ( font.unitsPerEm || 2048 ) * 72 ); const glyphIndexMap = font.encoding.cmap.glyphIndexMap; const unicodes = Object.keys( glyphIndexMap ); for ( let i = 0; i < unicodes.length; i ++ ) { const unicode = unicodes[ i ]; const glyph = font.glyphs.glyphs[ glyphIndexMap[ unicode ] ]; if ( unicode !== undefined ) { const token = { ha: round( glyph.advanceWidth * scale ), x_min: round( glyph.xMin * scale ), x_max: round( glyph.xMax * scale ), o: '' }; if ( reversed ) { glyph.path.commands = reverseCommands( glyph.path.commands ); } glyph.path.commands.forEach( function ( command ) { if ( command.type.toLowerCase() === 'c' ) { command.type = 'b'; } token.o += command.type.toLowerCase() + ' '; if ( command.x !== undefined && command.y !== undefined ) { token.o += round( command.x * scale ) + ' ' + round( command.y * scale ) + ' '; } if ( command.x1 !== undefined && command.y1 !== undefined ) { token.o += round( command.x1 * scale ) + ' ' + round( command.y1 * scale ) + ' '; } if ( command.x2 !== undefined && command.y2 !== undefined ) { token.o += round( command.x2 * scale ) + ' ' + round( command.y2 * scale ) + ' '; } } ); glyphs[ String.fromCodePoint( glyph.unicode ) ] = token; } } return { glyphs: glyphs, familyName: font.getEnglishName( 'fullName' ), ascender: round( font.ascender * scale ), descender: round( font.descender * scale ), underlinePosition: font.tables.post.underlinePosition, underlineThickness: font.tables.post.underlineThickness, boundingBox: { xMin: font.tables.head.xMin, xMax: font.tables.head.xMax, yMin: font.tables.head.yMin, yMax: font.tables.head.yMax }, resolution: 1000, original_font_information: font.tables.name }; } function reverseCommands( commands ) { const paths = []; let path; commands.forEach( function ( c ) { if ( c.type.toLowerCase() === 'm' ) { path = [ c ]; paths.push( path ); } else if ( c.type.toLowerCase() !== 'z' ) { path.push( c ); } } ); const reversed = []; paths.forEach( function ( p ) { const result = { type: 'm', x: p[ p.length - 1 ].x, y: p[ p.length - 1 ].y }; reversed.push( result ); for ( let i = p.length - 1; i > 0; i -- ) { const command = p[ i ]; const result = { type: command.type }; if ( command.x2 !== undefined && command.y2 !== undefined ) { result.x1 = command.x2; result.y1 = command.y2; result.x2 = command.x1; result.y2 = command.y1; } else if ( command.x1 !== undefined && command.y1 !== undefined ) { result.x1 = command.x1; result.y1 = command.y1; } result.x = p[ i - 1 ].x; result.y = p[ i - 1 ].y; reversed.push( result ); } } ); return reversed; } return convert( opentype.parse( arraybuffer ), this.reversed ); } } export { TTFLoader };"},{"title":"","date":"2023-10-12T14:08:40.753Z","updated":"2023-10-12T14:08:40.753Z","comments":true,"path":"js/three/jsm/loaders/TiltLoader.js","permalink":"http://19999997.xyz/js/three/jsm/loaders/TiltLoader.js","excerpt":"","text":"import { BufferAttribute, BufferGeometry, Color, DoubleSide, FileLoader, Group, Loader, Mesh, MeshBasicMaterial, RawShaderMaterial, TextureLoader, Quaternion, Vector3 } from 'three'; import * as fflate from '../libs/fflate.module.js'; class TiltLoader extends Loader { load( url, onLoad, onProgress, onError ) { const scope = this; const loader = new FileLoader( this.manager ); loader.setPath( this.path ); loader.setResponseType( 'arraybuffer' ); loader.setWithCredentials( this.withCredentials ); loader.load( url, function ( buffer ) { try { onLoad( scope.parse( buffer ) ); } catch ( e ) { if ( onError ) { onError( e ); } else { console.error( e ); } scope.manager.itemError( url ); } }, onProgress, onError ); } parse( buffer ) { const group = new Group(); // https://docs.google.com/document/d/11ZsHozYn9FnWG7y3s3WAyKIACfbfwb4PbaS8cZ_xjvo/edit# const zip = fflate.unzipSync( new Uint8Array( buffer.slice( 16 ) ) ); /* const thumbnail = zip[ 'thumbnail.png' ].buffer; const img = document.createElement( 'img' ); img.src = URL.createObjectURL( new Blob( [ thumbnail ] ) ); document.body.appendChild( img ); */ const metadata = JSON.parse( fflate.strFromU8( zip[ 'metadata.json' ] ) ); /* const blob = new Blob( [ zip[ 'data.sketch' ].buffer ], { type: 'application/octet-stream' } ); window.open( URL.createObjectURL( blob ) ); */ const data = new DataView( zip[ 'data.sketch' ].buffer ); const num_strokes = data.getInt32( 16, true ); const brushes = {}; let offset = 20; for ( let i = 0; i < num_strokes; i ++ ) { const brush_index = data.getInt32( offset, true ); const brush_color = [ data.getFloat32( offset + 4, true ), data.getFloat32( offset + 8, true ), data.getFloat32( offset + 12, true ), data.getFloat32( offset + 16, true ) ]; const brush_size = data.getFloat32( offset + 20, true ); const stroke_mask = data.getUint32( offset + 24, true ); const controlpoint_mask = data.getUint32( offset + 28, true ); let offset_stroke_mask = 0; let offset_controlpoint_mask = 0; for ( let j = 0; j < 4; j ++ ) { // TOFIX: I don't understand these masks yet const byte = 1 < j; if ( ( stroke_mask & byte ) > 0 ) offset_stroke_mask += 4; if ( ( controlpoint_mask & byte ) > 0 ) offset_controlpoint_mask += 4; } // console.log( { brush_index, brush_color, brush_size, stroke_mask, controlpoint_mask } ); // console.log( offset_stroke_mask, offset_controlpoint_mask ); offset = offset + 28 + offset_stroke_mask + 4; // TOFIX: This is wrong const num_control_points = data.getInt32( offset, true ); // console.log( { num_control_points } ); const positions = new Float32Array( num_control_points * 3 ); const quaternions = new Float32Array( num_control_points * 4 ); offset = offset + 4; for ( let j = 0, k = 0; j < positions.length; j += 3, k += 4 ) { positions[ j + 0 ] = data.getFloat32( offset + 0, true ); positions[ j + 1 ] = data.getFloat32( offset + 4, true ); positions[ j + 2 ] = data.getFloat32( offset + 8, true ); quaternions[ k + 0 ] = data.getFloat32( offset + 12, true ); quaternions[ k + 1 ] = data.getFloat32( offset + 16, true ); quaternions[ k + 2 ] = data.getFloat32( offset + 20, true ); quaternions[ k + 3 ] = data.getFloat32( offset + 24, true ); offset = offset + 28 + offset_controlpoint_mask; // TOFIX: This is wrong } if ( brush_index in brushes === false ) { brushes[ brush_index ] = []; } brushes[ brush_index ].push( [ positions, quaternions, brush_size, brush_color ] ); } for ( const brush_index in brushes ) { const geometry = new StrokeGeometry( brushes[ brush_index ] ); const material = getMaterial( metadata.BrushIndex[ brush_index ] ); group.add( new Mesh( geometry, material ) ); } return group; } } class StrokeGeometry extends BufferGeometry { constructor( strokes ) { super(); const vertices = []; const colors = []; const uvs = []; const position = new Vector3(); const prevPosition = new Vector3(); const quaternion = new Quaternion(); const prevQuaternion = new Quaternion(); const vector1 = new Vector3(); const vector2 = new Vector3(); const vector3 = new Vector3(); const vector4 = new Vector3(); const color = new Color(); // size = size / 2; for ( const k in strokes ) { const stroke = strokes[ k ]; const positions = stroke[ 0 ]; const quaternions = stroke[ 1 ]; const size = stroke[ 2 ]; const rgba = stroke[ 3 ]; const alpha = stroke[ 3 ][ 3 ]; color.fromArray( rgba ).convertSRGBToLinear(); prevPosition.fromArray( positions, 0 ); prevQuaternion.fromArray( quaternions, 0 ); for ( let i = 3, j = 4, l = positions.length; i < l; i += 3, j += 4 ) { position.fromArray( positions, i ); quaternion.fromArray( quaternions, j ); vector1.set( - size, 0, 0 ); vector1.applyQuaternion( quaternion ); vector1.add( position ); vector2.set( size, 0, 0 ); vector2.applyQuaternion( quaternion ); vector2.add( position ); vector3.set( size, 0, 0 ); vector3.applyQuaternion( prevQuaternion ); vector3.add( prevPosition ); vector4.set( - size, 0, 0 ); vector4.applyQuaternion( prevQuaternion ); vector4.add( prevPosition ); vertices.push( vector1.x, vector1.y, - vector1.z ); vertices.push( vector2.x, vector2.y, - vector2.z ); vertices.push( vector4.x, vector4.y, - vector4.z ); vertices.push( vector2.x, vector2.y, - vector2.z ); vertices.push( vector3.x, vector3.y, - vector3.z ); vertices.push( vector4.x, vector4.y, - vector4.z ); prevPosition.copy( position ); prevQuaternion.copy( quaternion ); colors.push( ...color, alpha ); colors.push( ...color, alpha ); colors.push( ...color, alpha ); colors.push( ...color, alpha ); colors.push( ...color, alpha ); colors.push( ...color, alpha ); const p1 = i / l; const p2 = ( i - 3 ) / l; uvs.push( p1, 0 ); uvs.push( p1, 1 ); uvs.push( p2, 0 ); uvs.push( p1, 1 ); uvs.push( p2, 1 ); uvs.push( p2, 0 ); } } this.setAttribute( 'position', new BufferAttribute( new Float32Array( vertices ), 3 ) ); this.setAttribute( 'color', new BufferAttribute( new Float32Array( colors ), 4 ) ); this.setAttribute( 'uv', new BufferAttribute( new Float32Array( uvs ), 2 ) ); } } const BRUSH_LIST_ARRAY = { '89d104cd-d012-426b-b5b3-bbaee63ac43c': 'Bubbles', '700f3aa8-9a7c-2384-8b8a-ea028905dd8c': 'CelVinyl', '0f0ff7b2-a677-45eb-a7d6-0cd7206f4816': 'ChromaticWave', '1161af82-50cf-47db-9706-0c3576d43c43': 'CoarseBristles', '79168f10-6961-464a-8be1-57ed364c5600': 'CoarseBristlesSingleSided', '1caa6d7d-f015-3f54-3a4b-8b5354d39f81': 'Comet', 'c8313697-2563-47fc-832e-290f4c04b901': 'DiamondHull', '4391aaaa-df73-4396-9e33-31e4e4930b27': 'Disco', 'd1d991f2-e7a0-4cf1-b328-f57e915e6260': 'DotMarker', '6a1cf9f9-032c-45ec-9b1d-a6680bee30f7': 'Dots', '0d3889f3-3ede-470c-8af4-f44813306126': 'DoubleTaperedFlat', '0d3889f3-3ede-470c-8af4-de4813306126': 'DoubleTaperedMarker', 'd0262945-853c-4481-9cbd-88586bed93cb': 'DuctTape', '3ca16e2f-bdcd-4da2-8631-dcef342f40f1': 'DuctTapeSingleSided', 'f6e85de3-6dcc-4e7f-87fd-cee8c3d25d51': 'Electricity', '02ffb866-7fb2-4d15-b761-1012cefb1360': 'Embers', 'cb92b597-94ca-4255-b017-0e3f42f12f9e': 'Fire', '2d35bcf0-e4d8-452c-97b1-3311be063130': 'Flat', '55303bc4-c749-4a72-98d9-d23e68e76e18': 'FlatDeprecated', '280c0a7a-aad8-416c-a7d2-df63d129ca70': 'FlatSingleSided', 'cf019139-d41c-4eb0-a1d0-5cf54b0a42f3': 'Highlighter', '6a1cf9f9-032c-45ec-9b6e-a6680bee32e9': 'HyperGrid', 'dce872c2-7b49-4684-b59b-c45387949c5c': 'Hypercolor', 'e8ef32b1-baa8-460a-9c2c-9cf8506794f5': 'HypercolorSingleSided', '2f212815-f4d3-c1a4-681a-feeaf9c6dc37': 'Icing', 'f5c336cf-5108-4b40-ade9-c687504385ab': 'Ink', 'c0012095-3ffd-4040-8ee1-fc180d346eaa': 'InkSingleSided', '4a76a27a-44d8-4bfe-9a8c-713749a499b0': 'Leaves', 'ea19de07-d0c0-4484-9198-18489a3c1487': 'LeavesSingleSided', '2241cd32-8ba2-48a5-9ee7-2caef7e9ed62': 'Light', '4391aaaa-df81-4396-9e33-31e4e4930b27': 'LightWire', 'd381e0f5-3def-4a0d-8853-31e9200bcbda': 'Lofted', '429ed64a-4e97-4466-84d3-145a861ef684': 'Marker', '79348357-432d-4746-8e29-0e25c112e3aa': 'MatteHull', 'b2ffef01-eaaa-4ab5-aa64-95a2c4f5dbc6': 'NeonPulse', 'f72ec0e7-a844-4e38-82e3-140c44772699': 'OilPaint', 'c515dad7-4393-4681-81ad-162ef052241b': 'OilPaintSingleSided', 'f1114e2e-eb8d-4fde-915a-6e653b54e9f5': 'Paper', '759f1ebd-20cd-4720-8d41-234e0da63716': 'PaperSingleSided', 'e0abbc80-0f80-e854-4970-8924a0863dcc': 'Petal', 'c33714d1-b2f9-412e-bd50-1884c9d46336': 'Plasma', 'ad1ad437-76e2-450d-a23a-e17f8310b960': 'Rainbow', 'faaa4d44-fcfb-4177-96be-753ac0421ba3': 'ShinyHull', '70d79cca-b159-4f35-990c-f02193947fe8': 'Smoke', 'd902ed8b-d0d1-476c-a8de-878a79e3a34c': 'Snow', 'accb32f5-4509-454f-93f8-1df3fd31df1b': 'SoftHighlighter', 'cf7f0059-7aeb-53a4-2b67-c83d863a9ffa': 'Spikes', '8dc4a70c-d558-4efd-a5ed-d4e860f40dc3': 'Splatter', '7a1c8107-50c5-4b70-9a39-421576d6617e': 'SplatterSingleSided', '0eb4db27-3f82-408d-b5a1-19ebd7d5b711': 'Stars', '44bb800a-fbc3-4592-8426-94ecb05ddec3': 'Streamers', '0077f88c-d93a-42f3-b59b-b31c50cdb414': 'Taffy', 'b468c1fb-f254-41ed-8ec9-57030bc5660c': 'TaperedFlat', 'c8ccb53d-ae13-45ef-8afb-b730d81394eb': 'TaperedFlatSingleSided', 'd90c6ad8-af0f-4b54-b422-e0f92abe1b3c': 'TaperedMarker', '1a26b8c0-8a07-4f8a-9fac-d2ef36e0cad0': 'TaperedMarker_Flat', '75b32cf0-fdd6-4d89-a64b-e2a00b247b0f': 'ThickPaint', 'fdf0326a-c0d1-4fed-b101-9db0ff6d071f': 'ThickPaintSingleSided', '4391385a-df73-4396-9e33-31e4e4930b27': 'Toon', 'a8fea537-da7c-4d4b-817f-24f074725d6d': 'UnlitHull', 'd229d335-c334-495a-a801-660ac8a87360': 'VelvetInk', '10201aa3-ebc2-42d8-84b7-2e63f6eeb8ab': 'Waveform', 'b67c0e81-ce6d-40a8-aeb0-ef036b081aa3': 'WetPaint', 'dea67637-cd1a-27e4-c9b1-52f4bbcb84e5': 'WetPaintSingleSided', '5347acf0-a8e2-47b6-8346-30c70719d763': 'WigglyGraphite', 'e814fef1-97fd-7194-4a2f-50c2bb918be2': 'WigglyGraphiteSingleSided', '4391385a-cf83-4396-9e33-31e4e4930b27': 'Wire' }; const common = { 'colors': { 'BloomColor': ` vec3 BloomColor(vec3 color, float gain) { // Guarantee that there's at least a little bit of all 3 channels. // This makes fully-saturated strokes (which only have 2 non-zero // color channels) eventually clip to white rather than to a secondary. float cmin = length(color.rgb) * .05; color.rgb = max(color.rgb, vec3(cmin, cmin, cmin)); // If we try to remove this pow() from .a, it brightens up // pressure-sensitive strokes; looks better as-is. color = pow(color, vec3(2.2)); color.rgb *= 2. * exp(gain * 10.); return color; } `, 'LinearToSrgb': ` vec3 LinearToSrgb(vec3 color) { // Approximation http://chilliant.blogspot.com/2012/08/srgb-approximations-for-hlsl.html vec3 linearColor = color.rgb; vec3 S1 = sqrt(linearColor); vec3 S2 = sqrt(S1); vec3 S3 = sqrt(S2); color.rgb = 0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * linearColor; return color; } `, 'hsv': ` // uniform sampler2D lookupTex; vec4 lookup(vec4 textureColor) { return textureColor; } vec3 lookup(vec3 textureColor) { return textureColor; } vec3 hsv2rgb( vec3 hsv ) { vec3 rgb = clamp( abs(mod(hsv.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 ); return hsv.z * mix( vec3(1.0), rgb, hsv.y); } vec3 rgb2hsv( vec3 rgb ) { vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0); vec4 p = mix(vec4(rgb.bg, K.wz), vec4(rgb.gb, K.xy), step(rgb.b, rgb.g)); vec4 q = mix(vec4(p.xyw, rgb.r), vec4(rgb.r, p.yzx), step(p.x, rgb.r)); float d = q.x - min(q.w, q.y); float e = 1.0e-10; return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x); } `, 'SrgbToLinear': ` vec3 SrgbToLinear(vec3 color) { // Approximation http://chilliant.blogspot.com/2012/08/srgb-approximations-for-hlsl.html vec3 sRGB = color.rgb; color.rgb = sRGB * (sRGB * (sRGB * 0.305306011 + 0.682171111) + 0.012522878); return color; } ` } }; let shaders = null; function getShaders() { if ( shaders === null ) { const loader = new TextureLoader().setPath( './textures/tiltbrush/' ); shaders = { 'Light': { uniforms: { mainTex: { value: loader.load( 'Light.webp' ) }, alphaTest: { value: 0.067 }, emission_gain: { value: 0.45 }, alpha: { value: 1 }, }, vertexShader: ` precision highp float; precision highp int; attribute vec2 uv; attribute vec4 color; attribute vec3 position; uniform mat4 modelMatrix; uniform mat4 modelViewMatrix; uniform mat4 projectionMatrix; uniform mat4 viewMatrix; uniform mat3 normalMatrix; uniform vec3 cameraPosition; varying vec2 vUv; varying vec3 vColor; ${ common.colors.LinearToSrgb } ${ common.colors.hsv } void main() { vUv = uv; vColor = lookup(color.rgb); vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 ); gl_Position = projectionMatrix * mvPosition; } `, fragmentShader: ` precision highp float; precision highp int; uniform float emission_gain; uniform sampler2D mainTex; uniform float alphaTest; varying vec2 vUv; varying vec3 vColor; ${ common.colors.BloomColor } ${ common.colors.SrgbToLinear } void main(){ vec4 col = texture2D(mainTex, vUv); vec3 color = vColor; color = BloomColor(color, emission_gain); color = color * col.rgb; color = color * col.a; color = SrgbToLinear(color); gl_FragColor = vec4(color, 1.0); } `, side: 2, transparent: true, depthFunc: 2, depthWrite: true, depthTest: false, blending: 5, blendDst: 201, blendDstAlpha: 201, blendEquation: 100, blendEquationAlpha: 100, blendSrc: 201, blendSrcAlpha: 201, } }; } return shaders; } function getMaterial( GUID ) { const name = BRUSH_LIST_ARRAY[ GUID ]; switch ( name ) { case 'Light': return new RawShaderMaterial( getShaders().Light ); default: return new MeshBasicMaterial( { vertexColors: true, side: DoubleSide } ); } } export { TiltLoader };"},{"title":"","date":"2023-10-12T14:08:40.756Z","updated":"2023-10-12T14:08:40.756Z","comments":true,"path":"js/three/jsm/loaders/USDZLoader.js","permalink":"http://19999997.xyz/js/three/jsm/loaders/USDZLoader.js","excerpt":"","text":"import { BufferAttribute, BufferGeometry, ClampToEdgeWrapping, FileLoader, Group, NoColorSpace, Loader, Mesh, MeshPhysicalMaterial, MirroredRepeatWrapping, RepeatWrapping, SRGBColorSpace, TextureLoader, Object3D, Vector2 } from 'three'; import * as fflate from '../libs/fflate.module.js'; class USDAParser { parse( text ) { const data = {}; const lines = text.split( '\\n' ); const length = lines.length; let current = 0; let string = null; let target = data; const stack = [ data ]; // debugger; function parseNextLine() { const line = lines[ current ]; // console.log( line ); if ( line.includes( '=' ) ) { const assignment = line.split( '=' ); const lhs = assignment[ 0 ].trim(); const rhs = assignment[ 1 ].trim(); if ( rhs.endsWith( '{' ) ) { const group = {}; stack.push( group ); target[ lhs ] = group; target = group; } else { target[ lhs ] = rhs; } } else if ( line.endsWith( '{' ) ) { const group = target[ string ] || {}; stack.push( group ); target[ string ] = group; target = group; } else if ( line.endsWith( '}' ) ) { stack.pop(); if ( stack.length === 0 ) return; target = stack[ stack.length - 1 ]; } else if ( line.endsWith( '(' ) ) { const meta = {}; stack.push( meta ); string = line.split( '(' )[ 0 ].trim() || string; target[ string ] = meta; target = meta; } else if ( line.endsWith( ')' ) ) { stack.pop(); target = stack[ stack.length - 1 ]; } else { string = line.trim(); } current ++; if ( current < length ) { parseNextLine(); } } parseNextLine(); return data; } } class USDZLoader extends Loader { constructor( manager ) { super( manager ); } load( url, onLoad, onProgress, onError ) { const scope = this; const loader = new FileLoader( scope.manager ); loader.setPath( scope.path ); loader.setResponseType( 'arraybuffer' ); loader.setRequestHeader( scope.requestHeader ); loader.setWithCredentials( scope.withCredentials ); loader.load( url, function ( text ) { try { onLoad( scope.parse( text ) ); } catch ( e ) { if ( onError ) { onError( e ); } else { console.error( e ); } scope.manager.itemError( url ); } }, onProgress, onError ); } parse( buffer ) { const parser = new USDAParser(); function parseAssets( zip ) { const data = {}; const loader = new FileLoader(); loader.setResponseType( 'arraybuffer' ); for ( const filename in zip ) { if ( filename.endsWith( 'png' ) ) { const blob = new Blob( [ zip[ filename ] ], { type: { type: 'image/png' } } ); data[ filename ] = URL.createObjectURL( blob ); } if ( filename.endsWith( 'usd' ) || filename.endsWith( 'usda' ) ) { if ( isCrateFile( zip[ filename ] ) ) { console.warn( 'THREE.USDZLoader: Crate files (.usdc or binary .usd) are not supported.' ); continue; } const text = fflate.strFromU8( zip[ filename ] ); data[ filename ] = parser.parse( text ); } } return data; } function isCrateFile( buffer ) { // Check if this a crate file. First 7 bytes of a crate file are \"PXR-USDC\". const fileHeader = buffer.slice( 0, 7 ); const crateHeader = new Uint8Array( [ 0x50, 0x58, 0x52, 0x2D, 0x55, 0x53, 0x44, 0x43 ] ); // If this is not a crate file, we assume it is a plain USDA file. return fileHeader.every( ( value, index ) => value === crateHeader[ index ] ); } function findUSD( zip ) { if ( zip.length < 1 ) return undefined; const firstFileName = Object.keys( zip )[ 0 ]; let isCrate = false; // As per the USD specification, the first entry in the zip archive is used as the main file (\"UsdStage\"). // ASCII files can end in either .usda or .usd. // See https://openusd.org/release/spec_usdz.html#layout if ( firstFileName.endsWith( 'usda' ) ) return zip[ firstFileName ]; if ( firstFileName.endsWith( 'usdc' ) ) { isCrate = true; } else if ( firstFileName.endsWith( 'usd' ) ) { // If this is not a crate file, we assume it is a plain USDA file. if ( ! isCrateFile( zip[ firstFileName ] ) ) { return zip[ firstFileName ]; } else { isCrate = true; } } if ( isCrate ) { console.warn( 'THREE.USDZLoader: Crate files (.usdc or binary .usd) are not supported.' ); } return undefined; } const zip = fflate.unzipSync( new Uint8Array( buffer ) ); // console.log( zip ); const assets = parseAssets( zip ); // console.log( assets ) const file = findUSD( zip ); if ( file === undefined ) { console.warn( 'THREE.USDZLoader: No usda file found.' ); return new Group(); } // Parse file const text = fflate.strFromU8( file ); const root = parser.parse( text ); // Build scene function findMeshGeometry( data ) { if ( ! data ) return undefined; if ( 'prepend references' in data ) { const reference = data[ 'prepend references' ]; const parts = reference.split( '@' ); const path = parts[ 1 ].replace( /^.\\//, '' ); const id = parts[ 2 ].replace( /^$/, '' ); return findGeometry( assets[ path ], id ); } return findGeometry( data ); } function findGeometry( data, id ) { if ( ! data ) return undefined; if ( id !== undefined ) { const def = `def Mesh \"${id}\"`; if ( def in data ) { return data[ def ]; } } for ( const name in data ) { const object = data[ name ]; if ( name.startsWith( 'def Mesh' ) ) { // Move points to Mesh if ( 'point3f[] points' in data ) { object[ 'point3f[] points' ] = data[ 'point3f[] points' ]; } // Move st to Mesh if ( 'texCoord2f[] primvars:st' in data ) { object[ 'texCoord2f[] primvars:st' ] = data[ 'texCoord2f[] primvars:st' ]; } // Move st indices to Mesh if ( 'int[] primvars:st:indices' in data ) { object[ 'int[] primvars:st:indices' ] = data[ 'int[] primvars:st:indices' ]; } return object; } if ( typeof object === 'object' ) { const geometry = findGeometry( object ); if ( geometry ) return geometry; } } } function buildGeometry( data ) { if ( ! data ) return undefined; let geometry = new BufferGeometry(); if ( 'int[] faceVertexIndices' in data ) { const indices = JSON.parse( data[ 'int[] faceVertexIndices' ] ); geometry.setIndex( indices ); } if ( 'point3f[] points' in data ) { const positions = JSON.parse( data[ 'point3f[] points' ].replace( /[()]*/g, '' ) ); const attribute = new BufferAttribute( new Float32Array( positions ), 3 ); geometry.setAttribute( 'position', attribute ); } if ( 'normal3f[] normals' in data ) { const normals = JSON.parse( data[ 'normal3f[] normals' ].replace( /[()]*/g, '' ) ); const attribute = new BufferAttribute( new Float32Array( normals ), 3 ); geometry.setAttribute( 'normal', attribute ); } else { geometry.computeVertexNormals(); } if ( 'float2[] primvars:st' in data ) { data[ 'texCoord2f[] primvars:st' ] = data[ 'float2[] primvars:st' ]; } if ( 'texCoord2f[] primvars:st' in data ) { const uvs = JSON.parse( data[ 'texCoord2f[] primvars:st' ].replace( /[()]*/g, '' ) ); const attribute = new BufferAttribute( new Float32Array( uvs ), 2 ); if ( 'int[] primvars:st:indices' in data ) { geometry = geometry.toNonIndexed(); const indices = JSON.parse( data[ 'int[] primvars:st:indices' ] ); geometry.setAttribute( 'uv', toFlatBufferAttribute( attribute, indices ) ); } else { geometry.setAttribute( 'uv', attribute ); } } return geometry; } function toFlatBufferAttribute( attribute, indices ) { const array = attribute.array; const itemSize = attribute.itemSize; const array2 = new array.constructor( indices.length * itemSize ); let index = 0, index2 = 0; for ( let i = 0, l = indices.length; i < l; i ++ ) { index = indices[ i ] * itemSize; for ( let j = 0; j < itemSize; j ++ ) { array2[ index2 ++ ] = array[ index ++ ]; } } return new BufferAttribute( array2, itemSize ); } function findMeshMaterial( data ) { if ( ! data ) return undefined; if ( 'rel material:binding' in data ) { const reference = data[ 'rel material:binding' ]; const id = reference.replace( /^$/, '' ); const parts = id.split( '/' ); return findMaterial( root, ` \"${ parts[ 1 ] }\"` ); } return findMaterial( data ); } function findMaterial( data, id = '' ) { for ( const name in data ) { const object = data[ name ]; if ( name.startsWith( 'def Material' + id ) ) { return object; } if ( typeof object === 'object' ) { const material = findMaterial( object, id ); if ( material ) return material; } } } function setTextureParams( map, data_value ) { // rotation, scale and translation if ( data_value[ 'float inputs:rotation' ] ) { map.rotation = parseFloat( data_value[ 'float inputs:rotation' ] ); } if ( data_value[ 'float2 inputs:scale' ] ) { map.repeat = new Vector2().fromArray( JSON.parse( '[' + data_value[ 'float2 inputs:scale' ].replace( /[()]*/g, '' ) + ']' ) ); } if ( data_value[ 'float2 inputs:translation' ] ) { map.offset = new Vector2().fromArray( JSON.parse( '[' + data_value[ 'float2 inputs:translation' ].replace( /[()]*/g, '' ) + ']' ) ); } } function buildMaterial( data ) { const material = new MeshPhysicalMaterial(); if ( data !== undefined ) { if ( 'def Shader \"PreviewSurface\"' in data ) { const surface = data[ 'def Shader \"PreviewSurface\"' ]; if ( 'color3f inputs:diffuseColor.connect' in surface ) { const path = surface[ 'color3f inputs:diffuseColor.connect' ]; const sampler = findTexture( root, /(\\w+).output/.exec( path )[ 1 ] ); material.map = buildTexture( sampler ); material.map.colorSpace = SRGBColorSpace; if ( 'def Shader \"Transform2d_diffuse\"' in data ) { setTextureParams( material.map, data[ 'def Shader \"Transform2d_diffuse\"' ] ); } } else if ( 'color3f inputs:diffuseColor' in surface ) { const color = surface[ 'color3f inputs:diffuseColor' ].replace( /[()]*/g, '' ); material.color.fromArray( JSON.parse( '[' + color + ']' ) ); } if ( 'color3f inputs:emissiveColor.connect' in surface ) { const path = surface[ 'color3f inputs:emissiveColor.connect' ]; const sampler = findTexture( root, /(\\w+).output/.exec( path )[ 1 ] ); material.emissiveMap = buildTexture( sampler ); material.emissiveMap.colorSpace = SRGBColorSpace; material.emissive.set( 0xffffff ); if ( 'def Shader \"Transform2d_emissive\"' in data ) { setTextureParams( material.emissiveMap, data[ 'def Shader \"Transform2d_emissive\"' ] ); } } else if ( 'color3f inputs:emissiveColor' in surface ) { const color = surface[ 'color3f inputs:emissiveColor' ].replace( /[()]*/g, '' ); material.emissive.fromArray( JSON.parse( '[' + color + ']' ) ); } if ( 'normal3f inputs:normal.connect' in surface ) { const path = surface[ 'normal3f inputs:normal.connect' ]; const sampler = findTexture( root, /(\\w+).output/.exec( path )[ 1 ] ); material.normalMap = buildTexture( sampler ); material.normalMap.colorSpace = NoColorSpace; if ( 'def Shader \"Transform2d_normal\"' in data ) { setTextureParams( material.normalMap, data[ 'def Shader \"Transform2d_normal\"' ] ); } } if ( 'float inputs:roughness.connect' in surface ) { const path = surface[ 'float inputs:roughness.connect' ]; const sampler = findTexture( root, /(\\w+).output/.exec( path )[ 1 ] ); material.roughness = 1.0; material.roughnessMap = buildTexture( sampler ); material.roughnessMap.colorSpace = NoColorSpace; if ( 'def Shader \"Transform2d_roughness\"' in data ) { setTextureParams( material.roughnessMap, data[ 'def Shader \"Transform2d_roughness\"' ] ); } } else if ( 'float inputs:roughness' in surface ) { material.roughness = parseFloat( surface[ 'float inputs:roughness' ] ); } if ( 'float inputs:metallic.connect' in surface ) { const path = surface[ 'float inputs:metallic.connect' ]; const sampler = findTexture( root, /(\\w+).output/.exec( path )[ 1 ] ); material.metalness = 1.0; material.metalnessMap = buildTexture( sampler ); material.metalnessMap.colorSpace = NoColorSpace; if ( 'def Shader \"Transform2d_metallic\"' in data ) { setTextureParams( material.metalnessMap, data[ 'def Shader \"Transform2d_metallic\"' ] ); } } else if ( 'float inputs:metallic' in surface ) { material.metalness = parseFloat( surface[ 'float inputs:metallic' ] ); } if ( 'float inputs:clearcoat.connect' in surface ) { const path = surface[ 'float inputs:clearcoat.connect' ]; const sampler = findTexture( root, /(\\w+).output/.exec( path )[ 1 ] ); material.clearcoat = 1.0; material.clearcoatMap = buildTexture( sampler ); material.clearcoatMap.colorSpace = NoColorSpace; if ( 'def Shader \"Transform2d_clearcoat\"' in data ) { setTextureParams( material.clearcoatMap, data[ 'def Shader \"Transform2d_clearcoat\"' ] ); } } else if ( 'float inputs:clearcoat' in surface ) { material.clearcoat = parseFloat( surface[ 'float inputs:clearcoat' ] ); } if ( 'float inputs:clearcoatRoughness.connect' in surface ) { const path = surface[ 'float inputs:clearcoatRoughness.connect' ]; const sampler = findTexture( root, /(\\w+).output/.exec( path )[ 1 ] ); material.clearcoatRoughness = 1.0; material.clearcoatRoughnessMap = buildTexture( sampler ); material.clearcoatRoughnessMap.colorSpace = NoColorSpace; if ( 'def Shader \"Transform2d_clearcoatRoughness\"' in data ) { setTextureParams( material.clearcoatRoughnessMap, data[ 'def Shader \"Transform2d_clearcoatRoughness\"' ] ); } } else if ( 'float inputs:clearcoatRoughness' in surface ) { material.clearcoatRoughness = parseFloat( surface[ 'float inputs:clearcoatRoughness' ] ); } if ( 'float inputs:ior' in surface ) { material.ior = parseFloat( surface[ 'float inputs:ior' ] ); } if ( 'float inputs:occlusion.connect' in surface ) { const path = surface[ 'float inputs:occlusion.connect' ]; const sampler = findTexture( root, /(\\w+).output/.exec( path )[ 1 ] ); material.aoMap = buildTexture( sampler ); material.aoMap.colorSpace = NoColorSpace; if ( 'def Shader \"Transform2d_occlusion\"' in data ) { setTextureParams( material.aoMap, data[ 'def Shader \"Transform2d_occlusion\"' ] ); } } } if ( 'def Shader \"diffuseColor_texture\"' in data ) { const sampler = data[ 'def Shader \"diffuseColor_texture\"' ]; material.map = buildTexture( sampler ); material.map.colorSpace = SRGBColorSpace; } if ( 'def Shader \"normal_texture\"' in data ) { const sampler = data[ 'def Shader \"normal_texture\"' ]; material.normalMap = buildTexture( sampler ); material.normalMap.colorSpace = NoColorSpace; } } return material; } function findTexture( data, id ) { for ( const name in data ) { const object = data[ name ]; if ( name.startsWith( `def Shader \"${ id }\"` ) ) { return object; } if ( typeof object === 'object' ) { const texture = findTexture( object, id ); if ( texture ) return texture; } } } function buildTexture( data ) { if ( 'asset inputs:file' in data ) { const path = data[ 'asset inputs:file' ].replace( /@*/g, '' ); const loader = new TextureLoader(); const texture = loader.load( assets[ path ] ); const map = { '\"clamp\"': ClampToEdgeWrapping, '\"mirror\"': MirroredRepeatWrapping, '\"repeat\"': RepeatWrapping }; if ( 'token inputs:wrapS' in data ) { texture.wrapS = map[ data[ 'token inputs:wrapS' ] ]; } if ( 'token inputs:wrapT' in data ) { texture.wrapT = map[ data[ 'token inputs:wrapT' ] ]; } return texture; } return null; } function buildObject( data ) { const geometry = buildGeometry( findMeshGeometry( data ) ); const material = buildMaterial( findMeshMaterial( data ) ); const mesh = geometry ? new Mesh( geometry, material ) : new Object3D(); if ( 'matrix4d xformOp:transform' in data ) { const array = JSON.parse( '[' + data[ 'matrix4d xformOp:transform' ].replace( /[()]*/g, '' ) + ']' ); mesh.matrix.fromArray( array ); mesh.matrix.decompose( mesh.position, mesh.quaternion, mesh.scale ); } return mesh; } function buildHierarchy( data, group ) { for ( const name in data ) { if ( name.startsWith( 'def Scope' ) ) { buildHierarchy( data[ name ], group ); } else if ( name.startsWith( 'def Xform' ) ) { const mesh = buildObject( data[ name ] ); if ( /def Xform \"(\\w+)\"/.test( name ) ) { mesh.name = /def Xform \"(\\w+)\"/.exec( name )[ 1 ]; } group.add( mesh ); buildHierarchy( data[ name ], mesh ); } } } const group = new Group(); buildHierarchy( root, group ); return group; } } export { USDZLoader };"},{"title":"","date":"2023-10-12T14:08:40.769Z","updated":"2023-10-12T14:08:40.769Z","comments":true,"path":"js/three/jsm/loaders/XYZLoader.js","permalink":"http://19999997.xyz/js/three/jsm/loaders/XYZLoader.js","excerpt":"","text":"import { BufferGeometry, Color, FileLoader, Float32BufferAttribute, Loader } from 'three'; class XYZLoader extends Loader { load( url, onLoad, onProgress, onError ) { const scope = this; const loader = new FileLoader( this.manager ); loader.setPath( this.path ); loader.setRequestHeader( this.requestHeader ); loader.setWithCredentials( this.withCredentials ); loader.load( url, function ( text ) { try { onLoad( scope.parse( text ) ); } catch ( e ) { if ( onError ) { onError( e ); } else { console.error( e ); } scope.manager.itemError( url ); } }, onProgress, onError ); } parse( text ) { const lines = text.split( '\\n' ); const vertices = []; const colors = []; const color = new Color(); for ( let line of lines ) { line = line.trim(); if ( line.charAt( 0 ) === '#' ) continue; // skip comments const lineValues = line.split( /\\s+/ ); if ( lineValues.length === 3 ) { // XYZ vertices.push( parseFloat( lineValues[ 0 ] ) ); vertices.push( parseFloat( lineValues[ 1 ] ) ); vertices.push( parseFloat( lineValues[ 2 ] ) ); } if ( lineValues.length === 6 ) { // XYZRGB vertices.push( parseFloat( lineValues[ 0 ] ) ); vertices.push( parseFloat( lineValues[ 1 ] ) ); vertices.push( parseFloat( lineValues[ 2 ] ) ); const r = parseFloat( lineValues[ 3 ] ) / 255; const g = parseFloat( lineValues[ 4 ] ) / 255; const b = parseFloat( lineValues[ 5 ] ) / 255; color.set( r, g, b ).convertSRGBToLinear(); colors.push( color.r, color.g, color.b ); } } const geometry = new BufferGeometry(); geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) ); if ( colors.length > 0 ) { geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) ); } return geometry; } } export { XYZLoader };"},{"title":"","date":"2023-10-12T14:08:40.764Z","updated":"2023-10-12T14:08:40.764Z","comments":true,"path":"js/three/jsm/loaders/VRMLLoader.js","permalink":"http://19999997.xyz/js/three/jsm/loaders/VRMLLoader.js","excerpt":"","text":"import { BackSide, BoxGeometry, BufferAttribute, BufferGeometry, ClampToEdgeWrapping, Color, ConeGeometry, CylinderGeometry, DataTexture, DoubleSide, FileLoader, Float32BufferAttribute, FrontSide, Group, LineBasicMaterial, LineSegments, Loader, LoaderUtils, Mesh, MeshBasicMaterial, MeshPhongMaterial, Object3D, Points, PointsMaterial, Quaternion, RepeatWrapping, Scene, ShapeUtils, SphereGeometry, SRGBColorSpace, TextureLoader, Vector2, Vector3 } from 'three'; import chevrotain from '../libs/chevrotain.module.min.js'; class VRMLLoader extends Loader { constructor( manager ) { super( manager ); } load( url, onLoad, onProgress, onError ) { const scope = this; const path = ( scope.path === '' ) ? LoaderUtils.extractUrlBase( url ) : scope.path; const loader = new FileLoader( scope.manager ); loader.setPath( scope.path ); loader.setRequestHeader( scope.requestHeader ); loader.setWithCredentials( scope.withCredentials ); loader.load( url, function ( text ) { try { onLoad( scope.parse( text, path ) ); } catch ( e ) { if ( onError ) { onError( e ); } else { console.error( e ); } scope.manager.itemError( url ); } }, onProgress, onError ); } parse( data, path ) { const nodeMap = {}; function generateVRMLTree( data ) { // create lexer, parser and visitor const tokenData = createTokens(); const lexer = new VRMLLexer( tokenData.tokens ); const parser = new VRMLParser( tokenData.tokenVocabulary ); const visitor = createVisitor( parser.getBaseCstVisitorConstructor() ); // lexing const lexingResult = lexer.lex( data ); parser.input = lexingResult.tokens; // parsing const cstOutput = parser.vrml(); if ( parser.errors.length > 0 ) { console.error( parser.errors ); throw Error( 'THREE.VRMLLoader: Parsing errors detected.' ); } // actions const ast = visitor.visit( cstOutput ); return ast; } function createTokens() { const createToken = chevrotain.createToken; // from http://gun.teipir.gr/VRML-amgem/spec/part1/concepts.html#SyntaxBasics const RouteIdentifier = createToken( { name: 'RouteIdentifier', pattern: /[^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*[\\.][^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*/ } ); const Identifier = createToken( { name: 'Identifier', pattern: /[^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*/, longer_alt: RouteIdentifier } ); // from http://gun.teipir.gr/VRML-amgem/spec/part1/nodesRef.html const nodeTypes = [ 'Anchor', 'Billboard', 'Collision', 'Group', 'Transform', // grouping nodes 'Inline', 'LOD', 'Switch', // special groups 'AudioClip', 'DirectionalLight', 'PointLight', 'Script', 'Shape', 'Sound', 'SpotLight', 'WorldInfo', // common nodes 'CylinderSensor', 'PlaneSensor', 'ProximitySensor', 'SphereSensor', 'TimeSensor', 'TouchSensor', 'VisibilitySensor', // sensors 'Box', 'Cone', 'Cylinder', 'ElevationGrid', 'Extrusion', 'IndexedFaceSet', 'IndexedLineSet', 'PointSet', 'Sphere', // geometries 'Color', 'Coordinate', 'Normal', 'TextureCoordinate', // geometric properties 'Appearance', 'FontStyle', 'ImageTexture', 'Material', 'MovieTexture', 'PixelTexture', 'TextureTransform', // appearance 'ColorInterpolator', 'CoordinateInterpolator', 'NormalInterpolator', 'OrientationInterpolator', 'PositionInterpolator', 'ScalarInterpolator', // interpolators 'Background', 'Fog', 'NavigationInfo', 'Viewpoint', // bindable nodes 'Text' // Text must be placed at the end of the regex so there are no matches for TextureTransform and TextureCoordinate ]; // const Version = createToken( { name: 'Version', pattern: /#VRML.*/, longer_alt: Identifier } ); const NodeName = createToken( { name: 'NodeName', pattern: new RegExp( nodeTypes.join( '|' ) ), longer_alt: Identifier } ); const DEF = createToken( { name: 'DEF', pattern: /DEF/, longer_alt: Identifier } ); const USE = createToken( { name: 'USE', pattern: /USE/, longer_alt: Identifier } ); const ROUTE = createToken( { name: 'ROUTE', pattern: /ROUTE/, longer_alt: Identifier } ); const TO = createToken( { name: 'TO', pattern: /TO/, longer_alt: Identifier } ); // const StringLiteral = createToken( { name: 'StringLiteral', pattern: /\"(?:[^\\\\\"\\n\\r]|\\\\[bfnrtv\"\\\\/]|\\\\u[0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F])*\"/ } ); const HexLiteral = createToken( { name: 'HexLiteral', pattern: /0[xX][0-9a-fA-F]+/ } ); const NumberLiteral = createToken( { name: 'NumberLiteral', pattern: /[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?/ } ); const TrueLiteral = createToken( { name: 'TrueLiteral', pattern: /TRUE/ } ); const FalseLiteral = createToken( { name: 'FalseLiteral', pattern: /FALSE/ } ); const NullLiteral = createToken( { name: 'NullLiteral', pattern: /NULL/ } ); const LSquare = createToken( { name: 'LSquare', pattern: /\\[/ } ); const RSquare = createToken( { name: 'RSquare', pattern: /]/ } ); const LCurly = createToken( { name: 'LCurly', pattern: /{/ } ); const RCurly = createToken( { name: 'RCurly', pattern: /}/ } ); const Comment = createToken( { name: 'Comment', pattern: /#.*/, group: chevrotain.Lexer.SKIPPED } ); // commas, blanks, tabs, newlines and carriage returns are whitespace characters wherever they appear outside of string fields const WhiteSpace = createToken( { name: 'WhiteSpace', pattern: /[ ,\\s]/, group: chevrotain.Lexer.SKIPPED } ); const tokens = [ WhiteSpace, // keywords appear before the Identifier NodeName, DEF, USE, ROUTE, TO, TrueLiteral, FalseLiteral, NullLiteral, // the Identifier must appear after the keywords because all keywords are valid identifiers Version, Identifier, RouteIdentifier, StringLiteral, HexLiteral, NumberLiteral, LSquare, RSquare, LCurly, RCurly, Comment ]; const tokenVocabulary = {}; for ( let i = 0, l = tokens.length; i < l; i ++ ) { const token = tokens[ i ]; tokenVocabulary[ token.name ] = token; } return { tokens: tokens, tokenVocabulary: tokenVocabulary }; } function createVisitor( BaseVRMLVisitor ) { // the visitor is created dynmaically based on the given base class class VRMLToASTVisitor extends BaseVRMLVisitor { constructor() { super(); this.validateVisitor(); } vrml( ctx ) { const data = { version: this.visit( ctx.version ), nodes: [], routes: [] }; for ( let i = 0, l = ctx.node.length; i < l; i ++ ) { const node = ctx.node[ i ]; data.nodes.push( this.visit( node ) ); } if ( ctx.route ) { for ( let i = 0, l = ctx.route.length; i < l; i ++ ) { const route = ctx.route[ i ]; data.routes.push( this.visit( route ) ); } } return data; } version( ctx ) { return ctx.Version[ 0 ].image; } node( ctx ) { const data = { name: ctx.NodeName[ 0 ].image, fields: [] }; if ( ctx.field ) { for ( let i = 0, l = ctx.field.length; i < l; i ++ ) { const field = ctx.field[ i ]; data.fields.push( this.visit( field ) ); } } // DEF if ( ctx.def ) { data.DEF = this.visit( ctx.def[ 0 ] ); } return data; } field( ctx ) { const data = { name: ctx.Identifier[ 0 ].image, type: null, values: null }; let result; // SFValue if ( ctx.singleFieldValue ) { result = this.visit( ctx.singleFieldValue[ 0 ] ); } // MFValue if ( ctx.multiFieldValue ) { result = this.visit( ctx.multiFieldValue[ 0 ] ); } data.type = result.type; data.values = result.values; return data; } def( ctx ) { return ( ctx.Identifier || ctx.NodeName )[ 0 ].image; } use( ctx ) { return { USE: ( ctx.Identifier || ctx.NodeName )[ 0 ].image }; } singleFieldValue( ctx ) { return processField( this, ctx ); } multiFieldValue( ctx ) { return processField( this, ctx ); } route( ctx ) { const data = { FROM: ctx.RouteIdentifier[ 0 ].image, TO: ctx.RouteIdentifier[ 1 ].image }; return data; } } function processField( scope, ctx ) { const field = { type: null, values: [] }; if ( ctx.node ) { field.type = 'node'; for ( let i = 0, l = ctx.node.length; i < l; i ++ ) { const node = ctx.node[ i ]; field.values.push( scope.visit( node ) ); } } if ( ctx.use ) { field.type = 'use'; for ( let i = 0, l = ctx.use.length; i < l; i ++ ) { const use = ctx.use[ i ]; field.values.push( scope.visit( use ) ); } } if ( ctx.StringLiteral ) { field.type = 'string'; for ( let i = 0, l = ctx.StringLiteral.length; i < l; i ++ ) { const stringLiteral = ctx.StringLiteral[ i ]; field.values.push( stringLiteral.image.replace( /'|\"/g, '' ) ); } } if ( ctx.NumberLiteral ) { field.type = 'number'; for ( let i = 0, l = ctx.NumberLiteral.length; i < l; i ++ ) { const numberLiteral = ctx.NumberLiteral[ i ]; field.values.push( parseFloat( numberLiteral.image ) ); } } if ( ctx.HexLiteral ) { field.type = 'hex'; for ( let i = 0, l = ctx.HexLiteral.length; i < l; i ++ ) { const hexLiteral = ctx.HexLiteral[ i ]; field.values.push( hexLiteral.image ); } } if ( ctx.TrueLiteral ) { field.type = 'boolean'; for ( let i = 0, l = ctx.TrueLiteral.length; i < l; i ++ ) { const trueLiteral = ctx.TrueLiteral[ i ]; if ( trueLiteral.image === 'TRUE' ) field.values.push( true ); } } if ( ctx.FalseLiteral ) { field.type = 'boolean'; for ( let i = 0, l = ctx.FalseLiteral.length; i < l; i ++ ) { const falseLiteral = ctx.FalseLiteral[ i ]; if ( falseLiteral.image === 'FALSE' ) field.values.push( false ); } } if ( ctx.NullLiteral ) { field.type = 'null'; ctx.NullLiteral.forEach( function () { field.values.push( null ); } ); } return field; } return new VRMLToASTVisitor(); } function parseTree( tree ) { // console.log( JSON.stringify( tree, null, 2 ) ); const nodes = tree.nodes; const scene = new Scene(); // first iteration: build nodemap based on DEF statements for ( let i = 0, l = nodes.length; i < l; i ++ ) { const node = nodes[ i ]; buildNodeMap( node ); } // second iteration: build nodes for ( let i = 0, l = nodes.length; i < l; i ++ ) { const node = nodes[ i ]; const object = getNode( node ); if ( object instanceof Object3D ) scene.add( object ); if ( node.name === 'WorldInfo' ) scene.userData.worldInfo = object; } return scene; } function buildNodeMap( node ) { if ( node.DEF ) { nodeMap[ node.DEF ] = node; } const fields = node.fields; for ( let i = 0, l = fields.length; i < l; i ++ ) { const field = fields[ i ]; if ( field.type === 'node' ) { const fieldValues = field.values; for ( let j = 0, jl = fieldValues.length; j < jl; j ++ ) { buildNodeMap( fieldValues[ j ] ); } } } } function getNode( node ) { // handle case where a node refers to a different one if ( node.USE ) { return resolveUSE( node.USE ); } if ( node.build !== undefined ) return node.build; node.build = buildNode( node ); return node.build; } // node builder function buildNode( node ) { const nodeName = node.name; let build; switch ( nodeName ) { case 'Anchor': case 'Group': case 'Transform': case 'Collision': build = buildGroupingNode( node ); break; case 'Background': build = buildBackgroundNode( node ); break; case 'Shape': build = buildShapeNode( node ); break; case 'Appearance': build = buildAppearanceNode( node ); break; case 'Material': build = buildMaterialNode( node ); break; case 'ImageTexture': build = buildImageTextureNode( node ); break; case 'PixelTexture': build = buildPixelTextureNode( node ); break; case 'TextureTransform': build = buildTextureTransformNode( node ); break; case 'IndexedFaceSet': build = buildIndexedFaceSetNode( node ); break; case 'IndexedLineSet': build = buildIndexedLineSetNode( node ); break; case 'PointSet': build = buildPointSetNode( node ); break; case 'Box': build = buildBoxNode( node ); break; case 'Cone': build = buildConeNode( node ); break; case 'Cylinder': build = buildCylinderNode( node ); break; case 'Sphere': build = buildSphereNode( node ); break; case 'ElevationGrid': build = buildElevationGridNode( node ); break; case 'Extrusion': build = buildExtrusionNode( node ); break; case 'Color': case 'Coordinate': case 'Normal': case 'TextureCoordinate': build = buildGeometricNode( node ); break; case 'WorldInfo': build = buildWorldInfoNode( node ); break; case 'Billboard': case 'Inline': case 'LOD': case 'Switch': case 'AudioClip': case 'DirectionalLight': case 'PointLight': case 'Script': case 'Sound': case 'SpotLight': case 'CylinderSensor': case 'PlaneSensor': case 'ProximitySensor': case 'SphereSensor': case 'TimeSensor': case 'TouchSensor': case 'VisibilitySensor': case 'Text': case 'FontStyle': case 'MovieTexture': case 'ColorInterpolator': case 'CoordinateInterpolator': case 'NormalInterpolator': case 'OrientationInterpolator': case 'PositionInterpolator': case 'ScalarInterpolator': case 'Fog': case 'NavigationInfo': case 'Viewpoint': // node not supported yet break; default: console.warn( 'THREE.VRMLLoader: Unknown node:', nodeName ); break; } if ( build !== undefined && node.DEF !== undefined && build.hasOwnProperty( 'name' ) === true ) { build.name = node.DEF; } return build; } function buildGroupingNode( node ) { const object = new Group(); // const fields = node.fields; for ( let i = 0, l = fields.length; i < l; i ++ ) { const field = fields[ i ]; const fieldName = field.name; const fieldValues = field.values; switch ( fieldName ) { case 'bboxCenter': // field not supported break; case 'bboxSize': // field not supported break; case 'center': // field not supported break; case 'children': parseFieldChildren( fieldValues, object ); break; case 'description': // field not supported break; case 'collide': // field not supported break; case 'parameter': // field not supported break; case 'rotation': const axis = new Vector3( fieldValues[ 0 ], fieldValues[ 1 ], fieldValues[ 2 ] ); const angle = fieldValues[ 3 ]; object.quaternion.setFromAxisAngle( axis, angle ); break; case 'scale': object.scale.set( fieldValues[ 0 ], fieldValues[ 1 ], fieldValues[ 2 ] ); break; case 'scaleOrientation': // field not supported break; case 'translation': object.position.set( fieldValues[ 0 ], fieldValues[ 1 ], fieldValues[ 2 ] ); break; case 'proxy': // field not supported break; case 'url': // field not supported break; default: console.warn( 'THREE.VRMLLoader: Unknown field:', fieldName ); break; } } return object; } function buildBackgroundNode( node ) { const group = new Group(); let groundAngle, groundColor; let skyAngle, skyColor; const fields = node.fields; for ( let i = 0, l = fields.length; i < l; i ++ ) { const field = fields[ i ]; const fieldName = field.name; const fieldValues = field.values; switch ( fieldName ) { case 'groundAngle': groundAngle = fieldValues; break; case 'groundColor': groundColor = fieldValues; break; case 'backUrl': // field not supported break; case 'bottomUrl': // field not supported break; case 'frontUrl': // field not supported break; case 'leftUrl': // field not supported break; case 'rightUrl': // field not supported break; case 'topUrl': // field not supported break; case 'skyAngle': skyAngle = fieldValues; break; case 'skyColor': skyColor = fieldValues; break; default: console.warn( 'THREE.VRMLLoader: Unknown field:', fieldName ); break; } } const radius = 10000; // sky if ( skyColor ) { const skyGeometry = new SphereGeometry( radius, 32, 16 ); const skyMaterial = new MeshBasicMaterial( { fog: false, side: BackSide, depthWrite: false, depthTest: false } ); if ( skyColor.length > 3 ) { paintFaces( skyGeometry, radius, skyAngle, toColorArray( skyColor ), true ); skyMaterial.vertexColors = true; } else { skyMaterial.color.setRGB( skyColor[ 0 ], skyColor[ 1 ], skyColor[ 2 ] ); skyMaterial.color.convertSRGBToLinear(); } const sky = new Mesh( skyGeometry, skyMaterial ); group.add( sky ); } // ground if ( groundColor ) { if ( groundColor.length > 0 ) { const groundGeometry = new SphereGeometry( radius, 32, 16, 0, 2 * Math.PI, 0.5 * Math.PI, 1.5 * Math.PI ); const groundMaterial = new MeshBasicMaterial( { fog: false, side: BackSide, vertexColors: true, depthWrite: false, depthTest: false } ); paintFaces( groundGeometry, radius, groundAngle, toColorArray( groundColor ), false ); const ground = new Mesh( groundGeometry, groundMaterial ); group.add( ground ); } } // render background group first group.renderOrder = - Infinity; return group; } function buildShapeNode( node ) { const fields = node.fields; // if the appearance field is NULL or unspecified, lighting is off and the unlit object color is (0, 0, 0) let material = new MeshBasicMaterial( { name: Loader.DEFAULT_MATERIAL_NAME, color: 0x000000 } ); let geometry; for ( let i = 0, l = fields.length; i < l; i ++ ) { const field = fields[ i ]; const fieldName = field.name; const fieldValues = field.values; switch ( fieldName ) { case 'appearance': if ( fieldValues[ 0 ] !== null ) { material = getNode( fieldValues[ 0 ] ); } break; case 'geometry': if ( fieldValues[ 0 ] !== null ) { geometry = getNode( fieldValues[ 0 ] ); } break; default: console.warn( 'THREE.VRMLLoader: Unknown field:', fieldName ); break; } } // build 3D object let object; if ( geometry && geometry.attributes.position ) { const type = geometry._type; if ( type === 'points' ) { // points const pointsMaterial = new PointsMaterial( { name: Loader.DEFAULT_MATERIAL_NAME, color: 0xffffff } ); if ( geometry.attributes.color !== undefined ) { pointsMaterial.vertexColors = true; } else { // if the color field is NULL and there is a material defined for the appearance affecting this PointSet, then use the emissiveColor of the material to draw the points if ( material.isMeshPhongMaterial ) { pointsMaterial.color.copy( material.emissive ); } } object = new Points( geometry, pointsMaterial ); } else if ( type === 'line' ) { // lines const lineMaterial = new LineBasicMaterial( { name: Loader.DEFAULT_MATERIAL_NAME, color: 0xffffff } ); if ( geometry.attributes.color !== undefined ) { lineMaterial.vertexColors = true; } else { // if the color field is NULL and there is a material defined for the appearance affecting this IndexedLineSet, then use the emissiveColor of the material to draw the lines if ( material.isMeshPhongMaterial ) { lineMaterial.color.copy( material.emissive ); } } object = new LineSegments( geometry, lineMaterial ); } else { // consider meshes // check \"solid\" hint (it's placed in the geometry but affects the material) if ( geometry._solid !== undefined ) { material.side = ( geometry._solid ) ? FrontSide : DoubleSide; } // check for vertex colors if ( geometry.attributes.color !== undefined ) { material.vertexColors = true; } object = new Mesh( geometry, material ); } } else { object = new Object3D(); // if the geometry field is NULL or no vertices are defined the object is not drawn object.visible = false; } return object; } function buildAppearanceNode( node ) { let material = new MeshPhongMaterial(); let transformData; const fields = node.fields; for ( let i = 0, l = fields.length; i < l; i ++ ) { const field = fields[ i ]; const fieldName = field.name; const fieldValues = field.values; switch ( fieldName ) { case 'material': if ( fieldValues[ 0 ] !== null ) { const materialData = getNode( fieldValues[ 0 ] ); if ( materialData.diffuseColor ) material.color.copy( materialData.diffuseColor ); if ( materialData.emissiveColor ) material.emissive.copy( materialData.emissiveColor ); if ( materialData.shininess ) material.shininess = materialData.shininess; if ( materialData.specularColor ) material.specular.copy( materialData.specularColor ); if ( materialData.transparency ) material.opacity = 1 - materialData.transparency; if ( materialData.transparency > 0 ) material.transparent = true; } else { // if the material field is NULL or unspecified, lighting is off and the unlit object color is (0, 0, 0) material = new MeshBasicMaterial( { name: Loader.DEFAULT_MATERIAL_NAME, color: 0x000000 } ); } break; case 'texture': const textureNode = fieldValues[ 0 ]; if ( textureNode !== null ) { if ( textureNode.name === 'ImageTexture' || textureNode.name === 'PixelTexture' ) { material.map = getNode( textureNode ); } else { // MovieTexture not supported yet } } break; case 'textureTransform': if ( fieldValues[ 0 ] !== null ) { transformData = getNode( fieldValues[ 0 ] ); } break; default: console.warn( 'THREE.VRMLLoader: Unknown field:', fieldName ); break; } } // only apply texture transform data if a texture was defined if ( material.map ) { // respect VRML lighting model if ( material.map.__type ) { switch ( material.map.__type ) { case TEXTURE_TYPE.INTENSITY_ALPHA: material.opacity = 1; // ignore transparency break; case TEXTURE_TYPE.RGB: material.color.set( 0xffffff ); // ignore material color break; case TEXTURE_TYPE.RGBA: material.color.set( 0xffffff ); // ignore material color material.opacity = 1; // ignore transparency break; default: } delete material.map.__type; } // apply texture transform if ( transformData ) { material.map.center.copy( transformData.center ); material.map.rotation = transformData.rotation; material.map.repeat.copy( transformData.scale ); material.map.offset.copy( transformData.translation ); } } return material; } function buildMaterialNode( node ) { const materialData = {}; const fields = node.fields; for ( let i = 0, l = fields.length; i < l; i ++ ) { const field = fields[ i ]; const fieldName = field.name; const fieldValues = field.values; switch ( fieldName ) { case 'ambientIntensity': // field not supported break; case 'diffuseColor': materialData.diffuseColor = new Color( fieldValues[ 0 ], fieldValues[ 1 ], fieldValues[ 2 ] ); materialData.diffuseColor.convertSRGBToLinear(); break; case 'emissiveColor': materialData.emissiveColor = new Color( fieldValues[ 0 ], fieldValues[ 1 ], fieldValues[ 2 ] ); materialData.emissiveColor.convertSRGBToLinear(); break; case 'shininess': materialData.shininess = fieldValues[ 0 ]; break; case 'specularColor': materialData.specularColor = new Color( fieldValues[ 0 ], fieldValues[ 1 ], fieldValues[ 2 ] ); materialData.specularColor.convertSRGBToLinear(); break; case 'transparency': materialData.transparency = fieldValues[ 0 ]; break; default: console.warn( 'THREE.VRMLLoader: Unknown field:', fieldName ); break; } } return materialData; } function parseHexColor( hex, textureType, color ) { let value; switch ( textureType ) { case TEXTURE_TYPE.INTENSITY: // Intensity texture: A one-component image specifies one-byte hexadecimal or integer values representing the intensity of the image value = parseInt( hex ); color.r = value; color.g = value; color.b = value; color.a = 1; break; case TEXTURE_TYPE.INTENSITY_ALPHA: // Intensity+Alpha texture: A two-component image specifies the intensity in the first (high) byte and the alpha opacity in the second (low) byte. value = parseInt( '0x' + hex.substring( 2, 4 ) ); color.r = value; color.g = value; color.b = value; color.a = parseInt( '0x' + hex.substring( 4, 6 ) ); break; case TEXTURE_TYPE.RGB: // RGB texture: Pixels in a three-component image specify the red component in the first (high) byte, followed by the green and blue components color.r = parseInt( '0x' + hex.substring( 2, 4 ) ); color.g = parseInt( '0x' + hex.substring( 4, 6 ) ); color.b = parseInt( '0x' + hex.substring( 6, 8 ) ); color.a = 1; break; case TEXTURE_TYPE.RGBA: // RGBA texture: Four-component images specify the alpha opacity byte after red/green/blue color.r = parseInt( '0x' + hex.substring( 2, 4 ) ); color.g = parseInt( '0x' + hex.substring( 4, 6 ) ); color.b = parseInt( '0x' + hex.substring( 6, 8 ) ); color.a = parseInt( '0x' + hex.substring( 8, 10 ) ); break; default: } } function getTextureType( num_components ) { let type; switch ( num_components ) { case 1: type = TEXTURE_TYPE.INTENSITY; break; case 2: type = TEXTURE_TYPE.INTENSITY_ALPHA; break; case 3: type = TEXTURE_TYPE.RGB; break; case 4: type = TEXTURE_TYPE.RGBA; break; default: } return type; } function buildPixelTextureNode( node ) { let texture; let wrapS = RepeatWrapping; let wrapT = RepeatWrapping; const fields = node.fields; for ( let i = 0, l = fields.length; i < l; i ++ ) { const field = fields[ i ]; const fieldName = field.name; const fieldValues = field.values; switch ( fieldName ) { case 'image': const width = fieldValues[ 0 ]; const height = fieldValues[ 1 ]; const num_components = fieldValues[ 2 ]; const textureType = getTextureType( num_components ); const data = new Uint8Array( 4 * width * height ); const color = { r: 0, g: 0, b: 0, a: 0 }; for ( let j = 3, k = 0, jl = fieldValues.length; j < jl; j ++, k ++ ) { parseHexColor( fieldValues[ j ], textureType, color ); const stride = k * 4; data[ stride + 0 ] = color.r; data[ stride + 1 ] = color.g; data[ stride + 2 ] = color.b; data[ stride + 3 ] = color.a; } texture = new DataTexture( data, width, height ); texture.colorSpace = SRGBColorSpace; texture.needsUpdate = true; texture.__type = textureType; // needed for material modifications break; case 'repeatS': if ( fieldValues[ 0 ] === false ) wrapS = ClampToEdgeWrapping; break; case 'repeatT': if ( fieldValues[ 0 ] === false ) wrapT = ClampToEdgeWrapping; break; default: console.warn( 'THREE.VRMLLoader: Unknown field:', fieldName ); break; } } if ( texture ) { texture.wrapS = wrapS; texture.wrapT = wrapT; } return texture; } function buildImageTextureNode( node ) { let texture; let wrapS = RepeatWrapping; let wrapT = RepeatWrapping; const fields = node.fields; for ( let i = 0, l = fields.length; i < l; i ++ ) { const field = fields[ i ]; const fieldName = field.name; const fieldValues = field.values; switch ( fieldName ) { case 'url': const url = fieldValues[ 0 ]; if ( url ) texture = textureLoader.load( url ); break; case 'repeatS': if ( fieldValues[ 0 ] === false ) wrapS = ClampToEdgeWrapping; break; case 'repeatT': if ( fieldValues[ 0 ] === false ) wrapT = ClampToEdgeWrapping; break; default: console.warn( 'THREE.VRMLLoader: Unknown field:', fieldName ); break; } } if ( texture ) { texture.wrapS = wrapS; texture.wrapT = wrapT; texture.colorSpace = SRGBColorSpace; } return texture; } function buildTextureTransformNode( node ) { const transformData = { center: new Vector2(), rotation: new Vector2(), scale: new Vector2(), translation: new Vector2() }; const fields = node.fields; for ( let i = 0, l = fields.length; i < l; i ++ ) { const field = fields[ i ]; const fieldName = field.name; const fieldValues = field.values; switch ( fieldName ) { case 'center': transformData.center.set( fieldValues[ 0 ], fieldValues[ 1 ] ); break; case 'rotation': transformData.rotation = fieldValues[ 0 ]; break; case 'scale': transformData.scale.set( fieldValues[ 0 ], fieldValues[ 1 ] ); break; case 'translation': transformData.translation.set( fieldValues[ 0 ], fieldValues[ 1 ] ); break; default: console.warn( 'THREE.VRMLLoader: Unknown field:', fieldName ); break; } } return transformData; } function buildGeometricNode( node ) { return node.fields[ 0 ].values; } function buildWorldInfoNode( node ) { const worldInfo = {}; const fields = node.fields; for ( let i = 0, l = fields.length; i < l; i ++ ) { const field = fields[ i ]; const fieldName = field.name; const fieldValues = field.values; switch ( fieldName ) { case 'title': worldInfo.title = fieldValues[ 0 ]; break; case 'info': worldInfo.info = fieldValues; break; default: console.warn( 'THREE.VRMLLoader: Unknown field:', fieldName ); break; } } return worldInfo; } function buildIndexedFaceSetNode( node ) { let color, coord, normal, texCoord; let ccw = true, solid = true, creaseAngle = 0; let colorIndex, coordIndex, normalIndex, texCoordIndex; let colorPerVertex = true, normalPerVertex = true; const fields = node.fields; for ( let i = 0, l = fields.length; i < l; i ++ ) { const field = fields[ i ]; const fieldName = field.name; const fieldValues = field.values; switch ( fieldName ) { case 'color': const colorNode = fieldValues[ 0 ]; if ( colorNode !== null ) { color = getNode( colorNode ); } break; case 'coord': const coordNode = fieldValues[ 0 ]; if ( coordNode !== null ) { coord = getNode( coordNode ); } break; case 'normal': const normalNode = fieldValues[ 0 ]; if ( normalNode !== null ) { normal = getNode( normalNode ); } break; case 'texCoord': const texCoordNode = fieldValues[ 0 ]; if ( texCoordNode !== null ) { texCoord = getNode( texCoordNode ); } break; case 'ccw': ccw = fieldValues[ 0 ]; break; case 'colorIndex': colorIndex = fieldValues; break; case 'colorPerVertex': colorPerVertex = fieldValues[ 0 ]; break; case 'convex': // field not supported break; case 'coordIndex': coordIndex = fieldValues; break; case 'creaseAngle': creaseAngle = fieldValues[ 0 ]; break; case 'normalIndex': normalIndex = fieldValues; break; case 'normalPerVertex': normalPerVertex = fieldValues[ 0 ]; break; case 'solid': solid = fieldValues[ 0 ]; break; case 'texCoordIndex': texCoordIndex = fieldValues; break; default: console.warn( 'THREE.VRMLLoader: Unknown field:', fieldName ); break; } } if ( coordIndex === undefined ) { console.warn( 'THREE.VRMLLoader: Missing coordIndex.' ); return new BufferGeometry(); // handle VRML files with incomplete geometry definition } const triangulatedCoordIndex = triangulateFaceIndex( coordIndex, ccw ); let colorAttribute; let normalAttribute; let uvAttribute; if ( color ) { if ( colorPerVertex === true ) { if ( colorIndex && colorIndex.length > 0 ) { // if the colorIndex field is not empty, then it is used to choose colors for each vertex of the IndexedFaceSet. const triangulatedColorIndex = triangulateFaceIndex( colorIndex, ccw ); colorAttribute = computeAttributeFromIndexedData( triangulatedCoordIndex, triangulatedColorIndex, color, 3 ); } else { // if the colorIndex field is empty, then the coordIndex field is used to choose colors from the Color node colorAttribute = toNonIndexedAttribute( triangulatedCoordIndex, new Float32BufferAttribute( color, 3 ) ); } } else { if ( colorIndex && colorIndex.length > 0 ) { // if the colorIndex field is not empty, then they are used to choose one color for each face of the IndexedFaceSet const flattenFaceColors = flattenData( color, colorIndex ); const triangulatedFaceColors = triangulateFaceData( flattenFaceColors, coordIndex ); colorAttribute = computeAttributeFromFaceData( triangulatedCoordIndex, triangulatedFaceColors ); } else { // if the colorIndex field is empty, then the color are applied to each face of the IndexedFaceSet in order const triangulatedFaceColors = triangulateFaceData( color, coordIndex ); colorAttribute = computeAttributeFromFaceData( triangulatedCoordIndex, triangulatedFaceColors ); } } convertColorsToLinearSRGB( colorAttribute ); } if ( normal ) { if ( normalPerVertex === true ) { // consider vertex normals if ( normalIndex && normalIndex.length > 0 ) { // if the normalIndex field is not empty, then it is used to choose normals for each vertex of the IndexedFaceSet. const triangulatedNormalIndex = triangulateFaceIndex( normalIndex, ccw ); normalAttribute = computeAttributeFromIndexedData( triangulatedCoordIndex, triangulatedNormalIndex, normal, 3 ); } else { // if the normalIndex field is empty, then the coordIndex field is used to choose normals from the Normal node normalAttribute = toNonIndexedAttribute( triangulatedCoordIndex, new Float32BufferAttribute( normal, 3 ) ); } } else { // consider face normals if ( normalIndex && normalIndex.length > 0 ) { // if the normalIndex field is not empty, then they are used to choose one normal for each face of the IndexedFaceSet const flattenFaceNormals = flattenData( normal, normalIndex ); const triangulatedFaceNormals = triangulateFaceData( flattenFaceNormals, coordIndex ); normalAttribute = computeAttributeFromFaceData( triangulatedCoordIndex, triangulatedFaceNormals ); } else { // if the normalIndex field is empty, then the normals are applied to each face of the IndexedFaceSet in order const triangulatedFaceNormals = triangulateFaceData( normal, coordIndex ); normalAttribute = computeAttributeFromFaceData( triangulatedCoordIndex, triangulatedFaceNormals ); } } } else { // if the normal field is NULL, then the loader should automatically generate normals, using creaseAngle to determine if and how normals are smoothed across shared vertices normalAttribute = computeNormalAttribute( triangulatedCoordIndex, coord, creaseAngle ); } if ( texCoord ) { // texture coordinates are always defined on vertex level if ( texCoordIndex && texCoordIndex.length > 0 ) { // if the texCoordIndex field is not empty, then it is used to choose texture coordinates for each vertex of the IndexedFaceSet. const triangulatedTexCoordIndex = triangulateFaceIndex( texCoordIndex, ccw ); uvAttribute = computeAttributeFromIndexedData( triangulatedCoordIndex, triangulatedTexCoordIndex, texCoord, 2 ); } else { // if the texCoordIndex field is empty, then the coordIndex array is used to choose texture coordinates from the TextureCoordinate node uvAttribute = toNonIndexedAttribute( triangulatedCoordIndex, new Float32BufferAttribute( texCoord, 2 ) ); } } const geometry = new BufferGeometry(); const positionAttribute = toNonIndexedAttribute( triangulatedCoordIndex, new Float32BufferAttribute( coord, 3 ) ); geometry.setAttribute( 'position', positionAttribute ); geometry.setAttribute( 'normal', normalAttribute ); // optional attributes if ( colorAttribute ) geometry.setAttribute( 'color', colorAttribute ); if ( uvAttribute ) geometry.setAttribute( 'uv', uvAttribute ); // \"solid\" influences the material so let's store it for later use geometry._solid = solid; geometry._type = 'mesh'; return geometry; } function buildIndexedLineSetNode( node ) { let color, coord; let colorIndex, coordIndex; let colorPerVertex = true; const fields = node.fields; for ( let i = 0, l = fields.length; i < l; i ++ ) { const field = fields[ i ]; const fieldName = field.name; const fieldValues = field.values; switch ( fieldName ) { case 'color': const colorNode = fieldValues[ 0 ]; if ( colorNode !== null ) { color = getNode( colorNode ); } break; case 'coord': const coordNode = fieldValues[ 0 ]; if ( coordNode !== null ) { coord = getNode( coordNode ); } break; case 'colorIndex': colorIndex = fieldValues; break; case 'colorPerVertex': colorPerVertex = fieldValues[ 0 ]; break; case 'coordIndex': coordIndex = fieldValues; break; default: console.warn( 'THREE.VRMLLoader: Unknown field:', fieldName ); break; } } // build lines let colorAttribute; const expandedLineIndex = expandLineIndex( coordIndex ); // create an index for three.js's linesegment primitive if ( color ) { if ( colorPerVertex === true ) { if ( colorIndex.length > 0 ) { // if the colorIndex field is not empty, then one color is used for each polyline of the IndexedLineSet. const expandedColorIndex = expandLineIndex( colorIndex ); // compute colors for each line segment (rendering primitve) colorAttribute = computeAttributeFromIndexedData( expandedLineIndex, expandedColorIndex, color, 3 ); // compute data on vertex level } else { // if the colorIndex field is empty, then the colors are applied to each polyline of the IndexedLineSet in order. colorAttribute = toNonIndexedAttribute( expandedLineIndex, new Float32BufferAttribute( color, 3 ) ); } } else { if ( colorIndex.length > 0 ) { // if the colorIndex field is not empty, then colors are applied to each vertex of the IndexedLineSet const flattenLineColors = flattenData( color, colorIndex ); // compute colors for each VRML primitve const expandedLineColors = expandLineData( flattenLineColors, coordIndex ); // compute colors for each line segment (rendering primitve) colorAttribute = computeAttributeFromLineData( expandedLineIndex, expandedLineColors ); // compute data on vertex level } else { // if the colorIndex field is empty, then the coordIndex field is used to choose colors from the Color node const expandedLineColors = expandLineData( color, coordIndex ); // compute colors for each line segment (rendering primitve) colorAttribute = computeAttributeFromLineData( expandedLineIndex, expandedLineColors ); // compute data on vertex level } } convertColorsToLinearSRGB( colorAttribute ); } // const geometry = new BufferGeometry(); const positionAttribute = toNonIndexedAttribute( expandedLineIndex, new Float32BufferAttribute( coord, 3 ) ); geometry.setAttribute( 'position', positionAttribute ); if ( colorAttribute ) geometry.setAttribute( 'color', colorAttribute ); geometry._type = 'line'; return geometry; } function buildPointSetNode( node ) { let color, coord; const fields = node.fields; for ( let i = 0, l = fields.length; i < l; i ++ ) { const field = fields[ i ]; const fieldName = field.name; const fieldValues = field.values; switch ( fieldName ) { case 'color': const colorNode = fieldValues[ 0 ]; if ( colorNode !== null ) { color = getNode( colorNode ); } break; case 'coord': const coordNode = fieldValues[ 0 ]; if ( coordNode !== null ) { coord = getNode( coordNode ); } break; default: console.warn( 'THREE.VRMLLoader: Unknown field:', fieldName ); break; } } const geometry = new BufferGeometry(); geometry.setAttribute( 'position', new Float32BufferAttribute( coord, 3 ) ); if ( color ) { const colorAttribute = new Float32BufferAttribute( color, 3 ); convertColorsToLinearSRGB( colorAttribute ); geometry.setAttribute( 'color', colorAttribute ); } geometry._type = 'points'; return geometry; } function buildBoxNode( node ) { const size = new Vector3( 2, 2, 2 ); const fields = node.fields; for ( let i = 0, l = fields.length; i < l; i ++ ) { const field = fields[ i ]; const fieldName = field.name; const fieldValues = field.values; switch ( fieldName ) { case 'size': size.x = fieldValues[ 0 ]; size.y = fieldValues[ 1 ]; size.z = fieldValues[ 2 ]; break; default: console.warn( 'THREE.VRMLLoader: Unknown field:', fieldName ); break; } } const geometry = new BoxGeometry( size.x, size.y, size.z ); return geometry; } function buildConeNode( node ) { let radius = 1, height = 2, openEnded = false; const fields = node.fields; for ( let i = 0, l = fields.length; i < l; i ++ ) { const field = fields[ i ]; const fieldName = field.name; const fieldValues = field.values; switch ( fieldName ) { case 'bottom': openEnded = ! fieldValues[ 0 ]; break; case 'bottomRadius': radius = fieldValues[ 0 ]; break; case 'height': height = fieldValues[ 0 ]; break; case 'side': // field not supported break; default: console.warn( 'THREE.VRMLLoader: Unknown field:', fieldName ); break; } } const geometry = new ConeGeometry( radius, height, 16, 1, openEnded ); return geometry; } function buildCylinderNode( node ) { let radius = 1, height = 2; const fields = node.fields; for ( let i = 0, l = fields.length; i < l; i ++ ) { const field = fields[ i ]; const fieldName = field.name; const fieldValues = field.values; switch ( fieldName ) { case 'bottom': // field not supported break; case 'radius': radius = fieldValues[ 0 ]; break; case 'height': height = fieldValues[ 0 ]; break; case 'side': // field not supported break; case 'top': // field not supported break; default: console.warn( 'THREE.VRMLLoader: Unknown field:', fieldName ); break; } } const geometry = new CylinderGeometry( radius, radius, height, 16, 1 ); return geometry; } function buildSphereNode( node ) { let radius = 1; const fields = node.fields; for ( let i = 0, l = fields.length; i < l; i ++ ) { const field = fields[ i ]; const fieldName = field.name; const fieldValues = field.values; switch ( fieldName ) { case 'radius': radius = fieldValues[ 0 ]; break; default: console.warn( 'THREE.VRMLLoader: Unknown field:', fieldName ); break; } } const geometry = new SphereGeometry( radius, 16, 16 ); return geometry; } function buildElevationGridNode( node ) { let color; let normal; let texCoord; let height; let colorPerVertex = true; let normalPerVertex = true; let solid = true; let ccw = true; let creaseAngle = 0; let xDimension = 2; let zDimension = 2; let xSpacing = 1; let zSpacing = 1; const fields = node.fields; for ( let i = 0, l = fields.length; i < l; i ++ ) { const field = fields[ i ]; const fieldName = field.name; const fieldValues = field.values; switch ( fieldName ) { case 'color': const colorNode = fieldValues[ 0 ]; if ( colorNode !== null ) { color = getNode( colorNode ); } break; case 'normal': const normalNode = fieldValues[ 0 ]; if ( normalNode !== null ) { normal = getNode( normalNode ); } break; case 'texCoord': const texCoordNode = fieldValues[ 0 ]; if ( texCoordNode !== null ) { texCoord = getNode( texCoordNode ); } break; case 'height': height = fieldValues; break; case 'ccw': ccw = fieldValues[ 0 ]; break; case 'colorPerVertex': colorPerVertex = fieldValues[ 0 ]; break; case 'creaseAngle': creaseAngle = fieldValues[ 0 ]; break; case 'normalPerVertex': normalPerVertex = fieldValues[ 0 ]; break; case 'solid': solid = fieldValues[ 0 ]; break; case 'xDimension': xDimension = fieldValues[ 0 ]; break; case 'xSpacing': xSpacing = fieldValues[ 0 ]; break; case 'zDimension': zDimension = fieldValues[ 0 ]; break; case 'zSpacing': zSpacing = fieldValues[ 0 ]; break; default: console.warn( 'THREE.VRMLLoader: Unknown field:', fieldName ); break; } } // vertex data const vertices = []; const normals = []; const colors = []; const uvs = []; for ( let i = 0; i < zDimension; i ++ ) { for ( let j = 0; j < xDimension; j ++ ) { // compute a row major index const index = ( i * xDimension ) + j; // vertices const x = xSpacing * i; const y = height[ index ]; const z = zSpacing * j; vertices.push( x, y, z ); // colors if ( color && colorPerVertex === true ) { const r = color[ index * 3 + 0 ]; const g = color[ index * 3 + 1 ]; const b = color[ index * 3 + 2 ]; colors.push( r, g, b ); } // normals if ( normal && normalPerVertex === true ) { const xn = normal[ index * 3 + 0 ]; const yn = normal[ index * 3 + 1 ]; const zn = normal[ index * 3 + 2 ]; normals.push( xn, yn, zn ); } // uvs if ( texCoord ) { const s = texCoord[ index * 2 + 0 ]; const t = texCoord[ index * 2 + 1 ]; uvs.push( s, t ); } else { uvs.push( i / ( xDimension - 1 ), j / ( zDimension - 1 ) ); } } } // indices const indices = []; for ( let i = 0; i < xDimension - 1; i ++ ) { for ( let j = 0; j < zDimension - 1; j ++ ) { // from https://tecfa.unige.ch/guides/vrml/vrml97/spec/part1/nodesRef.html#ElevationGrid const a = i + j * xDimension; const b = i + ( j + 1 ) * xDimension; const c = ( i + 1 ) + ( j + 1 ) * xDimension; const d = ( i + 1 ) + j * xDimension; // faces if ( ccw === true ) { indices.push( a, c, b ); indices.push( c, a, d ); } else { indices.push( a, b, c ); indices.push( c, d, a ); } } } // const positionAttribute = toNonIndexedAttribute( indices, new Float32BufferAttribute( vertices, 3 ) ); const uvAttribute = toNonIndexedAttribute( indices, new Float32BufferAttribute( uvs, 2 ) ); let colorAttribute; let normalAttribute; // color attribute if ( color ) { if ( colorPerVertex === false ) { for ( let i = 0; i < xDimension - 1; i ++ ) { for ( let j = 0; j < zDimension - 1; j ++ ) { const index = i + j * ( xDimension - 1 ); const r = color[ index * 3 + 0 ]; const g = color[ index * 3 + 1 ]; const b = color[ index * 3 + 2 ]; // one color per quad colors.push( r, g, b ); colors.push( r, g, b ); colors.push( r, g, b ); colors.push( r, g, b ); colors.push( r, g, b ); colors.push( r, g, b ); } } colorAttribute = new Float32BufferAttribute( colors, 3 ); } else { colorAttribute = toNonIndexedAttribute( indices, new Float32BufferAttribute( colors, 3 ) ); } convertColorsToLinearSRGB( colorAttribute ); } // normal attribute if ( normal ) { if ( normalPerVertex === false ) { for ( let i = 0; i < xDimension - 1; i ++ ) { for ( let j = 0; j < zDimension - 1; j ++ ) { const index = i + j * ( xDimension - 1 ); const xn = normal[ index * 3 + 0 ]; const yn = normal[ index * 3 + 1 ]; const zn = normal[ index * 3 + 2 ]; // one normal per quad normals.push( xn, yn, zn ); normals.push( xn, yn, zn ); normals.push( xn, yn, zn ); normals.push( xn, yn, zn ); normals.push( xn, yn, zn ); normals.push( xn, yn, zn ); } } normalAttribute = new Float32BufferAttribute( normals, 3 ); } else { normalAttribute = toNonIndexedAttribute( indices, new Float32BufferAttribute( normals, 3 ) ); } } else { normalAttribute = computeNormalAttribute( indices, vertices, creaseAngle ); } // build geometry const geometry = new BufferGeometry(); geometry.setAttribute( 'position', positionAttribute ); geometry.setAttribute( 'normal', normalAttribute ); geometry.setAttribute( 'uv', uvAttribute ); if ( colorAttribute ) geometry.setAttribute( 'color', colorAttribute ); // \"solid\" influences the material so let's store it for later use geometry._solid = solid; geometry._type = 'mesh'; return geometry; } function buildExtrusionNode( node ) { let crossSection = [ 1, 1, 1, - 1, - 1, - 1, - 1, 1, 1, 1 ]; let spine = [ 0, 0, 0, 0, 1, 0 ]; let scale; let orientation; let beginCap = true; let ccw = true; let creaseAngle = 0; let endCap = true; let solid = true; const fields = node.fields; for ( let i = 0, l = fields.length; i < l; i ++ ) { const field = fields[ i ]; const fieldName = field.name; const fieldValues = field.values; switch ( fieldName ) { case 'beginCap': beginCap = fieldValues[ 0 ]; break; case 'ccw': ccw = fieldValues[ 0 ]; break; case 'convex': // field not supported break; case 'creaseAngle': creaseAngle = fieldValues[ 0 ]; break; case 'crossSection': crossSection = fieldValues; break; case 'endCap': endCap = fieldValues[ 0 ]; break; case 'orientation': orientation = fieldValues; break; case 'scale': scale = fieldValues; break; case 'solid': solid = fieldValues[ 0 ]; break; case 'spine': spine = fieldValues; // only extrusion along the Y-axis are supported so far break; default: console.warn( 'THREE.VRMLLoader: Unknown field:', fieldName ); break; } } const crossSectionClosed = ( crossSection[ 0 ] === crossSection[ crossSection.length - 2 ] && crossSection[ 1 ] === crossSection[ crossSection.length - 1 ] ); // vertices const vertices = []; const spineVector = new Vector3(); const scaling = new Vector3(); const axis = new Vector3(); const vertex = new Vector3(); const quaternion = new Quaternion(); for ( let i = 0, j = 0, o = 0, il = spine.length; i < il; i += 3, j += 2, o += 4 ) { spineVector.fromArray( spine, i ); scaling.x = scale ? scale[ j + 0 ] : 1; scaling.y = 1; scaling.z = scale ? scale[ j + 1 ] : 1; axis.x = orientation ? orientation[ o + 0 ] : 0; axis.y = orientation ? orientation[ o + 1 ] : 0; axis.z = orientation ? orientation[ o + 2 ] : 1; const angle = orientation ? orientation[ o + 3 ] : 0; for ( let k = 0, kl = crossSection.length; k < kl; k += 2 ) { vertex.x = crossSection[ k + 0 ]; vertex.y = 0; vertex.z = crossSection[ k + 1 ]; // scale vertex.multiply( scaling ); // rotate quaternion.setFromAxisAngle( axis, angle ); vertex.applyQuaternion( quaternion ); // translate vertex.add( spineVector ); vertices.push( vertex.x, vertex.y, vertex.z ); } } // indices const indices = []; const spineCount = spine.length / 3; const crossSectionCount = crossSection.length / 2; for ( let i = 0; i < spineCount - 1; i ++ ) { for ( let j = 0; j < crossSectionCount - 1; j ++ ) { const a = j + i * crossSectionCount; let b = ( j + 1 ) + i * crossSectionCount; const c = j + ( i + 1 ) * crossSectionCount; let d = ( j + 1 ) + ( i + 1 ) * crossSectionCount; if ( ( j === crossSectionCount - 2 ) && ( crossSectionClosed === true ) ) { b = i * crossSectionCount; d = ( i + 1 ) * crossSectionCount; } if ( ccw === true ) { indices.push( a, b, c ); indices.push( c, b, d ); } else { indices.push( a, c, b ); indices.push( c, d, b ); } } } // triangulate cap if ( beginCap === true || endCap === true ) { const contour = []; for ( let i = 0, l = crossSection.length; i < l; i += 2 ) { contour.push( new Vector2( crossSection[ i ], crossSection[ i + 1 ] ) ); } const faces = ShapeUtils.triangulateShape( contour, [] ); const capIndices = []; for ( let i = 0, l = faces.length; i < l; i ++ ) { const face = faces[ i ]; capIndices.push( face[ 0 ], face[ 1 ], face[ 2 ] ); } // begin cap if ( beginCap === true ) { for ( let i = 0, l = capIndices.length; i < l; i += 3 ) { if ( ccw === true ) { indices.push( capIndices[ i + 0 ], capIndices[ i + 1 ], capIndices[ i + 2 ] ); } else { indices.push( capIndices[ i + 0 ], capIndices[ i + 2 ], capIndices[ i + 1 ] ); } } } // end cap if ( endCap === true ) { const indexOffset = crossSectionCount * ( spineCount - 1 ); // references to the first vertex of the last cross section for ( let i = 0, l = capIndices.length; i < l; i += 3 ) { if ( ccw === true ) { indices.push( indexOffset + capIndices[ i + 0 ], indexOffset + capIndices[ i + 2 ], indexOffset + capIndices[ i + 1 ] ); } else { indices.push( indexOffset + capIndices[ i + 0 ], indexOffset + capIndices[ i + 1 ], indexOffset + capIndices[ i + 2 ] ); } } } } const positionAttribute = toNonIndexedAttribute( indices, new Float32BufferAttribute( vertices, 3 ) ); const normalAttribute = computeNormalAttribute( indices, vertices, creaseAngle ); const geometry = new BufferGeometry(); geometry.setAttribute( 'position', positionAttribute ); geometry.setAttribute( 'normal', normalAttribute ); // no uvs yet // \"solid\" influences the material so let's store it for later use geometry._solid = solid; geometry._type = 'mesh'; return geometry; } // helper functions function resolveUSE( identifier ) { const node = nodeMap[ identifier ]; const build = getNode( node ); // because the same 3D objects can have different transformations, it's necessary to clone them. // materials can be influenced by the geometry (e.g. vertex normals). cloning is necessary to avoid // any side effects return ( build.isObject3D || build.isMaterial ) ? build.clone() : build; } function parseFieldChildren( children, owner ) { for ( let i = 0, l = children.length; i < l; i ++ ) { const object = getNode( children[ i ] ); if ( object instanceof Object3D ) owner.add( object ); } } function triangulateFaceIndex( index, ccw ) { const indices = []; // since face defintions can have more than three vertices, it's necessary to // perform a simple triangulation let start = 0; for ( let i = 0, l = index.length; i < l; i ++ ) { const i1 = index[ start ]; const i2 = index[ i + ( ccw ? 1 : 2 ) ]; const i3 = index[ i + ( ccw ? 2 : 1 ) ]; indices.push( i1, i2, i3 ); // an index of -1 indicates that the current face has ended and the next one begins if ( index[ i + 3 ] === - 1 || i + 3 >= l ) { i += 3; start = i + 1; } } return indices; } function triangulateFaceData( data, index ) { const triangulatedData = []; let start = 0; for ( let i = 0, l = index.length; i < l; i ++ ) { const stride = start * 3; const x = data[ stride ]; const y = data[ stride + 1 ]; const z = data[ stride + 2 ]; triangulatedData.push( x, y, z ); // an index of -1 indicates that the current face has ended and the next one begins if ( index[ i + 3 ] === - 1 || i + 3 >= l ) { i += 3; start ++; } } return triangulatedData; } function flattenData( data, index ) { const flattenData = []; for ( let i = 0, l = index.length; i < l; i ++ ) { const i1 = index[ i ]; const stride = i1 * 3; const x = data[ stride ]; const y = data[ stride + 1 ]; const z = data[ stride + 2 ]; flattenData.push( x, y, z ); } return flattenData; } function expandLineIndex( index ) { const indices = []; for ( let i = 0, l = index.length; i < l; i ++ ) { const i1 = index[ i ]; const i2 = index[ i + 1 ]; indices.push( i1, i2 ); // an index of -1 indicates that the current line has ended and the next one begins if ( index[ i + 2 ] === - 1 || i + 2 >= l ) { i += 2; } } return indices; } function expandLineData( data, index ) { const triangulatedData = []; let start = 0; for ( let i = 0, l = index.length; i < l; i ++ ) { const stride = start * 3; const x = data[ stride ]; const y = data[ stride + 1 ]; const z = data[ stride + 2 ]; triangulatedData.push( x, y, z ); // an index of -1 indicates that the current line has ended and the next one begins if ( index[ i + 2 ] === - 1 || i + 2 >= l ) { i += 2; start ++; } } return triangulatedData; } const vA = new Vector3(); const vB = new Vector3(); const vC = new Vector3(); const uvA = new Vector2(); const uvB = new Vector2(); const uvC = new Vector2(); function computeAttributeFromIndexedData( coordIndex, index, data, itemSize ) { const array = []; // we use the coordIndex.length as delimiter since normalIndex must contain at least as many indices for ( let i = 0, l = coordIndex.length; i < l; i += 3 ) { const a = index[ i ]; const b = index[ i + 1 ]; const c = index[ i + 2 ]; if ( itemSize === 2 ) { uvA.fromArray( data, a * itemSize ); uvB.fromArray( data, b * itemSize ); uvC.fromArray( data, c * itemSize ); array.push( uvA.x, uvA.y ); array.push( uvB.x, uvB.y ); array.push( uvC.x, uvC.y ); } else { vA.fromArray( data, a * itemSize ); vB.fromArray( data, b * itemSize ); vC.fromArray( data, c * itemSize ); array.push( vA.x, vA.y, vA.z ); array.push( vB.x, vB.y, vB.z ); array.push( vC.x, vC.y, vC.z ); } } return new Float32BufferAttribute( array, itemSize ); } function computeAttributeFromFaceData( index, faceData ) { const array = []; for ( let i = 0, j = 0, l = index.length; i < l; i += 3, j ++ ) { vA.fromArray( faceData, j * 3 ); array.push( vA.x, vA.y, vA.z ); array.push( vA.x, vA.y, vA.z ); array.push( vA.x, vA.y, vA.z ); } return new Float32BufferAttribute( array, 3 ); } function computeAttributeFromLineData( index, lineData ) { const array = []; for ( let i = 0, j = 0, l = index.length; i < l; i += 2, j ++ ) { vA.fromArray( lineData, j * 3 ); array.push( vA.x, vA.y, vA.z ); array.push( vA.x, vA.y, vA.z ); } return new Float32BufferAttribute( array, 3 ); } function toNonIndexedAttribute( indices, attribute ) { const array = attribute.array; const itemSize = attribute.itemSize; const array2 = new array.constructor( indices.length * itemSize ); let index = 0, index2 = 0; for ( let i = 0, l = indices.length; i < l; i ++ ) { index = indices[ i ] * itemSize; for ( let j = 0; j < itemSize; j ++ ) { array2[ index2 ++ ] = array[ index ++ ]; } } return new Float32BufferAttribute( array2, itemSize ); } const ab = new Vector3(); const cb = new Vector3(); function computeNormalAttribute( index, coord, creaseAngle ) { const faces = []; const vertexNormals = {}; // prepare face and raw vertex normals for ( let i = 0, l = index.length; i < l; i += 3 ) { const a = index[ i ]; const b = index[ i + 1 ]; const c = index[ i + 2 ]; const face = new Face( a, b, c ); vA.fromArray( coord, a * 3 ); vB.fromArray( coord, b * 3 ); vC.fromArray( coord, c * 3 ); cb.subVectors( vC, vB ); ab.subVectors( vA, vB ); cb.cross( ab ); cb.normalize(); face.normal.copy( cb ); if ( vertexNormals[ a ] === undefined ) vertexNormals[ a ] = []; if ( vertexNormals[ b ] === undefined ) vertexNormals[ b ] = []; if ( vertexNormals[ c ] === undefined ) vertexNormals[ c ] = []; vertexNormals[ a ].push( face.normal ); vertexNormals[ b ].push( face.normal ); vertexNormals[ c ].push( face.normal ); faces.push( face ); } // compute vertex normals and build final geometry const normals = []; for ( let i = 0, l = faces.length; i < l; i ++ ) { const face = faces[ i ]; const nA = weightedNormal( vertexNormals[ face.a ], face.normal, creaseAngle ); const nB = weightedNormal( vertexNormals[ face.b ], face.normal, creaseAngle ); const nC = weightedNormal( vertexNormals[ face.c ], face.normal, creaseAngle ); vA.fromArray( coord, face.a * 3 ); vB.fromArray( coord, face.b * 3 ); vC.fromArray( coord, face.c * 3 ); normals.push( nA.x, nA.y, nA.z ); normals.push( nB.x, nB.y, nB.z ); normals.push( nC.x, nC.y, nC.z ); } return new Float32BufferAttribute( normals, 3 ); } function weightedNormal( normals, vector, creaseAngle ) { const normal = new Vector3(); if ( creaseAngle === 0 ) { normal.copy( vector ); } else { for ( let i = 0, l = normals.length; i < l; i ++ ) { if ( normals[ i ].angleTo( vector ) < creaseAngle ) { normal.add( normals[ i ] ); } } } return normal.normalize(); } function toColorArray( colors ) { const array = []; for ( let i = 0, l = colors.length; i < l; i += 3 ) { array.push( new Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) ); } return array; } function convertColorsToLinearSRGB( attribute ) { const color = new Color(); for ( let i = 0; i < attribute.count; i ++ ) { color.fromBufferAttribute( attribute, i ); color.convertSRGBToLinear(); attribute.setXYZ( i, color.r, color.g, color.b ); } } /** * Vertically paints the faces interpolating between the * specified colors at the specified angels. This is used for the Background * node, but could be applied to other nodes with multiple faces as well. * * When used with the Background node, default is directionIsDown is true if * interpolating the skyColor down from the Zenith. When interpolationg up from * the Nadir i.e. interpolating the groundColor, the directionIsDown is false. * * The first angle is never specified, it is the Zenith (0 rad). Angles are specified * in radians. The geometry is thought a sphere, but could be anything. The color interpolation * is linear along the Y axis in any case. * * You must specify one more color than you have angles at the beginning of the colors array. * This is the color of the Zenith (the top of the shape). * * @param {BufferGeometry} geometry * @param {number} radius * @param {array} angles * @param {array} colors * @param {boolean} topDown - Whether to work top down or bottom up. */ function paintFaces( geometry, radius, angles, colors, topDown ) { // compute threshold values const thresholds = []; const startAngle = ( topDown === true ) ? 0 : Math.PI; for ( let i = 0, l = colors.length; i < l; i ++ ) { let angle = ( i === 0 ) ? 0 : angles[ i - 1 ]; angle = ( topDown === true ) ? angle : ( startAngle - angle ); const point = new Vector3(); point.setFromSphericalCoords( radius, angle, 0 ); thresholds.push( point ); } // generate vertex colors const indices = geometry.index; const positionAttribute = geometry.attributes.position; const colorAttribute = new BufferAttribute( new Float32Array( geometry.attributes.position.count * 3 ), 3 ); const position = new Vector3(); const color = new Color(); for ( let i = 0; i < indices.count; i ++ ) { const index = indices.getX( i ); position.fromBufferAttribute( positionAttribute, index ); let thresholdIndexA, thresholdIndexB; let t = 1; for ( let j = 1; j < thresholds.length; j ++ ) { thresholdIndexA = j - 1; thresholdIndexB = j; const thresholdA = thresholds[ thresholdIndexA ]; const thresholdB = thresholds[ thresholdIndexB ]; if ( topDown === true ) { // interpolation for sky color if ( position.y thresholdB.y ) { t = Math.abs( thresholdA.y - position.y ) / Math.abs( thresholdA.y - thresholdB.y ); break; } } else { // interpolation for ground color if ( position.y >= thresholdA.y && position.y < thresholdB.y ) { t = Math.abs( thresholdA.y - position.y ) / Math.abs( thresholdA.y - thresholdB.y ); break; } } } const colorA = colors[ thresholdIndexA ]; const colorB = colors[ thresholdIndexB ]; color.copy( colorA ).lerp( colorB, t ).convertSRGBToLinear(); colorAttribute.setXYZ( index, color.r, color.g, color.b ); } geometry.setAttribute( 'color', colorAttribute ); } // const textureLoader = new TextureLoader( this.manager ); textureLoader.setPath( this.resourcePath || path ).setCrossOrigin( this.crossOrigin ); // check version (only 2.0 is supported) if ( data.indexOf( '#VRML V2.0' ) === - 1 ) { throw Error( 'THREE.VRMLLexer: Version of VRML asset not supported.' ); } // create JSON representing the tree structure of the VRML asset const tree = generateVRMLTree( data ); // parse the tree structure to a three.js scene const scene = parseTree( tree ); return scene; } } class VRMLLexer { constructor( tokens ) { this.lexer = new chevrotain.Lexer( tokens ); } lex( inputText ) { const lexingResult = this.lexer.tokenize( inputText ); if ( lexingResult.errors.length > 0 ) { console.error( lexingResult.errors ); throw Error( 'THREE.VRMLLexer: Lexing errors detected.' ); } return lexingResult; } } const CstParser = chevrotain.CstParser; class VRMLParser extends CstParser { constructor( tokenVocabulary ) { super( tokenVocabulary ); const $ = this; const Version = tokenVocabulary[ 'Version' ]; const LCurly = tokenVocabulary[ 'LCurly' ]; const RCurly = tokenVocabulary[ 'RCurly' ]; const LSquare = tokenVocabulary[ 'LSquare' ]; const RSquare = tokenVocabulary[ 'RSquare' ]; const Identifier = tokenVocabulary[ 'Identifier' ]; const RouteIdentifier = tokenVocabulary[ 'RouteIdentifier' ]; const StringLiteral = tokenVocabulary[ 'StringLiteral' ]; const HexLiteral = tokenVocabulary[ 'HexLiteral' ]; const NumberLiteral = tokenVocabulary[ 'NumberLiteral' ]; const TrueLiteral = tokenVocabulary[ 'TrueLiteral' ]; const FalseLiteral = tokenVocabulary[ 'FalseLiteral' ]; const NullLiteral = tokenVocabulary[ 'NullLiteral' ]; const DEF = tokenVocabulary[ 'DEF' ]; const USE = tokenVocabulary[ 'USE' ]; const ROUTE = tokenVocabulary[ 'ROUTE' ]; const TO = tokenVocabulary[ 'TO' ]; const NodeName = tokenVocabulary[ 'NodeName' ]; $.RULE( 'vrml', function () { $.SUBRULE( $.version ); $.AT_LEAST_ONE( function () { $.SUBRULE( $.node ); } ); $.MANY( function () { $.SUBRULE( $.route ); } ); } ); $.RULE( 'version', function () { $.CONSUME( Version ); } ); $.RULE( 'node', function () { $.OPTION( function () { $.SUBRULE( $.def ); } ); $.CONSUME( NodeName ); $.CONSUME( LCurly ); $.MANY( function () { $.SUBRULE( $.field ); } ); $.CONSUME( RCurly ); } ); $.RULE( 'field', function () { $.CONSUME( Identifier ); $.OR2( [ { ALT: function () { $.SUBRULE( $.singleFieldValue ); } }, { ALT: function () { $.SUBRULE( $.multiFieldValue ); } } ] ); } ); $.RULE( 'def', function () { $.CONSUME( DEF ); $.OR( [ { ALT: function () { $.CONSUME( Identifier ); } }, { ALT: function () { $.CONSUME( NodeName ); } } ] ); } ); $.RULE( 'use', function () { $.CONSUME( USE ); $.OR( [ { ALT: function () { $.CONSUME( Identifier ); } }, { ALT: function () { $.CONSUME( NodeName ); } } ] ); } ); $.RULE( 'singleFieldValue', function () { $.AT_LEAST_ONE( function () { $.OR( [ { ALT: function () { $.SUBRULE( $.node ); } }, { ALT: function () { $.SUBRULE( $.use ); } }, { ALT: function () { $.CONSUME( StringLiteral ); } }, { ALT: function () { $.CONSUME( HexLiteral ); } }, { ALT: function () { $.CONSUME( NumberLiteral ); } }, { ALT: function () { $.CONSUME( TrueLiteral ); } }, { ALT: function () { $.CONSUME( FalseLiteral ); } }, { ALT: function () { $.CONSUME( NullLiteral ); } } ] ); } ); } ); $.RULE( 'multiFieldValue', function () { $.CONSUME( LSquare ); $.MANY( function () { $.OR( [ { ALT: function () { $.SUBRULE( $.node ); } }, { ALT: function () { $.SUBRULE( $.use ); } }, { ALT: function () { $.CONSUME( StringLiteral ); } }, { ALT: function () { $.CONSUME( HexLiteral ); } }, { ALT: function () { $.CONSUME( NumberLiteral ); } }, { ALT: function () { $.CONSUME( NullLiteral ); } } ] ); } ); $.CONSUME( RSquare ); } ); $.RULE( 'route', function () { $.CONSUME( ROUTE ); $.CONSUME( RouteIdentifier ); $.CONSUME( TO ); $.CONSUME2( RouteIdentifier ); } ); this.performSelfAnalysis(); } } class Face { constructor( a, b, c ) { this.a = a; this.b = b; this.c = c; this.normal = new Vector3(); } } const TEXTURE_TYPE = { INTENSITY: 1, INTENSITY_ALPHA: 2, RGB: 3, RGBA: 4 }; export { VRMLLoader };"},{"title":"","date":"2023-10-12T14:08:40.767Z","updated":"2023-10-12T14:08:40.767Z","comments":true,"path":"js/three/jsm/loaders/VTKLoader.js","permalink":"http://19999997.xyz/js/three/jsm/loaders/VTKLoader.js","excerpt":"","text":"import { BufferAttribute, BufferGeometry, Color, FileLoader, Float32BufferAttribute, Loader } from 'three'; import * as fflate from '../libs/fflate.module.js'; class VTKLoader extends Loader { constructor( manager ) { super( manager ); } load( url, onLoad, onProgress, onError ) { const scope = this; const loader = new FileLoader( scope.manager ); loader.setPath( scope.path ); loader.setResponseType( 'arraybuffer' ); loader.setRequestHeader( scope.requestHeader ); loader.setWithCredentials( scope.withCredentials ); loader.load( url, function ( text ) { try { onLoad( scope.parse( text ) ); } catch ( e ) { if ( onError ) { onError( e ); } else { console.error( e ); } scope.manager.itemError( url ); } }, onProgress, onError ); } parse( data ) { function parseASCII( data ) { // connectivity of the triangles const indices = []; // triangles vertices const positions = []; // red, green, blue colors in the range 0 to 1 const colors = []; // normal vector, one per vertex const normals = []; let result; // pattern for detecting the end of a number sequence const patWord = /^[^\\d.\\s-]+/; // pattern for reading vertices, 3 floats or integers const pat3Floats = /(\\-?\\d+\\.?[\\d\\-\\+e]*)\\s+(\\-?\\d+\\.?[\\d\\-\\+e]*)\\s+(\\-?\\d+\\.?[\\d\\-\\+e]*)/g; // pattern for connectivity, an integer followed by any number of ints // the first integer is the number of polygon nodes const patConnectivity = /^(\\d+)\\s+([\\s\\d]*)/; // indicates start of vertex data section const patPOINTS = /^POINTS /; // indicates start of polygon connectivity section const patPOLYGONS = /^POLYGONS /; // indicates start of triangle strips section const patTRIANGLE_STRIPS = /^TRIANGLE_STRIPS /; // POINT_DATA number_of_values const patPOINT_DATA = /^POINT_DATA[ ]+(\\d+)/; // CELL_DATA number_of_polys const patCELL_DATA = /^CELL_DATA[ ]+(\\d+)/; // Start of color section const patCOLOR_SCALARS = /^COLOR_SCALARS[ ]+(\\w+)[ ]+3/; // NORMALS Normals float const patNORMALS = /^NORMALS[ ]+(\\w+)[ ]+(\\w+)/; let inPointsSection = false; let inPolygonsSection = false; let inTriangleStripSection = false; let inPointDataSection = false; let inCellDataSection = false; let inColorSection = false; let inNormalsSection = false; const color = new Color(); const lines = data.split( '\\n' ); for ( const i in lines ) { const line = lines[ i ].trim(); if ( line.indexOf( 'DATASET' ) === 0 ) { const dataset = line.split( ' ' )[ 1 ]; if ( dataset !== 'POLYDATA' ) throw new Error( 'Unsupported DATASET type: ' + dataset ); } else if ( inPointsSection ) { // get the vertices while ( ( result = pat3Floats.exec( line ) ) !== null ) { if ( patWord.exec( line ) !== null ) break; const x = parseFloat( result[ 1 ] ); const y = parseFloat( result[ 2 ] ); const z = parseFloat( result[ 3 ] ); positions.push( x, y, z ); } } else if ( inPolygonsSection ) { if ( ( result = patConnectivity.exec( line ) ) !== null ) { // numVertices i0 i1 i2 ... const numVertices = parseInt( result[ 1 ] ); const inds = result[ 2 ].split( /\\s+/ ); if ( numVertices >= 3 ) { const i0 = parseInt( inds[ 0 ] ); let k = 1; // split the polygon in numVertices - 2 triangles for ( let j = 0; j < numVertices - 2; ++ j ) { const i1 = parseInt( inds[ k ] ); const i2 = parseInt( inds[ k + 1 ] ); indices.push( i0, i1, i2 ); k ++; } } } } else if ( inTriangleStripSection ) { if ( ( result = patConnectivity.exec( line ) ) !== null ) { // numVertices i0 i1 i2 ... const numVertices = parseInt( result[ 1 ] ); const inds = result[ 2 ].split( /\\s+/ ); if ( numVertices >= 3 ) { // split the polygon in numVertices - 2 triangles for ( let j = 0; j < numVertices - 2; j ++ ) { if ( j % 2 === 1 ) { const i0 = parseInt( inds[ j ] ); const i1 = parseInt( inds[ j + 2 ] ); const i2 = parseInt( inds[ j + 1 ] ); indices.push( i0, i1, i2 ); } else { const i0 = parseInt( inds[ j ] ); const i1 = parseInt( inds[ j + 1 ] ); const i2 = parseInt( inds[ j + 2 ] ); indices.push( i0, i1, i2 ); } } } } } else if ( inPointDataSection || inCellDataSection ) { if ( inColorSection ) { // Get the colors while ( ( result = pat3Floats.exec( line ) ) !== null ) { if ( patWord.exec( line ) !== null ) break; const r = parseFloat( result[ 1 ] ); const g = parseFloat( result[ 2 ] ); const b = parseFloat( result[ 3 ] ); color.set( r, g, b ).convertSRGBToLinear(); colors.push( color.r, color.g, color.b ); } } else if ( inNormalsSection ) { // Get the normal vectors while ( ( result = pat3Floats.exec( line ) ) !== null ) { if ( patWord.exec( line ) !== null ) break; const nx = parseFloat( result[ 1 ] ); const ny = parseFloat( result[ 2 ] ); const nz = parseFloat( result[ 3 ] ); normals.push( nx, ny, nz ); } } } if ( patPOLYGONS.exec( line ) !== null ) { inPolygonsSection = true; inPointsSection = false; inTriangleStripSection = false; } else if ( patPOINTS.exec( line ) !== null ) { inPolygonsSection = false; inPointsSection = true; inTriangleStripSection = false; } else if ( patTRIANGLE_STRIPS.exec( line ) !== null ) { inPolygonsSection = false; inPointsSection = false; inTriangleStripSection = true; } else if ( patPOINT_DATA.exec( line ) !== null ) { inPointDataSection = true; inPointsSection = false; inPolygonsSection = false; inTriangleStripSection = false; } else if ( patCELL_DATA.exec( line ) !== null ) { inCellDataSection = true; inPointsSection = false; inPolygonsSection = false; inTriangleStripSection = false; } else if ( patCOLOR_SCALARS.exec( line ) !== null ) { inColorSection = true; inNormalsSection = false; inPointsSection = false; inPolygonsSection = false; inTriangleStripSection = false; } else if ( patNORMALS.exec( line ) !== null ) { inNormalsSection = true; inColorSection = false; inPointsSection = false; inPolygonsSection = false; inTriangleStripSection = false; } } let geometry = new BufferGeometry(); geometry.setIndex( indices ); geometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) ); if ( normals.length === positions.length ) { geometry.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) ); } if ( colors.length !== indices.length ) { // stagger if ( colors.length === positions.length ) { geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) ); } } else { // cell geometry = geometry.toNonIndexed(); const numTriangles = geometry.attributes.position.count / 3; if ( colors.length === ( numTriangles * 3 ) ) { const newColors = []; for ( let i = 0; i < numTriangles; i ++ ) { const r = colors[ 3 * i + 0 ]; const g = colors[ 3 * i + 1 ]; const b = colors[ 3 * i + 2 ]; color.set( r, g, b ).convertSRGBToLinear(); newColors.push( color.r, color.g, color.b ); newColors.push( color.r, color.g, color.b ); newColors.push( color.r, color.g, color.b ); } geometry.setAttribute( 'color', new Float32BufferAttribute( newColors, 3 ) ); } } return geometry; } function parseBinary( data ) { const buffer = new Uint8Array( data ); const dataView = new DataView( data ); // Points and normals, by default, are empty let points = []; let normals = []; let indices = []; let index = 0; function findString( buffer, start ) { let index = start; let c = buffer[ index ]; const s = []; while ( c !== 10 ) { s.push( String.fromCharCode( c ) ); index ++; c = buffer[ index ]; } return { start: start, end: index, next: index + 1, parsedString: s.join( '' ) }; } let state, line; while ( true ) { // Get a string state = findString( buffer, index ); line = state.parsedString; if ( line.indexOf( 'DATASET' ) === 0 ) { const dataset = line.split( ' ' )[ 1 ]; if ( dataset !== 'POLYDATA' ) throw new Error( 'Unsupported DATASET type: ' + dataset ); } else if ( line.indexOf( 'POINTS' ) === 0 ) { // Add the points const numberOfPoints = parseInt( line.split( ' ' )[ 1 ], 10 ); // Each point is 3 4-byte floats const count = numberOfPoints * 4 * 3; points = new Float32Array( numberOfPoints * 3 ); let pointIndex = state.next; for ( let i = 0; i < numberOfPoints; i ++ ) { points[ 3 * i ] = dataView.getFloat32( pointIndex, false ); points[ 3 * i + 1 ] = dataView.getFloat32( pointIndex + 4, false ); points[ 3 * i + 2 ] = dataView.getFloat32( pointIndex + 8, false ); pointIndex = pointIndex + 12; } // increment our next pointer state.next = state.next + count + 1; } else if ( line.indexOf( 'TRIANGLE_STRIPS' ) === 0 ) { const numberOfStrips = parseInt( line.split( ' ' )[ 1 ], 10 ); const size = parseInt( line.split( ' ' )[ 2 ], 10 ); // 4 byte integers const count = size * 4; indices = new Uint32Array( 3 * size - 9 * numberOfStrips ); let indicesIndex = 0; let pointIndex = state.next; for ( let i = 0; i < numberOfStrips; i ++ ) { // For each strip, read the first value, then record that many more points const indexCount = dataView.getInt32( pointIndex, false ); const strip = []; pointIndex += 4; for ( let s = 0; s < indexCount; s ++ ) { strip.push( dataView.getInt32( pointIndex, false ) ); pointIndex += 4; } // retrieves the n-2 triangles from the triangle strip for ( let j = 0; j < indexCount - 2; j ++ ) { if ( j % 2 ) { indices[ indicesIndex ++ ] = strip[ j ]; indices[ indicesIndex ++ ] = strip[ j + 2 ]; indices[ indicesIndex ++ ] = strip[ j + 1 ]; } else { indices[ indicesIndex ++ ] = strip[ j ]; indices[ indicesIndex ++ ] = strip[ j + 1 ]; indices[ indicesIndex ++ ] = strip[ j + 2 ]; } } } // increment our next pointer state.next = state.next + count + 1; } else if ( line.indexOf( 'POLYGONS' ) === 0 ) { const numberOfStrips = parseInt( line.split( ' ' )[ 1 ], 10 ); const size = parseInt( line.split( ' ' )[ 2 ], 10 ); // 4 byte integers const count = size * 4; indices = new Uint32Array( 3 * size - 9 * numberOfStrips ); let indicesIndex = 0; let pointIndex = state.next; for ( let i = 0; i < numberOfStrips; i ++ ) { // For each strip, read the first value, then record that many more points const indexCount = dataView.getInt32( pointIndex, false ); const strip = []; pointIndex += 4; for ( let s = 0; s < indexCount; s ++ ) { strip.push( dataView.getInt32( pointIndex, false ) ); pointIndex += 4; } // divide the polygon in n-2 triangle for ( let j = 1; j < indexCount - 1; j ++ ) { indices[ indicesIndex ++ ] = strip[ 0 ]; indices[ indicesIndex ++ ] = strip[ j ]; indices[ indicesIndex ++ ] = strip[ j + 1 ]; } } // increment our next pointer state.next = state.next + count + 1; } else if ( line.indexOf( 'POINT_DATA' ) === 0 ) { const numberOfPoints = parseInt( line.split( ' ' )[ 1 ], 10 ); // Grab the next line state = findString( buffer, state.next ); // Now grab the binary data const count = numberOfPoints * 4 * 3; normals = new Float32Array( numberOfPoints * 3 ); let pointIndex = state.next; for ( let i = 0; i < numberOfPoints; i ++ ) { normals[ 3 * i ] = dataView.getFloat32( pointIndex, false ); normals[ 3 * i + 1 ] = dataView.getFloat32( pointIndex + 4, false ); normals[ 3 * i + 2 ] = dataView.getFloat32( pointIndex + 8, false ); pointIndex += 12; } // Increment past our data state.next = state.next + count; } // Increment index index = state.next; if ( index >= buffer.byteLength ) { break; } } const geometry = new BufferGeometry(); geometry.setIndex( new BufferAttribute( indices, 1 ) ); geometry.setAttribute( 'position', new BufferAttribute( points, 3 ) ); if ( normals.length === points.length ) { geometry.setAttribute( 'normal', new BufferAttribute( normals, 3 ) ); } return geometry; } function Float32Concat( first, second ) { const firstLength = first.length, result = new Float32Array( firstLength + second.length ); result.set( first ); result.set( second, firstLength ); return result; } function Int32Concat( first, second ) { const firstLength = first.length, result = new Int32Array( firstLength + second.length ); result.set( first ); result.set( second, firstLength ); return result; } function parseXML( stringFile ) { // Changes XML to JSON, based on https://davidwalsh.name/convert-xml-json function xmlToJson( xml ) { // Create the return object let obj = {}; if ( xml.nodeType === 1 ) { // element // do attributes if ( xml.attributes ) { if ( xml.attributes.length > 0 ) { obj[ 'attributes' ] = {}; for ( let j = 0; j < xml.attributes.length; j ++ ) { const attribute = xml.attributes.item( j ); obj[ 'attributes' ][ attribute.nodeName ] = attribute.nodeValue.trim(); } } } } else if ( xml.nodeType === 3 ) { // text obj = xml.nodeValue.trim(); } // do children if ( xml.hasChildNodes() ) { for ( let i = 0; i < xml.childNodes.length; i ++ ) { const item = xml.childNodes.item( i ); const nodeName = item.nodeName; if ( typeof obj[ nodeName ] === 'undefined' ) { const tmp = xmlToJson( item ); if ( tmp !== '' ) obj[ nodeName ] = tmp; } else { if ( typeof obj[ nodeName ].push === 'undefined' ) { const old = obj[ nodeName ]; obj[ nodeName ] = [ old ]; } const tmp = xmlToJson( item ); if ( tmp !== '' ) obj[ nodeName ].push( tmp ); } } } return obj; } // Taken from Base64-js function Base64toByteArray( b64 ) { const Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array; const revLookup = []; const code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'; for ( let i = 0, l = code.length; i < l; ++ i ) { revLookup[ code.charCodeAt( i ) ] = i; } revLookup[ '-'.charCodeAt( 0 ) ] = 62; revLookup[ '_'.charCodeAt( 0 ) ] = 63; const len = b64.length; if ( len % 4 > 0 ) { throw new Error( 'Invalid string. Length must be a multiple of 4' ); } const placeHolders = b64[ len - 2 ] === '=' ? 2 : b64[ len - 1 ] === '=' ? 1 : 0; const arr = new Arr( len * 3 / 4 - placeHolders ); const l = placeHolders > 0 ? len - 4 : len; let L = 0; let i, j; for ( i = 0, j = 0; i < l; i += 4, j += 3 ) { const tmp = ( revLookup[ b64.charCodeAt( i ) ] < 18 ) | ( revLookup[ b64.charCodeAt( i + 1 ) ] < 12 ) | ( revLookup[ b64.charCodeAt( i + 2 ) ] < 6 ) | revLookup[ b64.charCodeAt( i + 3 ) ]; arr[ L ++ ] = ( tmp & 0xFF0000 ) >> 16; arr[ L ++ ] = ( tmp & 0xFF00 ) >> 8; arr[ L ++ ] = tmp & 0xFF; } if ( placeHolders === 2 ) { const tmp = ( revLookup[ b64.charCodeAt( i ) ] < 2 ) | ( revLookup[ b64.charCodeAt( i + 1 ) ] >> 4 ); arr[ L ++ ] = tmp & 0xFF; } else if ( placeHolders === 1 ) { const tmp = ( revLookup[ b64.charCodeAt( i ) ] < 10 ) | ( revLookup[ b64.charCodeAt( i + 1 ) ] < 4 ) | ( revLookup[ b64.charCodeAt( i + 2 ) ] >> 2 ); arr[ L ++ ] = ( tmp >> 8 ) & 0xFF; arr[ L ++ ] = tmp & 0xFF; } return arr; } function parseDataArray( ele, compressed ) { let numBytes = 0; if ( json.attributes.header_type === 'UInt64' ) { numBytes = 8; } else if ( json.attributes.header_type === 'UInt32' ) { numBytes = 4; } let txt, content; // Check the format if ( ele.attributes.format === 'binary' && compressed ) { if ( ele.attributes.type === 'Float32' ) { txt = new Float32Array( ); } else if ( ele.attributes.type === 'Int32' || ele.attributes.type === 'Int64' ) { txt = new Int32Array( ); } // VTP data with the header has the following structure: // [#blocks][#u-size][#p-size][#c-size-1][#c-size-2]...[#c-size-#blocks][DATA] // // Each token is an integer value whose type is specified by \"header_type\" at the top of the file (UInt32 if no type specified). The token meanings are: // [#blocks] = Number of blocks // [#u-size] = Block size before compression // [#p-size] = Size of last partial block (zero if it not needed) // [#c-size-i] = Size in bytes of block i after compression // // The [DATA] portion stores contiguously every block appended together. The offset from the beginning of the data section to the beginning of a block is // computed by summing the compressed block sizes from preceding blocks according to the header. const textNode = ele[ '#text' ]; const rawData = Array.isArray( textNode ) ? textNode[ 0 ] : textNode; const byteData = Base64toByteArray( rawData ); // Each data point consists of 8 bits regardless of the header type const dataPointSize = 8; let blocks = byteData[ 0 ]; for ( let i = 1; i < numBytes - 1; i ++ ) { blocks = blocks | ( byteData[ i ] < ( i * dataPointSize ) ); } let headerSize = ( blocks + 3 ) * numBytes; const padding = ( ( headerSize % 3 ) > 0 ) ? 3 - ( headerSize % 3 ) : 0; headerSize = headerSize + padding; const dataOffsets = []; let currentOffset = headerSize; dataOffsets.push( currentOffset ); // Get the blocks sizes after the compression. // There are three blocks before c-size-i, so we skip 3*numBytes const cSizeStart = 3 * numBytes; for ( let i = 0; i < blocks; i ++ ) { let currentBlockSize = byteData[ i * numBytes + cSizeStart ]; for ( let j = 1; j < numBytes - 1; j ++ ) { currentBlockSize = currentBlockSize | ( byteData[ i * numBytes + cSizeStart + j ] < ( j * dataPointSize ) ); } currentOffset = currentOffset + currentBlockSize; dataOffsets.push( currentOffset ); } for ( let i = 0; i < dataOffsets.length - 1; i ++ ) { const data = fflate.unzlibSync( byteData.slice( dataOffsets[ i ], dataOffsets[ i + 1 ] ) ); content = data.buffer; if ( ele.attributes.type === 'Float32' ) { content = new Float32Array( content ); txt = Float32Concat( txt, content ); } else if ( ele.attributes.type === 'Int32' || ele.attributes.type === 'Int64' ) { content = new Int32Array( content ); txt = Int32Concat( txt, content ); } } delete ele[ '#text' ]; if ( ele.attributes.type === 'Int64' ) { if ( ele.attributes.format === 'binary' ) { txt = txt.filter( function ( el, idx ) { if ( idx % 2 !== 1 ) return true; } ); } } } else { if ( ele.attributes.format === 'binary' && ! compressed ) { content = Base64toByteArray( ele[ '#text' ] ); // VTP data for the uncompressed case has the following structure: // [#bytes][DATA] // where \"[#bytes]\" is an integer value specifying the number of bytes in the block of data following it. content = content.slice( numBytes ).buffer; } else { if ( ele[ '#text' ] ) { content = ele[ '#text' ].split( /\\s+/ ).filter( function ( el ) { if ( el !== '' ) return el; } ); } else { content = new Int32Array( 0 ).buffer; } } delete ele[ '#text' ]; // Get the content and optimize it if ( ele.attributes.type === 'Float32' ) { txt = new Float32Array( content ); } else if ( ele.attributes.type === 'Int32' ) { txt = new Int32Array( content ); } else if ( ele.attributes.type === 'Int64' ) { txt = new Int32Array( content ); if ( ele.attributes.format === 'binary' ) { txt = txt.filter( function ( el, idx ) { if ( idx % 2 !== 1 ) return true; } ); } } } // endif ( ele.attributes.format === 'binary' && compressed ) return txt; } // Main part // Get Dom const dom = new DOMParser().parseFromString( stringFile, 'application/xml' ); // Get the doc const doc = dom.documentElement; // Convert to json const json = xmlToJson( doc ); let points = []; let normals = []; let indices = []; if ( json.PolyData ) { const piece = json.PolyData.Piece; const compressed = json.attributes.hasOwnProperty( 'compressor' ); // Can be optimized // Loop through the sections const sections = [ 'PointData', 'Points', 'Strips', 'Polys' ];// +['CellData', 'Verts', 'Lines']; let sectionIndex = 0; const numberOfSections = sections.length; while ( sectionIndex < numberOfSections ) { const section = piece[ sections[ sectionIndex ] ]; // If it has a DataArray in it if ( section && section.DataArray ) { // Depending on the number of DataArrays let arr; if ( Array.isArray( section.DataArray ) ) { arr = section.DataArray; } else { arr = [ section.DataArray ]; } let dataArrayIndex = 0; const numberOfDataArrays = arr.length; while ( dataArrayIndex < numberOfDataArrays ) { // Parse the DataArray if ( ( '#text' in arr[ dataArrayIndex ] ) && ( arr[ dataArrayIndex ][ '#text' ].length > 0 ) ) { arr[ dataArrayIndex ].text = parseDataArray( arr[ dataArrayIndex ], compressed ); } dataArrayIndex ++; } switch ( sections[ sectionIndex ] ) { // if iti is point data case 'PointData': { const numberOfPoints = parseInt( piece.attributes.NumberOfPoints ); const normalsName = section.attributes.Normals; if ( numberOfPoints > 0 ) { for ( let i = 0, len = arr.length; i < len; i ++ ) { if ( normalsName === arr[ i ].attributes.Name ) { const components = arr[ i ].attributes.NumberOfComponents; normals = new Float32Array( numberOfPoints * components ); normals.set( arr[ i ].text, 0 ); } } } } break; // if it is points case 'Points': { const numberOfPoints = parseInt( piece.attributes.NumberOfPoints ); if ( numberOfPoints > 0 ) { const components = section.DataArray.attributes.NumberOfComponents; points = new Float32Array( numberOfPoints * components ); points.set( section.DataArray.text, 0 ); } } break; // if it is strips case 'Strips': { const numberOfStrips = parseInt( piece.attributes.NumberOfStrips ); if ( numberOfStrips > 0 ) { const connectivity = new Int32Array( section.DataArray[ 0 ].text.length ); const offset = new Int32Array( section.DataArray[ 1 ].text.length ); connectivity.set( section.DataArray[ 0 ].text, 0 ); offset.set( section.DataArray[ 1 ].text, 0 ); const size = numberOfStrips + connectivity.length; indices = new Uint32Array( 3 * size - 9 * numberOfStrips ); let indicesIndex = 0; for ( let i = 0, len = numberOfStrips; i < len; i ++ ) { const strip = []; for ( let s = 0, len1 = offset[ i ], len0 = 0; s < len1 - len0; s ++ ) { strip.push( connectivity[ s ] ); if ( i > 0 ) len0 = offset[ i - 1 ]; } for ( let j = 0, len1 = offset[ i ], len0 = 0; j < len1 - len0 - 2; j ++ ) { if ( j % 2 ) { indices[ indicesIndex ++ ] = strip[ j ]; indices[ indicesIndex ++ ] = strip[ j + 2 ]; indices[ indicesIndex ++ ] = strip[ j + 1 ]; } else { indices[ indicesIndex ++ ] = strip[ j ]; indices[ indicesIndex ++ ] = strip[ j + 1 ]; indices[ indicesIndex ++ ] = strip[ j + 2 ]; } if ( i > 0 ) len0 = offset[ i - 1 ]; } } } } break; // if it is polys case 'Polys': { const numberOfPolys = parseInt( piece.attributes.NumberOfPolys ); if ( numberOfPolys > 0 ) { const connectivity = new Int32Array( section.DataArray[ 0 ].text.length ); const offset = new Int32Array( section.DataArray[ 1 ].text.length ); connectivity.set( section.DataArray[ 0 ].text, 0 ); offset.set( section.DataArray[ 1 ].text, 0 ); const size = numberOfPolys + connectivity.length; indices = new Uint32Array( 3 * size - 9 * numberOfPolys ); let indicesIndex = 0, connectivityIndex = 0; let i = 0, len0 = 0; const len = numberOfPolys; while ( i < len ) { const poly = []; let s = 0; const len1 = offset[ i ]; while ( s < len1 - len0 ) { poly.push( connectivity[ connectivityIndex ++ ] ); s ++; } let j = 1; while ( j < len1 - len0 - 1 ) { indices[ indicesIndex ++ ] = poly[ 0 ]; indices[ indicesIndex ++ ] = poly[ j ]; indices[ indicesIndex ++ ] = poly[ j + 1 ]; j ++; } i ++; len0 = offset[ i - 1 ]; } } } break; default: break; } } sectionIndex ++; } const geometry = new BufferGeometry(); geometry.setIndex( new BufferAttribute( indices, 1 ) ); geometry.setAttribute( 'position', new BufferAttribute( points, 3 ) ); if ( normals.length === points.length ) { geometry.setAttribute( 'normal', new BufferAttribute( normals, 3 ) ); } return geometry; } else { throw new Error( 'Unsupported DATASET type' ); } } const textDecoder = new TextDecoder(); // get the 5 first lines of the files to check if there is the key word binary const meta = textDecoder.decode( new Uint8Array( data, 0, 250 ) ).split( '\\n' ); if ( meta[ 0 ].indexOf( 'xml' ) !== - 1 ) { return parseXML( textDecoder.decode( data ) ); } else if ( meta[ 2 ].includes( 'ASCII' ) ) { return parseASCII( textDecoder.decode( data ) ); } else { return parseBinary( data ); } } } export { VTKLoader };"},{"title":"","date":"2023-10-12T14:08:40.772Z","updated":"2023-10-12T14:08:40.772Z","comments":true,"path":"js/three/jsm/loaders/lwo/IFFParser.js","permalink":"http://19999997.xyz/js/three/jsm/loaders/lwo/IFFParser.js","excerpt":"","text":"/** * === IFFParser === * - Parses data from the IFF buffer. * - LWO3 files are in IFF format and can contain the following data types, referred to by shorthand codes * * ATOMIC DATA TYPES * ID Tag - 4x 7 bit uppercase ASCII chars: ID4 * signed integer, 1, 2, or 4 byte length: I1, I2, I4 * unsigned integer, 1, 2, or 4 byte length: U1, U2, U4 * float, 4 byte length: F4 * string, series of ASCII chars followed by null byte (If the length of the string including the null terminating byte is odd, an extra null is added so that the data that follows will begin on an even byte boundary): S0 * * COMPOUND DATA TYPES * Variable-length Index (index into an array or collection): U2 or U4 : VX * Color (RGB): F4 + F4 + F4: COL12 * Coordinate (x, y, z): F4 + F4 + F4: VEC12 * Percentage F4 data type from 0->1 with 1 = 100%: FP4 * Angle in radian F4: ANG4 * Filename (string) S0: FNAM0 * XValue F4 + index (VX) + optional envelope( ENVL ): XVAL * XValue vector VEC12 + index (VX) + optional envelope( ENVL ): XVAL3 * * The IFF file is arranged in chunks: * CHUNK = ID4 + length (U4) + length X bytes of data + optional 0 pad byte * optional 0 pad byte is there to ensure chunk ends on even boundary, not counted in size * * COMPOUND DATA TYPES * - Chunks are combined in Forms (collections of chunks) * - FORM = string 'FORM' (ID4) + length (U4) + type (ID4) + optional ( CHUNK | FORM ) * - CHUNKS and FORMS are collectively referred to as blocks * - The entire file is contained in one top level FORM * **/ import { LWO2Parser } from './LWO2Parser.js'; import { LWO3Parser } from './LWO3Parser.js'; function IFFParser( ) { this.debugger = new Debugger(); // this.debugger.enable(); // un-comment to log IFF hierarchy. } IFFParser.prototype = { constructor: IFFParser, parse: function ( buffer ) { this.reader = new DataViewReader( buffer ); this.tree = { materials: {}, layers: [], tags: [], textures: [], }; // start out at the top level to add any data before first layer is encountered this.currentLayer = this.tree; this.currentForm = this.tree; this.parseTopForm(); if ( this.tree.format === undefined ) return; if ( this.tree.format === 'LWO2' ) { this.parser = new LWO2Parser( this ); while ( ! this.reader.endOfFile() ) this.parser.parseBlock(); } else if ( this.tree.format === 'LWO3' ) { this.parser = new LWO3Parser( this ); while ( ! this.reader.endOfFile() ) this.parser.parseBlock(); } this.debugger.offset = this.reader.offset; this.debugger.closeForms(); return this.tree; }, parseTopForm() { this.debugger.offset = this.reader.offset; var topForm = this.reader.getIDTag(); if ( topForm !== 'FORM' ) { console.warn( 'LWOLoader: Top-level FORM missing.' ); return; } var length = this.reader.getUint32(); this.debugger.dataOffset = this.reader.offset; this.debugger.length = length; var type = this.reader.getIDTag(); if ( type === 'LWO2' ) { this.tree.format = type; } else if ( type === 'LWO3' ) { this.tree.format = type; } this.debugger.node = 0; this.debugger.nodeID = type; this.debugger.log(); return; }, /// // FORM PARSING METHODS /// // Forms are organisational and can contain any number of sub chunks and sub forms // FORM ::= 'FORM'[ID4], length[U4], type[ID4], ( chunk[CHUNK] | form[FORM] ) * } parseForm( length ) { var type = this.reader.getIDTag(); switch ( type ) { // SKIPPED FORMS // if skipForm( length ) is called, the entire form and any sub forms and chunks are skipped case 'ISEQ': // Image sequence case 'ANIM': // plug in animation case 'STCC': // Color-cycling Still case 'VPVL': case 'VPRM': case 'NROT': case 'WRPW': // image wrap w ( for cylindrical and spherical projections) case 'WRPH': // image wrap h case 'FUNC': case 'FALL': case 'OPAC': case 'GRAD': // gradient texture case 'ENVS': case 'VMOP': case 'VMBG': // Car Material FORMS case 'OMAX': case 'STEX': case 'CKBG': case 'CKEY': case 'VMLA': case 'VMLB': this.debugger.skipped = true; this.skipForm( length ); // not currently supported break; // if break; is called directly, the position in the lwoTree is not created // any sub chunks and forms are added to the parent form instead case 'META': case 'NNDS': case 'NODS': case 'NDTA': case 'ADAT': case 'AOVS': case 'BLOK': // used by texture nodes case 'IBGC': // imageBackgroundColor case 'IOPC': // imageOpacity case 'IIMG': // hold reference to image path case 'TXTR': // this.setupForm( type, length ); this.debugger.length = 4; this.debugger.skipped = true; break; case 'IFAL': // imageFallof case 'ISCL': // imageScale case 'IPOS': // imagePosition case 'IROT': // imageRotation case 'IBMP': case 'IUTD': case 'IVTD': this.parseTextureNodeAttribute( type ); break; case 'ENVL': this.parseEnvelope( length ); break; // CLIP FORM AND SUB FORMS case 'CLIP': if ( this.tree.format === 'LWO2' ) { this.parseForm( length ); } else { this.parseClip( length ); } break; case 'STIL': this.parseImage(); break; case 'XREF': // clone of another STIL this.reader.skip( 8 ); // unknown this.currentForm.referenceTexture = { index: this.reader.getUint32(), refName: this.reader.getString() // internal unique ref }; break; // Not in spec, used by texture nodes case 'IMST': this.parseImageStateForm( length ); break; // SURF FORM AND SUB FORMS case 'SURF': this.parseSurfaceForm( length ); break; case 'VALU': // Not in spec this.parseValueForm( length ); break; case 'NTAG': this.parseSubNode( length ); break; case 'ATTR': // BSDF Node Attributes case 'SATR': // Standard Node Attributes this.setupForm( 'attributes', length ); break; case 'NCON': this.parseConnections( length ); break; case 'SSHA': this.parentForm = this.currentForm; this.currentForm = this.currentSurface; this.setupForm( 'surfaceShader', length ); break; case 'SSHD': this.setupForm( 'surfaceShaderData', length ); break; case 'ENTR': // Not in spec this.parseEntryForm( length ); break; // Image Map Layer case 'IMAP': this.parseImageMap( length ); break; case 'TAMP': this.parseXVAL( 'amplitude', length ); break; //Texture Mapping Form case 'TMAP': this.setupForm( 'textureMap', length ); break; case 'CNTR': this.parseXVAL3( 'center', length ); break; case 'SIZE': this.parseXVAL3( 'scale', length ); break; case 'ROTA': this.parseXVAL3( 'rotation', length ); break; default: this.parseUnknownForm( type, length ); } this.debugger.node = 0; this.debugger.nodeID = type; this.debugger.log(); }, setupForm( type, length ) { if ( ! this.currentForm ) this.currentForm = this.currentNode; this.currentFormEnd = this.reader.offset + length; this.parentForm = this.currentForm; if ( ! this.currentForm[ type ] ) { this.currentForm[ type ] = {}; this.currentForm = this.currentForm[ type ]; } else { // should never see this unless there's a bug in the reader console.warn( 'LWOLoader: form already exists on parent: ', type, this.currentForm ); this.currentForm = this.currentForm[ type ]; } }, skipForm( length ) { this.reader.skip( length - 4 ); }, parseUnknownForm( type, length ) { console.warn( 'LWOLoader: unknown FORM encountered: ' + type, length ); printBuffer( this.reader.dv.buffer, this.reader.offset, length - 4 ); this.reader.skip( length - 4 ); }, parseSurfaceForm( length ) { this.reader.skip( 8 ); // unknown Uint32 x2 var name = this.reader.getString(); var surface = { attributes: {}, // LWO2 style non-node attributes will go here connections: {}, name: name, inputName: name, nodes: {}, source: this.reader.getString(), }; this.tree.materials[ name ] = surface; this.currentSurface = surface; this.parentForm = this.tree.materials; this.currentForm = surface; this.currentFormEnd = this.reader.offset + length; }, parseSurfaceLwo2( length ) { var name = this.reader.getString(); var surface = { attributes: {}, // LWO2 style non-node attributes will go here connections: {}, name: name, nodes: {}, source: this.reader.getString(), }; this.tree.materials[ name ] = surface; this.currentSurface = surface; this.parentForm = this.tree.materials; this.currentForm = surface; this.currentFormEnd = this.reader.offset + length; }, parseSubNode( length ) { // parse the NRNM CHUNK of the subnode FORM to get // a meaningful name for the subNode // some subnodes can be renamed, but Input and Surface cannot this.reader.skip( 8 ); // NRNM + length var name = this.reader.getString(); var node = { name: name }; this.currentForm = node; this.currentNode = node; this.currentFormEnd = this.reader.offset + length; }, // collect attributes from all nodes at the top level of a surface parseConnections( length ) { this.currentFormEnd = this.reader.offset + length; this.parentForm = this.currentForm; this.currentForm = this.currentSurface.connections; }, // surface node attribute data, e.g. specular, roughness etc parseEntryForm( length ) { this.reader.skip( 8 ); // NAME + length var name = this.reader.getString(); this.currentForm = this.currentNode.attributes; this.setupForm( name, length ); }, // parse values from material - doesn't match up to other LWO3 data types // sub form of entry form parseValueForm() { this.reader.skip( 8 ); // unknown + length var valueType = this.reader.getString(); if ( valueType === 'double' ) { this.currentForm.value = this.reader.getUint64(); } else if ( valueType === 'int' ) { this.currentForm.value = this.reader.getUint32(); } else if ( valueType === 'vparam' ) { this.reader.skip( 24 ); this.currentForm.value = this.reader.getFloat64(); } else if ( valueType === 'vparam3' ) { this.reader.skip( 24 ); this.currentForm.value = this.reader.getFloat64Array( 3 ); } }, // holds various data about texture node image state // Data other thanmipMapLevel unknown parseImageStateForm() { this.reader.skip( 8 ); // unknown this.currentForm.mipMapLevel = this.reader.getFloat32(); }, // LWO2 style image data node OR LWO3 textures defined at top level in editor (not as SURF node) parseImageMap( length ) { this.currentFormEnd = this.reader.offset + length; this.parentForm = this.currentForm; if ( ! this.currentForm.maps ) this.currentForm.maps = []; var map = {}; this.currentForm.maps.push( map ); this.currentForm = map; this.reader.skip( 10 ); // unknown, could be an issue if it contains a VX }, parseTextureNodeAttribute( type ) { this.reader.skip( 28 ); // FORM + length + VPRM + unknown + Uint32 x2 + float32 this.reader.skip( 20 ); // FORM + length + VPVL + float32 + Uint32 switch ( type ) { case 'ISCL': this.currentNode.scale = this.reader.getFloat32Array( 3 ); break; case 'IPOS': this.currentNode.position = this.reader.getFloat32Array( 3 ); break; case 'IROT': this.currentNode.rotation = this.reader.getFloat32Array( 3 ); break; case 'IFAL': this.currentNode.falloff = this.reader.getFloat32Array( 3 ); break; case 'IBMP': this.currentNode.amplitude = this.reader.getFloat32(); break; case 'IUTD': this.currentNode.uTiles = this.reader.getFloat32(); break; case 'IVTD': this.currentNode.vTiles = this.reader.getFloat32(); break; } this.reader.skip( 2 ); // unknown }, // ENVL forms are currently ignored parseEnvelope( length ) { this.reader.skip( length - 4 ); // skipping entirely for now }, /// // CHUNK PARSING METHODS /// // clips can either be defined inside a surface node, or at the top // level and they have a different format in each case parseClip( length ) { var tag = this.reader.getIDTag(); // inside surface node if ( tag === 'FORM' ) { this.reader.skip( 16 ); this.currentNode.fileName = this.reader.getString(); return; } // otherwise top level this.reader.setOffset( this.reader.offset - 4 ); this.currentFormEnd = this.reader.offset + length; this.parentForm = this.currentForm; this.reader.skip( 8 ); // unknown var texture = { index: this.reader.getUint32() }; this.tree.textures.push( texture ); this.currentForm = texture; }, parseClipLwo2( length ) { var texture = { index: this.reader.getUint32(), fileName: '' }; // seach STIL block while ( true ) { var tag = this.reader.getIDTag(); var n_length = this.reader.getUint16(); if ( tag === 'STIL' ) { texture.fileName = this.reader.getString(); break; } if ( n_length >= length ) { break; } } this.tree.textures.push( texture ); this.currentForm = texture; }, parseImage() { this.reader.skip( 8 ); // unknown this.currentForm.fileName = this.reader.getString(); }, parseXVAL( type, length ) { var endOffset = this.reader.offset + length - 4; this.reader.skip( 8 ); this.currentForm[ type ] = this.reader.getFloat32(); this.reader.setOffset( endOffset ); // set end offset directly to skip optional envelope }, parseXVAL3( type, length ) { var endOffset = this.reader.offset + length - 4; this.reader.skip( 8 ); this.currentForm[ type ] = { x: this.reader.getFloat32(), y: this.reader.getFloat32(), z: this.reader.getFloat32(), }; this.reader.setOffset( endOffset ); }, // Tags associated with an object // OTAG { type[ID4], tag-string[S0] } parseObjectTag() { if ( ! this.tree.objectTags ) this.tree.objectTags = {}; this.tree.objectTags[ this.reader.getIDTag() ] = { tagString: this.reader.getString() }; }, // Signals the start of a new layer. All the data chunks which follow will be included in this layer until another layer chunk is encountered. // LAYR: number[U2], flags[U2], pivot[VEC12], name[S0], parent[U2] parseLayer( length ) { var layer = { number: this.reader.getUint16(), flags: this.reader.getUint16(), // If the least significant bit of flags is set, the layer is hidden. pivot: this.reader.getFloat32Array( 3 ), // Note: this seems to be superflous, as the geometry is translated when pivot is present name: this.reader.getString(), }; this.tree.layers.push( layer ); this.currentLayer = layer; var parsedLength = 16 + stringOffset( this.currentLayer.name ); // index ( 2 ) + flags( 2 ) + pivot( 12 ) + stringlength // if we have not reached then end of the layer block, there must be a parent defined this.currentLayer.parent = ( parsedLength < length ) ? this.reader.getUint16() : - 1; // omitted or -1 for no parent }, // VEC12 * ( F4 + F4 + F4 ) array of x,y,z vectors // Converting from left to right handed coordinate system: // x -> -x and switch material FrontSide -> BackSide parsePoints( length ) { this.currentPoints = []; for ( var i = 0; i < length / 4; i += 3 ) { // z -> -z to match three.js right handed coords this.currentPoints.push( this.reader.getFloat32(), this.reader.getFloat32(), - this.reader.getFloat32() ); } }, // parse VMAP or VMAD // Associates a set of floating-point vectors with a set of points. // VMAP: { type[ID4], dimension[U2], name[S0], ( vert[VX], value[F4] # dimension ) * } // VMAD Associates a set of floating-point vectors with the vertices of specific polygons. // Similar to VMAP UVs, but associates with polygon vertices rather than points // to solve to problem of UV seams: VMAD chunks are paired with VMAPs of the same name, // if they exist. The vector values in the VMAD will then replace those in the // corresponding VMAP, but only for calculations involving the specified polygons. // VMAD { type[ID4], dimension[U2], name[S0], ( vert[VX], poly[VX], value[F4] # dimension ) * } parseVertexMapping( length, discontinuous ) { var finalOffset = this.reader.offset + length; var channelName = this.reader.getString(); if ( this.reader.offset === finalOffset ) { // then we are in a texture node and the VMAP chunk is just a reference to a UV channel name this.currentForm.UVChannel = channelName; return; } // otherwise reset to initial length and parse normal VMAP CHUNK this.reader.setOffset( this.reader.offset - stringOffset( channelName ) ); var type = this.reader.getIDTag(); this.reader.getUint16(); // dimension var name = this.reader.getString(); var remainingLength = length - 6 - stringOffset( name ); switch ( type ) { case 'TXUV': this.parseUVMapping( name, finalOffset, discontinuous ); break; case 'MORF': case 'SPOT': this.parseMorphTargets( name, finalOffset, type ); // can't be discontinuous break; // unsupported VMAPs case 'APSL': case 'NORM': case 'WGHT': case 'MNVW': case 'PICK': case 'RGB ': case 'RGBA': this.reader.skip( remainingLength ); break; default: console.warn( 'LWOLoader: unknown vertex map type: ' + type ); this.reader.skip( remainingLength ); } }, parseUVMapping( name, finalOffset, discontinuous ) { var uvIndices = []; var polyIndices = []; var uvs = []; while ( this.reader.offset < finalOffset ) { uvIndices.push( this.reader.getVariableLengthIndex() ); if ( discontinuous ) polyIndices.push( this.reader.getVariableLengthIndex() ); uvs.push( this.reader.getFloat32(), this.reader.getFloat32() ); } if ( discontinuous ) { if ( ! this.currentLayer.discontinuousUVs ) this.currentLayer.discontinuousUVs = {}; this.currentLayer.discontinuousUVs[ name ] = { uvIndices: uvIndices, polyIndices: polyIndices, uvs: uvs, }; } else { if ( ! this.currentLayer.uvs ) this.currentLayer.uvs = {}; this.currentLayer.uvs[ name ] = { uvIndices: uvIndices, uvs: uvs, }; } }, parseMorphTargets( name, finalOffset, type ) { var indices = []; var points = []; type = ( type === 'MORF' ) ? 'relative' : 'absolute'; while ( this.reader.offset < finalOffset ) { indices.push( this.reader.getVariableLengthIndex() ); // z -> -z to match three.js right handed coords points.push( this.reader.getFloat32(), this.reader.getFloat32(), - this.reader.getFloat32() ); } if ( ! this.currentLayer.morphTargets ) this.currentLayer.morphTargets = {}; this.currentLayer.morphTargets[ name ] = { indices: indices, points: points, type: type, }; }, // A list of polygons for the current layer. // POLS { type[ID4], ( numvert+flags[U2], vert[VX] # numvert ) * } parsePolygonList( length ) { var finalOffset = this.reader.offset + length; var type = this.reader.getIDTag(); var indices = []; // hold a list of polygon sizes, to be split up later var polygonDimensions = []; while ( this.reader.offset < finalOffset ) { var numverts = this.reader.getUint16(); //var flags = numverts & 64512; // 6 high order bits are flags - ignoring for now numverts = numverts & 1023; // remaining ten low order bits are vertex num polygonDimensions.push( numverts ); for ( var j = 0; j < numverts; j ++ ) indices.push( this.reader.getVariableLengthIndex() ); } var geometryData = { type: type, vertexIndices: indices, polygonDimensions: polygonDimensions, points: this.currentPoints }; // Note: assuming that all polys will be lines or points if the first is if ( polygonDimensions[ 0 ] === 1 ) geometryData.type = 'points'; else if ( polygonDimensions[ 0 ] === 2 ) geometryData.type = 'lines'; this.currentLayer.geometry = geometryData; }, // Lists the tag strings that can be associated with polygons by the PTAG chunk. // TAGS { tag-string[S0] * } parseTagStrings( length ) { this.tree.tags = this.reader.getStringArray( length ); }, // Associates tags of a given type with polygons in the most recent POLS chunk. // PTAG { type[ID4], ( poly[VX], tag[U2] ) * } parsePolygonTagMapping( length ) { var finalOffset = this.reader.offset + length; var type = this.reader.getIDTag(); if ( type === 'SURF' ) this.parseMaterialIndices( finalOffset ); else { //PART, SMGP, COLR not supported this.reader.skip( length - 4 ); } }, parseMaterialIndices( finalOffset ) { // array holds polygon index followed by material index this.currentLayer.geometry.materialIndices = []; while ( this.reader.offset < finalOffset ) { var polygonIndex = this.reader.getVariableLengthIndex(); var materialIndex = this.reader.getUint16(); this.currentLayer.geometry.materialIndices.push( polygonIndex, materialIndex ); } }, parseUnknownCHUNK( blockID, length ) { console.warn( 'LWOLoader: unknown chunk type: ' + blockID + ' length: ' + length ); // print the chunk plus some bytes padding either side // printBuffer( this.reader.dv.buffer, this.reader.offset - 20, length + 40 ); var data = this.reader.getString( length ); this.currentForm[ blockID ] = data; } }; function DataViewReader( buffer ) { this.dv = new DataView( buffer ); this.offset = 0; this._textDecoder = new TextDecoder(); this._bytes = new Uint8Array( buffer ); } DataViewReader.prototype = { constructor: DataViewReader, size: function () { return this.dv.buffer.byteLength; }, setOffset( offset ) { if ( offset > 0 && offset < this.dv.buffer.byteLength ) { this.offset = offset; } else { console.error( 'LWOLoader: invalid buffer offset' ); } }, endOfFile: function () { if ( this.offset >= this.size() ) return true; return false; }, skip: function ( length ) { this.offset += length; }, getUint8: function () { var value = this.dv.getUint8( this.offset ); this.offset += 1; return value; }, getUint16: function () { var value = this.dv.getUint16( this.offset ); this.offset += 2; return value; }, getInt32: function () { var value = this.dv.getInt32( this.offset, false ); this.offset += 4; return value; }, getUint32: function () { var value = this.dv.getUint32( this.offset, false ); this.offset += 4; return value; }, getUint64: function () { var low, high; high = this.getUint32(); low = this.getUint32(); return high * 0x100000000 + low; }, getFloat32: function () { var value = this.dv.getFloat32( this.offset, false ); this.offset += 4; return value; }, getFloat32Array: function ( size ) { var a = []; for ( var i = 0; i < size; i ++ ) { a.push( this.getFloat32() ); } return a; }, getFloat64: function () { var value = this.dv.getFloat64( this.offset, this.littleEndian ); this.offset += 8; return value; }, getFloat64Array: function ( size ) { var a = []; for ( var i = 0; i < size; i ++ ) { a.push( this.getFloat64() ); } return a; }, // get variable-length index data type // VX ::= index[U2] | (index + 0xFF000000)[U4] // If the index value is less than 65,280 (0xFF00),then VX === U2 // otherwise VX === U4 with bits 24-31 set // When reading an index, if the first byte encountered is 255 (0xFF), then // the four-byte form is being used and the first byte should be discarded or masked out. getVariableLengthIndex() { var firstByte = this.getUint8(); if ( firstByte === 255 ) { return this.getUint8() * 65536 + this.getUint8() * 256 + this.getUint8(); } return firstByte * 256 + this.getUint8(); }, // An ID tag is a sequence of 4 bytes containing 7-bit ASCII values getIDTag() { return this.getString( 4 ); }, getString: function ( size ) { if ( size === 0 ) return; const start = this.offset; let result; let length; if ( size ) { length = size; result = this._textDecoder.decode( new Uint8Array( this.dv.buffer, start, size ) ); } else { // use 1:1 mapping of buffer to avoid redundant new array creation. length = this._bytes.indexOf( 0, start ) - start; result = this._textDecoder.decode( new Uint8Array( this.dv.buffer, start, length ) ); // account for null byte in length length ++; // if string with terminating nullbyte is uneven, extra nullbyte is added, skip that too length += length % 2; } this.skip( length ); return result; }, getStringArray: function ( size ) { var a = this.getString( size ); a = a.split( '\\0' ); return a.filter( Boolean ); // return array with any empty strings removed } }; // ************** DEBUGGER ************** function Debugger( ) { this.active = false; this.depth = 0; this.formList = []; } Debugger.prototype = { constructor: Debugger, enable: function () { this.active = true; }, log: function () { if ( ! this.active ) return; var nodeType; switch ( this.node ) { case 0: nodeType = 'FORM'; break; case 1: nodeType = 'CHK'; break; case 2: nodeType = 'S-CHK'; break; } console.log( '| '.repeat( this.depth ) + nodeType, this.nodeID, `( ${this.offset} ) -> ( ${this.dataOffset + this.length} )`, ( ( this.node == 0 ) ? ' {' : '' ), ( ( this.skipped ) ? 'SKIPPED' : '' ), ( ( this.node == 0 && this.skipped ) ? '}' : '' ) ); if ( this.node == 0 && ! this.skipped ) { this.depth += 1; this.formList.push( this.dataOffset + this.length ); } this.skipped = false; }, closeForms: function () { if ( ! this.active ) return; for ( var i = this.formList.length - 1; i >= 0; i -- ) { if ( this.offset >= this.formList[ i ] ) { this.depth -= 1; console.log( '| '.repeat( this.depth ) + '}' ); this.formList.splice( - 1, 1 ); } } } }; // ************** UTILITY FUNCTIONS ************** function isEven( num ) { return num % 2; } // calculate the length of the string in the buffer // this will be string.length + nullbyte + optional padbyte to make the length even function stringOffset( string ) { return string.length + 1 + ( isEven( string.length + 1 ) ? 1 : 0 ); } // for testing purposes, dump buffer to console // printBuffer( this.reader.dv.buffer, this.reader.offset, length ); function printBuffer( buffer, from, to ) { console.log( new TextDecoder().decode( new Uint8Array( buffer, from, to ) ) ); } export { IFFParser };"},{"title":"","date":"2023-10-12T14:08:40.760Z","updated":"2023-10-12T14:08:40.760Z","comments":true,"path":"js/three/jsm/loaders/VOXLoader.js","permalink":"http://19999997.xyz/js/three/jsm/loaders/VOXLoader.js","excerpt":"","text":"import { BufferGeometry, Color, Data3DTexture, FileLoader, Float32BufferAttribute, Loader, LinearFilter, Mesh, MeshStandardMaterial, NearestFilter, RedFormat, SRGBColorSpace } from 'three'; class VOXLoader extends Loader { load( url, onLoad, onProgress, onError ) { const scope = this; const loader = new FileLoader( scope.manager ); loader.setPath( scope.path ); loader.setResponseType( 'arraybuffer' ); loader.setRequestHeader( scope.requestHeader ); loader.load( url, function ( buffer ) { try { onLoad( scope.parse( buffer ) ); } catch ( e ) { if ( onError ) { onError( e ); } else { console.error( e ); } scope.manager.itemError( url ); } }, onProgress, onError ); } parse( buffer ) { const data = new DataView( buffer ); const id = data.getUint32( 0, true ); const version = data.getUint32( 4, true ); if ( id !== 542658390 || version !== 150 ) { console.error( 'Not a valid VOX file' ); return; } const DEFAULT_PALETTE = [ 0x00000000, 0xffffffff, 0xffccffff, 0xff99ffff, 0xff66ffff, 0xff33ffff, 0xff00ffff, 0xffffccff, 0xffccccff, 0xff99ccff, 0xff66ccff, 0xff33ccff, 0xff00ccff, 0xffff99ff, 0xffcc99ff, 0xff9999ff, 0xff6699ff, 0xff3399ff, 0xff0099ff, 0xffff66ff, 0xffcc66ff, 0xff9966ff, 0xff6666ff, 0xff3366ff, 0xff0066ff, 0xffff33ff, 0xffcc33ff, 0xff9933ff, 0xff6633ff, 0xff3333ff, 0xff0033ff, 0xffff00ff, 0xffcc00ff, 0xff9900ff, 0xff6600ff, 0xff3300ff, 0xff0000ff, 0xffffffcc, 0xffccffcc, 0xff99ffcc, 0xff66ffcc, 0xff33ffcc, 0xff00ffcc, 0xffffcccc, 0xffcccccc, 0xff99cccc, 0xff66cccc, 0xff33cccc, 0xff00cccc, 0xffff99cc, 0xffcc99cc, 0xff9999cc, 0xff6699cc, 0xff3399cc, 0xff0099cc, 0xffff66cc, 0xffcc66cc, 0xff9966cc, 0xff6666cc, 0xff3366cc, 0xff0066cc, 0xffff33cc, 0xffcc33cc, 0xff9933cc, 0xff6633cc, 0xff3333cc, 0xff0033cc, 0xffff00cc, 0xffcc00cc, 0xff9900cc, 0xff6600cc, 0xff3300cc, 0xff0000cc, 0xffffff99, 0xffccff99, 0xff99ff99, 0xff66ff99, 0xff33ff99, 0xff00ff99, 0xffffcc99, 0xffcccc99, 0xff99cc99, 0xff66cc99, 0xff33cc99, 0xff00cc99, 0xffff9999, 0xffcc9999, 0xff999999, 0xff669999, 0xff339999, 0xff009999, 0xffff6699, 0xffcc6699, 0xff996699, 0xff666699, 0xff336699, 0xff006699, 0xffff3399, 0xffcc3399, 0xff993399, 0xff663399, 0xff333399, 0xff003399, 0xffff0099, 0xffcc0099, 0xff990099, 0xff660099, 0xff330099, 0xff000099, 0xffffff66, 0xffccff66, 0xff99ff66, 0xff66ff66, 0xff33ff66, 0xff00ff66, 0xffffcc66, 0xffcccc66, 0xff99cc66, 0xff66cc66, 0xff33cc66, 0xff00cc66, 0xffff9966, 0xffcc9966, 0xff999966, 0xff669966, 0xff339966, 0xff009966, 0xffff6666, 0xffcc6666, 0xff996666, 0xff666666, 0xff336666, 0xff006666, 0xffff3366, 0xffcc3366, 0xff993366, 0xff663366, 0xff333366, 0xff003366, 0xffff0066, 0xffcc0066, 0xff990066, 0xff660066, 0xff330066, 0xff000066, 0xffffff33, 0xffccff33, 0xff99ff33, 0xff66ff33, 0xff33ff33, 0xff00ff33, 0xffffcc33, 0xffcccc33, 0xff99cc33, 0xff66cc33, 0xff33cc33, 0xff00cc33, 0xffff9933, 0xffcc9933, 0xff999933, 0xff669933, 0xff339933, 0xff009933, 0xffff6633, 0xffcc6633, 0xff996633, 0xff666633, 0xff336633, 0xff006633, 0xffff3333, 0xffcc3333, 0xff993333, 0xff663333, 0xff333333, 0xff003333, 0xffff0033, 0xffcc0033, 0xff990033, 0xff660033, 0xff330033, 0xff000033, 0xffffff00, 0xffccff00, 0xff99ff00, 0xff66ff00, 0xff33ff00, 0xff00ff00, 0xffffcc00, 0xffcccc00, 0xff99cc00, 0xff66cc00, 0xff33cc00, 0xff00cc00, 0xffff9900, 0xffcc9900, 0xff999900, 0xff669900, 0xff339900, 0xff009900, 0xffff6600, 0xffcc6600, 0xff996600, 0xff666600, 0xff336600, 0xff006600, 0xffff3300, 0xffcc3300, 0xff993300, 0xff663300, 0xff333300, 0xff003300, 0xffff0000, 0xffcc0000, 0xff990000, 0xff660000, 0xff330000, 0xff0000ee, 0xff0000dd, 0xff0000bb, 0xff0000aa, 0xff000088, 0xff000077, 0xff000055, 0xff000044, 0xff000022, 0xff000011, 0xff00ee00, 0xff00dd00, 0xff00bb00, 0xff00aa00, 0xff008800, 0xff007700, 0xff005500, 0xff004400, 0xff002200, 0xff001100, 0xffee0000, 0xffdd0000, 0xffbb0000, 0xffaa0000, 0xff880000, 0xff770000, 0xff550000, 0xff440000, 0xff220000, 0xff110000, 0xffeeeeee, 0xffdddddd, 0xffbbbbbb, 0xffaaaaaa, 0xff888888, 0xff777777, 0xff555555, 0xff444444, 0xff222222, 0xff111111 ]; let i = 8; let chunk; const chunks = []; while ( i < data.byteLength ) { let id = ''; for ( let j = 0; j < 4; j ++ ) { id += String.fromCharCode( data.getUint8( i ++ ) ); } const chunkSize = data.getUint32( i, true ); i += 4; i += 4; // childChunks if ( id === 'SIZE' ) { const x = data.getUint32( i, true ); i += 4; const y = data.getUint32( i, true ); i += 4; const z = data.getUint32( i, true ); i += 4; chunk = { palette: DEFAULT_PALETTE, size: { x: x, y: y, z: z }, }; chunks.push( chunk ); i += chunkSize - ( 3 * 4 ); } else if ( id === 'XYZI' ) { const numVoxels = data.getUint32( i, true ); i += 4; chunk.data = new Uint8Array( buffer, i, numVoxels * 4 ); i += numVoxels * 4; } else if ( id === 'RGBA' ) { const palette = [ 0 ]; for ( let j = 0; j < 256; j ++ ) { palette[ j + 1 ] = data.getUint32( i, true ); i += 4; } chunk.palette = palette; } else { // console.log( id, chunkSize, childChunks ); i += chunkSize; } } return chunks; } } class VOXMesh extends Mesh { constructor( chunk ) { const data = chunk.data; const size = chunk.size; const palette = chunk.palette; // const vertices = []; const colors = []; const nx = [ 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1 ]; const px = [ 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0 ]; const py = [ 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1 ]; const ny = [ 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0 ]; const nz = [ 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0 ]; const pz = [ 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1 ]; const _color = new Color(); function add( tile, x, y, z, r, g, b ) { x -= size.x / 2; y -= size.z / 2; z += size.y / 2; for ( let i = 0; i < 18; i += 3 ) { _color.setRGB( r, g, b, SRGBColorSpace ); vertices.push( tile[ i + 0 ] + x, tile[ i + 1 ] + y, tile[ i + 2 ] + z ); colors.push( _color.r, _color.g, _color.b ); } } // Store data in a volume for sampling const offsety = size.x; const offsetz = size.x * size.y; const array = new Uint8Array( size.x * size.y * size.z ); for ( let j = 0; j < data.length; j += 4 ) { const x = data[ j + 0 ]; const y = data[ j + 1 ]; const z = data[ j + 2 ]; const index = x + ( y * offsety ) + ( z * offsetz ); array[ index ] = 255; } // Construct geometry let hasColors = false; for ( let j = 0; j < data.length; j += 4 ) { const x = data[ j + 0 ]; const y = data[ j + 1 ]; const z = data[ j + 2 ]; const c = data[ j + 3 ]; const hex = palette[ c ]; const r = ( hex >> 0 & 0xff ) / 0xff; const g = ( hex >> 8 & 0xff ) / 0xff; const b = ( hex >> 16 & 0xff ) / 0xff; if ( r > 0 || g > 0 || b > 0 ) hasColors = true; const index = x + ( y * offsety ) + ( z * offsetz ); if ( array[ index + 1 ] === 0 || x === size.x - 1 ) add( px, x, z, - y, r, g, b ); if ( array[ index - 1 ] === 0 || x === 0 ) add( nx, x, z, - y, r, g, b ); if ( array[ index + offsety ] === 0 || y === size.y - 1 ) add( ny, x, z, - y, r, g, b ); if ( array[ index - offsety ] === 0 || y === 0 ) add( py, x, z, - y, r, g, b ); if ( array[ index + offsetz ] === 0 || z === size.z - 1 ) add( pz, x, z, - y, r, g, b ); if ( array[ index - offsetz ] === 0 || z === 0 ) add( nz, x, z, - y, r, g, b ); } const geometry = new BufferGeometry(); geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) ); geometry.computeVertexNormals(); const material = new MeshStandardMaterial(); if ( hasColors ) { geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) ); material.vertexColors = true; } super( geometry, material ); } } class VOXData3DTexture extends Data3DTexture { constructor( chunk ) { const data = chunk.data; const size = chunk.size; const offsety = size.x; const offsetz = size.x * size.y; const array = new Uint8Array( size.x * size.y * size.z ); for ( let j = 0; j < data.length; j += 4 ) { const x = data[ j + 0 ]; const y = data[ j + 1 ]; const z = data[ j + 2 ]; const index = x + ( y * offsety ) + ( z * offsetz ); array[ index ] = 255; } super( array, size.x, size.y, size.z ); this.format = RedFormat; this.minFilter = NearestFilter; this.magFilter = LinearFilter; this.unpackAlignment = 1; this.needsUpdate = true; } } export { VOXLoader, VOXMesh, VOXData3DTexture };"},{"title":"","date":"2023-10-12T14:08:40.775Z","updated":"2023-10-12T14:08:40.775Z","comments":true,"path":"js/three/jsm/loaders/lwo/LWO2Parser.js","permalink":"http://19999997.xyz/js/three/jsm/loaders/lwo/LWO2Parser.js","excerpt":"","text":"class LWO2Parser { constructor( IFFParser ) { this.IFF = IFFParser; } parseBlock() { this.IFF.debugger.offset = this.IFF.reader.offset; this.IFF.debugger.closeForms(); const blockID = this.IFF.reader.getIDTag(); let length = this.IFF.reader.getUint32(); // size of data in bytes if ( length > this.IFF.reader.dv.byteLength - this.IFF.reader.offset ) { this.IFF.reader.offset -= 4; length = this.IFF.reader.getUint16(); } this.IFF.debugger.dataOffset = this.IFF.reader.offset; this.IFF.debugger.length = length; // Data types may be found in either LWO2 OR LWO3 spec switch ( blockID ) { case 'FORM': // form blocks may consist of sub -chunks or sub-forms this.IFF.parseForm( length ); break; // SKIPPED CHUNKS // if break; is called directly, the position in the lwoTree is not created // any sub chunks and forms are added to the parent form instead // MISC skipped case 'ICON': // Thumbnail Icon Image case 'VMPA': // Vertex Map Parameter case 'BBOX': // bounding box // case 'VMMD': // case 'VTYP': // normal maps can be specified, normally on models imported from other applications. Currently ignored case 'NORM': // ENVL FORM skipped case 'PRE ': case 'POST': case 'KEY ': case 'SPAN': // CLIP FORM skipped case 'TIME': case 'CLRS': case 'CLRA': case 'FILT': case 'DITH': case 'CONT': case 'BRIT': case 'SATR': case 'HUE ': case 'GAMM': case 'NEGA': case 'IFLT': case 'PFLT': // Image Map Layer skipped case 'PROJ': case 'AXIS': case 'AAST': case 'PIXB': case 'AUVO': case 'STCK': // Procedural Textures skipped case 'PROC': case 'VALU': case 'FUNC': // Gradient Textures skipped case 'PNAM': case 'INAM': case 'GRST': case 'GREN': case 'GRPT': case 'FKEY': case 'IKEY': // Texture Mapping Form skipped case 'CSYS': // Surface CHUNKs skipped case 'OPAQ': // top level 'opacity' checkbox case 'CMAP': // clip map // Surface node CHUNKS skipped // These mainly specify the node editor setup in LW case 'NLOC': case 'NZOM': case 'NVER': case 'NSRV': case 'NVSK': // unknown case 'NCRD': case 'WRPW': // image wrap w ( for cylindrical and spherical projections) case 'WRPH': // image wrap h case 'NMOD': case 'NSEL': case 'NPRW': case 'NPLA': case 'NODS': case 'VERS': case 'ENUM': case 'TAG ': case 'OPAC': // Car Material CHUNKS case 'CGMD': case 'CGTY': case 'CGST': case 'CGEN': case 'CGTS': case 'CGTE': case 'OSMP': case 'OMDE': case 'OUTR': case 'FLAG': case 'TRNL': case 'GLOW': case 'GVAL': // glow intensity case 'SHRP': case 'RFOP': case 'RSAN': case 'TROP': case 'RBLR': case 'TBLR': case 'CLRH': case 'CLRF': case 'ADTR': case 'LINE': case 'ALPH': case 'VCOL': case 'ENAB': this.IFF.debugger.skipped = true; this.IFF.reader.skip( length ); break; case 'SURF': this.IFF.parseSurfaceLwo2( length ); break; case 'CLIP': this.IFF.parseClipLwo2( length ); break; // Texture node chunks (not in spec) case 'IPIX': // usePixelBlending case 'IMIP': // useMipMaps case 'IMOD': // imageBlendingMode case 'AMOD': // unknown case 'IINV': // imageInvertAlpha case 'INCR': // imageInvertColor case 'IAXS': // imageAxis ( for non-UV maps) case 'IFOT': // imageFallofType case 'ITIM': // timing for animated textures case 'IWRL': case 'IUTI': case 'IINX': case 'IINY': case 'IINZ': case 'IREF': // possibly a VX for reused texture nodes if ( length === 4 ) this.IFF.currentNode[ blockID ] = this.IFF.reader.getInt32(); else this.IFF.reader.skip( length ); break; case 'OTAG': this.IFF.parseObjectTag(); break; case 'LAYR': this.IFF.parseLayer( length ); break; case 'PNTS': this.IFF.parsePoints( length ); break; case 'VMAP': this.IFF.parseVertexMapping( length ); break; case 'AUVU': case 'AUVN': this.IFF.reader.skip( length - 1 ); this.IFF.reader.getVariableLengthIndex(); // VX break; case 'POLS': this.IFF.parsePolygonList( length ); break; case 'TAGS': this.IFF.parseTagStrings( length ); break; case 'PTAG': this.IFF.parsePolygonTagMapping( length ); break; case 'VMAD': this.IFF.parseVertexMapping( length, true ); break; // Misc CHUNKS case 'DESC': // Description Line this.IFF.currentForm.description = this.IFF.reader.getString(); break; case 'TEXT': case 'CMNT': case 'NCOM': this.IFF.currentForm.comment = this.IFF.reader.getString(); break; // Envelope Form case 'NAME': this.IFF.currentForm.channelName = this.IFF.reader.getString(); break; // Image Map Layer case 'WRAP': this.IFF.currentForm.wrap = { w: this.IFF.reader.getUint16(), h: this.IFF.reader.getUint16() }; break; case 'IMAG': const index = this.IFF.reader.getVariableLengthIndex(); this.IFF.currentForm.imageIndex = index; break; // Texture Mapping Form case 'OREF': this.IFF.currentForm.referenceObject = this.IFF.reader.getString(); break; case 'ROID': this.IFF.currentForm.referenceObjectID = this.IFF.reader.getUint32(); break; // Surface Blocks case 'SSHN': this.IFF.currentSurface.surfaceShaderName = this.IFF.reader.getString(); break; case 'AOVN': this.IFF.currentSurface.surfaceCustomAOVName = this.IFF.reader.getString(); break; // Nodal Blocks case 'NSTA': this.IFF.currentForm.disabled = this.IFF.reader.getUint16(); break; case 'NRNM': this.IFF.currentForm.realName = this.IFF.reader.getString(); break; case 'NNME': this.IFF.currentForm.refName = this.IFF.reader.getString(); this.IFF.currentSurface.nodes[ this.IFF.currentForm.refName ] = this.IFF.currentForm; break; // Nodal Blocks : connections case 'INME': if ( ! this.IFF.currentForm.nodeName ) this.IFF.currentForm.nodeName = []; this.IFF.currentForm.nodeName.push( this.IFF.reader.getString() ); break; case 'IINN': if ( ! this.IFF.currentForm.inputNodeName ) this.IFF.currentForm.inputNodeName = []; this.IFF.currentForm.inputNodeName.push( this.IFF.reader.getString() ); break; case 'IINM': if ( ! this.IFF.currentForm.inputName ) this.IFF.currentForm.inputName = []; this.IFF.currentForm.inputName.push( this.IFF.reader.getString() ); break; case 'IONM': if ( ! this.IFF.currentForm.inputOutputName ) this.IFF.currentForm.inputOutputName = []; this.IFF.currentForm.inputOutputName.push( this.IFF.reader.getString() ); break; case 'FNAM': this.IFF.currentForm.fileName = this.IFF.reader.getString(); break; case 'CHAN': // NOTE: ENVL Forms may also have CHAN chunk, however ENVL is currently ignored if ( length === 4 ) this.IFF.currentForm.textureChannel = this.IFF.reader.getIDTag(); else this.IFF.reader.skip( length ); break; // LWO2 Spec chunks: these are needed since the SURF FORMs are often in LWO2 format case 'SMAN': const maxSmoothingAngle = this.IFF.reader.getFloat32(); this.IFF.currentSurface.attributes.smooth = ( maxSmoothingAngle < 0 ) ? false : true; break; // LWO2: Basic Surface Parameters case 'COLR': this.IFF.currentSurface.attributes.Color = { value: this.IFF.reader.getFloat32Array( 3 ) }; this.IFF.reader.skip( 2 ); // VX: envelope break; case 'LUMI': this.IFF.currentSurface.attributes.Luminosity = { value: this.IFF.reader.getFloat32() }; this.IFF.reader.skip( 2 ); break; case 'SPEC': this.IFF.currentSurface.attributes.Specular = { value: this.IFF.reader.getFloat32() }; this.IFF.reader.skip( 2 ); break; case 'DIFF': this.IFF.currentSurface.attributes.Diffuse = { value: this.IFF.reader.getFloat32() }; this.IFF.reader.skip( 2 ); break; case 'REFL': this.IFF.currentSurface.attributes.Reflection = { value: this.IFF.reader.getFloat32() }; this.IFF.reader.skip( 2 ); break; case 'GLOS': this.IFF.currentSurface.attributes.Glossiness = { value: this.IFF.reader.getFloat32() }; this.IFF.reader.skip( 2 ); break; case 'TRAN': this.IFF.currentSurface.attributes.opacity = this.IFF.reader.getFloat32(); this.IFF.reader.skip( 2 ); break; case 'BUMP': this.IFF.currentSurface.attributes.bumpStrength = this.IFF.reader.getFloat32(); this.IFF.reader.skip( 2 ); break; case 'SIDE': this.IFF.currentSurface.attributes.side = this.IFF.reader.getUint16(); break; case 'RIMG': this.IFF.currentSurface.attributes.reflectionMap = this.IFF.reader.getVariableLengthIndex(); break; case 'RIND': this.IFF.currentSurface.attributes.refractiveIndex = this.IFF.reader.getFloat32(); this.IFF.reader.skip( 2 ); break; case 'TIMG': this.IFF.currentSurface.attributes.refractionMap = this.IFF.reader.getVariableLengthIndex(); break; case 'IMAP': this.IFF.reader.skip( 2 ); break; case 'TMAP': this.IFF.debugger.skipped = true; this.IFF.reader.skip( length ); // needs implementing break; case 'IUVI': // uv channel name this.IFF.currentNode.UVChannel = this.IFF.reader.getString( length ); break; case 'IUTL': // widthWrappingMode: 0 = Reset, 1 = Repeat, 2 = Mirror, 3 = Edge this.IFF.currentNode.widthWrappingMode = this.IFF.reader.getUint32(); break; case 'IVTL': // heightWrappingMode this.IFF.currentNode.heightWrappingMode = this.IFF.reader.getUint32(); break; // LWO2 USE case 'BLOK': // skip break; default: this.IFF.parseUnknownCHUNK( blockID, length ); } if ( blockID != 'FORM' ) { this.IFF.debugger.node = 1; this.IFF.debugger.nodeID = blockID; this.IFF.debugger.log(); } if ( this.IFF.reader.offset >= this.IFF.currentFormEnd ) { this.IFF.currentForm = this.IFF.parentForm; } } } export { LWO2Parser };"},{"title":"","date":"2023-10-12T14:08:40.778Z","updated":"2023-10-12T14:08:40.778Z","comments":true,"path":"js/three/jsm/loaders/lwo/LWO3Parser.js","permalink":"http://19999997.xyz/js/three/jsm/loaders/lwo/LWO3Parser.js","excerpt":"","text":"class LWO3Parser { constructor( IFFParser ) { this.IFF = IFFParser; } parseBlock() { this.IFF.debugger.offset = this.IFF.reader.offset; this.IFF.debugger.closeForms(); const blockID = this.IFF.reader.getIDTag(); const length = this.IFF.reader.getUint32(); // size of data in bytes this.IFF.debugger.dataOffset = this.IFF.reader.offset; this.IFF.debugger.length = length; // Data types may be found in either LWO2 OR LWO3 spec switch ( blockID ) { case 'FORM': // form blocks may consist of sub -chunks or sub-forms this.IFF.parseForm( length ); break; // SKIPPED CHUNKS // MISC skipped case 'ICON': // Thumbnail Icon Image case 'VMPA': // Vertex Map Parameter case 'BBOX': // bounding box // case 'VMMD': // case 'VTYP': // normal maps can be specified, normally on models imported from other applications. Currently ignored case 'NORM': // ENVL FORM skipped case 'PRE ': // Pre-loop behavior for the keyframe case 'POST': // Post-loop behavior for the keyframe case 'KEY ': case 'SPAN': // CLIP FORM skipped case 'TIME': case 'CLRS': case 'CLRA': case 'FILT': case 'DITH': case 'CONT': case 'BRIT': case 'SATR': case 'HUE ': case 'GAMM': case 'NEGA': case 'IFLT': case 'PFLT': // Image Map Layer skipped case 'PROJ': case 'AXIS': case 'AAST': case 'PIXB': case 'STCK': // Procedural Textures skipped case 'VALU': // Gradient Textures skipped case 'PNAM': case 'INAM': case 'GRST': case 'GREN': case 'GRPT': case 'FKEY': case 'IKEY': // Texture Mapping Form skipped case 'CSYS': // Surface CHUNKs skipped case 'OPAQ': // top level 'opacity' checkbox case 'CMAP': // clip map // Surface node CHUNKS skipped // These mainly specify the node editor setup in LW case 'NLOC': case 'NZOM': case 'NVER': case 'NSRV': case 'NCRD': case 'NMOD': case 'NSEL': case 'NPRW': case 'NPLA': case 'VERS': case 'ENUM': case 'TAG ': // Car Material CHUNKS case 'CGMD': case 'CGTY': case 'CGST': case 'CGEN': case 'CGTS': case 'CGTE': case 'OSMP': case 'OMDE': case 'OUTR': case 'FLAG': case 'TRNL': case 'SHRP': case 'RFOP': case 'RSAN': case 'TROP': case 'RBLR': case 'TBLR': case 'CLRH': case 'CLRF': case 'ADTR': case 'GLOW': case 'LINE': case 'ALPH': case 'VCOL': case 'ENAB': this.IFF.debugger.skipped = true; this.IFF.reader.skip( length ); break; // Texture node chunks (not in spec) case 'IPIX': // usePixelBlending case 'IMIP': // useMipMaps case 'IMOD': // imageBlendingMode case 'AMOD': // unknown case 'IINV': // imageInvertAlpha case 'INCR': // imageInvertColor case 'IAXS': // imageAxis ( for non-UV maps) case 'IFOT': // imageFallofType case 'ITIM': // timing for animated textures case 'IWRL': case 'IUTI': case 'IINX': case 'IINY': case 'IINZ': case 'IREF': // possibly a VX for reused texture nodes if ( length === 4 ) this.IFF.currentNode[ blockID ] = this.IFF.reader.getInt32(); else this.IFF.reader.skip( length ); break; case 'OTAG': this.IFF.parseObjectTag(); break; case 'LAYR': this.IFF.parseLayer( length ); break; case 'PNTS': this.IFF.parsePoints( length ); break; case 'VMAP': this.IFF.parseVertexMapping( length ); break; case 'POLS': this.IFF.parsePolygonList( length ); break; case 'TAGS': this.IFF.parseTagStrings( length ); break; case 'PTAG': this.IFF.parsePolygonTagMapping( length ); break; case 'VMAD': this.IFF.parseVertexMapping( length, true ); break; // Misc CHUNKS case 'DESC': // Description Line this.IFF.currentForm.description = this.IFF.reader.getString(); break; case 'TEXT': case 'CMNT': case 'NCOM': this.IFF.currentForm.comment = this.IFF.reader.getString(); break; // Envelope Form case 'NAME': this.IFF.currentForm.channelName = this.IFF.reader.getString(); break; // Image Map Layer case 'WRAP': this.IFF.currentForm.wrap = { w: this.IFF.reader.getUint16(), h: this.IFF.reader.getUint16() }; break; case 'IMAG': const index = this.IFF.reader.getVariableLengthIndex(); this.IFF.currentForm.imageIndex = index; break; // Texture Mapping Form case 'OREF': this.IFF.currentForm.referenceObject = this.IFF.reader.getString(); break; case 'ROID': this.IFF.currentForm.referenceObjectID = this.IFF.reader.getUint32(); break; // Surface Blocks case 'SSHN': this.IFF.currentSurface.surfaceShaderName = this.IFF.reader.getString(); break; case 'AOVN': this.IFF.currentSurface.surfaceCustomAOVName = this.IFF.reader.getString(); break; // Nodal Blocks case 'NSTA': this.IFF.currentForm.disabled = this.IFF.reader.getUint16(); break; case 'NRNM': this.IFF.currentForm.realName = this.IFF.reader.getString(); break; case 'NNME': this.IFF.currentForm.refName = this.IFF.reader.getString(); this.IFF.currentSurface.nodes[ this.IFF.currentForm.refName ] = this.IFF.currentForm; break; // Nodal Blocks : connections case 'INME': if ( ! this.IFF.currentForm.nodeName ) this.IFF.currentForm.nodeName = []; this.IFF.currentForm.nodeName.push( this.IFF.reader.getString() ); break; case 'IINN': if ( ! this.IFF.currentForm.inputNodeName ) this.IFF.currentForm.inputNodeName = []; this.IFF.currentForm.inputNodeName.push( this.IFF.reader.getString() ); break; case 'IINM': if ( ! this.IFF.currentForm.inputName ) this.IFF.currentForm.inputName = []; this.IFF.currentForm.inputName.push( this.IFF.reader.getString() ); break; case 'IONM': if ( ! this.IFF.currentForm.inputOutputName ) this.IFF.currentForm.inputOutputName = []; this.IFF.currentForm.inputOutputName.push( this.IFF.reader.getString() ); break; case 'FNAM': this.IFF.currentForm.fileName = this.IFF.reader.getString(); break; case 'CHAN': // NOTE: ENVL Forms may also have CHAN chunk, however ENVL is currently ignored if ( length === 4 ) this.IFF.currentForm.textureChannel = this.IFF.reader.getIDTag(); else this.IFF.reader.skip( length ); break; // LWO2 Spec chunks: these are needed since the SURF FORMs are often in LWO2 format case 'SMAN': const maxSmoothingAngle = this.IFF.reader.getFloat32(); this.IFF.currentSurface.attributes.smooth = ( maxSmoothingAngle < 0 ) ? false : true; break; // LWO2: Basic Surface Parameters case 'COLR': this.IFF.currentSurface.attributes.Color = { value: this.IFF.reader.getFloat32Array( 3 ) }; this.IFF.reader.skip( 2 ); // VX: envelope break; case 'LUMI': this.IFF.currentSurface.attributes.Luminosity = { value: this.IFF.reader.getFloat32() }; this.IFF.reader.skip( 2 ); break; case 'SPEC': this.IFF.currentSurface.attributes.Specular = { value: this.IFF.reader.getFloat32() }; this.IFF.reader.skip( 2 ); break; case 'DIFF': this.IFF.currentSurface.attributes.Diffuse = { value: this.IFF.reader.getFloat32() }; this.IFF.reader.skip( 2 ); break; case 'REFL': this.IFF.currentSurface.attributes.Reflection = { value: this.IFF.reader.getFloat32() }; this.IFF.reader.skip( 2 ); break; case 'GLOS': this.IFF.currentSurface.attributes.Glossiness = { value: this.IFF.reader.getFloat32() }; this.IFF.reader.skip( 2 ); break; case 'TRAN': this.IFF.currentSurface.attributes.opacity = this.IFF.reader.getFloat32(); this.IFF.reader.skip( 2 ); break; case 'BUMP': this.IFF.currentSurface.attributes.bumpStrength = this.IFF.reader.getFloat32(); this.IFF.reader.skip( 2 ); break; case 'SIDE': this.IFF.currentSurface.attributes.side = this.IFF.reader.getUint16(); break; case 'RIMG': this.IFF.currentSurface.attributes.reflectionMap = this.IFF.reader.getVariableLengthIndex(); break; case 'RIND': this.IFF.currentSurface.attributes.refractiveIndex = this.IFF.reader.getFloat32(); this.IFF.reader.skip( 2 ); break; case 'TIMG': this.IFF.currentSurface.attributes.refractionMap = this.IFF.reader.getVariableLengthIndex(); break; case 'IMAP': this.IFF.currentSurface.attributes.imageMapIndex = this.IFF.reader.getUint32(); break; case 'IUVI': // uv channel name this.IFF.currentNode.UVChannel = this.IFF.reader.getString( length ); break; case 'IUTL': // widthWrappingMode: 0 = Reset, 1 = Repeat, 2 = Mirror, 3 = Edge this.IFF.currentNode.widthWrappingMode = this.IFF.reader.getUint32(); break; case 'IVTL': // heightWrappingMode this.IFF.currentNode.heightWrappingMode = this.IFF.reader.getUint32(); break; default: this.IFF.parseUnknownCHUNK( blockID, length ); } if ( blockID != 'FORM' ) { this.IFF.debugger.node = 1; this.IFF.debugger.nodeID = blockID; this.IFF.debugger.log(); } if ( this.IFF.reader.offset >= this.IFF.currentFormEnd ) { this.IFF.currentForm = this.IFF.parentForm; } } } export { LWO3Parser };"},{"title":"","date":"2023-10-12T14:08:39.217Z","updated":"2023-10-12T14:08:39.217Z","comments":true,"path":"js/three/build/three.module.min.js","permalink":"http://19999997.xyz/js/three/build/three.module.min.js","excerpt":"","text":"/** * @license * Copyright 2010-2023 Three.js Authors * SPDX-License-Identifier: MIT */ const t=\"157\",e={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2},n={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},i=0,r=1,s=2,a=3,o=0,l=1,c=2,h=3,u=0,d=1,p=2,m=2,f=0,g=1,v=2,_=3,y=4,x=5,M=100,S=101,b=102,E=103,T=104,w=200,A=201,R=202,C=203,P=204,L=205,I=206,U=207,N=208,D=209,O=210,F=0,B=1,z=2,H=3,V=4,k=5,G=6,W=7,X=0,j=1,q=2,Y=0,Z=1,J=2,K=3,$=4,Q=5,tt=300,et=301,nt=302,it=303,rt=304,st=306,at=1e3,ot=1001,lt=1002,ct=1003,ht=1004,ut=1004,dt=1005,pt=1005,mt=1006,ft=1007,gt=1007,vt=1008,_t=1008,yt=1009,xt=1010,Mt=1011,St=1012,bt=1013,Et=1014,Tt=1015,wt=1016,At=1017,Rt=1018,Ct=1020,Pt=1021,Lt=1023,It=1024,Ut=1025,Nt=1026,Dt=1027,Ot=1028,Ft=1029,Bt=1030,zt=1031,Ht=1033,Vt=33776,kt=33777,Gt=33778,Wt=33779,Xt=35840,jt=35841,qt=35842,Yt=35843,Zt=36196,Jt=37492,Kt=37496,$t=37808,Qt=37809,te=37810,ee=37811,ne=37812,ie=37813,re=37814,se=37815,ae=37816,oe=37817,le=37818,ce=37819,he=37820,ue=37821,de=36492,pe=36494,me=36495,fe=36283,ge=36284,ve=36285,_e=36286,ye=2200,xe=2201,Me=2202,Se=2300,be=2301,Ee=2302,Te=2400,we=2401,Ae=2402,Re=2500,Ce=2501,Pe=0,Le=1,Ie=2,Ue=3e3,Ne=3001,De=3200,Oe=3201,Fe=0,Be=1,ze=\"\",He=\"srgb\",Ve=\"srgb-linear\",ke=\"display-p3\",Ge=\"display-p3-linear\",We=\"linear\",Xe=\"srgb\",je=\"rec709\",qe=\"p3\",Ye=0,Ze=7680,Je=7681,Ke=7682,$e=7683,Qe=34055,tn=34056,en=5386,nn=512,rn=513,sn=514,an=515,on=516,ln=517,cn=518,hn=519,un=512,dn=513,pn=514,mn=515,fn=516,gn=517,vn=518,_n=519,yn=35044,xn=35048,Mn=35040,Sn=35045,bn=35049,En=35041,Tn=35046,wn=35050,An=35042,Rn=\"100\",Cn=\"300 es\",Pn=1035,Ln=2e3,In=2001;class Un{addEventListener(t,e){void 0===this._listeners&&(this._listeners={});const n=this._listeners;void 0===n[t]&&(n[t]=[]),-1===n[t].indexOf(e)&&n[t].push(e)}hasEventListener(t,e){if(void 0===this._listeners)return!1;const n=this._listeners;return void 0!==n[t]&&-1!==n[t].indexOf(e)}removeEventListener(t,e){if(void 0===this._listeners)return;const n=this._listeners[t];if(void 0!==n){const t=n.indexOf(e);-1!==t&&n.splice(t,1)}}dispatchEvent(t){if(void 0===this._listeners)return;const e=this._listeners[t.type];if(void 0!==e){t.target=this;const n=e.slice(0);for(let e=0,i=n.length;e>8&255]+Nn[t>>16&255]+Nn[t>>24&255]+\"-\"+Nn[255&e]+Nn[e>>8&255]+\"-\"+Nn[e>>16&15|64]+Nn[e>>24&255]+\"-\"+Nn[63&n|128]+Nn[n>>8&255]+\"-\"+Nn[n>>16&255]+Nn[n>>24&255]+Nn[255&i]+Nn[i>>8&255]+Nn[i>>16&255]+Nn[i>>24&255]).toLowerCase()}function zn(t,e,n){return Math.max(e,Math.min(n,t))}function Hn(t,e){return(t%e+e)%e}function Vn(t,e,n){return(1-n)*t+n*e}function kn(t){return 0==(t&t-1)&&0!==t}function Gn(t){return Math.pow(2,Math.ceil(Math.log(t)/Math.LN2))}function Wn(t){return Math.pow(2,Math.floor(Math.log(t)/Math.LN2))}function Xn(t,e){switch(e.constructor){case Float32Array:return t;case Uint32Array:return t/4294967295;case Uint16Array:return t/65535;case Uint8Array:return t/255;case Int32Array:return Math.max(t/2147483647,-1);case Int16Array:return Math.max(t/32767,-1);case Int8Array:return Math.max(t/127,-1);default:throw new Error(\"Invalid component type.\")}}function jn(t,e){switch(e.constructor){case Float32Array:return t;case Uint32Array:return Math.round(4294967295*t);case Uint16Array:return Math.round(65535*t);case Uint8Array:return Math.round(255*t);case Int32Array:return Math.round(2147483647*t);case Int16Array:return Math.round(32767*t);case Int8Array:return Math.round(127*t);default:throw new Error(\"Invalid component type.\")}}const qn={DEG2RAD:On,RAD2DEG:Fn,generateUUID:Bn,clamp:zn,euclideanModulo:Hn,mapLinear:function(t,e,n,i,r){return i+(t-e)*(r-i)/(n-e)},inverseLerp:function(t,e,n){return t!==e?(n-t)/(e-t):0},lerp:Vn,damp:function(t,e,n,i){return Vn(t,e,1-Math.exp(-n*i))},pingpong:function(t,e=1){return e-Math.abs(Hn(t,2*e)-e)},smoothstep:function(t,e,n){return t=n?1:(t=(t-e)/(n-e))*t*(3-2*t)},smootherstep:function(t,e,n){return t=n?1:(t=(t-e)/(n-e))*t*t*(t*(6*t-15)+10)},randInt:function(t,e){return t+Math.floor(Math.random()*(e-t+1))},randFloat:function(t,e){return t+Math.random()*(e-t)},randFloatSpread:function(t){return t*(.5-Math.random())},seededRandom:function(t){void 0!==t&&(Dn=t);let e=Dn+=1831565813;return e=Math.imul(e^e>>>15,1|e),e^=e+Math.imul(e^e>>>7,61|e),((e^e>>>14)>>>0)/4294967296},degToRad:function(t){return t*On},radToDeg:function(t){return t*Fn},isPowerOfTwo:kn,ceilPowerOfTwo:Gn,floorPowerOfTwo:Wn,setQuaternionFromProperEuler:function(t,e,n,i,r){const s=Math.cos,a=Math.sin,o=s(n/2),l=a(n/2),c=s((e+i)/2),h=a((e+i)/2),u=s((e-i)/2),d=a((e-i)/2),p=s((i-e)/2),m=a((i-e)/2);switch(r){case\"XYX\":t.set(o*h,l*u,l*d,o*c);break;case\"YZY\":t.set(l*d,o*h,l*u,o*c);break;case\"ZXZ\":t.set(l*u,l*d,o*h,o*c);break;case\"XZX\":t.set(o*h,l*m,l*p,o*c);break;case\"YXY\":t.set(l*p,o*h,l*m,o*c);break;case\"ZYZ\":t.set(l*m,l*p,o*h,o*c);break;default:console.warn(\"THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: \"+r)}},normalize:jn,denormalize:Xn};class Yn{constructor(t=0,e=0){Yn.prototype.isVector2=!0,this.x=t,this.y=e}get width(){return this.x}set width(t){this.x=t}get height(){return this.y}set height(t){this.y=t}set(t,e){return this.x=t,this.y=e,this}setScalar(t){return this.x=t,this.y=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;default:throw new Error(\"index is out of range: \"+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;default:throw new Error(\"index is out of range: \"+t)}}clone(){return new this.constructor(this.x,this.y)}copy(t){return this.x=t.x,this.y=t.y,this}add(t){return this.x+=t.x,this.y+=t.y,this}addScalar(t){return this.x+=t,this.y+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this}subScalar(t){return this.x-=t,this.y-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this}multiply(t){return this.x*=t.x,this.y*=t.y,this}multiplyScalar(t){return this.x*=t,this.y*=t,this}divide(t){return this.x/=t.x,this.y/=t.y,this}divideScalar(t){return this.multiplyScalar(1/t)}applyMatrix3(t){const e=this.x,n=this.y,i=t.elements;return this.x=i[0]*e+i[3]*n+i[6],this.y=i[1]*e+i[4]*n+i[7],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(0===e)return Math.PI/2;const n=this.dot(t)/e;return Math.acos(zn(n,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,n=this.y-t.y;return e*e+n*n}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this}equals(t){return t.x===this.x&&t.y===this.y}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this}rotateAround(t,e){const n=Math.cos(e),i=Math.sin(e),r=this.x-t.x,s=this.y-t.y;return this.x=r*n-s*i+t.x,this.y=r*i+s*n+t.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class Zn{constructor(t,e,n,i,r,s,a,o,l){Zn.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],void 0!==t&&this.set(t,e,n,i,r,s,a,o,l)}set(t,e,n,i,r,s,a,o,l){const c=this.elements;return c[0]=t,c[1]=i,c[2]=a,c[3]=e,c[4]=r,c[5]=o,c[6]=n,c[7]=s,c[8]=l,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(t){const e=this.elements,n=t.elements;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],this}extractBasis(t,e,n){return t.setFromMatrix3Column(this,0),e.setFromMatrix3Column(this,1),n.setFromMatrix3Column(this,2),this}setFromMatrix4(t){const e=t.elements;return this.set(e[0],e[4],e[8],e[1],e[5],e[9],e[2],e[6],e[10]),this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const n=t.elements,i=e.elements,r=this.elements,s=n[0],a=n[3],o=n[6],l=n[1],c=n[4],h=n[7],u=n[2],d=n[5],p=n[8],m=i[0],f=i[3],g=i[6],v=i[1],_=i[4],y=i[7],x=i[2],M=i[5],S=i[8];return r[0]=s*m+a*v+o*x,r[3]=s*f+a*_+o*M,r[6]=s*g+a*y+o*S,r[1]=l*m+c*v+h*x,r[4]=l*f+c*_+h*M,r[7]=l*g+c*y+h*S,r[2]=u*m+d*v+p*x,r[5]=u*f+d*_+p*M,r[8]=u*g+d*y+p*S,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[3]*=t,e[6]*=t,e[1]*=t,e[4]*=t,e[7]*=t,e[2]*=t,e[5]*=t,e[8]*=t,this}determinant(){const t=this.elements,e=t[0],n=t[1],i=t[2],r=t[3],s=t[4],a=t[5],o=t[6],l=t[7],c=t[8];return e*s*c-e*a*l-n*r*c+n*a*o+i*r*l-i*s*o}invert(){const t=this.elements,e=t[0],n=t[1],i=t[2],r=t[3],s=t[4],a=t[5],o=t[6],l=t[7],c=t[8],h=c*s-a*l,u=a*o-c*r,d=l*r-s*o,p=e*h+n*u+i*d;if(0===p)return this.set(0,0,0,0,0,0,0,0,0);const m=1/p;return t[0]=h*m,t[1]=(i*l-c*n)*m,t[2]=(a*n-i*s)*m,t[3]=u*m,t[4]=(c*e-i*o)*m,t[5]=(i*r-a*e)*m,t[6]=d*m,t[7]=(n*o-l*e)*m,t[8]=(s*e-n*r)*m,this}transpose(){let t;const e=this.elements;return t=e[1],e[1]=e[3],e[3]=t,t=e[2],e[2]=e[6],e[6]=t,t=e[5],e[5]=e[7],e[7]=t,this}getNormalMatrix(t){return this.setFromMatrix4(t).invert().transpose()}transposeIntoArray(t){const e=this.elements;return t[0]=e[0],t[1]=e[3],t[2]=e[6],t[3]=e[1],t[4]=e[4],t[5]=e[7],t[6]=e[2],t[7]=e[5],t[8]=e[8],this}setUvTransform(t,e,n,i,r,s,a){const o=Math.cos(r),l=Math.sin(r);return this.set(n*o,n*l,-n*(o*s+l*a)+s+t,-i*l,i*o,-i*(-l*s+o*a)+a+e,0,0,1),this}scale(t,e){return this.premultiply(Jn.makeScale(t,e)),this}rotate(t){return this.premultiply(Jn.makeRotation(-t)),this}translate(t,e){return this.premultiply(Jn.makeTranslation(t,e)),this}makeTranslation(t,e){return t.isVector2?this.set(1,0,t.x,0,1,t.y,0,0,1):this.set(1,0,t,0,1,e,0,0,1),this}makeRotation(t){const e=Math.cos(t),n=Math.sin(t);return this.set(e,-n,0,n,e,0,0,0,1),this}makeScale(t,e){return this.set(t,0,0,0,e,0,0,0,1),this}equals(t){const e=this.elements,n=t.elements;for(let t=0;t=65535)return!0;return!1}const $n={Int8Array:Int8Array,Uint8Array:Uint8Array,Uint8ClampedArray:Uint8ClampedArray,Int16Array:Int16Array,Uint16Array:Uint16Array,Int32Array:Int32Array,Uint32Array:Uint32Array,Float32Array:Float32Array,Float64Array:Float64Array};function Qn(t,e){return new $n[t](e)}function ti(t){return document.createElementNS(\"http://www.w3.org/1999/xhtml\",t)}function ei(){const t=ti(\"canvas\");return t.style.display=\"block\",t}const ni={};function ii(t){t in ni||(ni[t]=!0,console.warn(t))}const ri=(new Zn).set(.8224621,.177538,0,.0331941,.9668058,0,.0170827,.0723974,.9105199),si=(new Zn).set(1.2249401,-.2249404,0,-.0420569,1.0420571,0,-.0196376,-.0786361,1.0982735),ai={[Ve]:{transfer:We,primaries:je,toReference:t=>t,fromReference:t=>t},[He]:{transfer:Xe,primaries:je,toReference:t=>t.convertSRGBToLinear(),fromReference:t=>t.convertLinearToSRGB()},[Ge]:{transfer:We,primaries:qe,toReference:t=>t.applyMatrix3(si),fromReference:t=>t.applyMatrix3(ri)},[ke]:{transfer:Xe,primaries:qe,toReference:t=>t.convertSRGBToLinear().applyMatrix3(si),fromReference:t=>t.applyMatrix3(ri).convertLinearToSRGB()}},oi=new Set([Ve,Ge]),li={enabled:!0,_workingColorSpace:Ve,get legacyMode(){return console.warn(\"THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150.\"),!this.enabled},set legacyMode(t){console.warn(\"THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150.\"),this.enabled=!t},get workingColorSpace(){return this._workingColorSpace},set workingColorSpace(t){if(!oi.has(t))throw new Error(`Unsupported working color space, \"${t}\".`);this._workingColorSpace=t},convert:function(t,e,n){if(!1===this.enabled||e===n||!e||!n)return t;const i=ai[e].toReference;return(0,ai[n].fromReference)(i(t))},fromWorkingColorSpace:function(t,e){return this.convert(t,this._workingColorSpace,e)},toWorkingColorSpace:function(t,e){return this.convert(t,e,this._workingColorSpace)},getPrimaries:function(t){return ai[t].primaries},getTransfer:function(t){return t===ze?We:ai[t].transfer}};function ci(t){return t2048?(console.warn(\"THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons\",t),e.toDataURL(\"image/jpeg\",.6)):e.toDataURL(\"image/png\")}static sRGBToLinear(t){if(\"undefined\"!=typeof HTMLImageElement&&t instanceof HTMLImageElement||\"undefined\"!=typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||\"undefined\"!=typeof ImageBitmap&&t instanceof ImageBitmap){const e=ti(\"canvas\");e.width=t.width,e.height=t.height;const n=e.getContext(\"2d\");n.drawImage(t,0,0,t.width,t.height);const i=n.getImageData(0,0,t.width,t.height),r=i.data;for(let t=0;t"},{"title":"","date":"2023-10-12T14:08:39.205Z","updated":"2023-10-12T14:08:39.205Z","comments":true,"path":"js/three/build/three.min.js","permalink":"http://19999997.xyz/js/three/build/three.min.js","excerpt":"","text":"console.warn('Scripts \"build/three.js\" and \"build/three.min.js\" are deprecated with r150+, and will be removed with r160. Please use ES Modules or alternatives: https://threejs.org/docs/index.html#manual/en/introduction/Installation'), /** * @license * Copyright 2010-2023 Three.js Authors * SPDX-License-Identifier: MIT */ function(t,e){\"object\"==typeof exports&&\"undefined\"!=typeof module?e(exports):\"function\"==typeof define&&define.amd?define([\"exports\"],e):e((t=\"undefined\"!=typeof globalThis?globalThis:t||self).THREE={})}(this,(function(t){\"use strict\";const e=\"157\",n=1,i=2,r=3,s=0,a=1,o=100,l=0,c=1,h=2,u=0,d=1,p=2,m=3,f=4,g=5,_=300,v=301,y=302,x=303,M=304,S=306,b=1e3,T=1001,E=1002,w=1003,A=1004,R=1005,C=1006,L=1007,P=1008,I=1009,U=1012,D=1013,N=1014,O=1015,F=1016,B=1017,z=1018,H=1020,G=1023,V=1026,k=1027,W=1029,X=1031,j=1033,q=33776,Y=33777,Z=33778,J=33779,K=35840,$=35841,Q=35842,tt=35843,et=37492,nt=37496,it=37808,rt=37809,st=37810,at=37811,ot=37812,lt=37813,ct=37814,ht=37815,ut=37816,dt=37817,pt=37818,mt=37819,ft=37820,gt=37821,_t=36492,vt=36494,yt=36495,xt=36284,Mt=36285,St=36286,bt=2300,Tt=2301,Et=2302,wt=2400,At=2401,Rt=2402,Ct=2500,Lt=2501,Pt=3e3,It=3001,Ut=\"\",Dt=\"srgb\",Nt=\"srgb-linear\",Ot=\"display-p3\",Ft=\"display-p3-linear\",Bt=\"linear\",zt=\"srgb\",Ht=\"rec709\",Gt=\"p3\",Vt=7680,kt=35044,Wt=\"300 es\",Xt=1035,jt=2e3,qt=2001;class Yt{addEventListener(t,e){void 0===this._listeners&&(this._listeners={});const n=this._listeners;void 0===n[t]&&(n[t]=[]),-1===n[t].indexOf(e)&&n[t].push(e)}hasEventListener(t,e){if(void 0===this._listeners)return!1;const n=this._listeners;return void 0!==n[t]&&-1!==n[t].indexOf(e)}removeEventListener(t,e){if(void 0===this._listeners)return;const n=this._listeners[t];if(void 0!==n){const t=n.indexOf(e);-1!==t&&n.splice(t,1)}}dispatchEvent(t){if(void 0===this._listeners)return;const e=this._listeners[t.type];if(void 0!==e){t.target=this;const n=e.slice(0);for(let e=0,i=n.length;e>8&255]+Zt[t>>16&255]+Zt[t>>24&255]+\"-\"+Zt[255&e]+Zt[e>>8&255]+\"-\"+Zt[e>>16&15|64]+Zt[e>>24&255]+\"-\"+Zt[63&n|128]+Zt[n>>8&255]+\"-\"+Zt[n>>16&255]+Zt[n>>24&255]+Zt[255&i]+Zt[i>>8&255]+Zt[i>>16&255]+Zt[i>>24&255]).toLowerCase()}function te(t,e,n){return Math.max(e,Math.min(n,t))}function ee(t,e){return(t%e+e)%e}function ne(t,e,n){return(1-n)*t+n*e}function ie(t){return 0==(t&t-1)&&0!==t}function re(t){return Math.pow(2,Math.ceil(Math.log(t)/Math.LN2))}function se(t){return Math.pow(2,Math.floor(Math.log(t)/Math.LN2))}function ae(t,e){switch(e.constructor){case Float32Array:return t;case Uint32Array:return t/4294967295;case Uint16Array:return t/65535;case Uint8Array:return t/255;case Int32Array:return Math.max(t/2147483647,-1);case Int16Array:return Math.max(t/32767,-1);case Int8Array:return Math.max(t/127,-1);default:throw new Error(\"Invalid component type.\")}}function oe(t,e){switch(e.constructor){case Float32Array:return t;case Uint32Array:return Math.round(4294967295*t);case Uint16Array:return Math.round(65535*t);case Uint8Array:return Math.round(255*t);case Int32Array:return Math.round(2147483647*t);case Int16Array:return Math.round(32767*t);case Int8Array:return Math.round(127*t);default:throw new Error(\"Invalid component type.\")}}const le={DEG2RAD:Kt,RAD2DEG:$t,generateUUID:Qt,clamp:te,euclideanModulo:ee,mapLinear:function(t,e,n,i,r){return i+(t-e)*(r-i)/(n-e)},inverseLerp:function(t,e,n){return t!==e?(n-t)/(e-t):0},lerp:ne,damp:function(t,e,n,i){return ne(t,e,1-Math.exp(-n*i))},pingpong:function(t,e=1){return e-Math.abs(ee(t,2*e)-e)},smoothstep:function(t,e,n){return t=n?1:(t=(t-e)/(n-e))*t*(3-2*t)},smootherstep:function(t,e,n){return t=n?1:(t=(t-e)/(n-e))*t*t*(t*(6*t-15)+10)},randInt:function(t,e){return t+Math.floor(Math.random()*(e-t+1))},randFloat:function(t,e){return t+Math.random()*(e-t)},randFloatSpread:function(t){return t*(.5-Math.random())},seededRandom:function(t){void 0!==t&&(Jt=t);let e=Jt+=1831565813;return e=Math.imul(e^e>>>15,1|e),e^=e+Math.imul(e^e>>>7,61|e),((e^e>>>14)>>>0)/4294967296},degToRad:function(t){return t*Kt},radToDeg:function(t){return t*$t},isPowerOfTwo:ie,ceilPowerOfTwo:re,floorPowerOfTwo:se,setQuaternionFromProperEuler:function(t,e,n,i,r){const s=Math.cos,a=Math.sin,o=s(n/2),l=a(n/2),c=s((e+i)/2),h=a((e+i)/2),u=s((e-i)/2),d=a((e-i)/2),p=s((i-e)/2),m=a((i-e)/2);switch(r){case\"XYX\":t.set(o*h,l*u,l*d,o*c);break;case\"YZY\":t.set(l*d,o*h,l*u,o*c);break;case\"ZXZ\":t.set(l*u,l*d,o*h,o*c);break;case\"XZX\":t.set(o*h,l*m,l*p,o*c);break;case\"YXY\":t.set(l*p,o*h,l*m,o*c);break;case\"ZYZ\":t.set(l*m,l*p,o*h,o*c);break;default:console.warn(\"THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: \"+r)}},normalize:oe,denormalize:ae};class ce{constructor(t=0,e=0){ce.prototype.isVector2=!0,this.x=t,this.y=e}get width(){return this.x}set width(t){this.x=t}get height(){return this.y}set height(t){this.y=t}set(t,e){return this.x=t,this.y=e,this}setScalar(t){return this.x=t,this.y=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;default:throw new Error(\"index is out of range: \"+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;default:throw new Error(\"index is out of range: \"+t)}}clone(){return new this.constructor(this.x,this.y)}copy(t){return this.x=t.x,this.y=t.y,this}add(t){return this.x+=t.x,this.y+=t.y,this}addScalar(t){return this.x+=t,this.y+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this}subScalar(t){return this.x-=t,this.y-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this}multiply(t){return this.x*=t.x,this.y*=t.y,this}multiplyScalar(t){return this.x*=t,this.y*=t,this}divide(t){return this.x/=t.x,this.y/=t.y,this}divideScalar(t){return this.multiplyScalar(1/t)}applyMatrix3(t){const e=this.x,n=this.y,i=t.elements;return this.x=i[0]*e+i[3]*n+i[6],this.y=i[1]*e+i[4]*n+i[7],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(0===e)return Math.PI/2;const n=this.dot(t)/e;return Math.acos(te(n,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,n=this.y-t.y;return e*e+n*n}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this}equals(t){return t.x===this.x&&t.y===this.y}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this}rotateAround(t,e){const n=Math.cos(e),i=Math.sin(e),r=this.x-t.x,s=this.y-t.y;return this.x=r*n-s*i+t.x,this.y=r*i+s*n+t.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class he{constructor(t,e,n,i,r,s,a,o,l){he.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],void 0!==t&&this.set(t,e,n,i,r,s,a,o,l)}set(t,e,n,i,r,s,a,o,l){const c=this.elements;return c[0]=t,c[1]=i,c[2]=a,c[3]=e,c[4]=r,c[5]=o,c[6]=n,c[7]=s,c[8]=l,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(t){const e=this.elements,n=t.elements;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],this}extractBasis(t,e,n){return t.setFromMatrix3Column(this,0),e.setFromMatrix3Column(this,1),n.setFromMatrix3Column(this,2),this}setFromMatrix4(t){const e=t.elements;return this.set(e[0],e[4],e[8],e[1],e[5],e[9],e[2],e[6],e[10]),this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const n=t.elements,i=e.elements,r=this.elements,s=n[0],a=n[3],o=n[6],l=n[1],c=n[4],h=n[7],u=n[2],d=n[5],p=n[8],m=i[0],f=i[3],g=i[6],_=i[1],v=i[4],y=i[7],x=i[2],M=i[5],S=i[8];return r[0]=s*m+a*_+o*x,r[3]=s*f+a*v+o*M,r[6]=s*g+a*y+o*S,r[1]=l*m+c*_+h*x,r[4]=l*f+c*v+h*M,r[7]=l*g+c*y+h*S,r[2]=u*m+d*_+p*x,r[5]=u*f+d*v+p*M,r[8]=u*g+d*y+p*S,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[3]*=t,e[6]*=t,e[1]*=t,e[4]*=t,e[7]*=t,e[2]*=t,e[5]*=t,e[8]*=t,this}determinant(){const t=this.elements,e=t[0],n=t[1],i=t[2],r=t[3],s=t[4],a=t[5],o=t[6],l=t[7],c=t[8];return e*s*c-e*a*l-n*r*c+n*a*o+i*r*l-i*s*o}invert(){const t=this.elements,e=t[0],n=t[1],i=t[2],r=t[3],s=t[4],a=t[5],o=t[6],l=t[7],c=t[8],h=c*s-a*l,u=a*o-c*r,d=l*r-s*o,p=e*h+n*u+i*d;if(0===p)return this.set(0,0,0,0,0,0,0,0,0);const m=1/p;return t[0]=h*m,t[1]=(i*l-c*n)*m,t[2]=(a*n-i*s)*m,t[3]=u*m,t[4]=(c*e-i*o)*m,t[5]=(i*r-a*e)*m,t[6]=d*m,t[7]=(n*o-l*e)*m,t[8]=(s*e-n*r)*m,this}transpose(){let t;const e=this.elements;return t=e[1],e[1]=e[3],e[3]=t,t=e[2],e[2]=e[6],e[6]=t,t=e[5],e[5]=e[7],e[7]=t,this}getNormalMatrix(t){return this.setFromMatrix4(t).invert().transpose()}transposeIntoArray(t){const e=this.elements;return t[0]=e[0],t[1]=e[3],t[2]=e[6],t[3]=e[1],t[4]=e[4],t[5]=e[7],t[6]=e[2],t[7]=e[5],t[8]=e[8],this}setUvTransform(t,e,n,i,r,s,a){const o=Math.cos(r),l=Math.sin(r);return this.set(n*o,n*l,-n*(o*s+l*a)+s+t,-i*l,i*o,-i*(-l*s+o*a)+a+e,0,0,1),this}scale(t,e){return this.premultiply(ue.makeScale(t,e)),this}rotate(t){return this.premultiply(ue.makeRotation(-t)),this}translate(t,e){return this.premultiply(ue.makeTranslation(t,e)),this}makeTranslation(t,e){return t.isVector2?this.set(1,0,t.x,0,1,t.y,0,0,1):this.set(1,0,t,0,1,e,0,0,1),this}makeRotation(t){const e=Math.cos(t),n=Math.sin(t);return this.set(e,-n,0,n,e,0,0,0,1),this}makeScale(t,e){return this.set(t,0,0,0,e,0,0,0,1),this}equals(t){const e=this.elements,n=t.elements;for(let t=0;t=65535)return!0;return!1}const pe={Int8Array:Int8Array,Uint8Array:Uint8Array,Uint8ClampedArray:Uint8ClampedArray,Int16Array:Int16Array,Uint16Array:Uint16Array,Int32Array:Int32Array,Uint32Array:Uint32Array,Float32Array:Float32Array,Float64Array:Float64Array};function me(t,e){return new pe[t](e)}function fe(t){return document.createElementNS(\"http://www.w3.org/1999/xhtml\",t)}function ge(){const t=fe(\"canvas\");return t.style.display=\"block\",t}const _e={};function ve(t){t in _e||(_e[t]=!0,console.warn(t))}const ye=(new he).set(.8224621,.177538,0,.0331941,.9668058,0,.0170827,.0723974,.9105199),xe=(new he).set(1.2249401,-.2249404,0,-.0420569,1.0420571,0,-.0196376,-.0786361,1.0982735),Me={[Nt]:{transfer:Bt,primaries:Ht,toReference:t=>t,fromReference:t=>t},[Dt]:{transfer:zt,primaries:Ht,toReference:t=>t.convertSRGBToLinear(),fromReference:t=>t.convertLinearToSRGB()},[Ft]:{transfer:Bt,primaries:Gt,toReference:t=>t.applyMatrix3(xe),fromReference:t=>t.applyMatrix3(ye)},[Ot]:{transfer:zt,primaries:Gt,toReference:t=>t.convertSRGBToLinear().applyMatrix3(xe),fromReference:t=>t.applyMatrix3(ye).convertLinearToSRGB()}},Se=new Set([Nt,Ft]),be={enabled:!0,_workingColorSpace:Nt,get legacyMode(){return console.warn(\"THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150.\"),!this.enabled},set legacyMode(t){console.warn(\"THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150.\"),this.enabled=!t},get workingColorSpace(){return this._workingColorSpace},set workingColorSpace(t){if(!Se.has(t))throw new Error(`Unsupported working color space, \"${t}\".`);this._workingColorSpace=t},convert:function(t,e,n){if(!1===this.enabled||e===n||!e||!n)return t;const i=Me[e].toReference;return(0,Me[n].fromReference)(i(t))},fromWorkingColorSpace:function(t,e){return this.convert(t,this._workingColorSpace,e)},toWorkingColorSpace:function(t,e){return this.convert(t,e,this._workingColorSpace)},getPrimaries:function(t){return Me[t].primaries},getTransfer:function(t){return t===Ut?Bt:Me[t].transfer}};function Te(t){return t2048?(console.warn(\"THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons\",t),e.toDataURL(\"image/jpeg\",.6)):e.toDataURL(\"image/png\")}static sRGBToLinear(t){if(\"undefined\"!=typeof HTMLImageElement&&t instanceof HTMLImageElement||\"undefined\"!=typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||\"undefined\"!=typeof ImageBitmap&&t instanceof ImageBitmap){const e=fe(\"canvas\");e.width=t.width,e.height=t.height;const n=e.getContext(\"2d\");n.drawImage(t,0,0,t.width,t.height);const i=n.getImageData(0,0,t.width,t.height),r=i.data;for(let t=0;t"},{"title":"","date":"2023-10-12T14:08:40.432Z","updated":"2023-10-12T14:08:40.432Z","comments":true,"path":"js/three/jsm/libs/draco/draco_decoder.js","permalink":"http://19999997.xyz/js/three/jsm/libs/draco/draco_decoder.js","excerpt":"","text":"var DracoDecoderModule = (() => { var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined; if (typeof __filename !== 'undefined') _scriptDir = _scriptDir || __filename; return ( function(DracoDecoderModule = {}) { var Module=typeof DracoDecoderModule!=\"undefined\"?DracoDecoderModule:{};var readyPromiseResolve,readyPromiseReject;Module[\"ready\"]=new Promise(function(resolve,reject){readyPromiseResolve=resolve;readyPromiseReject=reject});var isRuntimeInitialized=false;var isModuleParsed=false;Module[\"onRuntimeInitialized\"]=function(){isRuntimeInitialized=true;if(isModuleParsed){if(typeof Module[\"onModuleLoaded\"]===\"function\"){Module[\"onModuleLoaded\"](Module)}}};Module[\"onModuleParsed\"]=function(){isModuleParsed=true;if(isRuntimeInitialized){if(typeof Module[\"onModuleLoaded\"]===\"function\"){Module[\"onModuleLoaded\"](Module)}}};function isVersionSupported(versionString){if(typeof versionString!==\"string\")return false;const version=versionString.split(\".\");if(version.length3)return false;if(version[0]==1&&version[1]>=0&&version[1]10)return false;return true}Module[\"isVersionSupported\"]=isVersionSupported;var moduleOverrides=Object.assign({},Module);var arguments_=[];var thisProgram=\"./this.program\";var quit_=(status,toThrow)=>{throw toThrow};var ENVIRONMENT_IS_WEB=typeof window==\"object\";var ENVIRONMENT_IS_WORKER=typeof importScripts==\"function\";var ENVIRONMENT_IS_NODE=typeof process==\"object\"&&typeof process.versions==\"object\"&&typeof process.versions.node==\"string\";var scriptDirectory=\"\";function locateFile(path){if(Module[\"locateFile\"]){return Module[\"locateFile\"](path,scriptDirectory)}return scriptDirectory+path}var read_,readAsync,readBinary,setWindowTitle;function logExceptionOnExit(e){if(e instanceof ExitStatus)return;let toLog=e;err(\"exiting due to exception: \"+toLog)}if(ENVIRONMENT_IS_NODE){var fs=require(\"fs\");var nodePath=require(\"path\");if(ENVIRONMENT_IS_WORKER){scriptDirectory=nodePath.dirname(scriptDirectory)+\"/\"}else{scriptDirectory=__dirname+\"/\"}read_=(filename,binary)=>{var ret=tryParseAsDataURI(filename);if(ret){return binary?ret:ret.toString()}filename=isFileURI(filename)?new URL(filename):nodePath.normalize(filename);return fs.readFileSync(filename,binary?undefined:\"utf8\")};readBinary=filename=>{var ret=read_(filename,true);if(!ret.buffer){ret=new Uint8Array(ret)}return ret};readAsync=(filename,onload,onerror)=>{var ret=tryParseAsDataURI(filename);if(ret){onload(ret)}filename=isFileURI(filename)?new URL(filename):nodePath.normalize(filename);fs.readFile(filename,function(err,data){if(err)onerror(err);else onload(data.buffer)})};if(process[\"argv\"].length>1){thisProgram=process[\"argv\"][1].replace(/\\\\/g,\"/\")}arguments_=process[\"argv\"].slice(2);quit_=(status,toThrow)=>{if(keepRuntimeAlive()){process[\"exitCode\"]=status;throw toThrow}logExceptionOnExit(toThrow);process[\"exit\"](status)};Module[\"inspect\"]=function(){return\"[Emscripten Module object]\"}}else if(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER){if(ENVIRONMENT_IS_WORKER){scriptDirectory=self.location.href}else if(typeof document!=\"undefined\"&&document.currentScript){scriptDirectory=document.currentScript.src}if(_scriptDir){scriptDirectory=_scriptDir}if(scriptDirectory.indexOf(\"blob:\")!==0){scriptDirectory=scriptDirectory.substr(0,scriptDirectory.replace(/[?#].*/,\"\").lastIndexOf(\"/\")+1)}else{scriptDirectory=\"\"}{read_=url=>{try{var xhr=new XMLHttpRequest;xhr.open(\"GET\",url,false);xhr.send(null);return xhr.responseText}catch(err){var data=tryParseAsDataURI(url);if(data){return intArrayToString(data)}throw err}};if(ENVIRONMENT_IS_WORKER){readBinary=url=>{try{var xhr=new XMLHttpRequest;xhr.open(\"GET\",url,false);xhr.responseType=\"arraybuffer\";xhr.send(null);return new Uint8Array(xhr.response)}catch(err){var data=tryParseAsDataURI(url);if(data){return data}throw err}}}readAsync=(url,onload,onerror)=>{var xhr=new XMLHttpRequest;xhr.open(\"GET\",url,true);xhr.responseType=\"arraybuffer\";xhr.onload=()=>{if(xhr.status==200||xhr.status==0&&xhr.response){onload(xhr.response);return}var data=tryParseAsDataURI(url);if(data){onload(data.buffer);return}onerror()};xhr.onerror=onerror;xhr.send(null)}}setWindowTitle=title=>document.title=title}else{}var out=Module[\"print\"]||console.log.bind(console);var err=Module[\"printErr\"]||console.warn.bind(console);Object.assign(Module,moduleOverrides);moduleOverrides=null;if(Module[\"arguments\"])arguments_=Module[\"arguments\"];if(Module[\"thisProgram\"])thisProgram=Module[\"thisProgram\"];if(Module[\"quit\"])quit_=Module[\"quit\"];var wasmBinary;if(Module[\"wasmBinary\"])wasmBinary=Module[\"wasmBinary\"];var noExitRuntime=Module[\"noExitRuntime\"]||true;var WebAssembly={Memory:function(opts){this.buffer=new ArrayBuffer(opts[\"initial\"]*65536)},Module:function(binary){},Instance:function(module,info){this.exports=( // EMSCRIPTEN_START_ASM function instantiate(na){function c(d){d.set=function(a,b){this[a]=b};d.get=function(a){return this[a]};return d}var e;var f=new Uint8Array(123);for(var a=25;a>=0;--a){f[48+a]=52+a;f[65+a]=a;f[97+a]=26+a}f[43]=62;f[47]=63;function l(m,n,o){var g,h,a=0,i=n,j=o.length,k=n+(j*3>>2)-(o[j-2]==\"=\")-(o[j-1]==\"=\");for(;a>2];e=H[b+16>>2];g=e+4|0;d=g>>>0>>0>k>>>0&(d|0)>=(s|0)|(d|0)>(s|0)){break c}d=e+H[b>>2]|0;H[a>>2]=I[d|0]|I[d+1|0]>0>2]=e;H[b+20>>2]=d;if(K[a>>2]>31){break c}s=H[b+8>>2];y=H[b+12>>2];d=k;g=g+8|0;d=g>>>0>>0>s>>>0&(d|0)>=(y|0)|(d|0)>(y|0)){break c}d=e+H[b>>2]|0;H[a+4>>2]=I[d|0]|I[d+1|0]>0>2]=e;H[b+20>>2]=d;s=H[b+8>>2];y=H[b+12>>2];d=k;g=g+8|0;d=g>>>0>>0>s>>>0&(d|0)>=(y|0)|(d|0)>(y|0)){break c}d=e+H[b>>2]|0;H[a+12>>2]=I[d|0]|I[d+1|0]>0>2]=e;H[b+20>>2]=d;d=H[a+20>>2];x=H[a+12>>2];if((x|0)!=(d|0)?d:0){break c}s=H[b+8>>2];y=H[b+12>>2];d=k;g=g+8|0;d=g>>>0>>0>s>>>0&(d|0)>=(y|0)|(d|0)>(y|0)){break c}d=e+H[b>>2]|0;e=I[d|0]|I[d+1|0]2]+4|0;g=d>>>0>2]=d;H[b+20>>2]=g;if(e>>>0>=7){H[B>>2]=e;Qd(1713,B);break c}H[B+664>>2]=c;d:{if(!x){break d}e:{k=H[c>>2];if(x>>>0>2]-k|0)/12>>>0){break e}if(x>>>0>2];d=N(x,12);e=pa(d);g=d+e|0;e=e+N((l-k|0)/12|0,12)|0;d=e;if((k|0)!=(l|0)){while(1){d=d-12|0;l=l-12|0;H[d>>2]=H[l>>2];H[d+4>>2]=H[l+4>>2];H[d+8>>2]=H[l+8>>2];if((k|0)!=(l|0)){continue}break}}H[c+8>>2]=g;H[c+4>>2]=e;H[c>>2]=d;if(!k){break e}oa(k);break e}break b}f:{switch(H[a+16>>2]){case 0:i=wb(B+8|0,3);z=B+664|0;k=H[b+8>>2];n=H[b+12>>2];d=H[b+20>>2];e=H[b+16>>2];g=e+4|0;d=g>>>0>>0>k>>>0&(d|0)>=(n|0)|(d|0)>(n|0)){break g}d=e+H[b>>2]|0;H[i>>2]=I[d|0]|I[d+1|0]>0>2]=e;H[b+20>>2]=d;if(K[i>>2]>32){break g}n=H[b+8>>2];s=H[b+12>>2];d=k;g=g+8|0;d=g>>>0>>0>n>>>0&(d|0)>=(s|0)|(d|0)>(s|0)){break g}d=e+H[b>>2]|0;e=I[d|0]|I[d+1|0]2]+4|0;g=d>>>0>2]=d;H[b+20>>2]=g;if(!e){break g}H[i+8>>2]=0;if(!ua(i+16|0,b)){break g}if(!ua(i+36|0,b)){break g}if(!ua(i+56|0,b)){break g}if(!ua(i+76|0,b)){break g}A=H[i+4>>2];d=0;g=0;f=ca-32|0;ca=f;m=H[i+12>>2];H[f+16>>2]=0;H[f+8>>2]=0;H[f+12>>2]=0;if(m){if(m>>>0>=1073741824){break b}b=m2]=g;d=b+g|0;H[f+16>>2]=d;ra(g,0,b);H[f+12>>2]=d}e=H[i+120>>2];b=H[e>>2];if(b){H[e+4>>2]=b;oa(b);m=H[i+12>>2];g=H[f+8>>2];d=H[f+12>>2]}H[e+4>>2]=d;H[e>>2]=g;H[e+8>>2]=H[f+16>>2];g=0;H[f+16>>2]=0;H[f+8>>2]=0;H[f+12>>2]=0;h:{if(m){if(m>>>0>=1073741824){break b}b=m2]=w;g=b+w|0;H[f+16>>2]=g;ra(w,0,b);H[f+12>>2]=g}d=H[i+132>>2];b=H[d>>2];if(b){H[d+4>>2]=b;oa(b);w=H[f+8>>2];g=H[f+12>>2]}H[d+4>>2]=g;H[d>>2]=w;H[d+8>>2]=H[f+16>>2];H[f+24>>2]=0;H[f+28>>2]=0;H[f+16>>2]=0;H[f+20>>2]=0;H[f+8>>2]=0;H[f+12>>2]=0;xa(f+8|0);d=H[f+24>>2]+H[f+28>>2]|0;b=(d>>>0)/341|0;b=H[H[f+12>>2]+(b2]+N(d-N(b,341)|0,12)|0;H[b+4>>2]=0;H[b+8>>2]=0;H[b>>2]=A;m=H[f+28>>2]+1|0;H[f+28>>2]=m;i:{if(!m){break i}y=i+96|0;while(1){n=H[f+12>>2];g=H[f+24>>2];e=m-1|0;d=g+e|0;b=(d>>>0)/341|0;b=H[n+(b2]+N(d-N(b,341)|0,12)|0;o=H[b+8>>2];k=H[b+4>>2];t=H[b>>2];H[f+28>>2]=e;b=H[f+16>>2];if((((b|0)!=(n|0)?N(b-n>>2,341)-1|0:0)-(g+m|0)|0)+1>>>0>=682){oa(H[b-4>>2]);H[f+16>>2]=H[f+16>>2]-4}b=0;if(t>>>0>A>>>0){break i}d=H[i+12>>2];m=(k|0)!=(d-1|0)?k+1|0:0;if(m>>>0>=d>>>0){break i}q=N(o,12);p=q+H[i+132>>2]|0;l=q+H[i+120>>2]|0;g=H[i>>2];r=m2]>>2];j:{k:{if((g|0)==(e|0)){if(!t){break k}while(1){d=H[l>>2];x=H[d+8>>2];s=H[d+4>>2];n=H[d>>2];q=H[z>>2];m=H[q+4>>2];d=H[q+8>>2];l:{if(m>>>0>>0){H[m+8>>2]=x;H[m+4>>2]=s;H[m>>2]=n;H[q+4>>2]=m+12;break l}r=H[q>>2];g=(m-r|0)/12|0;k=g+1|0;if(k>>>0>=357913942){break b}e=(d-r|0)/12|0;d=e>0>=178956970?357913941:d>>>0>k>>>0?d:k;if(k){if(k>>>0>=357913942){break a}d=pa(N(k,12))}else{d=0}w=d+N(g,12)|0;H[w+8>>2]=x;H[w+4>>2]=s;H[w>>2]=n;e=w+12|0;if((m|0)!=(r|0)){while(1){w=w-12|0;m=m-12|0;H[w>>2]=H[m>>2];H[w+4>>2]=H[m+4>>2];H[w+8>>2]=H[m+8>>2];if((m|0)!=(r|0)){continue}break}}H[q+8>>2]=d+N(k,12);H[q+4>>2]=e;H[q>>2]=w;if(!r){break l}oa(r)}H[i+8>>2]=H[i+8>>2]+1;b=b+1|0;if((t|0)!=(b|0)){continue}break}break k}m:{n:{o:{p:{if(t>>>0>2];H[d>>2]=m;w=1;g=H[i+12>>2];if(g>>>0>1){break p}break m}if(K[i+8>>2]>K[i+4>>2]){break i}b=H[i+120>>2];s=o+1|0;x=N(s,12);d=b+x|0;if((d|0)!=(l|0)){Aa(d,H[l>>2],H[l+4>>2]);b=H[i+120>>2]}b=r+H[b+x>>2]|0;H[b>>2]=H[b>>2]+(12];e=32-k|0;q:{if((n|0)>2];if((e|0)==H[i+20>>2]){break o}d=H[e>>2];b=k+n|0;H[i+32>>2]=b;w=d>32-n|0;if((b|0)!=32){break q}H[i+32>>2]=0;H[i+28>>2]=e+4;break q}g=H[i+28>>2];b=g+4|0;if((b|0)==H[i+20>>2]){break o}d=H[g>>2];H[i+28>>2]=b;b=n-e|0;H[i+32>>2]=b;w=H[g+4>>2]>>>32-b|d>32-n}d=t>>>1|0;if(w>>>0>d>>>0){break i}break n}while(1){m=(g-1|0)!=(m|0)?m+1|0:0;H[d+(w2]=m;g=H[i+12>>2];w=w+1|0;if(g>>>0>w>>>0){continue}break}break m}d=t>>>1|0;w=0}r:{s:{e=d-w|0;b=t-e|0;t:{if((b|0)==(e|0)){b=e;break t}n=H[i+88>>2];if((n|0)==H[i+80>>2]){break s}k=H[n>>2];g=H[i+92>>2];d=g+1|0;H[i+92>>2]=d;g=k&-2147483648>>>g;u:{if((d|0)==32){H[i+92>>2]=0;H[i+88>>2]=n+4;if(g){break u}break s}if(!g){break s}}}d=b;b=e;break r}d=e}n=H[i+132>>2];k=n+q|0;g=H[k>>2];e=g+r|0;H[e>>2]=H[e>>2]+1;Aa(n+x|0,g,H[k+4>>2]);if(b){g=H[f+28>>2]+H[f+24>>2]|0;e=H[f+16>>2];w=H[f+12>>2];if((g|0)==(((e|0)!=(w|0)?N(e-w>>2,341)-1|0:0)|0)){xa(f+8|0);w=H[f+12>>2];g=H[f+24>>2]+H[f+28>>2]|0}e=(g>>>0)/341|0;e=H[(e2]+N(g-N(e,341)|0,12)|0;H[e+8>>2]=o;H[e+4>>2]=m;H[e>>2]=b;H[f+28>>2]=H[f+28>>2]+1}if(!d){break k}g=H[f+28>>2]+H[f+24>>2]|0;b=H[f+16>>2];w=H[f+12>>2];if((g|0)==(((b|0)!=(w|0)?N(b-w>>2,341)-1|0:0)|0)){xa(f+8|0);w=H[f+12>>2];g=H[f+24>>2]+H[f+28>>2]|0}b=(g>>>0)/341|0;b=H[(b2]+N(g-N(b,341)|0,12)|0;H[b+8>>2]=s;H[b+4>>2]=m;H[b>>2]=d;m=H[f+28>>2]+1|0;H[f+28>>2]=m;break j}if(!t){break k}while(1){if(H[i+12>>2]){o=H[i+40>>2];n=H[p>>2];w=H[i+96>>2];k=H[i+108>>2];m=0;while(1){q=k+(m2]2]=0;g=H[i>>2];e=H[q>>2]2];v:{if((g|0)==(d|0)){break v}r=e+w|0;u=g-d|0;x=H[i+52>>2];g=32-x|0;if((u|0)>2];if((e|0)==(o|0)){break i}H[r>>2]=H[e>>2]>32-u;d=u+H[i+52>>2]|0;H[i+52>>2]=d;if((d|0)!=32){break v}H[i+52>>2]=0;H[i+48>>2]=e+4;break v}s=H[i+48>>2];d=s+4|0;if((d|0)==(o|0)){break i}e=H[s>>2];H[i+48>>2]=d;d=u-g|0;H[i+52>>2]=d;H[r>>2]=H[s+4>>2]>>>32-d|e>32-u}e=H[q>>2]2]=H[d>>2]|H[e+H[l>>2]>>2];m=m+1|0;if(m>>>0>2]){continue}break}}jb(z,y);H[i+8>>2]=H[i+8>>2]+1;b=b+1|0;if((t|0)!=(b|0)){continue}break}}m=H[f+28>>2]}if(m){continue}break}}H[f+28>>2]=0;w=H[f+16>>2];m=H[f+12>>2];g=w-m|0;if(g>>>0>=9){while(1){oa(H[m>>2]);m=H[f+12>>2]+4|0;H[f+12>>2]=m;w=H[f+16>>2];g=w-m|0;if(g>>>0>8){continue}break}}b=170;w:{switch((g>>>2|0)-1|0){case 1:b=341;case 0:H[f+24>>2]=b;break;default:break w}}x:{if((m|0)==(w|0)){break x}while(1){oa(H[m>>2]);m=m+4|0;if((w|0)!=(m|0)){continue}break}d=H[f+16>>2];b=H[f+12>>2];if((d|0)==(b|0)){break x}H[f+16>>2]=d+((b-d|0)+3&-4)}b=H[f+8>>2];if(b){oa(b)}ca=f+32|0;break h}}xb(i);break d;case 1:i=wb(B+8|0,3);A=B+664|0;k=H[b+8>>2];n=H[b+12>>2];d=H[b+20>>2];e=H[b+16>>2];g=e+4|0;d=g>>>0>>0>k>>>0&(d|0)>=(n|0)|(d|0)>(n|0)){break y}d=e+H[b>>2]|0;H[i>>2]=I[d|0]|I[d+1|0]>0>2]=e;H[b+20>>2]=d;if(K[i>>2]>32){break y}n=H[b+8>>2];s=H[b+12>>2];d=k;g=g+8|0;d=g>>>0>>0>n>>>0&(d|0)>=(s|0)|(d|0)>(s|0)){break y}d=e+H[b>>2]|0;e=I[d|0]|I[d+1|0]2]+4|0;g=d>>>0>2]=d;H[b+20>>2]=g;if(!e){break y}H[i+8>>2]=0;if(!ua(i+16|0,b)){break y}if(!ua(i+36|0,b)){break y}if(!ua(i+56|0,b)){break y}if(!ua(i+76|0,b)){break y}p=H[i+4>>2];d=0;f=ca-32|0;ca=f;m=H[i+12>>2];H[f+16>>2]=0;H[f+8>>2]=0;H[f+12>>2]=0;if(m){if(m>>>0>=1073741824){break b}b=m2]=t;d=b+t|0;H[f+16>>2]=d;ra(t,0,b);H[f+12>>2]=d}e=H[i+120>>2];b=H[e>>2];if(b){H[e+4>>2]=b;oa(b);m=H[i+12>>2];t=H[f+8>>2];d=H[f+12>>2]}H[e+4>>2]=d;H[e>>2]=t;H[e+8>>2]=H[f+16>>2];t=0;H[f+16>>2]=0;H[f+8>>2]=0;H[f+12>>2]=0;z:{if(m){if(m>>>0>=1073741824){break b}b=m2]=o;t=b+o|0;H[f+16>>2]=t;ra(o,0,b);H[f+12>>2]=t}d=H[i+132>>2];b=H[d>>2];if(b){H[d+4>>2]=b;oa(b);t=H[f+12>>2];o=H[f+8>>2]}H[d+4>>2]=t;H[d>>2]=o;H[d+8>>2]=H[f+16>>2];H[f+24>>2]=0;H[f+28>>2]=0;H[f+16>>2]=0;H[f+20>>2]=0;H[f+8>>2]=0;H[f+12>>2]=0;xa(f+8|0);d=H[f+24>>2]+H[f+28>>2]|0;b=(d>>>0)/341|0;b=H[H[f+12>>2]+(b2]+N(d-N(b,341)|0,12)|0;H[b+4>>2]=0;H[b+8>>2]=0;H[b>>2]=p;m=H[f+28>>2]+1|0;H[f+28>>2]=m;A:{if(!m){break A}s=i+96|0;while(1){k=H[f+12>>2];g=H[f+24>>2];e=m-1|0;d=g+e|0;b=(d>>>0)/341|0;b=H[k+(b2]+N(d-N(b,341)|0,12)|0;q=H[b+8>>2];d=H[b+4>>2];l=H[b>>2];H[f+28>>2]=e;b=H[f+16>>2];if((((b|0)!=(k|0)?N(b-k>>2,341)-1|0:0)-(g+m|0)|0)+1>>>0>=682){oa(H[b-4>>2]);H[f+16>>2]=H[f+16>>2]-4}if(l>>>0>p>>>0){break A}b=H[i+12>>2];m=(d|0)!=(b-1|0)?d+1|0:0;if(m>>>0>=b>>>0){break A}b=H[i+120>>2];r=N(q,12);u=b+r|0;e=H[i>>2];x=m2]|0;d=H[x+H[n>>2]>>2];B:{C:{if((e|0)==(d|0)){x=0;if(!l){break C}while(1){b=H[u>>2];y=H[b+8>>2];n=H[b+4>>2];k=H[b>>2];q=H[A>>2];m=H[q+4>>2];b=H[q+8>>2];D:{if(m>>>0>>0){H[m+8>>2]=y;H[m+4>>2]=n;H[m>>2]=k;H[q+4>>2]=m+12;break D}r=H[q>>2];e=(m-r|0)/12|0;g=e+1|0;if(g>>>0>=357913942){break b}d=(b-r|0)/12|0;b=d>0>=178956970?357913941:b>>>0>g>>>0?b:g;if(g){if(g>>>0>=357913942){break a}b=pa(N(g,12))}else{b=0}o=b+N(e,12)|0;H[o+8>>2]=y;H[o+4>>2]=n;H[o>>2]=k;d=o+12|0;if((m|0)!=(r|0)){while(1){o=o-12|0;m=m-12|0;H[o>>2]=H[m>>2];H[o+4>>2]=H[m+4>>2];H[o+8>>2]=H[m+8>>2];if((m|0)!=(r|0)){continue}break}}H[q+8>>2]=b+N(g,12);H[q+4>>2]=d;H[q>>2]=o;if(!r){break D}oa(r)}H[i+8>>2]=H[i+8>>2]+1;x=x+1|0;if((l|0)!=(x|0)){continue}break}break C}E:{F:{G:{H:{if(l>>>0>2];H[b>>2]=m;o=1;t=H[i+12>>2];if(t>>>0>1){break H}break E}if(K[i+8>>2]>K[i+4>>2]){break A}k=b;b=r+12|0;Aa(k+b|0,H[u>>2],H[u+4>>2]);b=x+H[b+H[i+120>>2]>>2]|0;H[b>>2]=H[b>>2]+(12];e=32-k|0;I:{if((n|0)>2];if((e|0)==H[i+20>>2]){break G}d=H[e>>2];b=k+n|0;H[i+32>>2]=b;d=d>32-n|0;if((b|0)!=32){break I}H[i+32>>2]=0;H[i+28>>2]=e+4;break I}g=H[i+28>>2];b=g+4|0;if((b|0)==H[i+20>>2]){break G}d=H[g>>2];H[i+28>>2]=b;b=n-e|0;H[i+32>>2]=b;d=H[g+4>>2]>>>32-b|d>32-n}o=l>>>1|0;if(o>>>0>>0){break A}break F}while(1){m=(t-1|0)!=(m|0)?m+1|0:0;H[b+(o2]=m;o=o+1|0;t=H[i+12>>2];if(o>>>0>>0){continue}break}break E}o=l>>>1|0;d=0}y=q+1|0;J:{K:{e=o-d|0;d=l-e|0;L:{if((d|0)==(e|0)){b=e;break L}n=H[i+88>>2];if((n|0)==H[i+80>>2]){break K}k=H[n>>2];g=H[i+92>>2];b=g+1|0;H[i+92>>2]=b;g=k&-2147483648>>>g;M:{if((b|0)==32){H[i+92>>2]=0;H[i+88>>2]=n+4;if(g){break M}break K}if(!g){break K}}b=d}d=e;break J}b=e}n=H[i+132>>2];k=n+r|0;g=H[k>>2];e=g+x|0;H[e>>2]=H[e>>2]+1;Aa(n+N(y,12)|0,g,H[k+4>>2]);if(d){t=H[f+28>>2]+H[f+24>>2]|0;e=H[f+16>>2];o=H[f+12>>2];if((t|0)==(((e|0)!=(o|0)?N(e-o>>2,341)-1|0:0)|0)){xa(f+8|0);t=H[f+24>>2]+H[f+28>>2]|0;o=H[f+12>>2]}e=(t>>>0)/341|0;e=H[o+(e2]+N(t-N(e,341)|0,12)|0;H[e+8>>2]=q;H[e+4>>2]=m;H[e>>2]=d;H[f+28>>2]=H[f+28>>2]+1}if(!b){break C}t=H[f+28>>2]+H[f+24>>2]|0;d=H[f+16>>2];o=H[f+12>>2];if((t|0)==(((d|0)!=(o|0)?N(d-o>>2,341)-1|0:0)|0)){xa(f+8|0);t=H[f+24>>2]+H[f+28>>2]|0;o=H[f+12>>2]}d=(t>>>0)/341|0;d=H[o+(d2]+N(t-N(d,341)|0,12)|0;H[d+8>>2]=y;H[d+4>>2]=m;H[d>>2]=b;m=H[f+28>>2]+1|0;H[f+28>>2]=m;break B}t=0;if(!l){break C}while(1){if(H[i+12>>2]){o=H[i+40>>2];k=H[n>>2];z=H[i+96>>2];g=H[i+108>>2];m=0;while(1){q=g+(m2]2]=0;e=H[i>>2];d=H[q>>2]2];N:{if((e|0)==(b|0)){break N}r=d+z|0;w=e-b|0;x=H[i+52>>2];e=32-x|0;if((w|0)>2];if((d|0)==(o|0)){break A}H[r>>2]=H[d>>2]>32-w;b=w+H[i+52>>2]|0;H[i+52>>2]=b;if((b|0)!=32){break N}H[i+52>>2]=0;H[i+48>>2]=d+4;break N}y=H[i+48>>2];b=y+4|0;if((b|0)==(o|0)){break A}d=H[y>>2];H[i+48>>2]=b;b=w-e|0;H[i+52>>2]=b;H[r>>2]=H[y+4>>2]>>>32-b|d>32-w}d=H[q>>2]2]=H[b>>2]|H[d+H[u>>2]>>2];m=m+1|0;if(m>>>0>2]){continue}break}}jb(A,s);H[i+8>>2]=H[i+8>>2]+1;t=t+1|0;if((l|0)!=(t|0)){continue}break}}m=H[f+28>>2]}if(m){continue}break}}H[f+28>>2]=0;o=H[f+16>>2];m=H[f+12>>2];t=o-m|0;if(t>>>0>=9){while(1){oa(H[m>>2]);m=H[f+12>>2]+4|0;H[f+12>>2]=m;o=H[f+16>>2];t=o-m|0;if(t>>>0>8){continue}break}}b=170;O:{switch((t>>>2|0)-1|0){case 1:b=341;case 0:H[f+24>>2]=b;break;default:break O}}P:{if((m|0)==(o|0)){break P}while(1){oa(H[m>>2]);m=m+4|0;if((o|0)!=(m|0)){continue}break}d=H[f+16>>2];b=H[f+12>>2];if((d|0)==(b|0)){break P}H[f+16>>2]=d+((b-d|0)+3&-4)}b=H[f+8>>2];if(b){oa(b)}ca=f+32|0;break z}}xb(i);break d;case 2:f=ub(B+8|0,3);w=B+664|0;k=H[b+8>>2];n=H[b+12>>2];d=H[b+20>>2];e=H[b+16>>2];g=e+4|0;d=g>>>0>>0>k>>>0&(d|0)>=(n|0)|(d|0)>(n|0)){break Q}d=e+H[b>>2]|0;H[f>>2]=I[d|0]|I[d+1|0]>0>2]=e;H[b+20>>2]=d;if(K[f>>2]>32){break Q}n=H[b+8>>2];s=H[b+12>>2];d=k;g=g+8|0;d=g>>>0>>0>n>>>0&(d|0)>=(s|0)|(d|0)>(s|0)){break Q}d=e+H[b>>2]|0;e=I[d|0]|I[d+1|0]2]+4|0;g=d>>>0>2]=d;H[b+20>>2]=g;if(!e){break Q}H[f+8>>2]=0;if(!ta(f+16|0,b)){break Q}if(!ua(f+32|0,b)){break Q}if(!ua(f+52|0,b)){break Q}if(!ua(f+72|0,b)){break Q}z=H[f+4>>2];g=0;b=0;h=ca-32|0;ca=h;j=H[f+12>>2];H[h+16>>2]=0;H[h+8>>2]=0;H[h+12>>2]=0;if(j){if(j>>>0>=1073741824){break b}d=j2]=g;b=d+g|0;H[h+16>>2]=b;ra(g,0,d);H[h+12>>2]=b}e=H[f+116>>2];d=H[e>>2];if(d){H[e+4>>2]=d;oa(d);j=H[f+12>>2];g=H[h+8>>2];b=H[h+12>>2]}H[e+4>>2]=b;H[e>>2]=g;H[e+8>>2]=H[h+16>>2];g=0;H[h+16>>2]=0;H[h+8>>2]=0;H[h+12>>2]=0;R:{if(j){if(j>>>0>=1073741824){break b}b=j2]=u;g=b+u|0;H[h+16>>2]=g;ra(u,0,b);H[h+12>>2]=g}d=H[f+128>>2];b=H[d>>2];if(b){H[d+4>>2]=b;oa(b);u=H[h+8>>2];g=H[h+12>>2]}H[d+4>>2]=g;H[d>>2]=u;H[d+8>>2]=H[h+16>>2];H[h+24>>2]=0;H[h+28>>2]=0;H[h+16>>2]=0;H[h+20>>2]=0;H[h+8>>2]=0;H[h+12>>2]=0;xa(h+8|0);d=H[h+24>>2]+H[h+28>>2]|0;b=(d>>>0)/341|0;b=H[H[h+12>>2]+(b2]+N(d-N(b,341)|0,12)|0;H[b+4>>2]=0;H[b+8>>2]=0;H[b>>2]=z;j=H[h+28>>2]+1|0;H[h+28>>2]=j;S:{if(!j){break S}x=f+92|0;y=f+16|0;while(1){n=H[h+12>>2];g=H[h+24>>2];e=j-1|0;d=g+e|0;b=(d>>>0)/341|0;b=H[n+(b2]+N(d-N(b,341)|0,12)|0;p=H[b+8>>2];k=H[b+4>>2];i=H[b>>2];H[h+28>>2]=e;b=H[h+16>>2];if((((b|0)!=(n|0)?N(b-n>>2,341)-1|0:0)-(g+j|0)|0)+1>>>0>=682){oa(H[b-4>>2]);H[h+16>>2]=H[h+16>>2]-4}d=0;if(i>>>0>z>>>0){break S}b=H[f+12>>2];j=(k|0)!=(b-1|0)?k+1|0:0;if(j>>>0>=b>>>0){break S}o=N(p,12);A=o+H[f+128>>2]|0;t=o+H[f+116>>2]|0;g=H[f>>2];q=j2]>>2];T:{if((g|0)==(e|0)){if(!i){break T}while(1){b=H[t>>2];r=H[b+8>>2];s=H[b+4>>2];n=H[b>>2];o=H[w>>2];j=H[o+4>>2];b=H[o+8>>2];U:{if(j>>>0>>0){H[j+8>>2]=r;H[j+4>>2]=s;H[j>>2]=n;H[o+4>>2]=j+12;break U}q=H[o>>2];g=(j-q|0)/12|0;k=g+1|0;if(k>>>0>=357913942){break b}e=(b-q|0)/12|0;b=e>0>=178956970?357913941:b>>>0>k>>>0?b:k;if(k){if(k>>>0>=357913942){break a}b=pa(N(k,12))}else{b=0}u=b+N(g,12)|0;H[u+8>>2]=r;H[u+4>>2]=s;H[u>>2]=n;e=u+12|0;if((j|0)!=(q|0)){while(1){u=u-12|0;j=j-12|0;H[u>>2]=H[j>>2];H[u+4>>2]=H[j+4>>2];H[u+8>>2]=H[j+8>>2];if((j|0)!=(q|0)){continue}break}}H[o+8>>2]=b+N(k,12);H[o+4>>2]=e;H[o>>2]=u;if(!q){break U}oa(q)}H[f+8>>2]=H[f+8>>2]+1;d=d+1|0;if((i|0)!=(d|0)){continue}break}break T}V:{W:{X:{Y:{if(i>>>0>2];H[b>>2]=j;u=1;g=H[f+12>>2];if(g>>>0>1){break Y}break V}if(K[f+8>>2]>K[f+4>>2]){break S}b=H[f+116>>2];s=p+1|0;r=N(s,12);d=b+r|0;if((d|0)!=(t|0)){Aa(d,H[t>>2],H[t+4>>2]);b=H[f+116>>2]}b=q+H[b+r>>2]|0;H[b>>2]=H[b>>2]+(12]=0;pc(y,Q(i)^31,h+4|0);d=i>>>1|0;b=H[h+4>>2];if(d>>>0>>0){break S}e=d-b|0;d=i-e|0;Z:{if((d|0)==(e|0)){b=e;break Z}n=H[f+84>>2];if((n|0)==H[f+76>>2]){break X}k=H[n>>2];g=H[f+88>>2];b=g+1|0;H[f+88>>2]=b;g=k&-2147483648>>>g;_:{if((b|0)==32){H[f+88>>2]=0;H[f+84>>2]=n+4;if(g){break _}break X}if(!g){break X}}b=d}d=e;break W}while(1){j=(g-1|0)!=(j|0)?j+1|0:0;H[b+(u2]=j;g=H[f+12>>2];u=u+1|0;if(g>>>0>u>>>0){continue}break}break V}b=e}n=H[f+128>>2];k=n+o|0;g=H[k>>2];e=g+q|0;H[e>>2]=H[e>>2]+1;Aa(n+r|0,g,H[k+4>>2]);if(d){g=H[h+28>>2]+H[h+24>>2]|0;e=H[h+16>>2];u=H[h+12>>2];if((g|0)==(((e|0)!=(u|0)?N(e-u>>2,341)-1|0:0)|0)){xa(h+8|0);u=H[h+12>>2];g=H[h+24>>2]+H[h+28>>2]|0}e=(g>>>0)/341|0;e=H[(e2]+N(g-N(e,341)|0,12)|0;H[e+8>>2]=p;H[e+4>>2]=j;H[e>>2]=d;H[h+28>>2]=H[h+28>>2]+1}if(!b){break T}g=H[h+28>>2]+H[h+24>>2]|0;d=H[h+16>>2];u=H[h+12>>2];if((g|0)==(((d|0)!=(u|0)?N(d-u>>2,341)-1|0:0)|0)){xa(h+8|0);u=H[h+12>>2];g=H[h+24>>2]+H[h+28>>2]|0}d=(g>>>0)/341|0;d=H[(d2]+N(g-N(d,341)|0,12)|0;H[d+8>>2]=s;H[d+4>>2]=j;H[d>>2]=b;H[h+28>>2]=H[h+28>>2]+1;break T}if(!i){break T}while(1){if(H[f+12>>2]){p=H[f+36>>2];n=H[A>>2];u=H[f+92>>2];k=H[f+104>>2];j=0;while(1){o=k+(j2]2]=0;g=H[f>>2];e=H[o>>2]2];$:{if((g|0)==(b|0)){break $}q=e+u|0;l=g-b|0;r=H[f+48>>2];g=32-r|0;if((l|0)>2];if((e|0)==(p|0)){break S}H[q>>2]=H[e>>2]>32-l;b=l+H[f+48>>2]|0;H[f+48>>2]=b;if((b|0)!=32){break $}H[f+48>>2]=0;H[f+44>>2]=e+4;break $}s=H[f+44>>2];b=s+4|0;if((b|0)==(p|0)){break S}e=H[s>>2];H[f+44>>2]=b;b=l-g|0;H[f+48>>2]=b;H[q>>2]=H[s+4>>2]>>>32-b|e>32-l}e=H[o>>2]2]=H[b>>2]|H[e+H[t>>2]>>2];j=j+1|0;if(j>>>0>2]){continue}break}}jb(w,x);H[f+8>>2]=H[f+8>>2]+1;d=d+1|0;if((i|0)!=(d|0)){continue}break}}j=H[h+28>>2];if(j){continue}break}}H[h+28>>2]=0;u=H[h+16>>2];j=H[h+12>>2];g=u-j|0;if(g>>>0>=9){while(1){oa(H[j>>2]);j=H[h+12>>2]+4|0;H[h+12>>2]=j;u=H[h+16>>2];g=u-j|0;if(g>>>0>8){continue}break}}b=170;aa:{switch((g>>>2|0)-1|0){case 1:b=341;case 0:H[h+24>>2]=b;break;default:break aa}}ba:{if((j|0)==(u|0)){break ba}while(1){oa(H[j>>2]);j=j+4|0;if((u|0)!=(j|0)){continue}break}d=H[h+16>>2];b=H[h+12>>2];if((d|0)==(b|0)){break ba}H[h+16>>2]=d+((b-d|0)+3&-4)}b=H[h+8>>2];if(b){oa(b)}ca=h+32|0;break R}}vb(f);break d;case 3:i=ub(B+8|0,3);z=B+664|0;k=H[b+8>>2];n=H[b+12>>2];d=H[b+20>>2];e=H[b+16>>2];g=e+4|0;d=g>>>0>>0>k>>>0&(d|0)>=(n|0)|(d|0)>(n|0)){break ca}d=e+H[b>>2]|0;H[i>>2]=I[d|0]|I[d+1|0]>0>2]=e;H[b+20>>2]=d;if(K[i>>2]>32){break ca}n=H[b+8>>2];s=H[b+12>>2];d=k;g=g+8|0;d=g>>>0>>0>n>>>0&(d|0)>=(s|0)|(d|0)>(s|0)){break ca}d=e+H[b>>2]|0;e=I[d|0]|I[d+1|0]2]+4|0;g=d>>>0>2]=d;H[b+20>>2]=g;if(!e){break ca}H[i+8>>2]=0;if(!ta(i+16|0,b)){break ca}if(!ua(i+32|0,b)){break ca}if(!ua(i+52|0,b)){break ca}if(!ua(i+72|0,b)){break ca}A=H[i+4>>2];d=0;f=ca-32|0;ca=f;j=H[i+12>>2];H[f+16>>2]=0;H[f+8>>2]=0;H[f+12>>2]=0;if(j){if(j>>>0>=1073741824){break b}b=j2]=m;d=b+m|0;H[f+16>>2]=d;ra(m,0,b);H[f+12>>2]=d}e=H[i+116>>2];b=H[e>>2];if(b){H[e+4>>2]=b;oa(b);j=H[i+12>>2];m=H[f+8>>2];d=H[f+12>>2]}H[e+4>>2]=d;H[e>>2]=m;H[e+8>>2]=H[f+16>>2];m=0;H[f+16>>2]=0;H[f+8>>2]=0;H[f+12>>2]=0;da:{if(j){if(j>>>0>=1073741824){break b}b=j2]=p;m=b+p|0;H[f+16>>2]=m;ra(p,0,b);H[f+12>>2]=m}d=H[i+128>>2];b=H[d>>2];if(b){H[d+4>>2]=b;oa(b);m=H[f+12>>2];p=H[f+8>>2]}H[d+4>>2]=m;H[d>>2]=p;H[d+8>>2]=H[f+16>>2];H[f+24>>2]=0;H[f+28>>2]=0;H[f+16>>2]=0;H[f+20>>2]=0;H[f+8>>2]=0;H[f+12>>2]=0;xa(f+8|0);d=H[f+24>>2]+H[f+28>>2]|0;b=(d>>>0)/341|0;b=H[H[f+12>>2]+(b2]+N(d-N(b,341)|0,12)|0;H[b+4>>2]=0;H[b+8>>2]=0;H[b>>2]=A;j=H[f+28>>2]+1|0;H[f+28>>2]=j;ea:{if(!j){break ea}y=i+92|0;s=i+16|0;while(1){k=H[f+12>>2];g=H[f+24>>2];e=j-1|0;d=g+e|0;b=(d>>>0)/341|0;b=H[k+(b2]+N(d-N(b,341)|0,12)|0;o=H[b+8>>2];d=H[b+4>>2];t=H[b>>2];H[f+28>>2]=e;b=H[f+16>>2];if((((b|0)!=(k|0)?N(b-k>>2,341)-1|0:0)-(g+j|0)|0)+1>>>0>=682){oa(H[b-4>>2]);H[f+16>>2]=H[f+16>>2]-4}if(t>>>0>A>>>0){break ea}b=H[i+12>>2];j=(d|0)!=(b-1|0)?d+1|0:0;if(j>>>0>=b>>>0){break ea}b=H[i+116>>2];q=N(o,12);l=b+q|0;e=H[i>>2];r=j2]|0;d=H[r+H[n>>2]>>2];fa:{if((e|0)==(d|0)){r=0;if(!t){break fa}while(1){b=H[l>>2];x=H[b+8>>2];n=H[b+4>>2];k=H[b>>2];o=H[z>>2];j=H[o+4>>2];b=H[o+8>>2];ga:{if(j>>>0>>0){H[j+8>>2]=x;H[j+4>>2]=n;H[j>>2]=k;H[o+4>>2]=j+12;break ga}q=H[o>>2];e=(j-q|0)/12|0;g=e+1|0;if(g>>>0>=357913942){break b}d=(b-q|0)/12|0;b=d>0>=178956970?357913941:b>>>0>g>>>0?b:g;if(g){if(g>>>0>=357913942){break a}b=pa(N(g,12))}else{b=0}p=b+N(e,12)|0;H[p+8>>2]=x;H[p+4>>2]=n;H[p>>2]=k;d=p+12|0;if((j|0)!=(q|0)){while(1){p=p-12|0;j=j-12|0;H[p>>2]=H[j>>2];H[p+4>>2]=H[j+4>>2];H[p+8>>2]=H[j+8>>2];if((j|0)!=(q|0)){continue}break}}H[o+8>>2]=b+N(g,12);H[o+4>>2]=d;H[o>>2]=p;if(!q){break ga}oa(q)}H[i+8>>2]=H[i+8>>2]+1;r=r+1|0;if((t|0)!=(r|0)){continue}break}break fa}ha:{ia:{ja:{ka:{if(t>>>0>2];H[b>>2]=j;p=1;m=H[i+12>>2];if(m>>>0>1){break ka}break ha}if(K[i+8>>2]>K[i+4>>2]){break ea}k=b;b=q+12|0;Aa(k+b|0,H[l>>2],H[l+4>>2]);b=r+H[b+H[i+116>>2]>>2]|0;H[b>>2]=H[b>>2]+(12]=0;pc(s,Q(t)^31,f+4|0);d=t>>>1|0;b=H[f+4>>2];if(d>>>0>>0){break ea}x=o+1|0;e=d-b|0;d=t-e|0;la:{if((d|0)==(e|0)){b=e;break la}n=H[i+84>>2];if((n|0)==H[i+76>>2]){break ja}k=H[n>>2];g=H[i+88>>2];b=g+1|0;H[i+88>>2]=b;g=k&-2147483648>>>g;ma:{if((b|0)==32){H[i+88>>2]=0;H[i+84>>2]=n+4;if(g){break ma}break ja}if(!g){break ja}}b=d}d=e;break ia}while(1){j=(m-1|0)!=(j|0)?j+1|0:0;H[b+(p2]=j;m=H[i+12>>2];p=p+1|0;if(m>>>0>p>>>0){continue}break}break ha}b=e}n=H[i+128>>2];k=n+q|0;g=H[k>>2];e=g+r|0;H[e>>2]=H[e>>2]+1;Aa(n+N(x,12)|0,g,H[k+4>>2]);if(d){m=H[f+28>>2]+H[f+24>>2]|0;e=H[f+16>>2];p=H[f+12>>2];if((m|0)==(((e|0)!=(p|0)?N(e-p>>2,341)-1|0:0)|0)){xa(f+8|0);m=H[f+24>>2]+H[f+28>>2]|0;p=H[f+12>>2]}e=(m>>>0)/341|0;e=H[p+(e2]+N(m-N(e,341)|0,12)|0;H[e+8>>2]=o;H[e+4>>2]=j;H[e>>2]=d;H[f+28>>2]=H[f+28>>2]+1}if(!b){break fa}m=H[f+28>>2]+H[f+24>>2]|0;d=H[f+16>>2];p=H[f+12>>2];if((m|0)==(((d|0)!=(p|0)?N(d-p>>2,341)-1|0:0)|0)){xa(f+8|0);m=H[f+24>>2]+H[f+28>>2]|0;p=H[f+12>>2]}d=(m>>>0)/341|0;d=H[p+(d2]+N(m-N(d,341)|0,12)|0;H[d+8>>2]=x;H[d+4>>2]=j;H[d>>2]=b;H[f+28>>2]=H[f+28>>2]+1;break fa}m=0;if(!t){break fa}while(1){if(H[i+12>>2]){p=H[i+36>>2];k=H[n>>2];w=H[i+92>>2];g=H[i+104>>2];j=0;while(1){o=g+(j2]2]=0;e=H[i>>2];d=H[o>>2]2];na:{if((e|0)==(b|0)){break na}q=d+w|0;u=e-b|0;r=H[i+48>>2];e=32-r|0;if((u|0)>2];if((d|0)==(p|0)){break ea}H[q>>2]=H[d>>2]>32-u;b=u+H[i+48>>2]|0;H[i+48>>2]=b;if((b|0)!=32){break na}H[i+48>>2]=0;H[i+44>>2]=d+4;break na}x=H[i+44>>2];b=x+4|0;if((b|0)==(p|0)){break ea}d=H[x>>2];H[i+44>>2]=b;b=u-e|0;H[i+48>>2]=b;H[q>>2]=H[x+4>>2]>>>32-b|d>32-u}d=H[o>>2]2]=H[b>>2]|H[d+H[l>>2]>>2];j=j+1|0;if(j>>>0>2]){continue}break}}jb(z,y);H[i+8>>2]=H[i+8>>2]+1;m=m+1|0;if((t|0)!=(m|0)){continue}break}}j=H[f+28>>2];if(j){continue}break}}H[f+28>>2]=0;p=H[f+16>>2];j=H[f+12>>2];m=p-j|0;if(m>>>0>=9){while(1){oa(H[j>>2]);j=H[f+12>>2]+4|0;H[f+12>>2]=j;p=H[f+16>>2];m=p-j|0;if(m>>>0>8){continue}break}}b=170;oa:{switch((m>>>2|0)-1|0){case 1:b=341;case 0:H[f+24>>2]=b;break;default:break oa}}pa:{if((j|0)==(p|0)){break pa}while(1){oa(H[j>>2]);j=j+4|0;if((p|0)!=(j|0)){continue}break}d=H[f+16>>2];b=H[f+12>>2];if((d|0)==(b|0)){break pa}H[f+16>>2]=d+((b-d|0)+3&-4)}b=H[f+8>>2];if(b){oa(b)}ca=f+32|0;break da}}vb(i);break d;case 4:f=$a(B+8|0,3);w=B+664|0;k=H[b+8>>2];n=H[b+12>>2];d=H[b+20>>2];e=H[b+16>>2];g=e+4|0;d=g>>>0>>0>k>>>0&(d|0)>=(n|0)|(d|0)>(n|0)){break qa}d=e+H[b>>2]|0;H[f>>2]=I[d|0]|I[d+1|0]>0>2]=e;H[b+20>>2]=d;if(K[f>>2]>32){break qa}n=H[b+8>>2];s=H[b+12>>2];d=k;g=g+8|0;d=g>>>0>>0>n>>>0&(d|0)>=(s|0)|(d|0)>(s|0)){break qa}d=e+H[b>>2]|0;e=I[d|0]|I[d+1|0]2]+4|0;g=d>>>0>2]=d;H[b+20>>2]=g;if(!e){break qa}H[f+8>>2]=0;if(!sb(f+16|0,b)){break qa}if(!ua(f+544|0,b)){break qa}if(!ua(f+564|0,b)){break qa}if(!ua(f+584|0,b)){break qa}z=H[f+4>>2];l=0;b=0;h=ca-32|0;ca=h;d=H[f+12>>2];H[h+16>>2]=0;H[h+8>>2]=0;H[h+12>>2]=0;if(d){if(d>>>0>=1073741824){break b}e=d2]=l;b=e+l|0;H[h+16>>2]=b;ra(l,0,e);H[h+12>>2]=b}g=H[f+628>>2];e=H[g>>2];if(e){H[g+4>>2]=e;oa(e);d=H[f+12>>2];l=H[h+8>>2];b=H[h+12>>2]}H[g+4>>2]=b;H[g>>2]=l;H[g+8>>2]=H[h+16>>2];l=0;H[h+16>>2]=0;H[h+8>>2]=0;H[h+12>>2]=0;ra:{if(d){if(d>>>0>=1073741824){break b}b=d2]=j;l=b+j|0;H[h+16>>2]=l;ra(j,0,b);H[h+12>>2]=l}d=H[f+640>>2];b=H[d>>2];if(b){H[d+4>>2]=b;oa(b);j=H[h+8>>2];l=H[h+12>>2]}H[d+4>>2]=l;H[d>>2]=j;H[d+8>>2]=H[h+16>>2];H[h+24>>2]=0;H[h+28>>2]=0;H[h+16>>2]=0;H[h+20>>2]=0;H[h+8>>2]=0;H[h+12>>2]=0;xa(h+8|0);d=H[h+24>>2]+H[h+28>>2]|0;b=(d>>>0)/341|0;b=H[H[h+12>>2]+(b2]+N(d-N(b,341)|0,12)|0;H[b+4>>2]=0;H[b+8>>2]=0;H[b>>2]=z;d=H[h+28>>2]+1|0;H[h+28>>2]=d;sa:{if(!d){break sa}x=f+604|0;y=f+16|0;while(1){n=H[h+12>>2];k=H[h+24>>2];g=d-1|0;e=k+g|0;b=(e>>>0)/341|0;b=H[n+(b2]+N(e-N(b,341)|0,12)|0;p=H[b+8>>2];e=H[b+4>>2];i=H[b>>2];H[h+28>>2]=g;b=H[h+16>>2];if((((b|0)!=(n|0)?N(b-n>>2,341)-1|0:0)-(d+k|0)|0)+1>>>0>=682){oa(H[b-4>>2]);H[h+16>>2]=H[h+16>>2]-4}if(i>>>0>z>>>0){break sa}b=H[f+12>>2];j=(e|0)!=(b-1|0)?e+1|0:0;if(j>>>0>=b>>>0){break sa}o=N(p,12);A=o+H[f+640>>2]|0;t=o+H[f+628>>2]|0;g=H[f>>2];q=j2]>>2];ta:{ua:{if((g|0)==(e|0)){o=0;if(!i){break ua}while(1){b=H[t>>2];r=H[b+8>>2];s=H[b+4>>2];n=H[b>>2];p=H[w>>2];d=H[p+4>>2];b=H[p+8>>2];va:{if(d>>>0>>0){H[d+8>>2]=r;H[d+4>>2]=s;H[d>>2]=n;H[p+4>>2]=d+12;break va}q=H[p>>2];g=(d-q|0)/12|0;k=g+1|0;if(k>>>0>=357913942){break b}e=(b-q|0)/12|0;b=e>0>=178956970?357913941:b>>>0>k>>>0?b:k;if(k){if(k>>>0>=357913942){break a}b=pa(N(k,12))}else{b=0}j=b+N(g,12)|0;H[j+8>>2]=r;H[j+4>>2]=s;H[j>>2]=n;e=j+12|0;if((d|0)!=(q|0)){while(1){j=j-12|0;d=d-12|0;H[j>>2]=H[d>>2];H[j+4>>2]=H[d+4>>2];H[j+8>>2]=H[d+8>>2];if((d|0)!=(q|0)){continue}break}}H[p+8>>2]=b+N(k,12);H[p+4>>2]=e;H[p>>2]=j;if(!q){break va}oa(q)}H[f+8>>2]=H[f+8>>2]+1;o=o+1|0;if((i|0)!=(o|0)){continue}break}break ua}wa:{xa:{ya:{if(i>>>0>2];H[b>>2]=j;d=1;l=H[f+12>>2];if(l>>>0>1){break ya}break wa}if(K[f+8>>2]>K[f+4>>2]){break sa}b=H[f+628>>2];s=p+1|0;r=N(s,12);d=b+r|0;if((d|0)!=(t|0)){Aa(d,H[t>>2],H[t+4>>2]);b=H[f+628>>2]}b=q+H[b+r>>2]|0;H[b>>2]=H[b>>2]+(1>1|0;break xa}while(1){l=Ba(y+(d>>0>>0){break xa}break sa}while(1){j=(l-1|0)!=(j|0)?j+1|0:0;H[b+(d2]=j;d=d+1|0;l=H[f+12>>2];if(d>>>0>>0){continue}break}break wa}za:{Aa:{e=d-l|0;d=i-e|0;Ba:{if((d|0)==(e|0)){b=e;break Ba}n=H[f+596>>2];if((n|0)==H[f+588>>2]){break Aa}k=H[n>>2];g=H[f+600>>2];b=g+1|0;H[f+600>>2]=b;g=k&-2147483648>>>g;Ca:{if((b|0)==32){H[f+600>>2]=0;H[f+596>>2]=n+4;if(g){break Ca}break Aa}if(!g){break Aa}}b=d}d=e;break za}b=e}n=H[f+640>>2];k=n+o|0;g=H[k>>2];e=g+q|0;H[e>>2]=H[e>>2]+1;Aa(n+r|0,g,H[k+4>>2]);if(d){g=H[h+28>>2]+H[h+24>>2]|0;e=H[h+16>>2];l=H[h+12>>2];if((g|0)==(((e|0)!=(l|0)?N(e-l>>2,341)-1|0:0)|0)){xa(h+8|0);l=H[h+12>>2];g=H[h+24>>2]+H[h+28>>2]|0}e=(g>>>0)/341|0;e=H[(e2]+N(g-N(e,341)|0,12)|0;H[e+8>>2]=p;H[e+4>>2]=j;H[e>>2]=d;H[h+28>>2]=H[h+28>>2]+1}if(!b){break ua}l=H[h+28>>2]+H[h+24>>2]|0;e=H[h+16>>2];d=H[h+12>>2];if((l|0)==(((d|0)!=(e|0)?N(e-d>>2,341)-1|0:0)|0)){xa(h+8|0);l=H[h+24>>2]+H[h+28>>2]|0;e=H[h+12>>2]}else{e=d}d=(l>>>0)/341|0;d=H[e+(d2]+N(l-N(d,341)|0,12)|0;H[d+8>>2]=s;H[d+4>>2]=j;H[d>>2]=b;d=H[h+28>>2]+1|0;H[h+28>>2]=d;break ta}j=0;if(!i){break ua}while(1){if(H[f+12>>2]){p=H[f+548>>2];n=H[A>>2];u=H[f+604>>2];k=H[f+616>>2];d=0;while(1){o=k+(d2]2]=0;g=H[f>>2];e=H[o>>2]2];Da:{if((g|0)==(b|0)){break Da}q=e+u|0;l=g-b|0;r=H[f+560>>2];g=32-r|0;if((l|0)>2];if((e|0)==(p|0)){break sa}H[q>>2]=H[e>>2]>32-l;b=l+H[f+560>>2]|0;H[f+560>>2]=b;if((b|0)!=32){break Da}H[f+560>>2]=0;H[f+556>>2]=e+4;break Da}s=H[f+556>>2];b=s+4|0;if((b|0)==(p|0)){break sa}e=H[s>>2];H[f+556>>2]=b;b=l-g|0;H[f+560>>2]=b;H[q>>2]=H[s+4>>2]>>>32-b|e>32-l}e=H[o>>2]2]=H[b>>2]|H[e+H[t>>2]>>2];d=d+1|0;if(d>>>0>2]){continue}break}}jb(w,x);H[f+8>>2]=H[f+8>>2]+1;j=j+1|0;if((i|0)!=(j|0)){continue}break}}d=H[h+28>>2]}if(d){continue}break}}H[h+28>>2]=0;j=H[h+16>>2];d=H[h+12>>2];l=j-d|0;if(l>>>0>=9){while(1){oa(H[d>>2]);d=H[h+12>>2]+4|0;H[h+12>>2]=d;j=H[h+16>>2];l=j-d|0;if(l>>>0>8){continue}break}}b=170;Ea:{switch((l>>>2|0)-1|0){case 1:b=341;case 0:H[h+24>>2]=b;break;default:break Ea}}Fa:{if((d|0)==(j|0)){break Fa}while(1){oa(H[d>>2]);d=d+4|0;if((j|0)!=(d|0)){continue}break}d=H[h+16>>2];b=H[h+12>>2];if((d|0)==(b|0)){break Fa}H[h+16>>2]=d+((b-d|0)+3&-4)}b=H[h+8>>2];if(b){oa(b)}ca=h+32|0;break ra}}ab(f);break d;case 5:f=$a(B+8|0,3);w=B+664|0;k=H[b+8>>2];n=H[b+12>>2];d=H[b+20>>2];e=H[b+16>>2];g=e+4|0;d=g>>>0>>0>k>>>0&(d|0)>=(n|0)|(d|0)>(n|0)){break Ga}d=e+H[b>>2]|0;H[f>>2]=I[d|0]|I[d+1|0]>0>2]=e;H[b+20>>2]=d;if(K[f>>2]>32){break Ga}n=H[b+8>>2];s=H[b+12>>2];d=k;g=g+8|0;d=g>>>0>>0>n>>>0&(d|0)>=(s|0)|(d|0)>(s|0)){break Ga}d=e+H[b>>2]|0;e=I[d|0]|I[d+1|0]2]+4|0;g=d>>>0>2]=d;H[b+20>>2]=g;if(!e){break Ga}H[f+8>>2]=0;if(!sb(f+16|0,b)){break Ga}if(!ua(f+544|0,b)){break Ga}if(!ua(f+564|0,b)){break Ga}if(!ua(f+584|0,b)){break Ga}z=H[f+4>>2];l=0;b=0;h=ca-32|0;ca=h;d=H[f+12>>2];H[h+16>>2]=0;H[h+8>>2]=0;H[h+12>>2]=0;if(d){if(d>>>0>=1073741824){break b}e=d2]=l;b=e+l|0;H[h+16>>2]=b;ra(l,0,e);H[h+12>>2]=b}g=H[f+628>>2];e=H[g>>2];if(e){H[g+4>>2]=e;oa(e);d=H[f+12>>2];l=H[h+8>>2];b=H[h+12>>2]}H[g+4>>2]=b;H[g>>2]=l;H[g+8>>2]=H[h+16>>2];l=0;H[h+16>>2]=0;H[h+8>>2]=0;H[h+12>>2]=0;Ha:{if(d){if(d>>>0>=1073741824){break b}b=d2]=p;l=b+p|0;H[h+16>>2]=l;ra(p,0,b);H[h+12>>2]=l}d=H[f+640>>2];b=H[d>>2];if(b){H[d+4>>2]=b;oa(b);l=H[h+12>>2];p=H[h+8>>2]}H[d+4>>2]=l;H[d>>2]=p;H[d+8>>2]=H[h+16>>2];H[h+24>>2]=0;H[h+28>>2]=0;H[h+16>>2]=0;H[h+20>>2]=0;H[h+8>>2]=0;H[h+12>>2]=0;xa(h+8|0);d=H[h+24>>2]+H[h+28>>2]|0;b=(d>>>0)/341|0;b=H[H[h+12>>2]+(b2]+N(d-N(b,341)|0,12)|0;H[b+4>>2]=0;H[b+8>>2]=0;H[b>>2]=z;d=H[h+28>>2]+1|0;H[h+28>>2]=d;Ia:{if(!d){break Ia}x=f+604|0;y=f+16|0;while(1){n=H[h+12>>2];k=H[h+24>>2];g=d-1|0;e=k+g|0;b=(e>>>0)/341|0;b=H[n+(b2]+N(e-N(b,341)|0,12)|0;o=H[b+8>>2];e=H[b+4>>2];i=H[b>>2];H[h+28>>2]=g;b=H[h+16>>2];if((((b|0)!=(n|0)?N(b-n>>2,341)-1|0:0)-(d+k|0)|0)+1>>>0>=682){oa(H[b-4>>2]);H[h+16>>2]=H[h+16>>2]-4}if(i>>>0>z>>>0){break Ia}m=0;b=H[f+12>>2];p=(e|0)!=(b-1|0)?e+1|0:0;if(p>>>0>=b>>>0){break Ia}b=H[f+628>>2];q=N(o,12);t=b+q|0;e=H[f>>2];r=p2]|0;d=H[r+H[s>>2]>>2];Ja:{Ka:{if((e|0)==(d|0)){if(!i){break Ka}while(1){b=H[t>>2];r=H[b+8>>2];s=H[b+4>>2];n=H[b>>2];o=H[w>>2];d=H[o+4>>2];b=H[o+8>>2];La:{if(d>>>0>>0){H[d+8>>2]=r;H[d+4>>2]=s;H[d>>2]=n;H[o+4>>2]=d+12;break La}q=H[o>>2];g=(d-q|0)/12|0;k=g+1|0;if(k>>>0>=357913942){break b}e=(b-q|0)/12|0;b=e>0>=178956970?357913941:b>>>0>k>>>0?b:k;if(k){if(k>>>0>=357913942){break a}b=pa(N(k,12))}else{b=0}p=b+N(g,12)|0;H[p+8>>2]=r;H[p+4>>2]=s;H[p>>2]=n;e=p+12|0;if((d|0)!=(q|0)){while(1){p=p-12|0;d=d-12|0;H[p>>2]=H[d>>2];H[p+4>>2]=H[d+4>>2];H[p+8>>2]=H[d+8>>2];if((d|0)!=(q|0)){continue}break}}H[o+8>>2]=b+N(k,12);H[o+4>>2]=e;H[o>>2]=p;if(!q){break La}oa(q)}H[f+8>>2]=H[f+8>>2]+1;m=m+1|0;if((i|0)!=(m|0)){continue}break}break Ka}Ma:{Na:{Oa:{if(i>>>0>2];H[b>>2]=p;d=1;l=H[f+12>>2];if(l>>>0>1){break Oa}break Ma}if(K[f+8>>2]>K[f+4>>2]){break Ia}k=b;b=q+12|0;Aa(k+b|0,H[t>>2],H[t+4>>2]);b=r+H[b+H[f+628>>2]>>2]|0;H[b>>2]=H[b>>2]+(1>1|0;break Na}while(1){l=Ba(y+(d>>0>>0){break Na}break Ia}while(1){p=(l-1|0)!=(p|0)?p+1|0:0;H[b+(d2]=p;d=d+1|0;l=H[f+12>>2];if(d>>>0>>0){continue}break}break Ma}s=o+1|0;Pa:{Qa:{e=d-l|0;d=i-e|0;Ra:{if((d|0)==(e|0)){b=e;break Ra}n=H[f+596>>2];if((n|0)==H[f+588>>2]){break Qa}k=H[n>>2];g=H[f+600>>2];b=g+1|0;H[f+600>>2]=b;g=k&-2147483648>>>g;Sa:{if((b|0)==32){H[f+600>>2]=0;H[f+596>>2]=n+4;if(g){break Sa}break Qa}if(!g){break Qa}}b=d}d=e;break Pa}b=e}n=H[f+640>>2];k=n+q|0;g=H[k>>2];e=g+r|0;H[e>>2]=H[e>>2]+1;Aa(n+N(s,12)|0,g,H[k+4>>2]);if(d){m=H[h+28>>2]+H[h+24>>2]|0;e=H[h+16>>2];l=H[h+12>>2];if((m|0)==(((e|0)!=(l|0)?N(e-l>>2,341)-1|0:0)|0)){xa(h+8|0);m=H[h+24>>2]+H[h+28>>2]|0;l=H[h+12>>2]}e=(m>>>0)/341|0;e=H[l+(e2]+N(m-N(e,341)|0,12)|0;H[e+8>>2]=o;H[e+4>>2]=p;H[e>>2]=d;H[h+28>>2]=H[h+28>>2]+1}if(!b){break Ka}l=H[h+28>>2]+H[h+24>>2]|0;e=H[h+16>>2];d=H[h+12>>2];if((l|0)==(((d|0)!=(e|0)?N(e-d>>2,341)-1|0:0)|0)){xa(h+8|0);l=H[h+24>>2]+H[h+28>>2]|0;e=H[h+12>>2]}else{e=d}d=(l>>>0)/341|0;d=H[e+(d2]+N(l-N(d,341)|0,12)|0;H[d+8>>2]=s;H[d+4>>2]=p;H[d>>2]=b;d=H[h+28>>2]+1|0;H[h+28>>2]=d;break Ja}if(!i){break Ka}while(1){if(H[f+12>>2]){A=H[f+548>>2];n=H[s>>2];u=H[f+604>>2];k=H[f+616>>2];d=0;while(1){p=k+(d2]2]=0;g=H[f>>2];e=H[p>>2]2];Ta:{if((g|0)==(b|0)){break Ta}o=e+u|0;l=g-b|0;q=H[f+560>>2];g=32-q|0;if((l|0)>2];if((e|0)==(A|0)){break Ia}H[o>>2]=H[e>>2]>32-l;b=l+H[f+560>>2]|0;H[f+560>>2]=b;if((b|0)!=32){break Ta}H[f+560>>2]=0;H[f+556>>2]=e+4;break Ta}r=H[f+556>>2];b=r+4|0;if((b|0)==(A|0)){break Ia}e=H[r>>2];H[f+556>>2]=b;b=l-g|0;H[f+560>>2]=b;H[o>>2]=H[r+4>>2]>>>32-b|e>32-l}e=H[p>>2]2]=H[b>>2]|H[e+H[t>>2]>>2];d=d+1|0;if(d>>>0>2]){continue}break}}jb(w,x);H[f+8>>2]=H[f+8>>2]+1;m=m+1|0;if((i|0)!=(m|0)){continue}break}}d=H[h+28>>2]}if(d){continue}break}}H[h+28>>2]=0;p=H[h+16>>2];d=H[h+12>>2];l=p-d|0;if(l>>>0>=9){while(1){oa(H[d>>2]);d=H[h+12>>2]+4|0;H[h+12>>2]=d;p=H[h+16>>2];l=p-d|0;if(l>>>0>8){continue}break}}b=170;Ua:{switch((l>>>2|0)-1|0){case 1:b=341;case 0:H[h+24>>2]=b;break;default:break Ua}}Va:{if((d|0)==(p|0)){break Va}while(1){oa(H[d>>2]);d=d+4|0;if((p|0)!=(d|0)){continue}break}d=H[h+16>>2];b=H[h+12>>2];if((d|0)==(b|0)){break Va}H[h+16>>2]=d+((b-d|0)+3&-4)}b=H[h+8>>2];if(b){oa(b)}ca=h+32|0;break Ha}}ab(f);break d;case 6:break f;default:break c}}f=$a(B+8|0,3);w=B+664|0;k=H[b+8>>2];n=H[b+12>>2];d=H[b+20>>2];e=H[b+16>>2];g=e+4|0;d=g>>>0>>0>k>>>0&(d|0)>=(n|0)|(d|0)>(n|0)){break Wa}d=e+H[b>>2]|0;H[f>>2]=I[d|0]|I[d+1|0]>0>2]=e;H[b+20>>2]=d;if(K[f>>2]>32){break Wa}n=H[b+8>>2];s=H[b+12>>2];d=k;g=g+8|0;d=g>>>0>>0>n>>>0&(d|0)>=(s|0)|(d|0)>(s|0)){break Wa}d=e+H[b>>2]|0;e=I[d|0]|I[d+1|0]2]+4|0;g=d>>>0>2]=d;H[b+20>>2]=g;if(!e){break Wa}H[f+8>>2]=0;if(!sb(f+16|0,b)){break Wa}if(!ua(f+544|0,b)){break Wa}if(!ua(f+564|0,b)){break Wa}if(!ua(f+584|0,b)){break Wa}z=H[f+4>>2];l=0;b=0;h=ca-32|0;ca=h;d=H[f+12>>2];H[h+16>>2]=0;H[h+8>>2]=0;H[h+12>>2]=0;if(d){if(d>>>0>=1073741824){break b}e=d2]=l;b=e+l|0;H[h+16>>2]=b;ra(l,0,e);H[h+12>>2]=b}g=H[f+628>>2];e=H[g>>2];if(e){H[g+4>>2]=e;oa(e);d=H[f+12>>2];l=H[h+8>>2];b=H[h+12>>2]}H[g+4>>2]=b;H[g>>2]=l;H[g+8>>2]=H[h+16>>2];l=0;H[h+16>>2]=0;H[h+8>>2]=0;H[h+12>>2]=0;Xa:{if(d){if(d>>>0>=1073741824){break b}b=d2]=j;l=b+j|0;H[h+16>>2]=l;ra(j,0,b);H[h+12>>2]=l}d=H[f+640>>2];b=H[d>>2];if(b){H[d+4>>2]=b;oa(b);j=H[h+8>>2];l=H[h+12>>2]}H[d+4>>2]=l;H[d>>2]=j;H[d+8>>2]=H[h+16>>2];H[h+24>>2]=0;H[h+28>>2]=0;H[h+16>>2]=0;H[h+20>>2]=0;H[h+8>>2]=0;H[h+12>>2]=0;xa(h+8|0);d=H[h+24>>2]+H[h+28>>2]|0;b=(d>>>0)/341|0;b=H[H[h+12>>2]+(b2]+N(d-N(b,341)|0,12)|0;H[b+4>>2]=0;H[b+8>>2]=0;H[b>>2]=z;d=H[h+28>>2]+1|0;H[h+28>>2]=d;Ya:{if(!d){break Ya}x=f+604|0;y=f+16|0;while(1){n=H[h+12>>2];k=H[h+24>>2];g=d-1|0;e=k+g|0;b=(e>>>0)/341|0;b=H[n+(b2]+N(e-N(b,341)|0,12)|0;p=H[b+8>>2];i=H[b>>2];H[h+28>>2]=g;b=H[h+16>>2];if((((b|0)!=(n|0)?N(b-n>>2,341)-1|0:0)-(d+k|0)|0)+1>>>0>=682){oa(H[b-4>>2]);H[h+16>>2]=H[h+16>>2]-4}if(i>>>0>z>>>0){break Ya}b=H[f+628>>2];o=N(p,12);A=o+H[f+640>>2]|0;j=Vd(f,i,A);if(j>>>0>=K[f+12>>2]){break Ya}t=b+o|0;g=H[f>>2];q=j2]>>2];Za:{_a:{if((g|0)==(e|0)){o=0;if(!i){break _a}while(1){b=H[t>>2];r=H[b+8>>2];s=H[b+4>>2];n=H[b>>2];p=H[w>>2];d=H[p+4>>2];b=H[p+8>>2];$a:{if(d>>>0>>0){H[d+8>>2]=r;H[d+4>>2]=s;H[d>>2]=n;H[p+4>>2]=d+12;break $a}q=H[p>>2];g=(d-q|0)/12|0;k=g+1|0;if(k>>>0>=357913942){break b}e=(b-q|0)/12|0;b=e>0>=178956970?357913941:b>>>0>k>>>0?b:k;if(k){if(k>>>0>=357913942){break a}b=pa(N(k,12))}else{b=0}j=b+N(g,12)|0;H[j+8>>2]=r;H[j+4>>2]=s;H[j>>2]=n;e=j+12|0;if((d|0)!=(q|0)){while(1){j=j-12|0;d=d-12|0;H[j>>2]=H[d>>2];H[j+4>>2]=H[d+4>>2];H[j+8>>2]=H[d+8>>2];if((d|0)!=(q|0)){continue}break}}H[p+8>>2]=b+N(k,12);H[p+4>>2]=e;H[p>>2]=j;if(!q){break $a}oa(q)}H[f+8>>2]=H[f+8>>2]+1;o=o+1|0;if((i|0)!=(o|0)){continue}break}break _a}ab:{bb:{cb:{if(i>>>0>2];H[b>>2]=j;d=1;l=H[f+12>>2];if(l>>>0>1){break cb}break ab}if(K[f+8>>2]>K[f+4>>2]){break Ya}b=H[f+628>>2];s=p+1|0;r=N(s,12);d=b+r|0;if((d|0)!=(t|0)){Aa(d,H[t>>2],H[t+4>>2]);b=H[f+628>>2]}b=q+H[b+r>>2]|0;H[b>>2]=H[b>>2]+(1>1|0;break bb}while(1){l=Ba(y+(d>>0>>0){break bb}break Ya}while(1){j=(l-1|0)!=(j|0)?j+1|0:0;H[b+(d2]=j;d=d+1|0;l=H[f+12>>2];if(d>>>0>>0){continue}break}break ab}db:{eb:{e=d-l|0;d=i-e|0;fb:{if((d|0)==(e|0)){b=e;break fb}n=H[f+596>>2];if((n|0)==H[f+588>>2]){break eb}k=H[n>>2];g=H[f+600>>2];b=g+1|0;H[f+600>>2]=b;g=k&-2147483648>>>g;gb:{if((b|0)==32){H[f+600>>2]=0;H[f+596>>2]=n+4;if(g){break gb}break eb}if(!g){break eb}}b=d}d=e;break db}b=e}n=H[f+640>>2];k=n+o|0;g=H[k>>2];e=g+q|0;H[e>>2]=H[e>>2]+1;Aa(n+r|0,g,H[k+4>>2]);if(d){g=H[h+28>>2]+H[h+24>>2]|0;e=H[h+16>>2];l=H[h+12>>2];if((g|0)==(((e|0)!=(l|0)?N(e-l>>2,341)-1|0:0)|0)){xa(h+8|0);l=H[h+12>>2];g=H[h+24>>2]+H[h+28>>2]|0}e=(g>>>0)/341|0;e=H[(e2]+N(g-N(e,341)|0,12)|0;H[e+8>>2]=p;H[e+4>>2]=j;H[e>>2]=d;H[h+28>>2]=H[h+28>>2]+1}if(!b){break _a}l=H[h+28>>2]+H[h+24>>2]|0;e=H[h+16>>2];d=H[h+12>>2];if((l|0)==(((d|0)!=(e|0)?N(e-d>>2,341)-1|0:0)|0)){xa(h+8|0);l=H[h+24>>2]+H[h+28>>2]|0;e=H[h+12>>2]}else{e=d}d=(l>>>0)/341|0;d=H[e+(d2]+N(l-N(d,341)|0,12)|0;H[d+8>>2]=s;H[d+4>>2]=j;H[d>>2]=b;d=H[h+28>>2]+1|0;H[h+28>>2]=d;break Za}j=0;if(!i){break _a}while(1){if(H[f+12>>2]){p=H[f+548>>2];n=H[A>>2];u=H[f+604>>2];k=H[f+616>>2];d=0;while(1){o=k+(d2]2]=0;g=H[f>>2];e=H[o>>2]2];hb:{if((g|0)==(b|0)){break hb}q=e+u|0;l=g-b|0;r=H[f+560>>2];g=32-r|0;if((l|0)>2];if((e|0)==(p|0)){break Ya}H[q>>2]=H[e>>2]>32-l;b=l+H[f+560>>2]|0;H[f+560>>2]=b;if((b|0)!=32){break hb}H[f+560>>2]=0;H[f+556>>2]=e+4;break hb}s=H[f+556>>2];b=s+4|0;if((b|0)==(p|0)){break Ya}e=H[s>>2];H[f+556>>2]=b;b=l-g|0;H[f+560>>2]=b;H[q>>2]=H[s+4>>2]>>>32-b|e>32-l}e=H[o>>2]2]=H[b>>2]|H[e+H[t>>2]>>2];d=d+1|0;if(d>>>0>2]){continue}break}}jb(w,x);H[f+8>>2]=H[f+8>>2]+1;j=j+1|0;if((i|0)!=(j|0)){continue}break}}d=H[h+28>>2]}if(d){continue}break}}H[h+28>>2]=0;j=H[h+16>>2];d=H[h+12>>2];l=j-d|0;if(l>>>0>=9){while(1){oa(H[d>>2]);d=H[h+12>>2]+4|0;H[h+12>>2]=d;j=H[h+16>>2];l=j-d|0;if(l>>>0>8){continue}break}}b=170;ib:{switch((l>>>2|0)-1|0){case 1:b=341;case 0:H[h+24>>2]=b;break;default:break ib}}jb:{if((d|0)==(j|0)){break jb}while(1){oa(H[d>>2]);d=d+4|0;if((j|0)!=(d|0)){continue}break}d=H[h+16>>2];b=H[h+12>>2];if((d|0)==(b|0)){break jb}H[h+16>>2]=d+((b-d|0)+3&-4)}b=H[h+8>>2];if(b){oa(b)}ca=h+32|0;break Xa}}ab(f)}n=H[a+12>>2]==((H[c+4>>2]-H[c>>2]|0)/12|0)}ca=B+672|0;return n}sa();v()}wa();v()}function kd(a,b,c,d){var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0;if(!a){return 1}e=H[c+20>>2];g=H[c+12>>2];i=H[c+16>>2];a:{if((e|0)>=(g|0)&i>>>0>=K[c+8>>2]|(e|0)>(g|0)){break a}g=I[i+H[c>>2]|0];i=i+1|0;e=i?e:e+1|0;H[c+16>>2]=i;H[c+20>>2]=e;b:{switch(g|0){case 0:e=a;f=b;i=d;a=0;d=0;m=ca+-64|0;ca=m;H[m+56>>2]=0;H[m+48>>2]=0;H[m+52>>2]=0;H[m+40>>2]=0;H[m+44>>2]=0;H[m+32>>2]=0;H[m+36>>2]=0;H[m+24>>2]=0;H[m+28>>2]=0;H[m+16>>2]=0;H[m+20>>2]=0;H[m+8>>2]=0;H[m+12>>2]=0;c:{if(!Ne(m+8|0,c)){break c}if(!Me(m+8|0,c)|(H[m+20>>2]?0:e)){break c}Db(c,0,0);if(e){s=f2];w=H[m+48>>2];x=H[m+24>>2];l=H[m+56>>2];j=H[m+52>>2];while(1){d:{if(l>>>0>16383){break d}while(1){if((j|0)>2]=j;l=I[j+w|0]|l2]=l;if(l>>>0>>12|0)+a|0)-H[b+4>>2]|0;H[m+56>>2]=l;if((f|0)>0){a=0;if(!I[c+36|0]|r>>>0>32){break c}g=d+f|0;e:{if(!r){ra(i+(d2];h=H[c+28>>2];n=H[c+24>>2];while(1){k=0;a=b;o=0;q=0;if((r|0)!=1){while(1){p=n+(a>>>3|0)|0;f:{if(p>>>0>=h>>>0){p=0;break f}p=I[p|0];b=a+1|0;H[c+32>>2]=b;p=p>>>(a&7)&1;a=b}p=p>3|0)|0;if(u>>>0>>0){o=I[u|0];b=a+1|0;H[c+32>>2]=b;o=o>>>(a&7)&1;a=b}u=k|1;k=k+2|0;o=p|o>>0>>0){p=I[p|0];b=a+1|0;H[c+32>>2]=b;a=p>>>(a&7)&1}else{a=0}o=a2]=o;d=d+1|0;if((g|0)!=(d|0)){continue}break}}d=g}v=f+v|0;if(e>>>0>v>>>0){continue}break}}F[c+36|0]=0;b=H[c+20>>2];e=0;d=H[c+32>>2]+7|0;e=d>>>03;a=d+H[c+16>>2]|0;e=(e>>>3|0)+b|0;H[c+16>>2]=a;H[c+20>>2]=a>>>0>>0?e+1|0:e;a=1}b=H[m+36>>2];if(b){H[m+40>>2]=b;oa(b)}b=H[m+24>>2];if(b){H[m+28>>2]=b;oa(b)}b=H[m+8>>2];if(b){H[m+12>>2]=b;oa(b)}ca=m- -64|0;return a;case 1:break b;default:break a}}b=0;e=H[c+20>>2];g=H[c+12>>2];i=H[c+16>>2];g:{if((e|0)>=(g|0)&i>>>0>=K[c+8>>2]|(e|0)>(g|0)){break g}g=I[i+H[c>>2]|0];i=i+1|0;e=i?e:e+1|0;H[c+16>>2]=i;H[c+20>>2]=e;h:{switch(g-1|0){case 8:g=a;r=d;i=ca+-64|0;ca=i;H[i+56>>2]=0;H[i+48>>2]=0;H[i+52>>2]=0;H[i+40>>2]=0;H[i+44>>2]=0;H[i+32>>2]=0;H[i+36>>2]=0;H[i+24>>2]=0;H[i+28>>2]=0;H[i+16>>2]=0;H[i+20>>2]=0;H[i+8>>2]=0;H[i+12>>2]=0;j=i+8|0;a=J[c+38>>1];i:{j:{if(!a){break j}k:{if(a>>>0>2];b=H[c+12>>2];e=H[c+20>>2];a=H[c+16>>2];f=a+4|0;e=f>>>0>>0>>0&(b|0)2]|0;h=I[a|0]|I[a+1|0]2]+4|0;e=f>>>0>2]=f;H[c+20>>2]=e;break k}if(!hb(1,j+12|0,c)){break j}f=H[c+16>>2];e=H[c+20>>2];h=H[j+12>>2]}a=H[c+8>>2];d=a-f|0;a=H[c+12>>2]-((a>>>0>>0)+e|0)|0;if(d>>>0>>6>>>0&(a|0)2];a=H[j+4>>2]-b>>2;l:{if(a>>>0>>0){ya(j,h-a|0);h=H[j+12>>2];break l}if(a>>>0>>0){break l}H[j+4>>2]=b+(h2];e=H[c+20>>2];s=H[j>>2];m=H[c+8>>2];n=H[c+12>>2];b=0;while(1){d=0;if((e|0)>=(n|0)&f>>>0>=m>>>0|(e|0)>(n|0)){break i}d=H[c>>2];p=I[d+f|0];f=f+1|0;e=f?e:e+1|0;H[c+16>>2]=f;H[c+20>>2]=e;a=p>>>2|0;l=0;m:{n:{o:{p:{t=p&3;switch(t|0){case 0:break n;case 3:break p;default:break o}}a=a+b|0;d=0;if(a>>>0>=h>>>0){break i}ra(s+(b2]=f;H[c+20>>2]=e;a=h>0>>0){continue}break}a=j+16|0;n=H[j>>2];d=H[j+16>>2];b=H[j+20>>2]-d|0;q:{if(b>>>0>>2|0)|0);break q}if((b|0)==32768){break q}H[j+20>>2]=d+32768}d=j+28|0;b=H[d>>2];f=H[j+32>>2]-b>>3;r:{if(f>>>0>>0){ob(d,h-f|0);b=H[d>>2];break r}if(f>>>0>h>>>0){H[j+32>>2]=(h2];f=0;d=0;while(1){e=n+(f2];l=(f2]=a;H[l>>2]=j;e=H[e>>2];d=e+a|0;if(d>>>0>8192){break j}s:{if(a>>>0>=d>>>0){break s}l=0;j=e&7;if(j){while(1){H[m+(a2]=f;a=a+1|0;l=l+1|0;if((j|0)!=(l|0)){continue}break}}if(e-1>>>0>2]=f;H[e+24>>2]=f;H[e+20>>2]=f;H[e+16>>2]=f;H[e+12>>2]=f;H[e+8>>2]=f;H[e+4>>2]=f;a=a+8|0;if((d|0)!=(a|0)){continue}break}}f=f+1|0;if((h|0)!=(f|0)){continue}break}k=(d|0)==8192}d=k}t:{if(!d|(H[i+20>>2]?0:g)){break t}d=0;m=ca-16|0;ca=m;u:{v:{if(J[c+38>>1]>2];a=H[c+12>>2];h=a;e=H[c+20>>2];k=H[c+16>>2];f=k+8|0;e=f>>>0>>0>>0&(a|0)2]|0;a=I[k|0]|I[k+1|0]2];a=H[m+8>>2];k=H[m+12>>2]}j=b-f|0;b=h-((b>>>0>>0)+e|0)|0;if((b|0)==(k|0)&a>>>0>j>>>0|b>>>0>>0){break u}e=e+k|0;b=a+f|0;e=b>>>0>>0?e+1|0:e;H[c+16>>2]=b;H[c+20>>2]=e;if((a|0)>2]+f|0;H[i+48>>2]=b;c=a-1|0;f=c+b|0;e=I[f|0];w:{if(e>>>0>2]=c;a=I[f|0]&63;break w}x:{switch((e>>>6|0)-1|0){case 0:if(a>>>0>2]=a;a=a+b|0;a=I[a+1|0]>0>2]=a;a=a+b|0;a=I[a+1|0]2];c=H[i+36>>2];d=H[i+48>>2];f=H[i+24>>2];while(1){y:{if(a>>>0>32767){break y}while(1){if((b|0)>2]=b;a=I[b+d|0]|a2]=a;if(a>>>0>>13|0)+e|0)-H[k+4>>2]|0;H[i+56>>2]=a;H[r+(q2]=o;o=1;q=q+1|0;if((g|0)!=(q|0)){continue}break}}a=H[i+36>>2];if(a){H[i+40>>2]=a;oa(a)}a=H[i+24>>2];if(a){H[i+28>>2]=a;oa(a)}a=H[i+8>>2];if(a){H[i+12>>2]=a;oa(a)}ca=i- -64|0;b=o;break g;case 9:m=a;r=d;g=ca+-64|0;ca=g;H[g+56>>2]=0;H[g+48>>2]=0;H[g+52>>2]=0;H[g+40>>2]=0;H[g+44>>2]=0;H[g+32>>2]=0;H[g+36>>2]=0;H[g+24>>2]=0;H[g+28>>2]=0;H[g+16>>2]=0;H[g+20>>2]=0;H[g+8>>2]=0;H[g+12>>2]=0;j=g+8|0;a=J[c+38>>1];z:{A:{if(!a){break A}B:{if(a>>>0>2];b=H[c+12>>2];e=H[c+20>>2];a=H[c+16>>2];f=a+4|0;e=f>>>0>>0>>0&(b|0)2]|0;h=I[a|0]|I[a+1|0]2]+4|0;e=f>>>0>2]=f;H[c+20>>2]=e;break B}if(!hb(1,j+12|0,c)){break A}f=H[c+16>>2];e=H[c+20>>2];h=H[j+12>>2]}a=H[c+8>>2];d=a-f|0;a=H[c+12>>2]-((a>>>0>>0)+e|0)|0;if(d>>>0>>6>>>0&(a|0)2];a=H[j+4>>2]-b>>2;C:{if(a>>>0>>0){ya(j,h-a|0);h=H[j+12>>2];break C}if(a>>>0>>0){break C}H[j+4>>2]=b+(h2];e=H[c+20>>2];s=H[j>>2];i=H[c+8>>2];n=H[c+12>>2];b=0;while(1){d=0;if((e|0)>=(n|0)&f>>>0>=i>>>0|(e|0)>(n|0)){break z}d=H[c>>2];p=I[d+f|0];f=f+1|0;e=f?e:e+1|0;H[c+16>>2]=f;H[c+20>>2]=e;a=p>>>2|0;l=0;D:{E:{F:{G:{t=p&3;switch(t|0){case 0:break E;case 3:break G;default:break F}}a=a+b|0;d=0;if(a>>>0>=h>>>0){break z}ra(s+(b2]=f;H[c+20>>2]=e;a=h>0>>0){continue}break}a=j+16|0;n=H[j>>2];d=H[j+16>>2];b=H[j+20>>2]-d|0;H:{if(b>>>0>>2|0)|0);break H}if((b|0)==131072){break H}H[j+20>>2]=d+131072}d=j+28|0;b=H[d>>2];f=H[j+32>>2]-b>>3;I:{if(f>>>0>>0){ob(d,h-f|0);b=H[d>>2];break I}if(f>>>0>h>>>0){H[j+32>>2]=(h2];f=0;d=0;while(1){e=n+(f2];l=(f2]=a;H[l>>2]=j;e=H[e>>2];d=e+a|0;if(d>>>0>32768){break A}J:{if(a>>>0>=d>>>0){break J}l=0;j=e&7;if(j){while(1){H[i+(a2]=f;a=a+1|0;l=l+1|0;if((j|0)!=(l|0)){continue}break}}if(e-1>>>0>2]=f;H[e+24>>2]=f;H[e+20>>2]=f;H[e+16>>2]=f;H[e+12>>2]=f;H[e+8>>2]=f;H[e+4>>2]=f;a=a+8|0;if((d|0)!=(a|0)){continue}break}}f=f+1|0;if((h|0)!=(f|0)){continue}break}k=(d|0)==32768}d=k}K:{if(!d|(H[g+20>>2]?0:m)){break K}d=0;j=ca-16|0;ca=j;L:{M:{if(J[c+38>>1]>2];a=H[c+12>>2];h=a;e=H[c+20>>2];k=H[c+16>>2];f=k+8|0;e=f>>>0>>0>>0&(a|0)2]|0;a=I[k|0]|I[k+1|0]2];a=H[j+8>>2];k=H[j+12>>2]}i=b-f|0;b=h-((b>>>0>>0)+e|0)|0;if((b|0)==(k|0)&a>>>0>i>>>0|b>>>0>>0){break L}i=e+k|0;b=a+f|0;i=b>>>0>>0?i+1|0:i;H[c+16>>2]=b;H[c+20>>2]=i;if((a|0)>2]+f|0;H[g+48>>2]=b;c=a-1|0;f=c+b|0;e=I[f|0];N:{if(e>>>0>2]=c;a=I[f|0]&63;break N}O:{switch((e>>>6|0)-1|0){case 0:if(a>>>0>2]=a;a=a+b|0;a=I[a+1|0]>0>2]=a;a=a+b|0;a=I[a+1|0]2];c=H[g+36>>2];d=H[g+48>>2];f=H[g+24>>2];while(1){P:{if(a>>>0>131071){break P}while(1){if((b|0)>2]=b;a=I[b+d|0]|a2]=a;if(a>>>0>>15|0)+e|0)-H[k+4>>2]|0;H[g+56>>2]=a;H[r+(q2]=o;o=1;q=q+1|0;if((m|0)!=(q|0)){continue}break}}a=H[g+36>>2];if(a){H[g+40>>2]=a;oa(a)}a=H[g+24>>2];if(a){H[g+28>>2]=a;oa(a)}a=H[g+8>>2];if(a){H[g+12>>2]=a;oa(a)}ca=g- -64|0;b=o;break g;case 10:m=a;j=d;g=ca+-64|0;ca=g;H[g+56>>2]=0;H[g+48>>2]=0;H[g+52>>2]=0;H[g+40>>2]=0;H[g+44>>2]=0;H[g+32>>2]=0;H[g+36>>2]=0;H[g+24>>2]=0;H[g+28>>2]=0;H[g+16>>2]=0;H[g+20>>2]=0;H[g+8>>2]=0;H[g+12>>2]=0;n=g+8|0;a=J[c+38>>1];Q:{R:{if(!a){break R}S:{if(a>>>0>2];b=H[c+12>>2];e=H[c+20>>2];a=H[c+16>>2];f=a+4|0;e=f>>>0>>0>>0&(b|0)2]|0;h=I[a|0]|I[a+1|0]2]+4|0;e=f>>>0>2]=f;H[c+20>>2]=e;break S}if(!hb(1,n+12|0,c)){break R}f=H[c+16>>2];e=H[c+20>>2];h=H[n+12>>2]}a=H[c+8>>2];d=a-f|0;a=H[c+12>>2]-((a>>>0>>0)+e|0)|0;if(d>>>0>>6>>>0&(a|0)2];a=H[n+4>>2]-b>>2;T:{if(a>>>0>>0){ya(n,h-a|0);h=H[n+12>>2];break T}if(a>>>0>>0){break T}H[n+4>>2]=b+(h2];e=H[c+20>>2];t=H[n>>2];r=H[c+8>>2];p=H[c+12>>2];b=0;while(1){d=0;if((e|0)>=(p|0)&f>>>0>=r>>>0|(e|0)>(p|0)){break Q}d=H[c>>2];s=I[d+f|0];f=f+1|0;i=f?e:e+1|0;H[c+16>>2]=f;e=i;H[c+20>>2]=e;a=s>>>2|0;l=0;U:{V:{W:{X:{i=s&3;switch(i|0){case 0:break V;case 3:break X;default:break W}}a=a+b|0;d=0;if(a>>>0>=h>>>0){break Q}ra(t+(b2]=f;H[c+20>>2]=e;a=h>0>>0){continue}break}a=n+16|0;r=H[n>>2];d=H[n+16>>2];b=H[n+20>>2]-d|0;Y:{if(b>>>0>>2|0)|0);break Y}if((b|0)==262144){break Y}H[n+20>>2]=d+262144}d=n+28|0;b=H[d>>2];f=H[n+32>>2]-b>>3;Z:{if(f>>>0>>0){ob(d,h-f|0);b=H[d>>2];break Z}if(f>>>0>h>>>0){H[n+32>>2]=(h2];f=0;d=0;while(1){e=r+(f2];n=(f2]=a;H[n>>2]=l;e=H[e>>2];d=e+a|0;if(d>>>0>65536){break R}_:{if(a>>>0>=d>>>0){break _}l=0;n=e&7;if(n){while(1){H[i+(a2]=f;a=a+1|0;l=l+1|0;if((n|0)!=(l|0)){continue}break}}if(e-1>>>0>2]=f;H[e+24>>2]=f;H[e+20>>2]=f;H[e+16>>2]=f;H[e+12>>2]=f;H[e+8>>2]=f;H[e+4>>2]=f;a=a+8|0;if((d|0)!=(a|0)){continue}break}}f=f+1|0;if((h|0)!=(f|0)){continue}break}k=(d|0)==65536}d=k}$:{if(!d|(H[g+20>>2]?0:m)){break $}d=0;i=ca-16|0;ca=i;aa:{ba:{if(J[c+38>>1]>2];a=H[c+12>>2];h=a;e=H[c+20>>2];k=H[c+16>>2];f=k+8|0;e=f>>>0>>0>>0&(a|0)2]|0;a=I[k|0]|I[k+1|0]2];a=H[i+8>>2];k=H[i+12>>2]}r=b-f|0;b=h-((b>>>0>>0)+e|0)|0;if((b|0)==(k|0)&a>>>0>r>>>0|b>>>0>>0){break aa}e=e+k|0;b=a+f|0;e=b>>>0>>0?e+1|0:e;H[c+16>>2]=b;H[c+20>>2]=e;if((a|0)>2]+f|0;H[g+48>>2]=b;c=a-1|0;f=c+b|0;e=I[f|0];ca:{if(e>>>0>2]=c;a=I[f|0]&63;break ca}da:{switch((e>>>6|0)-1|0){case 0:if(a>>>0>2]=a;a=a+b|0;a=I[a+1|0]>0>2]=a;a=a+b|0;a=I[a+1|0]2];c=H[g+36>>2];d=H[g+48>>2];f=H[g+24>>2];while(1){ea:{if(a>>>0>262143){break ea}while(1){if((b|0)>2]=b;a=I[b+d|0]|a2]=a;if(a>>>0>>16|0)+e|0)-H[k+4>>2]|0;H[g+56>>2]=a;H[j+(q2]=o;o=1;q=q+1|0;if((m|0)!=(q|0)){continue}break}}a=H[g+36>>2];if(a){H[g+40>>2]=a;oa(a)}a=H[g+24>>2];if(a){H[g+28>>2]=a;oa(a)}a=H[g+8>>2];if(a){H[g+12>>2]=a;oa(a)}ca=g- -64|0;b=o;break g;case 11:m=a;r=d;g=ca+-64|0;ca=g;H[g+56>>2]=0;H[g+48>>2]=0;H[g+52>>2]=0;H[g+40>>2]=0;H[g+44>>2]=0;H[g+32>>2]=0;H[g+36>>2]=0;H[g+24>>2]=0;H[g+28>>2]=0;H[g+16>>2]=0;H[g+20>>2]=0;H[g+8>>2]=0;H[g+12>>2]=0;j=g+8|0;a=J[c+38>>1];fa:{ga:{if(!a){break ga}ha:{if(a>>>0>2];b=H[c+12>>2];e=H[c+20>>2];a=H[c+16>>2];f=a+4|0;e=f>>>0>>0>>0&(b|0)2]|0;h=I[a|0]|I[a+1|0]2]+4|0;i=f>>>0>2]=f;e=i;H[c+20>>2]=e;break ha}if(!hb(1,j+12|0,c)){break ga}f=H[c+16>>2];e=H[c+20>>2];h=H[j+12>>2]}a=H[c+8>>2];d=a-f|0;a=H[c+12>>2]-((a>>>0>>0)+e|0)|0;if(d>>>0>>6>>>0&(a|0)2];a=H[j+4>>2]-b>>2;ia:{if(a>>>0>>0){ya(j,h-a|0);h=H[j+12>>2];break ia}if(a>>>0>>0){break ia}H[j+4>>2]=b+(h2];e=H[c+20>>2];s=H[j>>2];i=H[c+8>>2];n=H[c+12>>2];b=0;while(1){d=0;if((e|0)>=(n|0)&f>>>0>=i>>>0|(e|0)>(n|0)){break fa}d=H[c>>2];p=I[d+f|0];f=f+1|0;e=f?e:e+1|0;H[c+16>>2]=f;H[c+20>>2]=e;a=p>>>2|0;l=0;ja:{ka:{la:{ma:{t=p&3;switch(t|0){case 0:break ka;case 3:break ma;default:break la}}a=a+b|0;d=0;if(a>>>0>=h>>>0){break fa}ra(s+(b2]=f;H[c+20>>2]=e;a=h>0>>0){continue}break}a=j+16|0;n=H[j>>2];d=H[j+16>>2];b=H[j+20>>2]-d|0;na:{if(b>>>0>>2|0)|0);break na}if((b|0)==1048576){break na}H[j+20>>2]=d- -1048576}d=j+28|0;b=H[d>>2];f=H[j+32>>2]-b>>3;oa:{if(f>>>0>>0){ob(d,h-f|0);b=H[d>>2];break oa}if(f>>>0>h>>>0){H[j+32>>2]=(h2];f=0;d=0;while(1){e=n+(f2];l=(f2]=a;H[l>>2]=j;e=H[e>>2];d=e+a|0;if(d>>>0>262144){break ga}pa:{if(a>>>0>=d>>>0){break pa}l=0;j=e&7;if(j){while(1){H[i+(a2]=f;a=a+1|0;l=l+1|0;if((j|0)!=(l|0)){continue}break}}if(e-1>>>0>2]=f;H[e+24>>2]=f;H[e+20>>2]=f;H[e+16>>2]=f;H[e+12>>2]=f;H[e+8>>2]=f;H[e+4>>2]=f;a=a+8|0;if((d|0)!=(a|0)){continue}break}}f=f+1|0;if((h|0)!=(f|0)){continue}break}k=(d|0)==262144}d=k}qa:{if(!d|(H[g+20>>2]?0:m)){break qa}d=0;j=ca-16|0;ca=j;ra:{sa:{if(J[c+38>>1]>2];a=H[c+12>>2];h=a;i=H[c+20>>2];k=H[c+16>>2];f=k+8|0;i=f>>>0>>0>>0&(e|0)>=(a|0)|(a|0)>2]|0;a=I[k|0]|I[k+1|0]2];a=H[j+8>>2];k=H[j+12>>2]}i=b-f|0;b=h-((b>>>0>>0)+e|0)|0;if((b|0)==(k|0)&a>>>0>i>>>0|b>>>0>>0){break ra}e=e+k|0;b=a+f|0;e=b>>>0>>0?e+1|0:e;H[c+16>>2]=b;H[c+20>>2]=e;if((a|0)>2]+f|0;H[g+48>>2]=b;c=a-1|0;f=c+b|0;e=I[f|0];ta:{if(e>>>0>2]=c;a=I[f|0]&63;break ta}ua:{switch((e>>>6|0)-1|0){case 0:if(a>>>0>2]=a;a=a+b|0;a=I[a+1|0]>0>2]=a;a=a+b|0;a=I[a+1|0]2];c=H[g+36>>2];d=H[g+48>>2];f=H[g+24>>2];while(1){va:{if(a>>>0>1048575){break va}while(1){if((b|0)>2]=b;a=I[b+d|0]|a2]=a;if(a>>>0>>18|0)+e|0)-H[k+4>>2]|0;H[g+56>>2]=a;H[r+(q2]=o;o=1;q=q+1|0;if((m|0)!=(q|0)){continue}break}}a=H[g+36>>2];if(a){H[g+40>>2]=a;oa(a)}a=H[g+24>>2];if(a){H[g+28>>2]=a;oa(a)}a=H[g+8>>2];if(a){H[g+12>>2]=a;oa(a)}ca=g- -64|0;b=o;break g;case 12:m=a;r=d;g=ca+-64|0;ca=g;H[g+56>>2]=0;H[g+48>>2]=0;H[g+52>>2]=0;H[g+40>>2]=0;H[g+44>>2]=0;H[g+32>>2]=0;H[g+36>>2]=0;H[g+24>>2]=0;H[g+28>>2]=0;H[g+16>>2]=0;H[g+20>>2]=0;H[g+8>>2]=0;H[g+12>>2]=0;j=g+8|0;a=J[c+38>>1];wa:{xa:{if(!a){break xa}ya:{if(a>>>0>2];b=H[c+12>>2];i=H[c+20>>2];a=H[c+16>>2];f=a+4|0;i=f>>>0>>0>>0&(b|0)2]|0;h=I[a|0]|I[a+1|0]2]+4|0;e=f>>>0>2]=f;H[c+20>>2]=e;break ya}if(!hb(1,j+12|0,c)){break xa}f=H[c+16>>2];e=H[c+20>>2];h=H[j+12>>2]}a=H[c+8>>2];d=a-f|0;a=H[c+12>>2]-((a>>>0>>0)+e|0)|0;if(d>>>0>>6>>>0&(a|0)2];a=H[j+4>>2]-b>>2;za:{if(a>>>0>>0){ya(j,h-a|0);h=H[j+12>>2];break za}if(a>>>0>>0){break za}H[j+4>>2]=b+(h2];e=H[c+20>>2];s=H[j>>2];i=H[c+8>>2];n=H[c+12>>2];b=0;while(1){d=0;if((e|0)>=(n|0)&f>>>0>=i>>>0|(e|0)>(n|0)){break wa}d=H[c>>2];p=I[d+f|0];f=f+1|0;e=f?e:e+1|0;H[c+16>>2]=f;H[c+20>>2]=e;a=p>>>2|0;l=0;Aa:{Ba:{Ca:{Da:{t=p&3;switch(t|0){case 0:break Ba;case 3:break Da;default:break Ca}}a=a+b|0;d=0;if(a>>>0>=h>>>0){break wa}ra(s+(b2]=f;H[c+20>>2]=e;a=h>0>>0){continue}break}a=j+16|0;n=H[j>>2];d=H[j+16>>2];b=H[j+20>>2]-d|0;Ea:{if(b>>>0>>2|0)|0);break Ea}if((b|0)==2097152){break Ea}H[j+20>>2]=d+2097152}d=j+28|0;b=H[d>>2];f=H[j+32>>2]-b>>3;Fa:{if(f>>>0>>0){ob(d,h-f|0);b=H[d>>2];break Fa}if(f>>>0>h>>>0){H[j+32>>2]=(h2];f=0;d=0;while(1){e=n+(f2];l=(f2]=a;H[l>>2]=j;e=H[e>>2];d=e+a|0;if(d>>>0>524288){break xa}Ga:{if(a>>>0>=d>>>0){break Ga}l=0;j=e&7;if(j){while(1){H[i+(a2]=f;a=a+1|0;l=l+1|0;if((j|0)!=(l|0)){continue}break}}if(e-1>>>0>2]=f;H[e+24>>2]=f;H[e+20>>2]=f;H[e+16>>2]=f;H[e+12>>2]=f;H[e+8>>2]=f;H[e+4>>2]=f;a=a+8|0;if((d|0)!=(a|0)){continue}break}}f=f+1|0;if((h|0)!=(f|0)){continue}break}k=(d|0)==524288}d=k}Ha:{if(!d|(H[g+20>>2]?0:m)){break Ha}d=0;i=ca-16|0;ca=i;Ia:{Ja:{if(J[c+38>>1]>2];a=H[c+12>>2];h=a;e=H[c+20>>2];k=H[c+16>>2];f=k+8|0;e=f>>>0>>0>>0&(a|0)2]|0;a=I[k|0]|I[k+1|0]2];a=H[i+8>>2];k=H[i+12>>2]}j=b-f|0;b=h-((b>>>0>>0)+e|0)|0;if((b|0)==(k|0)&a>>>0>j>>>0|b>>>0>>0){break Ia}e=e+k|0;b=a+f|0;e=b>>>0>>0?e+1|0:e;H[c+16>>2]=b;H[c+20>>2]=e;if((a|0)>2]+f|0;H[g+48>>2]=b;c=a-1|0;f=c+b|0;e=I[f|0];Ka:{if(e>>>0>2]=c;a=I[f|0]&63;break Ka}La:{switch((e>>>6|0)-1|0){case 0:if(a>>>0>2]=a;a=a+b|0;a=I[a+1|0]>0>2]=a;a=a+b|0;a=I[a+1|0]2];c=H[g+36>>2];d=H[g+48>>2];f=H[g+24>>2];while(1){Ma:{if(a>>>0>2097151){break Ma}while(1){if((b|0)>2]=b;a=I[b+d|0]|a2]=a;if(a>>>0>>19|0)+e|0)-H[k+4>>2]|0;H[g+56>>2]=a;H[r+(q2]=o;o=1;q=q+1|0;if((m|0)!=(q|0)){continue}break}}a=H[g+36>>2];if(a){H[g+40>>2]=a;oa(a)}a=H[g+24>>2];if(a){H[g+28>>2]=a;oa(a)}a=H[g+8>>2];if(a){H[g+12>>2]=a;oa(a)}ca=g- -64|0;b=o;break g;case 17:b=Le(a,c,d);break g;case 0:case 1:case 2:case 3:case 4:case 5:case 6:case 7:b=ca+-64|0;ca=b;H[b+56>>2]=0;H[b+48>>2]=0;H[b+52>>2]=0;H[b+40>>2]=0;H[b+44>>2]=0;H[b+32>>2]=0;H[b+36>>2]=0;H[b+24>>2]=0;H[b+28>>2]=0;H[b+16>>2]=0;H[b+20>>2]=0;H[b+8>>2]=0;H[b+12>>2]=0;Na:{if(!Ne(b+8|0,c)|(H[b+20>>2]?0:a)){break Na}if(!Me(b+8|0,c)){break Na}if(!a){f=1;break Na}e=H[b+52>>2];c=H[b+56>>2];k=H[b+36>>2];i=H[b+48>>2];g=H[b+24>>2];while(1){Oa:{if(c>>>0>16383){break Oa}while(1){if((e|0)>2]=e;c=I[e+i|0]|c2]=c;if(c>>>0>>12|0)+f|0)-H[r+4>>2]|0;H[b+56>>2]=c;H[(o2]=m;f=1;o=o+1|0;if((o|0)!=(a|0)){continue}break}}a=H[b+36>>2];if(a){H[b+40>>2]=a;oa(a)}a=H[b+24>>2];if(a){H[b+28>>2]=a;oa(a)}a=H[b+8>>2];if(a){H[b+12>>2]=a;oa(a)}ca=b- -64|0;b=f;break g;case 13:case 14:case 15:case 16:break h;default:break g}}b=Le(a,c,d)}f=b}return f}function gi(a){a=a|0;var b=0,c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,L=0,M=0,O=0,P=0,Q=0,R=0;s=ca+-64|0;ca=s;H[a+132>>2]=0;if(H[a+148>>2]){c=H[a+144>>2];if(c){while(1){d=H[c>>2];oa(c);c=d;if(c){continue}break}}c=0;H[a+144>>2]=0;d=H[a+140>>2];a:{if(!d){break a}if(d>>>0>=4){g=d&-4;while(1){e=c2]>>2]=0;H[H[a+136>>2]+(e|4)>>2]=0;H[H[a+136>>2]+(e|8)>>2]=0;H[H[a+136>>2]+(e|12)>>2]=0;c=c+4|0;b=b+4|0;if((g|0)!=(b|0)){continue}break}}b=d&3;if(!b){break a}while(1){H[H[a+136>>2]+(c2]=0;c=c+1|0;u=u+1|0;if((b|0)!=(u|0)){continue}break}}H[a+148>>2]=0}b:{c:{d:{c=H[a+4>>2];u=I[c+36|0];b=u>0>2];e:{if(b>>>0>2];e=H[i+16>>2];d=e+4|0;b=d>>>0>2];if(K[i+8>>2]>>0&(b|0)>=(h|0)|(b|0)>(h|0)){break d}b=e+H[i>>2]|0;b=I[b|0]|I[b+1|0]2];u=I[c+36|0];b=H[s>>2]}H[a+132>>2]=b}g=H[c+32>>2];f:{g:{h:{if((u&255)>>>0>2];e=H[g+16>>2];b=e+4|0;d=b>>>0>2];if(K[g+8>>2]>>0&(i|0)(i|0)){break c}e=e+H[g>>2]|0;e=I[e|0]|I[e+1|0]2]=d;H[a+156>>2]=e;n=a+156|0;break h}u=0;if(!Ea(1,s+60|0,g)){break c}c=H[a+4>>2];b=I[c+36|0];H[a+156>>2]=H[s+60>>2];n=a+156|0;if(b>>>0>1){break g}}g=H[c+32>>2];h=H[g+8>>2];i=H[g+12>>2];c=H[g+20>>2];d=H[g+16>>2];b=d+4|0;c=b>>>0>>0>h>>>0&(c|0)>=(i|0)|(c|0)>(i|0)){break c}b=d+H[g>>2]|0;b=I[b|0]|I[b+1|0]2]=c;break f}if(!Ea(1,s+56|0,H[c+32>>2])){break c}b=H[s+56>>2]}if(b>>>0>1431655765|K[n>>2]>N(b,3)>>>0){break c}f=H[a+4>>2];g=H[f+32>>2];c=g;e=H[c+8>>2];i=H[c+16>>2];j=H[c+12>>2];d=H[c+20>>2];c=d;if((j|0)>>0>>0|(c|0)>(j|0)){break c}n=H[g>>2];o=I[n+i|0];h=i+1|0;c=h?c:c+1|0;H[g+16>>2]=h;H[g+20>>2]=c;i:{if(I[f+36|0]>>0>0>f>>>0|(c|0)>2]}if(b>>>0>>0|((n>>>0)/3|0)+n>>>0>>0){break c}c=H[a+4>>2];i=H[c+32>>2];j:{if(I[c+36|0]>2];e=H[i+16>>2];d=e+4|0;c=d>>>0>2]>>0;d=H[i+12>>2];if(f&(d|0)(d|0)){break c}d=e+H[i>>2]|0;d=I[d|0]|I[d+1|0]2]=c;break j}if(!Ea(1,s+48|0,i)){break c}d=H[s+48>>2]}if(d>>>0>n>>>0){break c}H[a+28>>2]=H[a+24>>2];e=$b(pa(88));c=H[a+8>>2];H[a+8>>2]=e;if(c){cb(c);if(!H[a+8>>2]){break c}}H[a+164>>2]=H[a+160>>2];Jb(a+160|0,b);H[a+176>>2]=H[a+172>>2];Jb(a+172|0,b);H[a- -64>>2]=0;H[a+92>>2]=-1;H[a+84>>2]=-1;H[a+88>>2]=-1;H[a+40>>2]=H[a+36>>2];H[a+52>>2]=H[a+48>>2];H[a+76>>2]=H[a+72>>2];B=a+216|0;ed(B);dd(B,o);if(!Lc(H[a+8>>2],b,H[a+156>>2]+d|0)){break c}c=H[a+156>>2];F[s|0]=1;Oa(a+120|0,c+d|0,s);c=H[a+4>>2];b=J[c+36>>1];b=(b>8)&65535;k:{if(b>>>0>2];l:{if(b>>>0>2];e=H[i+16>>2];c=e+4|0;b=c>>>0>2];if(K[i+8>>2]>>0&(b|0)>=(h|0)|(b|0)>(h|0)){break c}b=e+H[i>>2]|0;b=I[b|0]|I[b+1|0]2]}if(!b){break c}c=H[H[a+4>>2]+32>>2];e=H[c+8>>2];g=H[c+16>>2];i=e-g|0;c=H[c+12>>2]-(H[c+20>>2]+(e>>>0>>0)|0)|0;if((c|0)>>0>i>>>0|(c|0)>2]+32>>2];g=H[e+16>>2];i=(g+H[e>>2]|0)+b|0;g=H[e+8>>2]-g|0;G[c+38>>1]=J[e+38>>1];H[c>>2]=i;H[c+16>>2]=0;H[c+20>>2]=0;H[c+8>>2]=g-b;H[c+12>>2]=0;C=Ib(a,c);if((C|0)==-1){break c}M=C>>31;break k}C=-1;M=-1;if((Ib(a,H[c+32>>2])|0)==-1){break c}}e=a+232|0;Ee(e,a);H[a+372>>2]=o;H[a+384>>2]=H[a+156>>2]+d;O=Ha(s);g=O;b=0;j=ca-16|0;ca=j;m:{n:{c=H[e+144>>2];c=J[(ea[H[H[c>>2]+32>>2]](c)|0)+36>>1];if(((c>8)&65535)>>>0>2];H[e+40>>2]=H[e>>2];H[e+44>>2]=c;c=H[e+36>>2];H[e+72>>2]=H[e+32>>2];H[e+76>>2]=c;d=H[e+28>>2];c=e- -64|0;H[c>>2]=H[e+24>>2];H[c+4>>2]=d;c=H[e+20>>2];H[e+56>>2]=H[e+16>>2];H[e+60>>2]=c;c=H[e+12>>2];H[e+48>>2]=H[e+8>>2];H[e+52>>2]=c;if(!Db(e+40|0,1,j+8|0)){break n}c=H[e+44>>2];H[e>>2]=H[e+40>>2];H[e+4>>2]=c;c=H[e+76>>2];H[e+32>>2]=H[e+72>>2];H[e+36>>2]=c;c=H[e+68>>2];H[e+24>>2]=H[e+64>>2];H[e+28>>2]=c;c=H[e+60>>2];h=c;d=H[e+56>>2];H[e+16>>2]=d;H[e+20>>2]=c;i=H[e+52>>2];f=i;c=H[e+48>>2];H[e+8>>2]=c;H[e+12>>2]=f;o=c-d|0;k=H[j+12>>2];c=f-((c>>>0>>0)+h|0)|0;i=H[j+8>>2];if((k|0)==(c|0)&o>>>0>>0|c>>>0>>0){break n}c=h+k|0;f=d;d=d+i|0;c=f>>>0>d>>>0?c+1|0:c;H[e+16>>2]=d;H[e+20>>2]=c}o:{if(J[e+38>>1]>2];H[e+96>>2]=H[e>>2];H[e+100>>2]=c;c=H[e+36>>2];H[e+128>>2]=H[e+32>>2];H[e+132>>2]=c;c=H[e+28>>2];H[e+120>>2]=H[e+24>>2];H[e+124>>2]=c;c=H[e+20>>2];H[e+112>>2]=H[e+16>>2];H[e+116>>2]=c;c=H[e+12>>2];H[e+104>>2]=H[e+8>>2];H[e+108>>2]=c;if(!Db(e+96|0,1,j+8|0)){break n}c=H[e+100>>2];H[e>>2]=H[e+96>>2];H[e+4>>2]=c;c=H[e+132>>2];H[e+32>>2]=H[e+128>>2];H[e+36>>2]=c;c=H[e+124>>2];H[e+24>>2]=H[e+120>>2];H[e+28>>2]=c;d=H[e+116>>2];h=d;c=H[e+112>>2];H[e+16>>2]=c;H[e+20>>2]=d;i=H[e+108>>2];f=i;d=H[e+104>>2];H[e+8>>2]=d;H[e+12>>2]=f;o=d-c|0;k=H[j+12>>2];d=f-((c>>>0>d>>>0)+h|0)|0;i=H[j+8>>2];if((k|0)==(d|0)&o>>>0>>0|d>>>0>>0){break n}d=h+k|0;f=c;c=c+i|0;d=f>>>0>c>>>0?d+1|0:d;H[e+16>>2]=c;H[e+20>>2]=d;break o}if(!ta(e+80|0,e)){break m}}if(!Fe(e)){break m}c=H[e+4>>2];H[g>>2]=H[e>>2];H[g+4>>2]=c;c=H[e+36>>2];H[g+32>>2]=H[e+32>>2];H[g+36>>2]=c;c=H[e+28>>2];H[g+24>>2]=H[e+24>>2];H[g+28>>2]=c;c=H[e+20>>2];H[g+16>>2]=H[e+16>>2];H[g+20>>2]=c;c=H[e+12>>2];H[g+8>>2]=H[e+8>>2];H[g+12>>2]=c;c=H[e+144>>2];c=J[(ea[H[H[c>>2]+32>>2]](c)|0)+36>>1];p:{if(((c>8)&65535)>>>0>2];q:{if(I[(ea[H[H[c>>2]+32>>2]](c)|0)+36|0]>2];i=H[g+16>>2];d=i+4|0;c=d>>>0>2]>>0;d=H[g+12>>2];if(f&(d|0)(d|0)){break m}d=i+H[g>>2]|0;d=I[d|0]|I[d+1|0]2]}c=H[e+152>>2];if(d>>>0>=c>>>0){break m}d=H[g+20>>2];h=H[g+12>>2];i=H[g+16>>2];if((d|0)>=(h|0)&i>>>0>=K[g+8>>2]|(d|0)>(h|0)){break m}h=I[i+H[g>>2]|0];i=i+1|0;d=i?d:d+1|0;H[g+16>>2]=i;H[g+20>>2]=d;if(h){break m}H[e+176>>2]=2;H[e+180>>2]=7;break p}H[e+176>>2]=2;H[e+180>>2]=7;c=H[e+152>>2]}if((c|0)>2]=0;b=2;h=H[e+156>>2];i=H[e+160>>2]-h>>2;r:{if(i>>>0>>0){Pa(e+156|0,c-i|0,j+8|0);b=H[e+176>>2];d=H[e+180>>2];break r}d=7;if(c>>>0>=i>>>0){break r}H[e+160>>2]=h+(c2];h=H[e+184>>2];d=(c-h|0)/12|0;s:{if(b>>>0>d>>>0){o=0;d=b-d|0;f=H[i+8>>2];c=H[i+4>>2];t:{if(d>>>0>>0){if(d){b=c;c=N(d,12)-12|0;c=(c-((c>>>0)%12|0)|0)+12|0;c=ra(b,0,c)+c|0}H[i+4>>2]=c;break t}u:{v:{w:{h=H[i>>2];k=(c-h|0)/12|0;b=k+d|0;if(b>>>00>=178956970?357913941:b>>>0>>0?l:b;if(f){if(f>>>0>=357913942){break w}o=pa(N(f,12))}b=N(k,12)+o|0;d=N(d,12)-12|0;k=(d-((d>>>0)%12|0)|0)+12|0;d=ra(b,0,k);k=d+k|0;f=N(f,12)+o|0;if((c|0)==(h|0)){break v}while(1){b=b-12|0;c=c-12|0;H[b>>2]=H[c>>2];H[b+4>>2]=H[c+4>>2];H[b+8>>2]=H[c+8>>2];H[c+8>>2]=0;H[c>>2]=0;H[c+4>>2]=0;if((c|0)!=(h|0)){continue}break}H[i+8>>2]=f;d=H[i+4>>2];H[i+4>>2]=k;c=H[i>>2];H[i>>2]=b;if((c|0)==(d|0)){break u}while(1){b=d-12|0;h=H[b>>2];if(h){H[d-8>>2]=h;oa(h)}d=b;if((b|0)!=(c|0)){continue}break}break u}break b}wa();v()}H[i+8>>2]=f;H[i+4>>2]=k;H[i>>2]=d}if(c){oa(c)}}d=H[e+188>>2];break s}if(b>>>0>=d>>>0){d=c;break s}d=h+N(b,12)|0;if((d|0)!=(c|0)){while(1){b=c-12|0;h=H[b>>2];if(h){H[c-8>>2]=h;oa(h)}c=b;if((d|0)!=(b|0)){continue}break}}H[e+188>>2]=d}f=e+196|0;b=H[e+184>>2];c=(d-b|0)/12|0;o=H[e+196>>2];h=H[e+200>>2]-o>>2;x:{if(c>>>0>h>>>0){ya(f,c-h|0);b=H[e+184>>2];d=H[e+188>>2];break x}if(c>>>0>=h>>>0){break x}H[e+200>>2]=o+(c2];d=(H[b+4>>2]-H[b>>2]>>2>>>0)/3|0;b=H[j+8>>2];if(d>>>0>>0){break n}if(b){k=N(c,12);h=k+H[i>>2]|0;d=H[h>>2];o=H[h+4>>2]-d>>2;y:{if(o>>>0>>0){ya(h,b-o|0);d=H[k+H[i>>2]>>2];break y}if(b>>>0>=o>>>0){break y}H[h+4>>2]=(b2]+(c2]=b}b=1;c=c+1|0;if(c>>>0>2]-H[e+184>>2]|0)/12>>>0){continue}break}break m}b=0}ca=j+16|0;z:{if(!b){break z}d=0;c=0;g=0;i=0;o=0;l=ca-96|0;ca=l;H[l+72>>2]=0;H[l+64>>2]=0;H[l+68>>2]=0;H[l+48>>2]=0;H[l+52>>2]=0;H[l+40>>2]=0;H[l+44>>2]=0;H[l+56>>2]=1065353216;H[l+32>>2]=0;H[l+24>>2]=0;H[l+28>>2]=0;j=a;L=H[a+124>>2];A:{B:{C:{D:{E:{if((n|0)>2]!=H[j+220>>2];D=1;while(1){h=i;i=h+1|0;a=H[r+172>>2];F:{G:{if((a|0)!=-1){b=H[r+196>>2]+(a2];a=f-1|0;H[b>>2]=a;b=9;if((f|0)>2]+N(H[r+172>>2],12)>>2]+(a2];if(a>>>0>4){break F}b=H[(a2];break G}b=7;a=H[r+144>>2];a=J[(ea[H[H[a>>2]+32>>2]](a)|0)+36>>1];if(((a>8)&65535)>>>0>513|!I[r+76|0]){break G}b=0;m=H[r- -64>>2];k=H[r+72>>2];a=m+(k>>>3|0)|0;p=H[r+68>>2];if(a>>>0>=p>>>0){break G}f=I[a|0];a=k+1|0;H[r+72>>2]=a;f=f>>>(k&7)&1;if(!f){break G}q=a>>>3|0;b=m+q|0;H:{if(b>>>0>=p>>>0){b=a;a=0;break H}t=I[b|0];b=k+2|0;H[r+72>>2]=b;q=b>>>3|0;a=t>>>(a&7)&1}k=m+q|0;if(k>>>0>>0){k=I[k|0];H[r+72>>2]=b+1;b=k>>>(b&7)2];t=H[m+24>>2];D=c-4|0;f=H[D>>2];a=-1;K:{if((f|0)==-1){break K}k=f+1|0;k=(k>>>0)%3|0?k:f-2|0;a=-1;if((k|0)==-1){break K}a=H[H[m>>2]+(k2]}b=H[t+(a2];if((b|0)!=-1){d=b+1|0;d=(d>>>0)%3|0?d:b-2|0}if((d|0)==(f|0)){b=-1;break D}if((f|0)!=-1){b=-1;if(H[H[m+12>>2]+(f2]!=-1){break D}}k=H[m+12>>2];if((d|0)!=-1){b=-1;if(H[k+(d2]!=-1){break D}}p=N(h,3);b=p+1|0;H[k+(f2]=b;w=b2]=f;q=p+2|0;H[k+(d2]=q;y=q2]=d;k=-1;h=-1;L:{if((f|0)==-1){break L}M:{if((f>>>0)%3|0){b=f-1|0;break M}b=f+2|0;h=-1;if((b|0)==-1){break L}}h=H[H[m>>2]+(b2]}N:{if((d|0)==-1){break N}b=d+1|0;b=(b>>>0)%3|0?b:d-2|0;if((b|0)==-1){break N}k=H[H[m>>2]+(b2]}b=-1;if((a|0)==(h|0)|(a|0)==(k|0)){break D}b=H[m>>2];H[b+(p2]=a;H[b+w>>2]=k;H[b+y>>2]=h;if((h|0)!=-1){H[t+(h2]=q}b=H[j+120>>2]+(a>>>3&536870908)|0;d=H[b>>2];Q=b,R=Vj(a)&d,H[Q>>2]=R;H[D>>2]=p;k=H[c-4>>2];break J}b=-1;O:{P:{Q:{R:{S:{T:{U:{V:{W:{switch(a-1|0){case 2:case 4:if((c|0)==(g|0)){break D}t=c-4|0;d=H[t>>2];f=H[j+8>>2];m=H[f+12>>2];if((d|0)!=-1&H[m+(d2]!=-1){break D}k=N(h,3);p=(a|0)==5;q=k+(p?2:1)|0;w=q2]=d;H[m+(d2]=q;Ka(f+24|0,11424);a=H[j+8>>2];m=H[a+24>>2];if(H[a+28>>2]-m>>2>(L|0)){break D}a=H[a>>2];y=a+w|0;b=H[f+28>>2];f=H[f+24>>2];w=(b-f>>2)-1|0;H[y>>2]=w;if((b|0)!=(f|0)){H[m+(w2]=q}b=p?k:k+2|0;q=a+(k+p>0)%3|0){f=d-1|0;break _}f=d+2|0;if((f|0)==-1){break Z}}f=H[a+(f2];H[a+(b2]=f;if((f|0)==-1){break Y}H[m+(f2]=b;break Y}H[a+(b2]=-1}f=d+1|0;d=(f>>>0)%3|0?f:d-2|0;b=-1;if((d|0)==-1){break X}b=H[a+(d2]}H[q>>2]=b;H[t>>2]=k;break V;case 0:if((c|0)==(d|0)){break D}a=c-4|0;m=H[a>>2];H[l+68>>2]=a;p=H[l+44>>2];$:{if(!p){c=a;break $}f=H[l+40>>2];q=Uj(p)>>>0>1;b=h&p+2147483647;aa:{if(!q){break aa}b=h;if(b>>>0>>0){break aa}b=(h>>>0)%(p>>>0)|0}k=b;b=H[f+(k2];if(!b){c=a;break $}b=H[b>>2];if(!b){c=a;break $}ba:{if(!q){f=p-1|0;while(1){p=H[b+4>>2];ca:{if((p|0)!=(h|0)){if((k|0)==(f&p)){break ca}c=a;break $}if((h|0)==H[b+8>>2]){break ba}}b=H[b>>2];if(b){continue}break}c=a;break $}while(1){f=H[b+4>>2];da:{if((f|0)!=(h|0)){if(f>>>0>=p>>>0){f=(f>>>0)%(p>>>0)|0}if((f|0)==(k|0)){break da}c=a;break $}if((h|0)==H[b+8>>2]){break ba}}b=H[b>>2];if(b){continue}break}c=a;break $}if((a|0)!=(x|0)){H[a>>2]=H[b+12>>2];H[l+68>>2]=c;break $}a=x-d|0;g=a>>2;c=g+1|0;if(c>>>0>=1073741824){break b}f=a>>>1|0;f=a>>>0>=2147483644?1073741823:c>>>0>>0?f:c;if(f){if(f>>>0>=1073741824){break B}a=pa(f2];c=g+4|0;if((d|0)!=(x|0)){while(1){g=g-4|0;x=x-4|0;H[g>>2]=H[x>>2];if((d|0)!=(x|0)){continue}break}}x=a+(f2]=x;H[l+68>>2]=c;H[l+64>>2]=g;if(d){oa(d)}}if((c|0)==(g|0)){break P}w=c-4|0;a=H[w>>2];if((a|0)==(m|0)){break P}b=(a|0)==-1;p=H[j+8>>2];if(!b&H[H[p+12>>2]+(a2]!=-1){break P}q=H[p+12>>2];if((m|0)!=-1&H[q+(m2]!=-1){break P}k=N(h,3);t=k+2|0;H[q+(a2]=t;h=t2]=a;d=k+1|0;H[q+(m2]=d;y=d2]=m;if(b){break T}if((a>>>0)%3|0){f=a-1|0;break S}f=a+2|0;if((f|0)!=-1){break S}d=H[p>>2];f=-1;break R;case 6:break W;default:break D}}k=H[j+8>>2];Ka(k+24|0,11424);f=H[j+8>>2];a=N(h,3);m=H[k+28>>2];p=H[k+24>>2];q=m-p|0;k=q>>2;t=k-1|0;H[H[f>>2]+(a2]=t;Ka(f+24|0,11424);w=a+1|0;H[H[f>>2]+(w2]=(H[f+28>>2]-H[f+24>>2]>>2)-1;f=H[j+8>>2];Ka(f+24|0,11424);y=a+2|0;H[H[f>>2]+(y2]=(H[f+28>>2]-H[f+24>>2]>>2)-1;E=H[j+8>>2];f=H[E+24>>2];if(H[E+28>>2]-f>>2>(L|0)){break D}ea:{fa:{if((m|0)!=(p|0)){H[f+(t2]=a;b=0;if((q|0)==-4){break fa}}H[f+(k2]=w;b=k+1|0;if((b|0)==-1){break ea}}H[f+(b2]=y}if((c|0)!=(x|0)){H[c>>2]=a;c=c+4|0;H[l+68>>2]=c;break U}b=c-d|0;k=b>>2;g=k+1|0;if(g>>>0>=1073741824){break b}f=b>>>1|0;b=b>>>0>=2147483644?1073741823:g>>>0>>0?f:g;if(b){if(b>>>0>=1073741824){break B}f=pa(b2];if((c|0)!=(d|0)){continue}break}}H[l+72>>2]=x;H[l+68>>2]=a;H[l+64>>2]=g;if(d){oa(d)}c=a}d=g}Ce(r,H[c-4>>2]);a=H[j+40>>2];if((a|0)==H[j+36>>2]){break I}b=a-12|0;f=H[b+4>>2];h=(h^-1)+n|0;if(f>>>0>h>>>0){break P}if((f|0)!=(h|0)){break I}k=I[a-4|0];f=H[b>>2];H[j+40>>2]=b;if((f|0)>2];H[l+20>>2]=(f^-1)+n;b=l+20|0;H[l+88>>2]=b;Gb(l,l+40|0,b,l+88|0);f=H[l>>2];ga:{if(k&1){b=-1;if((a|0)==-1){break ga}b=a+1|0;b=(b>>>0)%3|0?b:a-2|0;break ga}b=-1;if((a|0)==-1){break ga}b=a-1|0;if((a>>>0)%3|0){break ga}b=a+2|0}H[f+12>>2]=b;b=H[j+40>>2];if((b|0)==H[j+36>>2]){break I}while(1){a=b-12|0;f=H[a+4>>2];if(f>>>0>h>>>0){break P}if((f|0)!=(h|0)){break I}f=I[b-4|0];b=H[a>>2];H[j+40>>2]=a;if((b|0)>2];H[l+20>>2]=(b^-1)+n;b=l+20|0;H[l+88>>2]=b;Gb(l,l+40|0,b,l+88|0);k=H[l>>2];ha:{if(f&1){b=-1;if((a|0)==-1){break ha}b=a+1|0;b=(b>>>0)%3|0?b:a-2|0;break ha}b=-1;if((a|0)==-1){break ha}b=a-1|0;if((a>>>0)%3|0){break ha}b=a+2|0}H[k+12>>2]=b;b=H[j+40>>2];if((b|0)!=H[j+36>>2]){continue}break}break I}f=-1;d=H[p>>2];H[d+(k2]=-1;b=-1;break Q}d=H[p>>2];f=H[d+(f2]}H[(k2]=f;E=a+1|0;a=(E>>>0)%3|0?E:a-2|0;b=-1;if((a|0)==-1){break Q}b=H[(a2]}H[d+y>>2]=b;ia:{if((m|0)==-1){H[d+h>>2]=-1;t=-1;a=-1;break ia}ja:{ka:{la:{if((m>>>0)%3|0){b=m-1|0;break la}b=m+2|0;if((b|0)==-1){break ka}}a=H[(b2];H[d+h>>2]=a;if((a|0)==-1){break ja}H[H[p+24>>2]+(a2]=t;break ja}H[d+h>>2]=-1}t=-1;b=m+1|0;b=(b>>>0)%3|0?b:m-2|0;a=-1;if((b|0)==-1){break ia}t=H[(b2];a=b}b=H[j+388>>2];h=f2]+H[y+b>>2];m=b;b=H[p+24>>2];m=m+b|0;if((f|0)!=-1){H[b+h>>2]=H[m>>2]}b=a;while(1){if((b|0)==-1){break O}H[(b2]=f;p=b+1|0;b=(p>>>0)%3|0?p:b-2|0;h=-1;ma:{if((b|0)==-1){break ma}b=H[q+(b2];h=-1;if((b|0)==-1){break ma}h=b+1|0;h=(h>>>0)%3|0?h:b-2|0}b=h;if((a|0)!=(b|0)){continue}break}}b=-1;if(!D){break E}break D}H[m>>2]=-1;na:{if(P){break na}if((z|0)!=(A|0)){H[A>>2]=t;A=A+4|0;H[l+28>>2]=A;break na}a=z-o|0;h=a>>2;b=h+1|0;if(b>>>0>=1073741824){break b}d=a>>>1|0;d=a>>>0>=2147483644?1073741823:b>>>0>>0?d:b;if(d){if(d>>>0>=1073741824){break B}a=pa(d2]=H[z>>2];if((o|0)!=(z|0)){continue}break}}z=a+(d2]=z;H[l+28>>2]=A;H[l+24>>2]=b;if(o){oa(o)}o=b}H[w>>2]=k}Ce(r,k);d=g}D=(i|0)>2];if(H[d+28>>2]-H[d+24>>2]>>2>(L|0)){break D}if((c|0)!=(g|0)){x=j+72|0;h=j+60|0;p=j+312|0;while(1){c=c-4|0;o=H[c>>2];H[l+68>>2]=c;oa:{pa:{qa:{if(J[j+270>>1]>2];b=H[j+352>>2]+(a>>>3|0)|0;if(b>>>0>=K[j+356>>2]){break qa}b=I[b|0];H[j+360>>2]=a+1;if(!(b>>>(a&7)&1)){break qa}break pa}if(Ba(p)){break pa}}b=H[j+64>>2];a=H[j+68>>2];if((b|0)==a00>b>>>0?a:b}else{a=2147483647}pb(h,a);b=H[j+64>>2]}H[j+64>>2]=b+1;a=H[j+60>>2]+(b>>>3&536870908)|0;d=H[a>>2];Q=a,R=Vj(b)&d,H[Q>>2]=R;b=H[j+76>>2];if((b|0)!=H[j+80>>2]){H[b>>2]=o;H[j+76>>2]=b+4;break oa}d=H[x>>2];a=b-d|0;k=a>>2;f=k+1|0;if(f>>>0>>1|0;n=a>>>0>=2147483644?1073741823:f>>>0>>0?n:f;if(n){if(n>>>0>=1073741824){break B}a=pa(n2]=H[b>>2];if((b|0)!=(d|0)){continue}break}}H[j+80>>2]=a+(n2]=o;H[j+72>>2]=f;if(!d){break oa}oa(d);break oa}break b}m=H[j+8>>2];r=H[m>>2];if(((H[m+4>>2]-r>>2>>>0)/3|0)>2];n=-1;ra:{if((o|0)==-1){break ra}g=o+1|0;g=(g>>>0)%3|0?g:o-2|0;n=-1;if((g|0)==-1){break ra}n=H[r+(g2]}a=H[q+(n2];sa:{if((a|0)==-1){k=1;f=-1;break sa}k=1;f=-1;b=a+1|0;a=(b>>>0)%3|0?b:a-2|0;if((a|0)==-1){break sa}k=0;d=a;b=a+1|0;b=(b>>>0)%3|0?b:a-2|0;if((b|0)!=-1){f=H[r+(b2]}}b=-1;g=-1;a=H[q+(f2];if((a|0)!=-1){g=a+1|0;g=(g>>>0)%3|0?g:a-2|0}if((d|0)==(o|0)|(g|0)==(o|0)|((o|0)!=-1&H[H[m+12>>2]+(o2]!=-1|(d|0)==(g|0))){break D}if(!k&H[H[m+12>>2]+(d2]!=-1){break D}k=-1;a=H[m+12>>2];m=-1;ta:{if((g|0)==-1){break ta}if(H[a+(g2]!=-1){break D}b=g+1|0;b=(b>>>0)%3|0?b:g-2|0;m=-1;if((b|0)==-1){break ta}m=H[r+(b2]}b=N(i,3);H[l>>2]=b;H[a+(b2]=o;H[a+(o2]=b;b=H[l>>2]+1|0;H[a+(b2]=d;H[a+(d2]=b;b=H[l>>2]+2|0;H[a+(b2]=g;H[a+(g2]=b;a=H[l>>2];H[r+(a2]=f;b=a+1|0;d=r+(b2]=m;g=a+2|0;o=r+(g2]=n;a=H[j+120>>2];f=b?f:-1;n=a+(f>>>3&536870908)|0;r=H[n>>2];Q=n,R=Vj(f)&r,H[Q>>2]=R;k=(b|0)!=-1?H[d>>2]:k;b=a+(k>>>3&536870908)|0;d=H[b>>2];Q=b,R=Vj(k)&d,H[Q>>2]=R;b=-1;b=(g|0)!=-1?H[o>>2]:b;a=a+(b>>>3&536870908)|0;d=H[a>>2];Q=a,R=Vj(b)&d,H[Q>>2]=R;F[l+88|0]=1;_c(h,l+88|0);Ka(x,l);i=i+1|0;g=H[l+64>>2]}if((c|0)!=(g|0)){continue}break}d=H[j+8>>2]}b=-1;if(((H[d+4>>2]-H[d>>2]>>2>>>0)/3|0)!=(i|0)){break D}b=H[d+28>>2]-H[d+24>>2]>>2;i=H[l+24>>2];f=H[l+28>>2];if((i|0)==(f|0)){break C}while(1){a=H[i>>2];h=H[d+24>>2];c=b-1|0;g=h+(c2]==-1){while(1){c=b-2|0;b=b-1|0;g=h+(c2]==-1){continue}break}}if(a>>>0>>0){H[l>>2]=d;g=H[g>>2];F[l+12|0]=1;H[l+8>>2]=g;H[l+4>>2]=g;if((g|0)!=-1){while(1){d=H[H[j+8>>2]>>2]+(g2]!=(c|0)){b=-1;break D}H[d>>2]=a;uc(l);g=H[l+8>>2];if((g|0)!=-1){continue}break}d=H[j+8>>2]}h=H[d+24>>2];g=h+(c2]}H[g>>2]=-1;g=12];a=h+(a>>>3&536870908)|0;h=h+(c>>>3&536870908)|0;c=12]&c){g=g|H[a>>2]}else{g=H[a>>2]&(g^-1)}H[a>>2]=g;H[h>>2]=H[h>>2]&(c^-1);b=b-1|0}i=i+4|0;if((f|0)!=(i|0)){continue}break}}i=H[l+24>>2]}if(i){oa(i)}a=H[l+48>>2];if(a){while(1){c=H[a>>2];oa(a);a=c;if(a){continue}break}}a=H[l+40>>2];H[l+40>>2]=0;if(a){oa(a)}a=H[l+64>>2];if(a){H[l+68>>2]=a;oa(a)}ca=l+96|0;break A}wa();v()}if((b|0)==-1){break z}a=O;c=H[a+16>>2];d=c+H[a>>2]|0;c=H[a+8>>2]-c|0;a=H[H[j+4>>2]+32>>2];G[a+38>>1]=J[a+38>>1];H[a>>2]=d;H[a+16>>2]=0;H[a+20>>2]=0;H[a+8>>2]=c;H[a+12>>2]=0;a=H[j+4>>2];c=J[a+36>>1];g=c>8;if((g&65535)>>>0>2];c=H[a+16>>2];d=M+H[a+20>>2]|0;c=c+C|0;d=c>>>0>>0?d+1|0:d;H[a+16>>2]=c;H[a+20>>2]=d}ua:{if(H[j+216>>2]==H[j+220>>2]){break ua}c=H[j+8>>2];a=H[c>>2];c=H[c+4>>2];va:{if((g&65535)>>>0>=513){if((a|0)==(c|0)){break ua}c=0;break va}if((a|0)==(c|0)){break ua}c=0;while(1){if(cd(j,c)){c=c+3|0;a=H[j+8>>2];if(c>>>0>2]-H[a>>2]>>2>>>0){continue}break ua}break}break z}while(1){if(bd(j,c)){c=c+3|0;a=H[j+8>>2];if(c>>>0>2]-H[a>>2]>>2>>>0){continue}break ua}break}break z}ad(e);c=H[j+216>>2];if((c|0)!=H[j+220>>2]){n=0;while(1){d=N(n,144);Jc((d+c|0)+4|0,H[j+8>>2]);a=H[B>>2];e=a+d|0;c=H[e+132>>2];e=H[e+136>>2];if((c|0)!=(e|0)){while(1){Hc((d+H[B>>2]|0)+4|0,H[c>>2]);c=c+4|0;if((e|0)!=(c|0)){continue}break}a=H[B>>2]}if(!Ic((a+d|0)+4|0)){break z}n=n+1|0;c=H[j+216>>2];if(n>>>0>2]-c|0)/144>>>0){continue}break}}a=H[j+8>>2];Hb(j+184|0,H[a+28>>2]-H[a+24>>2]>>2);u=H[j+216>>2];if((u|0)!=H[j+220>>2]){c=0;while(1){a=N(c,144)+u|0;d=H[a+60>>2]-H[a+56>>2]>>2;f=a+104|0;a=H[j+8>>2];a=H[a+28>>2]-H[a+24>>2]>>2;Hb(f,(a|0)>2];if(c>>>0>2]-u|0)/144>>>0){continue}break}}u=$c(j,b)}break c}u=0}ca=s- -64|0;return u|0}sa();v()}function ii(a){a=a|0;var b=0,c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,L=0,M=0,O=0,P=0,Q=0,R=0,S=0;u=ca+-64|0;ca=u;H[a+132>>2]=0;if(H[a+148>>2]){c=H[a+144>>2];if(c){while(1){b=H[c>>2];oa(c);c=b;if(b){continue}break}}c=0;H[a+144>>2]=0;l=H[a+140>>2];a:{if(!l){break a}if(l>>>0>=4){b=l&-4;while(1){e=c2]>>2]=0;H[H[a+136>>2]+(e|4)>>2]=0;H[H[a+136>>2]+(e|8)>>2]=0;H[H[a+136>>2]+(e|12)>>2]=0;c=c+4|0;f=f+4|0;if((b|0)!=(f|0)){continue}break}}b=l&3;if(!b){break a}while(1){H[H[a+136>>2]+(c2]=0;c=c+1|0;w=w+1|0;if((b|0)!=(w|0)){continue}break}}H[a+148>>2]=0}b:{c:{c=H[a+4>>2];w=I[c+36|0];b=w>0>2];d:{if(b>>>0>2];l=H[g+16>>2];e=l+4|0;f=e>>>0>2];if(K[g+8>>2]>>0&(b|0)>=(d|0)|(b|0)>(d|0)){break c}f=l+H[g>>2]|0;f=I[f|0]|I[f+1|0]2];w=I[c+36|0];f=H[u>>2]}H[a+132>>2]=f}d=H[c+32>>2];e:{f:{g:{if((w&255)>>>0>2];e=H[d+16>>2];f=e+4|0;b=f>>>0>2];if(K[d+8>>2]>>0&(l|0)(l|0)){break b}e=e+H[d>>2]|0;e=I[e|0]|I[e+1|0]2]=b;H[a+156>>2]=e;t=a+156|0;break g}w=0;if(!Ea(1,u+60|0,d)){break b}c=H[a+4>>2];b=I[c+36|0];H[a+156>>2]=H[u+60>>2];t=a+156|0;if(b>>>0>1){break f}}d=H[c+32>>2];e=H[d+8>>2];l=H[d+12>>2];c=H[d+20>>2];f=H[d+16>>2];b=f+4|0;c=b>>>0>>0>e>>>0&(c|0)>=(l|0)|(c|0)>(l|0)){break b}f=f+H[d>>2]|0;f=I[f|0]|I[f+1|0]2]=c;break e}if(!Ea(1,u+56|0,H[c+32>>2])){break b}f=H[u+56>>2]}if(f>>>0>1431655765|K[t>>2]>N(f,3)>>>0){break b}E=H[a+4>>2];x=H[E+32>>2];c=H[x+8>>2];d=H[x+12>>2];b=H[x+20>>2];h=H[x+16>>2];if((d|0)>>0>=c>>>0|(b|0)>(d|0)){break b}j=H[x>>2];k=I[j+h|0];e=x;l=h+1|0;g=l?b:b+1|0;H[e+16>>2]=l;H[e+20>>2]=g;h:{if(I[E+36|0]>>0>>0>e>>>0&(b|0)>=(d|0)|(b|0)>(d|0)){break b}e=j+l|0;t=I[e|0]|I[e+1|0]2]=b;break h}if(!Ea(1,u+52|0,x)){break b}t=H[u+52>>2]}if(f>>>0>>0|((t>>>0)/3|0)+t>>>0>>0){break b}c=H[a+4>>2];d=H[c+32>>2];i:{if(I[c+36|0]>2];b=H[d+16>>2];e=b+4|0;c=e>>>0>2];if(K[d+8>>2]>>0&(l|0)(l|0)){break b}b=b+H[d>>2]|0;b=I[b|0]|I[b+1|0]2]=c;break i}if(!Ea(1,u+48|0,d)){break b}b=H[u+48>>2]}if(b>>>0>t>>>0){break b}H[a+28>>2]=H[a+24>>2];c=$b(pa(88));e=H[a+8>>2];H[a+8>>2]=c;if(e){cb(e);if(!H[a+8>>2]){break b}}H[a+164>>2]=H[a+160>>2];Jb(a+160|0,f);H[a+176>>2]=H[a+172>>2];Jb(a+172|0,f);H[a- -64>>2]=0;H[a+92>>2]=-1;H[a+84>>2]=-1;H[a+88>>2]=-1;H[a+40>>2]=H[a+36>>2];H[a+52>>2]=H[a+48>>2];H[a+76>>2]=H[a+72>>2];M=a+216|0;ed(M);dd(M,k);if(!Lc(H[a+8>>2],f,H[a+156>>2]+b|0)){break b}c=H[a+156>>2];F[u|0]=1;Oa(a+120|0,b+c|0,u);f=H[a+4>>2];c=J[f+36>>1];c=(c>8)&65535;j:{if(c>>>0>2];k:{if(c>>>0>2];l=H[g+16>>2];e=l+4|0;f=e>>>0>2];if(K[g+8>>2]>>0&(c|0)>=(d|0)|(c|0)>(d|0)){break b}f=l+H[g>>2]|0;f=I[f|0]|I[f+1|0]2]}if(!f){break b}d=H[H[a+4>>2]+32>>2];l=H[d+8>>2];c=H[d+16>>2];e=l-c|0;c=H[d+12>>2]-(H[d+20>>2]+(c>>>0>l>>>0)|0)|0;if((c|0)>>0>e>>>0|(c|0)>2]+32>>2];l=H[d+16>>2];e=(l+H[d>>2]|0)+f|0;c=H[d+8>>2]-l|0;G[g+38>>1]=J[d+38>>1];H[g>>2]=e;H[g+16>>2]=0;H[g+20>>2]=0;H[g+8>>2]=c-f;H[g+12>>2]=0;c=Ib(a,g);if((c|0)==-1){break b}E=c;P=c>>31;break j}E=-1;P=-1;if((Ib(a,H[f+32>>2])|0)==-1){break b}}B=a+232|0;Ee(B,a);H[a+372>>2]=k;H[a+384>>2]=H[a+156>>2]+b;x=Ha(u);g=x;d=0;l=ca-16|0;ca=l;l:{if(!Ge(B,g)){break l}b=H[g+20>>2];f=H[g+16>>2];c=f+4|0;b=c>>>0>2];if(K[g+8>>2]>>0&(e|0)(e|0)){break l}f=f+H[g>>2]|0;f=I[f|0]|I[f+1|0]=(f|0)){break l}H[l+12>>2]=0;c=H[B+156>>2];b=H[B+160>>2]-c>>2;m:{if(b>>>0>>0){Pa(B+156|0,f-b|0,l+12|0);break m}if(b>>>0>>0){break m}H[B+160>>2]=c+(f2]=0;H[i+64>>2]=0;H[i+68>>2]=0;H[i+48>>2]=0;H[i+52>>2]=0;H[i+40>>2]=0;H[i+44>>2]=0;H[i+56>>2]=1065353216;H[i+32>>2]=0;H[i+24>>2]=0;H[i+28>>2]=0;g=a;O=H[a+124>>2];o:{p:{q:{r:{s:{t:{if((t|0)>2]!=H[g+220>>2];y=1;while(1){e=l;l=e+1|0;u:{v:{w:{x:{y:{if(H[g+420>>2]!=-1){if(Ba(z)){break y}}if(!I[g+308|0]){break x}z:{o=H[g+296>>2];r=H[g+304>>2];a=o+(r>>>3|0)|0;k=H[g+300>>2];if(a>>>0>=k>>>0){break z}b=I[a|0];a=r+1|0;H[g+304>>2]=a;h=b>>>(r&7)&1;if(!h){break z}n=a>>>3|0;b=o+n|0;A:{if(b>>>0>=k>>>0){b=a;a=0;break A}j=I[b|0];b=r+2|0;H[g+304>>2]=b;n=b>>>3|0;a=j>>>(a&7)&1}j=n+o|0;if(j>>>0>>0){j=I[j|0];H[g+304>>2]=b+1;b=j>>>(b&7)2]=0;break x}p=H[g+420>>2];H[g+416>>2]=p;if(p){break w}}if((c|0)==(f|0)){b=-1;break s}p=-1;n=H[g+8>>2];o=H[n+24>>2];j=c-4|0;m=H[j>>2];d=-1;B:{if((m|0)==-1){break B}b=m+1|0;b=(b>>>0)%3|0?b:m-2|0;d=-1;if((b|0)==-1){break B}d=H[H[n>>2]+(b2]}b=H[o+(d2];if((b|0)!=-1){a=b+1|0;p=(a>>>0)%3|0?a:b-2|0}if((m|0)==(p|0)){b=-1;break s}if((m|0)!=-1){b=-1;if(H[H[n+12>>2]+(m2]!=-1){break s}}k=H[n+12>>2];if((p|0)!=-1){b=-1;if(H[k+(p2]!=-1){break s}}q=N(e,3);a=q+1|0;H[k+(m2]=a;h=a2]=m;r=q+2|0;H[k+(p2]=r;e=r2]=p;k=-1;a=-1;C:{if((m|0)==-1){break C}D:{if((m>>>0)%3|0){b=m-1|0;break D}b=m+2|0;a=-1;if((b|0)==-1){break C}}a=H[H[n>>2]+(b2]}E:{if((p|0)==-1){break E}b=p+1|0;b=(b>>>0)%3|0?b:p-2|0;if((b|0)==-1){break E}k=H[H[n>>2]+(b2]}b=-1;if((a|0)==(d|0)|(d|0)==(k|0)){break s}b=H[n>>2];H[b+(q2]=d;H[b+h>>2]=k;H[b+e>>2]=a;if((a|0)!=-1){H[o+(a2]=r}b=H[g+120>>2]+(d>>>3&536870908)|0;a=H[b>>2];R=b,S=Vj(d)&a,H[R>>2]=S;H[j>>2]=q;p=H[c-4>>2];break v}b=-1;F:{G:{H:{I:{J:{K:{L:{M:{N:{O:{P:{switch(p-1|0){case 2:case 4:if((c|0)==(f|0)){break s}h=c-4|0;m=H[h>>2];r=H[g+8>>2];d=H[r+12>>2];if((m|0)!=-1&H[d+(m2]!=-1){break s}q=N(e,3);k=(p|0)==5;j=q+(k?2:1)|0;a=j2]=m;H[d+(m2]=j;Ka(r+24|0,11424);d=H[g+8>>2];o=H[d+24>>2];if(H[d+28>>2]-o>>2>(O|0)){break s}n=H[d>>2];p=n+a|0;d=H[r+28>>2];b=H[r+24>>2];a=(d-b>>2)-1|0;H[p>>2]=a;if((b|0)!=(d|0)){H[o+(a2]=j}d=k?q:q+2|0;j=n+(k+q>0)%3|0){a=m-1|0;break T}a=m+2|0;if((a|0)==-1){break S}}a=H[n+(a2];H[n+(d2]=a;if((a|0)==-1){break R}H[o+(a2]=d;break R}H[n+(d2]=-1}a=m+1|0;a=(a>>>0)%3|0?a:m-2|0;b=-1;if((a|0)==-1){break Q}b=H[n+(a2]}H[j>>2]=b;H[h>>2]=q;break O;case 0:if((c|0)==(d|0)){break s}a=c-4|0;m=H[a>>2];H[i+68>>2]=a;k=H[i+44>>2];U:{if(!k){c=a;break U}o=H[i+40>>2];h=Uj(k)>>>0>1;b=e&k+2147483647;V:{if(!h){break V}b=e;if(b>>>0>>0){break V}b=(e>>>0)%(k>>>0)|0}j=b;b=H[o+(j2];if(!b){c=a;break U}b=H[b>>2];if(!b){c=a;break U}W:{if(!h){k=k-1|0;while(1){h=H[b+4>>2];X:{if((h|0)!=(e|0)){if((j|0)==(h&k)){break X}c=a;break U}if((e|0)==H[b+8>>2]){break W}}b=H[b>>2];if(b){continue}break}c=a;break U}while(1){h=H[b+4>>2];Y:{if((h|0)!=(e|0)){if(h>>>0>=k>>>0){h=(h>>>0)%(k>>>0)|0}if((h|0)==(j|0)){break Y}c=a;break U}if((e|0)==H[b+8>>2]){break W}}b=H[b>>2];if(b){continue}break}c=a;break U}if((a|0)!=(A|0)){H[a>>2]=H[b+12>>2];H[i+68>>2]=c;break U}h=A-d|0;c=h>>2;f=c+1|0;if(f>>>0>=1073741824){break M}a=h>>>1|0;h=h>>>0>=2147483644?1073741823:a>>>0>f>>>0?a:f;if(h){if(h>>>0>=1073741824){break p}a=pa(h2];c=f+4|0;if((d|0)!=(A|0)){while(1){f=f-4|0;A=A-4|0;H[f>>2]=H[A>>2];if((d|0)!=(A|0)){continue}break}}A=a+(h2]=A;H[i+68>>2]=c;H[i+64>>2]=f;if(d){oa(d)}}if((c|0)==(f|0)){break G}j=c-4|0;n=H[j>>2];if((n|0)==(m|0)){break G}d=(n|0)==-1;q=H[g+8>>2];if(!d&H[H[q+12>>2]+(n2]!=-1){break G}r=H[q+12>>2];if((m|0)!=-1&H[r+(m2]!=-1){break G}p=N(e,3);e=p+2|0;H[r+(n2]=e;o=e2]=n;a=p+1|0;H[r+(m2]=a;b=a2]=m;if(d){break L}if((n>>>0)%3|0){k=n-1|0;break J}k=n+2|0;if((k|0)!=-1){break J}d=H[q>>2];a=-1;break I;case 6:break P;default:break s}}a=H[g+8>>2];Ka(a+24|0,11424);h=H[g+8>>2];p=N(e,3);q=H[a+28>>2];r=H[a+24>>2];o=q-r|0;n=o>>2;k=n-1|0;H[H[h>>2]+(p2]=k;Ka(h+24|0,11424);j=p+1|0;H[H[h>>2]+(j2]=(H[h+28>>2]-H[h+24>>2]>>2)-1;a=H[g+8>>2];Ka(a+24|0,11424);h=p+2|0;H[H[a>>2]+(h2]=(H[a+28>>2]-H[a+24>>2]>>2)-1;a=H[g+8>>2];m=H[a+24>>2];if(H[a+28>>2]-m>>2>(O|0)){break s}Z:{_:{if((q|0)!=(r|0)){H[m+(k2]=p;b=0;if((o|0)==-4){break _}}H[m+(n2]=j;b=n+1|0;if((b|0)==-1){break Z}}H[m+(b2]=h}if((c|0)!=(A|0)){H[c>>2]=p;c=c+4|0;H[i+68>>2]=c;break N}h=c-d|0;b=h>>2;f=b+1|0;if(f>>>0>=1073741824){break K}a=h>>>1|0;h=h>>>0>=2147483644?1073741823:a>>>0>f>>>0?a:f;if(h){if(h>>>0>=1073741824){break p}a=pa(h2];if((c|0)!=(d|0)){continue}break}}H[i+72>>2]=A;H[i+68>>2]=a;H[i+64>>2]=f;if(d){oa(d)}c=a}d=f}De(Q,H[c-4>>2]);h=H[g+40>>2];if((h|0)==H[g+36>>2]){break u}b=h-12|0;a=H[b+4>>2];k=(e^-1)+t|0;if(a>>>0>k>>>0){break G}if((a|0)!=(k|0)){break u}e=I[h-4|0];a=H[b>>2];H[g+40>>2]=b;if((a|0)>2];H[i+20>>2]=(a^-1)+t;a=i+20|0;H[i+88>>2]=a;Gb(i,i+40|0,a,i+88|0);b=H[i>>2];$:{if(e&1){a=-1;if((j|0)==-1){break $}a=j+1|0;a=(a>>>0)%3|0?a:j-2|0;break $}a=-1;if((j|0)==-1){break $}a=j-1|0;if((j>>>0)%3|0){break $}a=j+2|0}H[b+12>>2]=a;b=H[g+40>>2];if((b|0)==H[g+36>>2]){break u}while(1){j=b-12|0;a=H[j+4>>2];if(a>>>0>k>>>0){break G}if((a|0)!=(k|0)){break u}e=I[b-4|0];a=H[j>>2];H[g+40>>2]=j;if((a|0)>2];H[i+20>>2]=(a^-1)+t;a=i+20|0;H[i+88>>2]=a;Gb(i,i+40|0,a,i+88|0);b=H[i>>2];aa:{if(e&1){a=-1;if((j|0)==-1){break aa}a=j+1|0;a=(a>>>0)%3|0?a:j-2|0;break aa}a=-1;if((j|0)==-1){break aa}a=j-1|0;if((j>>>0)%3|0){break aa}a=j+2|0}H[b+12>>2]=a;b=H[g+40>>2];if((b|0)!=H[g+36>>2]){continue}break}break u}sa();v()}k=-1;d=H[q>>2];H[d+(p2]=-1;h=-1;break H}sa();v()}d=H[q>>2];a=H[d+(k2]}k=a;H[(p2]=a;a=n+1|0;a=(a>>>0)%3|0?a:n-2|0;h=-1;if((a|0)==-1){break H}h=H[(a2]}H[b+d>>2]=h;ba:{if((m|0)==-1){H[d+o>>2]=-1;n=-1;a=-1;break ba}ca:{da:{ea:{if((m>>>0)%3|0){b=m-1|0;break ea}b=m+2|0;if((b|0)==-1){break da}}a=H[(b2];H[d+o>>2]=a;if((a|0)==-1){break ca}H[H[q+24>>2]+(a2]=e;break ca}H[d+o>>2]=-1}n=-1;b=m+1|0;b=(b>>>0)%3|0?b:m-2|0;a=-1;if((b|0)==-1){break ba}n=H[(b2];a=b}h=H[g+388>>2];e=k2];b=n2]=m+H[b+h>>2];h=b;b=H[q+24>>2];o=h+b|0;if((k|0)!=-1){H[b+e>>2]=H[o>>2]}b=a;while(1){if((b|0)==-1){break F}H[(b2]=k;h=b+1|0;b=(h>>>0)%3|0?h:b-2|0;e=-1;fa:{if((b|0)==-1){break fa}h=H[r+(b2];e=-1;if((h|0)==-1){break fa}b=h+1|0;e=(b>>>0)%3|0?b:h-2|0}b=e;if((a|0)!=(b|0)){continue}break}}b=-1;if(!(y&1)){break t}break s}H[o>>2]=-1;ga:{if(C){break ga}if((D|0)!=(L|0)){H[L>>2]=n;L=L+4|0;H[i+28>>2]=L;break ga}d=D-s|0;b=d>>2;e=b+1|0;if(e>>>0>=1073741824){break q}a=d>>>1|0;e=d>>>0>=2147483644?1073741823:a>>>0>e>>>0?a:e;if(e){if(e>>>0>=1073741824){break p}a=pa(e2]=H[D>>2];if((s|0)!=(D|0)){continue}break}}D=a+(e2]=D;H[i+28>>2]=L;H[i+24>>2]=b;if(s){oa(s)}s=b}H[j>>2]=p}De(Q,p);d=f}y=(l|0)>2];if(H[y+28>>2]-H[y+24>>2]>>2>(O|0)){break s}if((c|0)!=(f|0)){r=g+72|0;j=g+60|0;t=g+312|0;while(1){c=c-4|0;z=H[c>>2];H[i+68>>2]=c;ha:{ia:{ja:{if(J[g+270>>1]>2];a=H[g+352>>2]+(b>>>3|0)|0;if(a>>>0>=K[g+356>>2]){break ja}a=I[a|0];H[g+360>>2]=b+1;if(!(a>>>(b&7)&1)){break ja}break ia}if(Ba(t)){break ia}}ka:{la:{b=H[g+64>>2];e=H[g+68>>2];if((b|0)==e00>>0?e:b}else{a=2147483647}pb(j,a);b=H[g+64>>2]}H[g+64>>2]=b+1;e=H[g+60>>2]+(b>>>3&536870908)|0;a=H[e>>2];R=e,S=Vj(b)&a,H[R>>2]=S;b=H[g+76>>2];if((b|0)!=H[g+80>>2]){H[b>>2]=z;H[g+76>>2]=b+4;break ha}s=H[r>>2];h=b-s|0;e=h>>2;d=e+1|0;if(d>>>0>=1073741824){break ka}a=h>>>1|0;h=h>>>0>=2147483644?1073741823:a>>>0>d>>>0?a:d;if(h){if(h>>>0>=1073741824){break p}a=pa(h2]=H[b>>2];if((b|0)!=(s|0)){continue}break}}H[g+80>>2]=a+(h2]=e;H[g+72>>2]=d;if(!s){break ha}oa(s);break ha}sa();v()}sa();v()}q=H[g+8>>2];C=H[q>>2];if(((H[q+4>>2]-C>>2>>>0)/3|0)>2];e=-1;ma:{if((z|0)==-1){break ma}a=z+1|0;a=(a>>>0)%3|0?a:z-2|0;e=-1;if((a|0)==-1){break ma}e=H[C+(a2]}o=H[s+(e2];na:{if((o|0)==-1){k=1;a=-1;break na}k=1;h=o+1|0;h=(h>>>0)%3|0?h:o-2|0;a=-1;if((h|0)==-1){break na}k=0;a=h+1|0;f=h;a=(a>>>0)%3|0?a:f-2|0;if((a|0)!=-1){a=H[C+(a2]}else{a=-1}}h=H[(a2];if((h|0)!=-1){d=h+1|0;d=(d>>>0)%3|0?d:h-2|0}if((f|0)==(z|0)|(d|0)==(z|0)|((z|0)!=-1&H[H[q+12>>2]+(z2]!=-1|(d|0)==(f|0))){break s}if(!k&H[H[q+12>>2]+(f2]!=-1){break s}k=-1;s=H[q+12>>2];h=-1;oa:{if((d|0)==-1){break oa}if(H[s+(d2]!=-1){break s}b=d+1|0;b=(b>>>0)%3|0?b:d-2|0;h=-1;if((b|0)==-1){break oa}h=H[C+(b2]}b=N(l,3);H[i>>2]=b;H[s+(b2]=z;H[s+(z2]=b;b=H[i>>2]+1|0;H[s+(b2]=f;H[s+(f2]=b;b=H[i>>2]+2|0;H[s+(b2]=d;H[s+(d2]=b;b=H[i>>2];H[C+(b2]=a;o=b+1|0;s=C+(o2]=h;h=b+2|0;d=C+(h2]=e;e=H[g+120>>2];f=o?a:-1;b=e+(f>>>3&536870908)|0;a=H[b>>2];R=b,S=Vj(f)&a,H[R>>2]=S;k=(o|0)!=-1?H[s>>2]:k;b=e+(k>>>3&536870908)|0;a=H[b>>2];R=b,S=Vj(k)&a,H[R>>2]=S;b=-1;b=(h|0)!=-1?H[d>>2]:b;f=e+(b>>>3&536870908)|0;a=H[f>>2];R=f,S=Vj(b)&a,H[R>>2]=S;F[i+88|0]=1;_c(j,i+88|0);Ka(r,i);l=l+1|0;f=H[i+64>>2]}if((c|0)!=(f|0)){continue}break}y=H[g+8>>2]}b=-1;if(((H[y+4>>2]-H[y>>2]>>2>>>0)/3|0)!=(l|0)){break s}b=H[y+28>>2]-H[y+24>>2]>>2;l=H[i+24>>2];e=H[i+28>>2];if((l|0)==(e|0)){break r}while(1){j=H[l>>2];a=H[y+24>>2];c=b-1|0;d=a+(c2]==-1){while(1){c=b-2|0;b=b-1|0;d=a+(c2]==-1){continue}break}}if(c>>>0>=j>>>0){H[i>>2]=y;d=H[d>>2];F[i+12|0]=1;H[i+8>>2]=d;H[i+4>>2]=d;if((d|0)!=-1){while(1){a=H[H[g+8>>2]>>2]+(d2]!=(c|0)){b=-1;break s}H[a>>2]=j;uc(i);d=H[i+8>>2];if((d|0)!=-1){continue}break}y=H[g+8>>2]}a=H[y+24>>2];f=a+(c2]}H[f>>2]=-1;h=12];f=a+(j>>>3&536870908)|0;d=a+(c>>>3&536870908)|0;a=12]&a){c=h|H[f>>2]}else{c=H[f>>2]&(h^-1)}H[f>>2]=c;H[d>>2]=H[d>>2]&(a^-1);b=b-1|0}l=l+4|0;if((e|0)!=(l|0)){continue}break}}l=H[i+24>>2]}if(l){oa(l)}a=H[i+48>>2];if(a){while(1){c=H[a>>2];oa(a);a=c;if(a){continue}break}}a=H[i+40>>2];H[i+40>>2]=0;if(a){oa(a)}a=H[i+64>>2];if(a){H[i+68>>2]=a;oa(a)}ca=i+96|0;break o}sa();v()}wa();v()}f=b;if((b|0)==-1){break n}b=H[x+16>>2];c=b+H[x>>2]|0;a=H[x+8>>2]-b|0;b=H[H[g+4>>2]+32>>2];G[b+38>>1]=J[b+38>>1];H[b>>2]=c;H[b+16>>2]=0;H[b+20>>2]=0;H[b+8>>2]=a;H[b+12>>2]=0;b=H[g+4>>2];a=J[b+36>>1];c=a>8;if((c&65535)>>>0>2];e=b;a=H[b+16>>2];b=P+H[b+20>>2]|0;a=a+E|0;b=a>>>0>>0?b+1|0:b;H[e+16>>2]=a;H[e+20>>2]=b}pa:{if(H[g+216>>2]==H[g+220>>2]){break pa}a=H[g+8>>2];b=H[a>>2];a=H[a+4>>2];qa:{if((c&65535)>>>0>=513){if((a|0)==(b|0)){break pa}c=0;break qa}if((a|0)==(b|0)){break pa}c=0;while(1){if(cd(g,c)){c=c+3|0;a=H[g+8>>2];if(c>>>0>2]-H[a>>2]>>2>>>0){continue}break pa}break}break n}while(1){if(bd(g,c)){c=c+3|0;a=H[g+8>>2];if(c>>>0>2]-H[a>>2]>>2>>>0){continue}break pa}break}break n}ad(B);c=H[g+216>>2];if((c|0)!=H[g+220>>2]){t=0;while(1){e=N(t,144);Jc((e+c|0)+4|0,H[g+8>>2]);a=H[M>>2];b=a+e|0;c=H[b+132>>2];b=H[b+136>>2];if((c|0)!=(b|0)){while(1){Hc((e+H[M>>2]|0)+4|0,H[c>>2]);c=c+4|0;if((b|0)!=(c|0)){continue}break}a=H[M>>2]}if(!Ic((a+e|0)+4|0)){break n}t=t+1|0;c=H[g+216>>2];if(t>>>0>2]-c|0)/144>>>0){continue}break}}a=H[g+8>>2];Hb(g+184|0,H[a+28>>2]-H[a+24>>2]>>2);w=H[g+216>>2];if((w|0)!=H[g+220>>2]){c=0;while(1){a=N(c,144)+w|0;b=H[a+60>>2]-H[a+56>>2]>>2;e=a+104|0;a=H[g+8>>2];a=H[a+28>>2]-H[a+24>>2]>>2;Hb(e,(a|0)>2];if(c>>>0>2]-w|0)/144>>>0){continue}break}}w=$c(g,f)}break b}w=0}ca=u- -64|0;return w|0}function ki(a){a=a|0;var b=0,c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,L=0,M=0,O=0,P=0,Q=0;t=ca+-64|0;ca=t;H[a+132>>2]=0;if(H[a+148>>2]){d=H[a+144>>2];if(d){while(1){b=H[d>>2];oa(d);d=b;if(b){continue}break}}d=0;H[a+144>>2]=0;k=H[a+140>>2];a:{if(!k){break a}if(k>>>0>=4){b=k&-4;while(1){c=d2]>>2]=0;H[H[a+136>>2]+(c|4)>>2]=0;H[H[a+136>>2]+(c|8)>>2]=0;H[H[a+136>>2]+(c|12)>>2]=0;d=d+4|0;e=e+4|0;if((b|0)!=(e|0)){continue}break}}b=k&3;if(!b){break a}while(1){H[H[a+136>>2]+(d2]=0;d=d+1|0;x=x+1|0;if((b|0)!=(x|0)){continue}break}}H[a+148>>2]=0}b:{c:{d=H[a+4>>2];x=I[d+36|0];b=x>0>2];d:{if(b>>>0>2];e=H[f+16>>2];c=e+4|0;b=c>>>0>2];if(K[f+8>>2]>>0&(k|0)(k|0)){break c}e=e+H[f>>2]|0;e=I[e|0]|I[e+1|0]2];x=I[d+36|0];e=H[t>>2]}H[a+132>>2]=e}f=H[d+32>>2];e:{f:{g:{if((x&255)>>>0>2];c=H[f+16>>2];e=c+4|0;b=e>>>0>2];if(K[f+8>>2]>>0&(k|0)(k|0)){break b}c=c+H[f>>2]|0;c=I[c|0]|I[c+1|0]2]=b;H[a+156>>2]=c;l=a+156|0;break g}x=0;if(!Ea(1,t+60|0,f)){break b}d=H[a+4>>2];b=I[d+36|0];H[a+156>>2]=H[t+60>>2];l=a+156|0;if(b>>>0>1){break f}}f=H[d+32>>2];c=H[f+8>>2];k=H[f+12>>2];d=H[f+20>>2];e=H[f+16>>2];b=e+4|0;d=b>>>0>>0>c>>>0&(d|0)>=(k|0)|(d|0)>(k|0)){break b}e=e+H[f>>2]|0;e=I[e|0]|I[e+1|0]2]=d;break e}if(!Ea(1,t+56|0,H[d+32>>2])){break b}e=H[t+56>>2]}if(e>>>0>1431655765|K[l>>2]>N(e,3)>>>0){break b}j=H[a+4>>2];y=H[j+32>>2];d=H[y+8>>2];f=H[y+12>>2];b=H[y+20>>2];m=H[y+16>>2];if((f|0)>>0>=d>>>0|(b|0)>(f|0)){break b}l=H[y>>2];g=I[l+m|0];c=y;k=m+1|0;C=k?b:b+1|0;H[c+16>>2]=k;H[c+20>>2]=C;h:{if(I[j+36|0]>>0>>0>>0&(b|0)>=(f|0)|(b|0)>(f|0)){break b}c=k+l|0;l=I[c|0]|I[c+1|0]2]=b;break h}if(!Ea(1,t+52|0,y)){break b}l=H[t+52>>2]}if(e>>>0>>0|((l>>>0)/3|0)+l>>>0>>0){break b}d=H[a+4>>2];f=H[d+32>>2];i:{if(I[d+36|0]>2];b=H[f+16>>2];c=b+4|0;d=c>>>0>2];if(K[f+8>>2]>>0&(k|0)(k|0)){break b}b=b+H[f>>2]|0;b=I[b|0]|I[b+1|0]2]=d;break i}if(!Ea(1,t+48|0,f)){break b}b=H[t+48>>2]}if(b>>>0>l>>>0){break b}H[a+28>>2]=H[a+24>>2];d=$b(pa(88));c=H[a+8>>2];H[a+8>>2]=d;if(c){cb(c);if(!H[a+8>>2]){break b}}H[a+164>>2]=H[a+160>>2];Jb(a+160|0,e);H[a+176>>2]=H[a+172>>2];Jb(a+172|0,e);H[a- -64>>2]=0;H[a+92>>2]=-1;H[a+84>>2]=-1;H[a+88>>2]=-1;H[a+40>>2]=H[a+36>>2];H[a+52>>2]=H[a+48>>2];H[a+76>>2]=H[a+72>>2];E=a+216|0;ed(E);dd(E,g);if(!Lc(H[a+8>>2],e,H[a+156>>2]+b|0)){break b}d=H[a+156>>2];F[t|0]=1;Oa(a+120|0,b+d|0,t);b=H[a+4>>2];d=J[b+36>>1];d=(d>8)&65535;j:{if(d>>>0>2];k:{if(d>>>0>2];e=H[k+16>>2];d=e+4|0;b=d>>>0>2];if(K[k+8>>2]>>0&(c|0)(c|0)){break b}e=e+H[k>>2]|0;e=I[e|0]|I[e+1|0]2]}if(!e){break b}k=H[H[a+4>>2]+32>>2];c=H[k+8>>2];d=H[k+16>>2];b=c-d|0;d=H[k+12>>2]-(H[k+20>>2]+(c>>>0>>0)|0)|0;if(b>>>0>>0&(d|0)2]+32>>2];c=H[k+16>>2];b=(c+H[k>>2]|0)+e|0;d=H[k+8>>2]-c|0;G[f+38>>1]=J[k+38>>1];H[f>>2]=b;H[f+16>>2]=0;H[f+20>>2]=0;H[f+8>>2]=d-e;H[f+12>>2]=0;d=Ib(a,f);if((d|0)==-1){break b}y=d;M=d>>31;break j}y=-1;M=-1;if((Ib(a,H[b+32>>2])|0)==-1){break b}}O=a+232|0;e=O;H[e+144>>2]=a;d=H[(ea[H[H[a>>2]+32>>2]](a)|0)+32>>2];b=H[d>>2]+H[d+16>>2]|0;d=H[(ea[H[H[a>>2]+32>>2]](a)|0)+32>>2];d=H[d+8>>2]-H[d+16>>2]|0;P=e,Q=J[H[(ea[H[H[a>>2]+32>>2]](a)|0)+32>>2]+38>>1],G[P+38>>1]=Q;H[e>>2]=b;H[e+16>>2]=0;H[e+20>>2]=0;H[e+8>>2]=d;H[e+12>>2]=0;H[a+372>>2]=g;C=Ha(t);l:{if(!Ge(e,C)){break l}b=0;d=0;e=0;k=0;i=ca-96|0;ca=i;H[i+72>>2]=0;H[i+64>>2]=0;H[i+68>>2]=0;H[i+48>>2]=0;H[i+52>>2]=0;H[i+40>>2]=0;H[i+44>>2]=0;H[i+56>>2]=1065353216;H[i+32>>2]=0;H[i+24>>2]=0;H[i+28>>2]=0;h=a;L=H[a+124>>2];m:{n:{o:{p:{q:{r:{if((l|0)>2]!=H[h+220>>2];s=1;while(1){f=k;k=f+1|0;s:{t:{u:{v:{w:{x:{y:{z:{A:{B:{C:{D:{E:{F:{G:{if(!I[h+308|0]){break G}u=H[h+296>>2];g=H[h+304>>2];a=u+(g>>>3|0)|0;p=H[h+300>>2];if(a>>>0>=p>>>0){break G}c=I[a|0];a=g+1|0;H[h+304>>2]=a;m=c>>>(g&7)&1;if(!m){break G}n=0;j=a>>>3|0;c=u+j|0;H:{if(c>>>0>=p>>>0){g=a;a=0;break H}c=I[c|0];g=g+2|0;H[h+304>>2]=g;j=g>>>3|0;a=c>>>(a&7)&1}c=j+u|0;if(c>>>0>>0){c=I[c|0];H[h+304>>2]=g+1;n=c>>>(g&7)2];p=d-4|0;s=H[p>>2];c=-1;I:{if((s|0)==-1){break I}b=s+1|0;b=(b>>>0)%3|0?b:s-2|0;c=-1;if((b|0)==-1){break I}c=H[H[q>>2]+(b2]}b=H[u+(c2];if((b|0)!=-1){a=b+1|0;g=(a>>>0)%3|0?a:b-2|0}if((g|0)==(s|0)){j=-1;break q}if((s|0)!=-1){j=-1;if(H[H[q+12>>2]+(s2]!=-1){break q}}b=H[q+12>>2];if((g|0)!=-1){j=-1;if(H[b+(g2]!=-1){break q}}n=N(f,3);a=n+1|0;H[b+(s2]=a;m=a2]=s;r=n+2|0;H[b+(g2]=r;f=r2]=g;o=-1;a=-1;J:{if((s|0)==-1){break J}K:{if((s>>>0)%3|0){b=s-1|0;break K}b=s+2|0;a=-1;if((b|0)==-1){break J}}a=H[H[q>>2]+(b2]}L:{if((g|0)==-1){break L}b=g+1|0;b=(b>>>0)%3|0?b:g-2|0;if((b|0)==-1){break L}o=H[H[q>>2]+(b2]}j=-1;if((a|0)==(c|0)|(c|0)==(o|0)){break q}b=H[q>>2];H[b+(n2]=c;H[b+m>>2]=o;H[b+f>>2]=a;if((a|0)!=-1){H[u+(a2]=r}b=H[h+120>>2]+(c>>>3&536870908)|0;a=H[b>>2];P=b,Q=Vj(c)&a,H[P>>2]=Q;H[p>>2]=n;b=e;break s}if((d|0)==(e|0)){break q}m=d-4|0;n=H[m>>2];r=H[h+8>>2];b=H[r+12>>2];if((n|0)!=-1&H[b+(n2]!=-1){break q}o=N(f,3);p=(a|0)==5;g=o+(p?2:1)|0;a=g2]=n;H[b+(n2]=g;Ka(r+24|0,11424);b=H[h+8>>2];u=H[b+24>>2];if(H[b+28>>2]-u>>2>(L|0)){break q}j=H[b>>2];q=j+a|0;c=H[r+28>>2];b=H[r+24>>2];a=(c-b>>2)-1|0;H[q>>2]=a;if((b|0)!=(c|0)){H[u+(a2]=g}c=p?o:o+2|0;g=j+(o+p>0)%3|0){a=n-1|0;break P}a=n+2|0;if((a|0)==-1){break O}}a=H[j+(a2];H[j+(c2]=a;if((a|0)==-1){break N}H[u+(a2]=c;break N}H[j+(c2]=-1}a=n+1|0;a=(a>>>0)%3|0?a:n-2|0;b=-1;if((a|0)==-1){break M}b=H[j+(a2]}H[g>>2]=b;H[m>>2]=o;b=e;break y}if((b|0)==(d|0)){break q}a=d-4|0;q=H[a>>2];H[i+68>>2]=a;p=H[i+44>>2];Q:{if(!p){d=a;break Q}g=H[i+40>>2];j=Uj(p)>>>0>1;c=f&p+2147483647;R:{if(!j){break R}c=f;if(c>>>0>>0){break R}c=(f>>>0)%(p>>>0)|0}m=c;c=H[g+(m2];if(!c){d=a;break Q}g=H[c>>2];if(!g){d=a;break Q}S:{if(!j){j=p-1|0;while(1){c=H[g+4>>2];T:{if((c|0)!=(f|0)){if((m|0)==(c&j)){break T}d=a;break Q}if((f|0)==H[g+8>>2]){break S}}g=H[g>>2];if(g){continue}break}d=a;break Q}while(1){c=H[g+4>>2];U:{if((c|0)!=(f|0)){if(c>>>0>=p>>>0){c=(c>>>0)%(p>>>0)|0}if((c|0)==(m|0)){break U}d=a;break Q}if((f|0)==H[g+8>>2]){break S}}g=H[g>>2];if(g){continue}break}d=a;break Q}if((a|0)!=(z|0)){H[a>>2]=H[g+12>>2];H[i+68>>2]=d;break Q}c=z-b|0;d=c>>2;e=d+1|0;if(e>>>0>=1073741824){break C}a=c>>>1|0;c=c>>>0>=2147483644?1073741823:a>>>0>e>>>0?a:e;if(c){if(c>>>0>=1073741824){break n}a=pa(c2];d=e+4|0;if((b|0)!=(z|0)){while(1){e=e-4|0;z=z-4|0;H[e>>2]=H[z>>2];if((b|0)!=(z|0)){continue}break}}z=a+(c2]=z;H[i+68>>2]=d;H[i+64>>2]=e;if(b){oa(b)}}if((d|0)==(e|0)){break u}g=d-4|0;n=H[g>>2];if((n|0)==(q|0)){break u}b=(n|0)==-1;o=H[h+8>>2];if(!b&H[H[o+12>>2]+(n2]!=-1){break u}r=H[o+12>>2];if((q|0)!=-1&H[r+(q2]!=-1){break u}u=N(f,3);f=u+2|0;H[r+(n2]=f;p=f2]=n;a=u+1|0;H[r+(q2]=a;c=a2]=q;if(b){break B}if((n>>>0)%3|0){m=n-1|0;break x}m=n+2|0;if((m|0)!=-1){break x}a=H[o>>2];b=-1;break w}a=H[h+8>>2];Ka(a+24|0,11424);c=H[h+8>>2];q=N(f,3);r=H[a+28>>2];u=H[a+24>>2];p=r-u|0;o=p>>2;g=o-1|0;H[H[c>>2]+(q2]=g;Ka(c+24|0,11424);m=q+1|0;H[H[c>>2]+(m2]=(H[c+28>>2]-H[c+24>>2]>>2)-1;a=H[h+8>>2];Ka(a+24|0,11424);c=q+2|0;H[H[a>>2]+(c2]=(H[a+28>>2]-H[a+24>>2]>>2)-1;a=H[h+8>>2];n=H[a+24>>2];if(H[a+28>>2]-n>>2>(L|0)){break q}V:{W:{if((r|0)!=(u|0)){H[n+(g2]=q;j=0;if((p|0)==-4){break W}}H[n+(o2]=m;j=o+1|0;if((j|0)==-1){break V}}H[n+(j2]=c}if((d|0)!=(z|0)){H[d>>2]=q;d=d+4|0;H[i+68>>2]=d;break y}m=d-b|0;e=m>>2;c=e+1|0;if(c>>>0>=1073741824){break A}a=m>>>1|0;c=m>>>0>=2147483644?1073741823:a>>>0>c>>>0?a:c;if(c){if(c>>>0>=1073741824){break n}a=pa(c2];if((b|0)!=(d|0)){continue}break}}H[i+72>>2]=z;H[i+68>>2]=a;H[i+64>>2]=e;if(!b){break z}oa(b);break z}sa();v()}m=-1;a=H[o>>2];H[a+(u2]=-1;j=-1;break v}sa();v()}d=a;b=e}m=H[h+40>>2];if((m|0)==H[h+36>>2]){break s}c=m-12|0;a=H[c+4>>2];j=(f^-1)+l|0;if(a>>>0>j>>>0){break u}if((a|0)!=(j|0)){break s}f=I[m-4|0];a=H[c>>2];H[h+40>>2]=c;if((a|0)>2];H[i+20>>2]=(a^-1)+l;a=i+20|0;H[i+88>>2]=a;Gb(i,i+40|0,a,i+88|0);c=H[i>>2];X:{if(f&1){a=-1;if((g|0)==-1){break X}a=g+1|0;a=(a>>>0)%3|0?a:g-2|0;break X}a=-1;if((g|0)==-1){break X}a=g-1|0;if((g>>>0)%3|0){break X}a=g+2|0}H[c+12>>2]=a;g=H[h+40>>2];if((g|0)==H[h+36>>2]){break s}while(1){c=g-12|0;a=H[c+4>>2];if(a>>>0>j>>>0){break u}if((a|0)!=(j|0)){break s}f=I[g-4|0];a=H[c>>2];H[h+40>>2]=c;if((a|0)>2];H[i+20>>2]=(a^-1)+l;a=i+20|0;H[i+88>>2]=a;Gb(i,i+40|0,a,i+88|0);c=H[i>>2];Y:{if(f&1){a=-1;if((g|0)==-1){break Y}a=g+1|0;a=(a>>>0)%3|0?a:g-2|0;break Y}a=-1;if((g|0)==-1){break Y}a=g-1|0;if((g>>>0)%3|0){break Y}a=g+2|0}H[c+12>>2]=a;g=H[h+40>>2];if((g|0)!=H[h+36>>2]){continue}break}break s}a=H[o>>2];b=H[a+(m2]}m=b;H[(u2]=b;b=n+1|0;b=(b>>>0)%3|0?b:n-2|0;j=-1;if((b|0)==-1){break v}j=H[(b2]}H[a+c>>2]=j;Z:{if((q|0)==-1){H[a+p>>2]=-1;n=-1;c=-1;break Z}_:{$:{aa:{if((q>>>0)%3|0){b=q-1|0;break aa}b=q+2|0;if((b|0)==-1){break $}}b=H[(b2];H[a+p>>2]=b;if((b|0)==-1){break _}H[H[o+24>>2]+(b2]=f;break _}H[a+p>>2]=-1}n=-1;b=q+1|0;b=(b>>>0)%3|0?b:q-2|0;c=-1;if((b|0)==-1){break Z}n=H[(b2];c=b}b=H[o+24>>2];p=b+(n2]}b=c;while(1){if((b|0)==-1){break t}H[(b2]=m;j=b+1|0;b=(j>>>0)%3|0?j:b-2|0;f=-1;ba:{if((b|0)==-1){break ba}j=H[r+(b2];f=-1;if((j|0)==-1){break ba}b=j+1|0;f=(b>>>0)%3|0?b:j-2|0}b=f;if((c|0)!=(b|0)){continue}break}}j=-1;if(!(s&1)){break r}break q}H[p>>2]=-1;ca:{if(A){break ca}if((B|0)!=(D|0)){H[D>>2]=n;D=D+4|0;H[i+28>>2]=D;break ca}f=B-w|0;b=f>>2;c=b+1|0;if(c>>>0>=1073741824){break o}a=f>>>1|0;c=f>>>0>=2147483644?1073741823:a>>>0>c>>>0?a:c;if(c){if(c>>>0>=1073741824){break n}a=pa(c2]=H[B>>2];if((w|0)!=(B|0)){continue}break}}B=a+(c2]=B;H[i+28>>2]=D;H[i+24>>2]=b;if(w){oa(w)}w=b}H[g>>2]=u;b=e}s=(k|0)>2];if(H[a+28>>2]-H[a+24>>2]>>2>(L|0)){break q}if((d|0)!=(e|0)){u=h+72|0;m=h+60|0;p=h+312|0;while(1){d=d-4|0;o=H[d>>2];H[i+68>>2]=d;da:{ea:{fa:{if(J[h+270>>1]>2];a=H[h+352>>2]+(b>>>3|0)|0;if(a>>>0>=K[h+356>>2]){break fa}a=I[a|0];H[h+360>>2]=b+1;if(!(a>>>(b&7)&1)){break fa}break ea}if(Ba(p)){break ea}}ga:{ha:{b=H[h+64>>2];c=H[h+68>>2];if((b|0)==c00>>0?c:b}else{a=2147483647}pb(m,a);b=H[h+64>>2]}H[h+64>>2]=b+1;c=H[h+60>>2]+(b>>>3&536870908)|0;a=H[c>>2];P=c,Q=Vj(b)&a,H[P>>2]=Q;b=H[h+76>>2];if((b|0)!=H[h+80>>2]){H[b>>2]=o;H[h+76>>2]=b+4;break da}l=H[u>>2];w=b-l|0;c=w>>2;f=c+1|0;if(f>>>0>=1073741824){break ga}a=w>>>1|0;f=w>>>0>=2147483644?1073741823:a>>>0>f>>>0?a:f;if(f){if(f>>>0>=1073741824){break n}a=pa(f2]=H[b>>2];if((b|0)!=(l|0)){continue}break}}H[h+80>>2]=a+(f2]=c;H[h+72>>2]=g;if(!l){break da}oa(l);break da}sa();v()}sa();v()}r=H[h+8>>2];A=H[r>>2];if(((H[r+4>>2]-A>>2>>>0)/3|0)>2];f=-1;ia:{if((o|0)==-1){break ia}e=o+1|0;e=(e>>>0)%3|0?e:o-2|0;f=-1;if((e|0)==-1){break ia}f=H[A+(e2]}l=H[w+(f2];ja:{if((l|0)==-1){g=1;e=-1;break ja}g=1;c=l+1|0;c=(c>>>0)%3|0?c:l-2|0;e=-1;if((c|0)==-1){break ja}g=0;a=c;e=a+1|0;e=(e>>>0)%3|0?e:a-2|0;if((e|0)!=-1){e=H[A+(e2]}else{e=-1}}c=H[(e2];if((c|0)!=-1){b=c+1|0;b=(b>>>0)%3|0?b:c-2|0}if((a|0)==(o|0)|(b|0)==(o|0)|((o|0)!=-1&H[H[r+12>>2]+(o2]!=-1|(a|0)==(b|0))){break q}if(!g&H[H[r+12>>2]+(a2]!=-1){break q}g=-1;l=H[r+12>>2];w=-1;ka:{if((b|0)==-1){break ka}if(H[l+(b2]!=-1){break q}c=b+1|0;c=(c>>>0)%3|0?c:b-2|0;w=-1;if((c|0)==-1){break ka}w=H[A+(c2]}c=N(k,3);H[i>>2]=c;H[l+(c2]=o;H[l+(o2]=c;c=H[i>>2]+1|0;H[l+(c2]=a;H[l+(a2]=c;a=H[i>>2]+2|0;H[l+(a2]=b;H[l+(b2]=a;a=H[i>>2];H[A+(a2]=e;j=a+1|0;l=A+(j2]=w;w=a+2|0;c=A+(w2]=f;f=H[h+120>>2];e=j?e:-1;b=f+(e>>>3&536870908)|0;a=H[b>>2];P=b,Q=Vj(e)&a,H[P>>2]=Q;g=(j|0)!=-1?H[l>>2]:g;b=f+(g>>>3&536870908)|0;a=H[b>>2];P=b,Q=Vj(g)&a,H[P>>2]=Q;b=-1;b=(w|0)!=-1?H[c>>2]:b;e=f+(b>>>3&536870908)|0;a=H[e>>2];P=e,Q=Vj(b)&a,H[P>>2]=Q;F[i+88|0]=1;_c(m,i+88|0);Ka(u,i);k=k+1|0;e=H[i+64>>2]}if((d|0)!=(e|0)){continue}break}a=H[h+8>>2]}j=-1;if(((H[a+4>>2]-H[a>>2]>>2>>>0)/3|0)!=(k|0)){break q}j=H[a+28>>2]-H[a+24>>2]>>2;s=H[i+24>>2];c=H[i+28>>2];if((s|0)==(c|0)){break p}while(1){k=H[s>>2];d=H[a+24>>2];b=j-1|0;g=d+(b2]==-1){while(1){b=j-2|0;j=j-1|0;g=d+(b2]==-1){continue}break}}if(b>>>0>=k>>>0){H[i>>2]=a;g=H[g>>2];F[i+12|0]=1;H[i+8>>2]=g;H[i+4>>2]=g;if((g|0)!=-1){while(1){a=H[H[h+8>>2]>>2]+(g2]!=(b|0)){j=-1;break q}H[a>>2]=k;uc(i);g=H[i+8>>2];if((g|0)!=-1){continue}break}a=H[h+8>>2]}d=H[a+24>>2];e=d+(b2]}H[e>>2]=-1;f=12];e=d+(k>>>3&536870908)|0;k=d+(b>>>3&536870908)|0;d=12]&d){b=f|H[e>>2]}else{b=H[e>>2]&(f^-1)}H[e>>2]=b;H[k>>2]=H[k>>2]&(d^-1);j=j-1|0}s=s+4|0;if((c|0)!=(s|0)){continue}break}}s=H[i+24>>2]}if(s){oa(s)}a=H[i+48>>2];if(a){while(1){d=H[a>>2];oa(a);a=d;if(a){continue}break}}a=H[i+40>>2];H[i+40>>2]=0;if(a){oa(a)}a=H[i+64>>2];if(a){H[i+68>>2]=a;oa(a)}ca=i+96|0;a=j;break m}sa();v()}wa();v()}e=a;if((a|0)==-1){break l}b=H[C+16>>2];d=b+H[C>>2]|0;a=H[C+8>>2]-b|0;b=H[H[h+4>>2]+32>>2];G[b+38>>1]=J[b+38>>1];H[b>>2]=d;H[b+16>>2]=0;H[b+20>>2]=0;H[b+8>>2]=a;H[b+12>>2]=0;b=H[h+4>>2];a=J[b+36>>1];d=a>8;if((d&65535)>>>0>2];c=b;a=H[b+16>>2];b=M+H[b+20>>2]|0;a=a+y|0;b=a>>>0>>0?b+1|0:b;H[c+16>>2]=a;H[c+20>>2]=b}la:{if(H[h+216>>2]==H[h+220>>2]){break la}a=H[h+8>>2];b=H[a>>2];a=H[a+4>>2];ma:{if((d&65535)>>>0>=513){if((a|0)==(b|0)){break la}d=0;break ma}if((a|0)==(b|0)){break la}d=0;while(1){if(cd(h,d)){d=d+3|0;a=H[h+8>>2];if(d>>>0>2]-H[a>>2]>>2>>>0){continue}break la}break}break l}while(1){if(bd(h,d)){d=d+3|0;a=H[h+8>>2];if(d>>>0>2]-H[a>>2]>>2>>>0){continue}break la}break}break l}ad(O);d=H[h+216>>2];if((d|0)!=H[h+220>>2]){l=0;while(1){c=N(l,144);Jc((c+d|0)+4|0,H[h+8>>2]);a=H[E>>2];b=a+c|0;d=H[b+132>>2];b=H[b+136>>2];if((d|0)!=(b|0)){while(1){Hc((c+H[E>>2]|0)+4|0,H[d>>2]);d=d+4|0;if((b|0)!=(d|0)){continue}break}a=H[E>>2]}if(!Ic((a+c|0)+4|0)){break l}l=l+1|0;d=H[h+216>>2];if(l>>>0>2]-d|0)/144>>>0){continue}break}}a=H[h+8>>2];Hb(h+184|0,H[a+28>>2]-H[a+24>>2]>>2);x=H[h+216>>2];if((x|0)!=H[h+220>>2]){d=0;while(1){a=N(d,144)+x|0;b=H[a+60>>2]-H[a+56>>2]>>2;c=a+104|0;a=H[h+8>>2];a=H[a+28>>2]-H[a+24>>2]>>2;Hb(c,(a|0)>2];if(d>>>0>2]-x|0)/144>>>0){continue}break}}x=$c(h,e)}break b}x=0}ca=t- -64|0;return x|0}function Bg(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,G=0,J=0,K=0,L=0,M=0,O=0;B=c;c=0;m=ca-96|0;ca=m;l=m+16|0;ra(l,0,76);H[m+92>>2]=-1;H[m+8>>2]=0;H[m>>2]=0;H[m+4>>2]=0;r=ca-16|0;ca=r;H[l+68>>2]=0;H[l+72>>2]=0;H[l>>2]=b;s=ca-16|0;ca=s;u=b;a=H[b+20>>2];a:{if((H[b+24>>2]-a|0)>2];if((a|0)==-1){break a}c=H[H[u+8>>2]+(a2]}b:{c:{d:{if(!c){a=0;break d}a=H[u+100>>2];e=H[u+96>>2];H[s+8>>2]=0;H[s>>2]=0;H[s+4>>2]=0;f=a-e|0;b=(f|0)/12|0;e:{if((a|0)==(e|0)){break e}if(b>>>0>=357913942){break c}d=pa(f);H[s>>2]=d;H[s+8>>2]=d+N(b,12);a=0;n=d;f=f-12|0;d=(f-((f>>>0)%12|0)|0)+12|0;f=ra(n,0,d);H[s+4>>2]=d+f;if(I[c+84|0]){c=b>>>0>>0>=2){g=c&-2;c=0;while(1){d=N(a,12);b=d+e|0;i=H[b+4>>2];j=H[b>>2];d=d+f|0;H[d+8>>2]=H[b+8>>2];H[d>>2]=j;H[d+4>>2]=i;d=N(a|1,12);b=d+e|0;i=H[b+4>>2];j=H[b>>2];d=d+f|0;H[d+8>>2]=H[b+8>>2];H[d>>2]=j;H[d+4>>2]=i;a=a+2|0;c=c+2|0;if((g|0)!=(c|0)){continue}break}}if(!h){break e}b=N(a,12);a=b+e|0;c=H[a+4>>2];e=H[a>>2];b=b+f|0;H[b+8>>2]=H[a+8>>2];H[b>>2]=e;H[b+4>>2]=c;break e}h=b>>>0>2];c=0;while(1){d=N(c,12);b=d+e|0;g=H[a+(H[b>>2]2];i=H[a+(H[b+4>>2]2];d=d+f|0;H[d+8>>2]=H[a+(H[b+8>>2]2];H[d+4>>2]=i;H[d>>2]=g;c=c+1|0;if((h|0)!=(c|0)){continue}break}}d=0;E=ca-16|0;ca=E;h=pa(88);$b(h);C=ca-16|0;ca=C;H[h+80>>2]=0;H[h+84>>2]=0;a=H[h+76>>2];H[h+76>>2]=0;if(a){oa(a)}H[h+68>>2]=0;H[h+72>>2]=0;b=h- -64|0;a=H[b>>2];H[b>>2]=0;if(a){oa(a)}g=H[s+4>>2];b=H[s>>2];c=(g-b|0)/12|0;a=N(c,3);f=H[h>>2];e=H[h+4>>2]-f>>2;f:{if(a>>>0>e>>>0){ue(h,a-e|0);g=H[s+4>>2];b=H[s>>2];c=(g-b|0)/12|0;break f}if(a>>>0>=e>>>0){break f}H[h+4>>2]=f+(a>0>2];if(c>>>0>=2){i=e&-2;c=0;while(1){e=N(d,12);j=e+a|0;f=b+e|0;H[j>>2]=H[f>>2];H[a+(e|4)>>2]=H[f+4>>2];H[j+8>>2]=H[f+8>>2];f=N(d|1,12);e=f+a|0;f=b+f|0;H[e>>2]=H[f>>2];H[e+4>>2]=H[f+4>>2];H[e+8>>2]=H[f+8>>2];d=d+2|0;c=c+2|0;if((i|0)!=(c|0)){continue}break}}if(!g){break g}c=N(d,12);a=c+a|0;b=b+c|0;H[a>>2]=H[b>>2];H[a+4>>2]=H[b+4>>2];H[a+8>>2]=H[b+8>>2]}H[C+12>>2]=-1;a=0;e=0;g=0;f=ca-32|0;ca=f;h:{i:{w=C+12|0;j:{if(!w){break j}c=H[h+4>>2];j=H[h>>2];d=c-j|0;i=d>>2;n=H[h+12>>2];b=H[h+16>>2]-n>>2;k:{if(i>>>0>b>>>0){qb(h+12|0,i-b|0,13652);c=H[h+4>>2];j=H[h>>2];d=c-j|0;i=d>>2;break k}if(b>>>0>>0){break k}H[h+16>>2]=n+(i2]=0;H[f+16>>2]=0;H[f+20>>2]=0;b=(c|0)==(j|0);if(!b){if((d|0)>2]=e;H[f+16>>2]=e;H[f+24>>2]=(i2]-e>>2;q:{if(i>>>0>>0){break q}H[f>>2]=0;d=i+1|0;if(d>>>0>b>>>0){Pa(f+16|0,d-b|0,f);j=H[h>>2];c=H[h+4>>2];e=H[f+16>>2];break q}if(b>>>0>>0){break q}H[f+20>>2]=(d2]+1;a=a+1|0;d=c-j|0;i=d>>2;if(a>>>0>>0){continue}break}break p}d=0;if(!b){break o}break n}if((c|0)==(j|0)){d=0;break n}if(d>>>0>=2147483645){break m}}d=pa(d2]=0;H[f+4>>2]=0;b=H[f+20>>2];a=b-e|0;t=a>>2;r:{s:{if((b|0)==(e|0)){break s}if((a|0)>2]=q;H[f+8>>2]=(t2]=b+a;c=t>>>0>>0>=3){o=c&-4;while(1){c=g2]=a;x=c|4;a=H[c+e>>2]+a|0;H[x+b>>2]=a;y=c|8;a=a+H[e+x>>2]|0;H[y+b>>2]=a;c=c|12;a=a+H[e+y>>2]|0;H[c+b>>2]=a;a=a+H[c+e>>2]|0;g=g+4|0;p=p+4|0;if((o|0)!=(p|0)){continue}break}}if(!n){break s}while(1){c=g2]=a;g=g+1|0;a=H[c+e>>2]+a|0;k=k+1|0;if((n|0)!=(k|0)){continue}break}}if(!i){break l}x=H[h+40>>2];y=H[h+12>>2];n=0;while(1){G=n>0)%3|0?c:n-2|0;if((b|0)!=-1){k=H[(b2]}b=H[a>>2];t:{u:{if(!((n>>>0)%3|0)){p=-1;a=n+2|0;if((a|0)!=-1){p=H[(a2]}if(!((b|0)==(k|0)|(b|0)==(p|0))&(k|0)!=(p|0)){break u}x=x+1|0;H[h+40>>2]=x;c=n+3|0;break t}p=H[a-4>>2]}a=p2];v:{w:{if((A|0)>2];g=0;while(1){o=(a2];if((z|0)==-1){break w}x:{if((k|0)!=(z|0)){break x}o=H[o+4>>2];if((o|0)!=-1){z=H[(o2]}else{z=-1}if((z|0)==(b|0)){break x}while(1){y:{b=a;g=g+1|0;if((A|0)>2];H[K>>2]=z;if((z|0)!=-1){continue}}break}H[(b2]=-1;if((o|0)==-1){break w}H[y+G>>2]=o;H[y+(o2]=n;break v}a=a+1|0;g=g+1|0;if((A|0)!=(g|0)){continue}break}}a=k2];if((k|0)>2];g=0;while(1){b=(a2]==-1){H[b>>2]=p;H[b+4>>2]=n;break v}a=a+1|0;g=g+1|0;if((k|0)!=(g|0)){continue}break}}}n=c;if(n>>>0>>0){continue}break}break l}break i}sa();v()}H[w>>2]=t;if(q){oa(q)}if(d){oa(d)}a=H[f+16>>2];if(!a){break j}H[f+20>>2]=a;oa(a)}ca=f+32|0;x=(w|0)!=0;if(x){k=ca-32|0;ca=k;a=H[h>>2];g=H[h+4>>2];H[k+24>>2]=0;H[k+16>>2]=0;H[k+20>>2]=0;if((a|0)==(g|0)){c=g}else{a=g-a|0;if((a|0)>2;b=(a-1>>>5|0)+1|0;c=pa(b2]=b;H[k+20>>2]=0;H[k+16>>2]=c;Mc(k+16|0,a);g=H[h>>2];c=H[h+4>>2]}H[k+8>>2]=0;H[k>>2]=0;while(1){z:{o=0;i=0;if((c|0)==(g|0)){break z}while(1){b=H[k+16>>2];A:{if(H[b+(i>>>3&536870908)>>2]>>>i&1){break A}c=H[k>>2];H[k+4>>2]=c;e=H[h+12>>2];a=i;while(1){B:{f=a+1|0;d=a;a=(f>>>0)%3|0?f:a-2|0;if((a|0)==-1){break B}a=H[e+(a2];if((a|0)==-1){break B}f=a+1|0;a=(f>>>0)%3|0?f:a-2|0;if((i|0)==(a|0)|(a|0)==-1){break B}if(!(H[b+(a>>>3&536870908)>>2]>>>a&1)){continue}}break}j=d;C:{D:{E:{while(1){a=H[k+16>>2]+(j>>>3&536870908)|0;H[a>>2]=H[a>>2]|1>0)%3|0?a:j-2|0;g=H[h>>2];y=(j>>>0)%3|0;b=(y?-1:2)+j|0;n=H[k>>2];A=(n|0)==(c|0);F:{if(A){break F}w=H[(f2];q=H[h+12>>2];a=n;if((b|0)!=-1){e=q+(b2]){break G}p=H[a+4>>2];t=H[e>>2];if((p|0)==(t|0)){break G}e=b;c=-1;a=-1;if((p|0)==-1){break C}break D}a=a+8|0;if((c|0)!=(a|0)){continue}break}break F}while(1){if((w|0)==H[a>>2]){t=-1;e=-1;p=H[a+4>>2];if((p|0)!=-1){break D}}a=a+8|0;if((c|0)!=(a|0)){continue}break}}b=H[(b2];H:{if(H[k+8>>2]!=(c|0)){H[c>>2]=b;H[c+4>>2]=f;c=c+8|0;H[k+4>>2]=c;break H}a=c-n|0;p=a>>3;e=p+1|0;if(e>>>0>=536870912){break i}g=a>>>2|0;g=a>>>0>=2147483640?536870911:e>>>0>>0?g:e;if(g){if(g>>>0>=536870912){break E}e=pa(g2]=f;b=a+8|0;if(!A){while(1){c=c-8|0;f=H[c+4>>2];a=a-8|0;H[a>>2]=H[c>>2];H[a+4>>2]=f;if((c|0)!=(n|0)){continue}break}c=H[k>>2]}H[k+8>>2]=e+(g2]=b;H[k>>2]=a;if(c){oa(c)}c=b}I:{J:{if(y){a=j-1|0;break J}a=j+2|0;if((a|0)==-1){break I}}a=H[H[h+12>>2]+(a2];if((a|0)==-1){break I}j=a+((a>>>0)%3|0?-1:2)|0;if((d|0)==(j|0)){break I}if((j|0)!=-1){continue}}break}g=H[h>>2];break A}wa();v()}c=H[q+(p2];b=e;a=p}if((t|0)!=-1){H[q+(t2]=-1}if((c|0)!=-1){H[q+(c2]=-1}H[q+(b2]=-1;H[q+(a2]=-1;o=1}i=i+1|0;c=H[h+4>>2];if(i>>>0>2>>>0){continue}break}if(o){continue}}break}a=H[k>>2];if(a){oa(a)}a=H[k+16>>2];if(a){oa(a)}ca=k+32|0;n=0;g=ca-32|0;ca=g;e=H[C+12>>2];H[h+36>>2]=e;p=h+24|0;b=H[h+24>>2];a=H[h+28>>2]-b>>2;K:{L:{if(a>>>0>>0){qb(p,e-a|0,13652);H[g+24>>2]=0;H[g+16>>2]=0;H[g+20>>2]=0;break L}if(a>>>0>e>>>0){H[h+28>>2]=b+(e2]=0;H[g+16>>2]=0;H[g+20>>2]=0;if(!e){break K}}if((e|0)>>5|0)+1|0;b=pa(a2]=a;H[g+20>>2]=0;H[g+16>>2]=b;Mc(g+16|0,e)}a=H[h>>2];b=H[h+4>>2];H[g+8>>2]=0;H[g>>2]=0;H[g+4>>2]=0;M:{if((a|0)==(b|0)){a=b}else{a=b-a|0;if((a|0)>2;b=(a-1>>>5|0)+1|0;c=pa(b2]=b;H[g+4>>2]=0;H[g>>2]=c;Mc(g,a);b=H[h>>2];a=H[h+4>>2]}if(a-b>>>0>2];if((i|0)==(f|0)|(c|0)==(f|0)){break O}k=0;i=H[g>>2];while(1){f=k+q|0;if(!(H[(f>>>3&536870908)+i>>2]>>>f&1)){a=H[(f2];c=12];b=a>>>5|0;i=H[d+(b2];t=c&i;if(t){c=H[h+28>>2];P:{if((c|0)!=H[h+32>>2]){H[c>>2]=-1;H[h+28>>2]=c+4;break P}i=H[p>>2];b=c-i|0;o=b>>2;d=o+1|0;if(d>>>0>=1073741824){break i}j=b>>>1|0;j=b>>>0>=2147483644?1073741823:d>>>0>>0?j:d;if(j){if(j>>>0>=1073741824){break N}b=pa(j2]=H[c>>2];if((c|0)!=(i|0)){continue}break}}H[h+32>>2]=b+(j2]=o;H[h+24>>2]=d;if(!i){break P}oa(i)}c=H[h+52>>2];Q:{if((c|0)!=H[h+56>>2]){H[c>>2]=a;H[h+52>>2]=c+4;break Q}i=H[h+48>>2];b=c-i|0;o=b>>2;d=o+1|0;if(d>>>0>=1073741824){break i}j=b>>>1|0;j=b>>>0>=2147483644?1073741823:d>>>0>>0?j:d;if(j){if(j>>>0>=1073741824){break N}b=pa(j2]=H[c>>2];if((c|0)!=(i|0)){continue}break}}H[h+56>>2]=b+(j2]=a;H[h+48>>2]=d;if(!i){break Q}oa(i)}c=H[g+20>>2];a=H[g+24>>2];if((c|0)==a00>c>>>0?a:c}else{a=2147483647}pb(b,a);c=H[g+20>>2]}H[g+20>>2]=c+1;d=H[g+16>>2];a=d+(c>>>3&536870908)|0;b=H[a>>2];M=a,O=Vj(c)&b,H[M>>2]=O;c=1>5|0;i=H[(b2];a=e;e=a+1|0}H[(b2]=c|i;o=H[h+24>>2]+(a2];b=H[h>>2];i=H[g>>2];c=f;R:{S:{T:{while(1){if((c|0)==-1){break T}d=(c>>>3&536870908)+i|0;H[d>>2]=H[d>>2]|12]=c;if(t){H[(c2]=a}w=c+1|0;c=(w>>>0)%3|0?w:c-2|0;d=-1;U:{if((c|0)==-1){break U}c=H[j+(c2];d=-1;if((c|0)==-1){break U}d=c+1|0;d=(d>>>0)%3|0?d:c-2|0}c=d;if((f|0)!=(c|0)){continue}break}if((f|0)!=-1){break R}c=1;break S}if((f>>>0)%3|0){c=f-1|0;break S}c=f+2|0;if((c|0)==-1){break R}}c=H[j+(c2];if((c|0)==-1){break R}V:{if((c>>>0)%3|0){c=c-1|0;break V}c=c+2|0;if((c|0)==-1){break R}}f=H[h+12>>2];b=H[h>>2];while(1){d=(c>>>3&536870908)+i|0;H[d>>2]=H[d>>2]|1>0)%3|0){c=c-1|0;break W}c=c+2|0;if((c|0)==-1){break R}}c=H[f+(c2];if((c|0)==-1){break R}c=c+((c>>>0)%3|0?-1:2)|0;if((c|0)!=-1){continue}break}}}k=k+1|0;if((k|0)!=3){continue}break}b=H[h>>2];a=H[h+4>>2]}n=n+1|0;if(n>>>0>2>>>0)/3>>>0){continue}break}break M}wa();v()}c=0;H[h+44>>2]=0;a=H[g+16>>2];b=H[g+20>>2];if(b){e=b&31;b=(b>>>3&536870908)+a|0;d=a;i=0;while(1){if(!(H[d>>2]>>>c&1)){i=i+1|0;H[h+44>>2]=i}f=(c|0)==31;c=f?0:c+1|0;d=(f2];if(b){oa(b);a=H[g+16>>2]}if(a){oa(a)}ca=g+32|0}ca=C+16|0;if(!x){H[E+8>>2]=0;cb(h);h=0}ca=E+16|0;a=h;break h}sa();v()}b=H[s>>2];if(!b){break d}H[s+4>>2]=b;oa(b)}ca=s+16|0;break b}sa();v()}c=H[l+4>>2];b=a;H[l+4>>2]=a;if(c){cb(c);b=H[l+4>>2]}X:{if(!b){break X}a=H[u+100>>2];c=H[u+96>>2];F[r+12|0]=0;Oa(l+56|0,(a-c|0)/12|0,r+12|0);a=H[u+100>>2];c=H[u+96>>2];if((a|0)==(c|0)){break X}while(1){if(!(H[H[l+56>>2]+(D>>>3&536870908)>>2]>>>D&1)){a=N(D,3);Gc(l,0,a);c=H[l+8>>2];e=H[l+12>>2];Gc(l,1,a+1|0);f=H[l+20>>2];d=H[l+24>>2];Gc(l,2,a+2|0);n=(c|0)==(e|0)?-1:0;a=d-f>>2;c=e-c>>2;e=a>>>0>c>>>0;c=H[l+36>>2]-H[l+32>>2]>>2>>>0>(e?a:c)>>>0?2:e?1:n;Y:{if(H[l+68>>2]>2]=H[l+76>>2];H[r+8>>2]=m;bb(r+8|0,r+12|0);a=H[((c2];if((a|0)>>0)/3|0;a=H[(H[H[l>>2]+96>>2]+N(e,12)|0)+(a-N(e,3)2]}H[r+12>>2]=a;H[r+8>>2]=m;bb(r+8|0,r+12|0);e=H[l+72>>2];H[l+72>>2]=e+2;if(!(e&1)){break Y}H[r+12>>2]=a;H[r+8>>2]=m;bb(r+8|0,r+12|0);H[l+72>>2]=H[l+72>>2]+1}d=0;e=ca-16|0;ca=e;H[l+68>>2]=H[l+68>>2]+1;a=N(c,12)+l|0;a=H[a+12>>2]-H[a+8>>2]|0;if((a|0)>0){a=a>>>2|0;h=a>>>0>>0)/3|0;c=(a|0)==-1;g=c?-1:f;i=H[l+56>>2]+(g>>>3&536870908)|0;H[i>>2]=H[i>>2]|12]=H[l+72>>2]+1;Z:{_:{$:{aa:{ba:{if(!d){ca:{if((a|0)>=0){H[e+12>>2]=H[(H[H[l>>2]+96>>2]+N(f,12)|0)+((a>>>0)%32];H[e+8>>2]=m;bb(e+8|0,e+12|0);break ca}H[e+12>>2]=-1;H[e+8>>2]=m;bb(e+8|0,e+12|0);if(c){break ba}}c=-1;f=a+1|0;f=(f>>>0)%3|0?f:a-2|0;if((f|0)>=0){g=(f>>>0)/3|0;f=H[(H[H[l>>2]+96>>2]+N(g,12)|0)+(f-N(g,3)2]}else{f=-1}H[e+12>>2]=f;H[e+8>>2]=m;bb(e+8|0,e+12|0);f=((a>>>0)%3|0?-1:2)+a|0;if((f|0)>>0)/3|0;c=H[(H[H[l>>2]+96>>2]+N(c,12)|0)+(f-N(c,3)2];break aa}c=(a|0)>2]+96>>2]+N(f,12)|0)+((a>>>0)%32];H[l+76>>2]=c;H[e+12>>2]=c;H[e+8>>2]=m;bb(e+8|0,e+12|0);if(d&1){c=-1;if((a|0)==-1){break Z}if((N(f,3)|0)!=(a|0)){a=a-1|0;break _}a=a+2|0;break $}c=-1;if((a|0)==-1){break Z}c=a+1|0;a=(c>>>0)%3|0?c:a-2|0;break $}c=-1;H[e+12>>2]=-1;H[e+8>>2]=m;bb(e+8|0,e+12|0)}H[l+76>>2]=c;H[e+12>>2]=c;H[e+8>>2]=m;bb(e+8|0,e+12|0)}c=-1;if((a|0)==-1){break Z}}c=H[H[H[l+4>>2]+12>>2]+(a2]}d=d+1|0;if((h|0)!=(d|0)){continue}break}}ca=e+16|0;c=H[u+96>>2];a=H[u+100>>2]}D=D+1|0;if(D>>>0>>0){continue}break}}ca=r+16|0;da:{if(b){a=H[B>>2];if(a){H[B+4>>2]=a;oa(a)}H[B>>2]=H[m>>2];H[B+4>>2]=H[m+4>>2];H[B+8>>2]=H[m+8>>2];L=H[m+84>>2];break da}a=H[m>>2];if(!a){break da}H[m+4>>2]=a;oa(a)}a=H[m+72>>2];if(a){oa(a)}a=H[m+48>>2];if(a){H[m+52>>2]=a;oa(a)}a=H[m+36>>2];if(a){H[m+40>>2]=a;oa(a)}a=H[m+24>>2];if(a){H[m+28>>2]=a;oa(a)}a=H[m+20>>2];H[m+20>>2]=0;if(a){cb(a)}ca=m+96|0;return L|0}function qg(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0;i=b;a=0;b=0;a:{b:{switch(d-1|0){case 0:j=H[i+80>>2];h=I[c+24|0];c:{if((N(j,h)|0)!=(e|0)){break c}d=H[c+28>>2]!=1;b=I[c+84|0];if(!(d|!b)){qa(f,H[H[c>>2]>>2]+H[c+48>>2]|0,e);b=1;break c}if(h){a=pa(h);ra(a,0,h)}d:{if(!j){b=1;break d}if(!d){if(h){d=0;e=0;while(1){i=d+f|0;k=H[H[c>>2]>>2];m=H[c+48>>2];g=H[c+40>>2];b=Rj(g,H[c+44>>2],I[c+84|0]?e:H[H[c+68>>2]+(e2],0);n=b;b=b+m|0;qa(i,qa(a,b+k|0,g),h);d=d+h|0;b=1;e=e+1|0;if((j|0)!=(e|0)){continue}break}break d}if(b){b=1;h=H[c>>2];e=H[c+48>>2];f=H[c+40>>2];i=H[c+44>>2];if((j|0)!=1){g=j&-2;c=0;d=0;while(1){k=H[h>>2];m=Rj(f,i,c,0)+e|0;k=qa(a,k+m|0,f);m=H[h>>2];n=Rj(f,i,c|1,0)+e|0;qa(k,m+n|0,f);c=c+2|0;d=d+2|0;if((g|0)!=(d|0)){continue}break}g=c}if(!(j&1)){break d}c=H[h>>2];d=Rj(g,0,f,i)+e|0;qa(a,c+d|0,f);break d}b=1;h=H[c>>2];e=H[c+48>>2];g=H[c+68>>2];f=H[c+40>>2];i=H[c+44>>2];c=0;if((j|0)!=1){k=j&-2;d=0;while(1){m=H[h>>2];n=c2],0)+e|0;m=qa(a,m+l|0,f);l=H[h>>2];n=Rj(f,i,H[g+(n|4)>>2],0)+e|0;qa(m,l+n|0,f);c=c+2|0;d=d+2|0;if((k|0)!=(d|0)){continue}break}}if(!(j&1)){break d}d=H[h>>2];c=Rj(f,i,H[g+(c2],0)+e|0;qa(a,c+d|0,f);break d}b=0;if(!h){d=0;while(1){if(!ic(c,I[c+84|0]?d:H[H[c+68>>2]+(d2],F[c+24|0],a)){break d}d=d+1|0;b=j>>>0>>0;if((d|0)!=(j|0)){continue}break}break d}d=0;e=0;while(1){if(!ic(c,I[c+84|0]?e:H[H[c+68>>2]+(e2],F[c+24|0],a)){break d}qa(d+f|0,a,h);d=d+h|0;e=e+1|0;b=j>>>0>>0;if((e|0)!=(j|0)){continue}break}}if(!a){break c}oa(a)}break a;case 2:n=I[c+24|0];l=n2];e:{if((N(l,j)|0)!=(e|0)){break e}i=H[c+28>>2]!=3;d=I[c+84|0];if(!(i|!d)){qa(f,H[H[c>>2]>>2]+H[c+48>>2]|0,e);a=1;break e}f:{if(!n){e=0;break f}e=pa(l);ra(e,0,l)}g:{if(!j){a=1;break g}if(!i){o=H[c+68>>2];k=H[c>>2];b=H[c+48>>2];i=H[c+40>>2];m=H[c+44>>2];if(n){if(!d){c=0;d=0;while(1){a=1;g=H[k>>2];p=Rj(i,m,H[o+(d2],0)+b|0;qa((c2];p=Rj(g,h,i,m)+b|0;qa((c2];g=c2],0)+b|0;h=qa(e,h+n|0,i);n=H[k>>2];g=Rj(i,m,H[o+(g|4)>>2],0)+b|0;qa(h,g+n|0,i);c=c+2|0;d=d+2|0;if((f|0)!=(d|0)){continue}break}}if(!(j&1)){break g}d=H[k>>2];b=Rj(i,m,H[o+(c2],0)+b|0;qa(e,b+d|0,i);break g}n=j&1;a=1;if((j|0)!=1){j=j&-2;f=0;c=0;while(1){d=H[k>>2];l=Rj(g,h,i,m)+b|0;d=qa(e,d+l|0,i);l=H[k>>2];o=Rj(i,m,g|1,h)+b|0;qa(d,l+o|0,i);g=g+2|0;h=g>>>0>>0>2];b=Rj(g,h,i,m)+b|0;qa(e,b+c|0,i);break g}if(!n){d=0;while(1){if(!gc(c,I[c+84|0]?d:H[H[c+68>>2]+(d2],F[c+24|0],e)){break g}d=d+1|0;a=j>>>0>>0;if((d|0)!=(j|0)){continue}break}break g}d=0;while(1){if(!gc(c,I[c+84|0]?d:H[H[c+68>>2]+(d2],F[c+24|0],e)){break g}qa((b>0>>0;if((d|0)!=(j|0)){continue}break}}if(!e){break e}oa(e)}b=a;break a;case 4:l=I[c+24|0];o=l2];h:{if((N(o,j)|0)!=(e|0)){break h}i=H[c+28>>2]!=5;d=I[c+84|0];if(!(i|!d)){qa(f,H[H[c>>2]>>2]+H[c+48>>2]|0,e);b=1;break h}i:{if(!l){e=0;break i}e=pa(o);ra(e,0,o)}b=1;j:{if(!j){break j}if(!i){a=H[c+68>>2];m=H[c>>2];i=H[c+48>>2];k=H[c+40>>2];n=H[c+44>>2];if(l){if(!d){c=0;d=0;while(1){g=H[m>>2];p=Rj(k,n,H[a+(d2],0)+i|0;qa((c2];p=Rj(g,h,k,n)+i|0;qa((c2];g=c2],0)+i|0;h=qa(e,h+l|0,k);l=H[m>>2];g=Rj(k,n,H[a+(g|4)>>2],0)+i|0;qa(h,g+l|0,k);c=c+2|0;d=d+2|0;if((f|0)!=(d|0)){continue}break}}if(!(j&1)){break j}d=H[m>>2];a=Rj(k,n,H[a+(c2],0)+i|0;qa(e,a+d|0,k);break j}l=j&1;if((j|0)!=1){j=j&-2;f=0;c=0;while(1){a=H[m>>2];d=Rj(g,h,k,n)+i|0;a=qa(e,a+d|0,k);d=H[m>>2];o=Rj(k,n,g|1,h)+i|0;qa(a,d+o|0,k);d=h;g=g+2|0;h=g>>>0>>0>2];c=Rj(g,h,k,n)+i|0;qa(e,a+c|0,k);break j}b=0;if(!l){d=0;while(1){if(!ec(c,I[c+84|0]?d:H[H[c+68>>2]+(d2],F[c+24|0],e)){break j}d=d+1|0;b=j>>>0>>0;if((d|0)!=(j|0)){continue}break}break j}d=0;while(1){if(!ec(c,I[c+84|0]?d:H[H[c+68>>2]+(d2],F[c+24|0],e)){break j}qa((a>0>>0;if((d|0)!=(j|0)){continue}break}}if(!e){break h}oa(e)}break a;case 1:j=H[i+80>>2];h=I[c+24|0];k:{if((N(j,h)|0)!=(e|0)){break k}d=H[c+28>>2]!=2;b=I[c+84|0];if(!(d|!b)){qa(f,H[H[c>>2]>>2]+H[c+48>>2]|0,e);b=1;break k}if(h){a=pa(h);ra(a,0,h)}l:{if(!j){b=1;break l}if(!d){if(h){d=0;e=0;while(1){i=d+f|0;k=H[H[c>>2]>>2];m=H[c+48>>2];g=H[c+40>>2];b=Rj(g,H[c+44>>2],I[c+84|0]?e:H[H[c+68>>2]+(e2],0);n=b;b=b+m|0;qa(i,qa(a,b+k|0,g),h);d=d+h|0;b=1;e=e+1|0;if((j|0)!=(e|0)){continue}break}break l}if(b){b=1;h=H[c>>2];e=H[c+48>>2];f=H[c+40>>2];i=H[c+44>>2];if((j|0)!=1){g=j&-2;c=0;d=0;while(1){k=H[h>>2];m=Rj(f,i,c,0)+e|0;k=qa(a,k+m|0,f);m=H[h>>2];n=Rj(f,i,c|1,0)+e|0;qa(k,m+n|0,f);c=c+2|0;d=d+2|0;if((g|0)!=(d|0)){continue}break}g=c}if(!(j&1)){break l}c=H[h>>2];d=Rj(g,0,f,i)+e|0;qa(a,c+d|0,f);break l}b=1;h=H[c>>2];e=H[c+48>>2];g=H[c+68>>2];f=H[c+40>>2];i=H[c+44>>2];c=0;if((j|0)!=1){k=j&-2;d=0;while(1){m=H[h>>2];n=c2],0)+e|0;m=qa(a,m+l|0,f);l=H[h>>2];n=Rj(f,i,H[g+(n|4)>>2],0)+e|0;qa(m,l+n|0,f);c=c+2|0;d=d+2|0;if((k|0)!=(d|0)){continue}break}}if(!(j&1)){break l}d=H[h>>2];c=Rj(f,i,H[g+(c2],0)+e|0;qa(a,c+d|0,f);break l}b=0;if(!h){d=0;while(1){if(!hc(c,I[c+84|0]?d:H[H[c+68>>2]+(d2],F[c+24|0],a)){break l}d=d+1|0;b=j>>>0>>0;if((d|0)!=(j|0)){continue}break}break l}d=0;e=0;while(1){if(!hc(c,I[c+84|0]?e:H[H[c+68>>2]+(e2],F[c+24|0],a)){break l}qa(d+f|0,a,h);d=d+h|0;e=e+1|0;b=j>>>0>>0;if((e|0)!=(j|0)){continue}break}}if(!a){break k}oa(a)}break a;case 3:n=I[c+24|0];l=n2];m:{if((N(l,j)|0)!=(e|0)){break m}i=H[c+28>>2]!=4;d=I[c+84|0];if(!(i|!d)){qa(f,H[H[c>>2]>>2]+H[c+48>>2]|0,e);a=1;break m}n:{if(!n){e=0;break n}e=pa(l);ra(e,0,l)}o:{if(!j){a=1;break o}if(!i){o=H[c+68>>2];k=H[c>>2];b=H[c+48>>2];i=H[c+40>>2];m=H[c+44>>2];if(n){if(!d){c=0;d=0;while(1){a=1;g=H[k>>2];p=Rj(i,m,H[o+(d2],0)+b|0;qa((c2];p=Rj(g,h,i,m)+b|0;qa((c2];g=c2],0)+b|0;h=qa(e,h+n|0,i);n=H[k>>2];g=Rj(i,m,H[o+(g|4)>>2],0)+b|0;qa(h,g+n|0,i);c=c+2|0;d=d+2|0;if((f|0)!=(d|0)){continue}break}}if(!(j&1)){break o}d=H[k>>2];b=Rj(i,m,H[o+(c2],0)+b|0;qa(e,b+d|0,i);break o}n=j&1;a=1;if((j|0)!=1){j=j&-2;f=0;c=0;while(1){d=H[k>>2];l=Rj(g,h,i,m)+b|0;d=qa(e,d+l|0,i);l=H[k>>2];o=Rj(i,m,g|1,h)+b|0;qa(d,l+o|0,i);g=g+2|0;h=g>>>0>>0>2];b=Rj(g,h,i,m)+b|0;qa(e,b+c|0,i);break o}if(!n){d=0;while(1){if(!fc(c,I[c+84|0]?d:H[H[c+68>>2]+(d2],F[c+24|0],e)){break o}d=d+1|0;a=j>>>0>>0;if((d|0)!=(j|0)){continue}break}break o}d=0;while(1){if(!fc(c,I[c+84|0]?d:H[H[c+68>>2]+(d2],F[c+24|0],e)){break o}qa((b>0>>0;if((d|0)!=(j|0)){continue}break}}if(!e){break m}oa(e)}b=a;break a;case 5:l=I[c+24|0];o=l2];p:{if((N(o,j)|0)!=(e|0)){break p}i=H[c+28>>2]!=6;d=I[c+84|0];if(!(i|!d)){qa(f,H[H[c>>2]>>2]+H[c+48>>2]|0,e);b=1;break p}q:{if(!l){e=0;break q}e=pa(o);ra(e,0,o)}b=1;r:{if(!j){break r}if(!i){a=H[c+68>>2];m=H[c>>2];i=H[c+48>>2];k=H[c+40>>2];n=H[c+44>>2];if(l){if(!d){c=0;d=0;while(1){g=H[m>>2];p=Rj(k,n,H[a+(d2],0)+i|0;qa((c2];p=Rj(g,h,k,n)+i|0;qa((c2];g=c2],0)+i|0;h=qa(e,h+l|0,k);l=H[m>>2];g=Rj(k,n,H[a+(g|4)>>2],0)+i|0;qa(h,g+l|0,k);c=c+2|0;d=d+2|0;if((f|0)!=(d|0)){continue}break}}if(!(j&1)){break r}d=H[m>>2];a=Rj(k,n,H[a+(c2],0)+i|0;qa(e,a+d|0,k);break r}l=j&1;if((j|0)!=1){j=j&-2;f=0;c=0;while(1){a=H[m>>2];d=Rj(g,h,k,n)+i|0;a=qa(e,a+d|0,k);d=H[m>>2];o=Rj(k,n,g|1,h)+i|0;qa(a,d+o|0,k);d=h;g=g+2|0;h=g>>>0>>0>2];c=Rj(g,h,k,n)+i|0;qa(e,a+c|0,k);break r}b=0;if(!l){d=0;while(1){if(!dc(c,I[c+84|0]?d:H[H[c+68>>2]+(d2],F[c+24|0],e)){break r}d=d+1|0;b=j>>>0>>0;if((d|0)!=(j|0)){continue}break}break r}d=0;while(1){if(!dc(c,I[c+84|0]?d:H[H[c+68>>2]+(d2],F[c+24|0],e)){break r}qa((a>0>>0;if((d|0)!=(j|0)){continue}break}}if(!e){break p}oa(e)}break a;case 8:p=I[c+24|0];q=p2];s:{if((N(q,k)|0)!=(e|0)){break s}i=H[c+28>>2];t:{if(!p){break t}a=pa(q);d=a;m=q-4|0;l=(m>>>2|0)+1&7;if(l){e=0;while(1){H[d>>2]=-1073741824;d=d+4|0;e=e+1|0;if((l|0)!=(e|0)){continue}break}}if(m>>>0>2]=-1073741824;H[d+16>>2]=-1073741824;H[d+20>>2]=-1073741824;H[d+8>>2]=-1073741824;H[d+12>>2]=-1073741824;H[d>>2]=-1073741824;H[d+4>>2]=-1073741824;d=d+32|0;if((e|0)!=(d|0)){continue}break}}u:{if(!k){b=1;break u}if((i|0)==9){r=H[c+68>>2];l=H[c>>2];i=H[c+48>>2];s=I[c+84|0];m=H[c+44>>2];c=H[c+40>>2];o=c;if(p){e=0;d=0;while(1){h=(e2];b=Rj(c,m,s?d:H[r+(d2],0)+i|0;qa(h,qa(a,b+g|0,o),q);e=e+p|0;b=1;d=d+1|0;if((k|0)!=(d|0)){continue}break}break u}if(!s){b=1;d=0;if((k|0)!=1){f=k&-2;e=0;while(1){h=H[l>>2];g=d2],0)+i|0;h=qa(a,h+j|0,o);j=H[l>>2];g=Rj(c,m,H[r+(g|4)>>2],0)+i|0;qa(h,j+g|0,o);d=d+2|0;e=e+2|0;if((f|0)!=(e|0)){continue}break}}if(!(k&1)){break u}e=H[l>>2];c=Rj(c,m,H[r+(d2],0)+i|0;qa(a,c+e|0,o);break u}f=k&1;b=1;if((k|0)!=1){k=k&-2;while(1){d=H[l>>2];e=Rj(g,h,c,m)+i|0;d=qa(a,d+e|0,o);e=H[l>>2];p=Rj(c,m,g|1,h)+i|0;qa(d,e+p|0,o);g=g+2|0;h=g>>>0>>0>2];c=Rj(g,h,c,m)+i|0;qa(a,c+d|0,o);break u}if(!p){d=0;while(1){if(!Va(c,I[c+84|0]?d:H[H[c+68>>2]+(d2],F[c+24|0],a)){break u}d=d+1|0;b=k>>>0>>0;if((d|0)!=(k|0)){continue}break}break u}e=0;d=0;while(1){if(!Va(c,I[c+84|0]?d:H[H[c+68>>2]+(d2],F[c+24|0],a)){break u}qa((e>0>>0;if((d|0)!=(k|0)){continue}break}}if(!a){break s}oa(a)}a=b;break;default:break b}}b=a}return b|0}function ef(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0;i=ca-48|0;ca=i;a:{b:{if((c|0)!=1){break b}c=H[a+4>>2];g=H[a+12>>2];H[i+40>>2]=0;a=i;H[a+32>>2]=0;H[a+36>>2]=0;H[a+24>>2]=0;H[a+28>>2]=0;H[a+16>>2]=0;H[a+20>>2]=0;H[a+8>>2]=0;H[a+12>>2]=0;e=a+8|0;c:{if((b|0)==-2){break c}l=H[H[H[c+4>>2]+8>>2]+(g2];if((ea[H[H[c>>2]+8>>2]](c)|0)==1){a=J[c+36>>1];j=(a>8)&65535;a=0;h=ca-32|0;ca=h;d=H[H[H[c+4>>2]+8>>2]+(g2];d:{if((ea[H[H[c>>2]+8>>2]](c)|0)!=1|b-1>>>0>5){break d}k=ea[H[H[c>>2]+36>>2]](c)|0;f=ea[H[H[c>>2]+44>>2]](c,g)|0;if(!k|!f){break d}a=ea[H[H[c>>2]+40>>2]](c,g)|0;if(a){c=H[c+44>>2];H[h+12>>2]=a;H[h+8>>2]=c;H[h+20>>2]=f;H[h+16>>2]=f+12;c=h+8|0;a=0;e:{f:{switch(b-1|0){case 0:a=pa(60);H[a+4>>2]=d;H[a>>2]=3272;b=H[e+4>>2];H[a+8>>2]=H[e>>2];H[a+12>>2]=b;b=H[e+12>>2];H[a+16>>2]=H[e+8>>2];H[a+20>>2]=b;b=H[e+20>>2];H[a+24>>2]=H[e+16>>2];H[a+28>>2]=b;H[a+40>>2]=0;H[a+32>>2]=0;H[a+36>>2]=0;d=H[e+24>>2];f=H[e+28>>2];if((d|0)!=(f|0)){g=f-d|0;if((g|0)>2]=b;H[a+40>>2]=(g&-4)+b;while(1){H[b>>2]=H[d>>2];b=b+4|0;d=d+4|0;if((f|0)!=(d|0)){continue}break}H[a+36>>2]=b}b=H[c+4>>2];H[a+44>>2]=H[c>>2];H[a+48>>2]=b;b=H[c+12>>2];H[a+52>>2]=H[c+8>>2];H[a+56>>2]=b;H[a>>2]=2564;break e;case 1:a=pa(60);H[a+4>>2]=d;H[a>>2]=3272;b=H[e+4>>2];H[a+8>>2]=H[e>>2];H[a+12>>2]=b;b=H[e+12>>2];H[a+16>>2]=H[e+8>>2];H[a+20>>2]=b;b=H[e+20>>2];H[a+24>>2]=H[e+16>>2];H[a+28>>2]=b;H[a+40>>2]=0;H[a+32>>2]=0;H[a+36>>2]=0;d=H[e+24>>2];f=H[e+28>>2];if((d|0)!=(f|0)){g=f-d|0;if((g|0)>2]=b;H[a+40>>2]=(g&-4)+b;while(1){H[b>>2]=H[d>>2];b=b+4|0;d=d+4|0;if((f|0)!=(d|0)){continue}break}H[a+36>>2]=b}b=H[c+4>>2];H[a+44>>2]=H[c>>2];H[a+48>>2]=b;b=H[c+12>>2];H[a+52>>2]=H[c+8>>2];H[a+56>>2]=b;H[a>>2]=3328;break e;case 3:a=pa(112);H[a+4>>2]=d;H[a>>2]=3272;b=H[e+4>>2];H[a+8>>2]=H[e>>2];H[a+12>>2]=b;b=H[e+12>>2];H[a+16>>2]=H[e+8>>2];H[a+20>>2]=b;b=H[e+20>>2];H[a+24>>2]=H[e+16>>2];H[a+28>>2]=b;H[a+40>>2]=0;H[a+32>>2]=0;H[a+36>>2]=0;d=H[e+24>>2];f=H[e+28>>2];if((d|0)!=(f|0)){g=f-d|0;if((g|0)>2]=b;H[a+40>>2]=(g&-4)+b;while(1){H[b>>2]=H[d>>2];b=b+4|0;d=d+4|0;if((f|0)!=(d|0)){continue}break}H[a+36>>2]=b}b=H[c+4>>2];H[a+44>>2]=H[c>>2];H[a+48>>2]=b;b=H[c+12>>2];H[a+52>>2]=H[c+8>>2];H[a+56>>2]=b;H[a+60>>2]=0;H[a+64>>2]=0;H[a>>2]=3564;H[a+68>>2]=0;H[a+72>>2]=0;H[a+76>>2]=0;H[a+80>>2]=0;H[a+84>>2]=0;H[a+88>>2]=0;H[a+92>>2]=0;H[a+96>>2]=0;H[a+100>>2]=0;H[a+104>>2]=0;H[a+108>>2]=0;break e;case 2:a=pa(92);H[a+4>>2]=d;H[a>>2]=3272;b=H[e+4>>2];H[a+8>>2]=H[e>>2];H[a+12>>2]=b;b=H[e+12>>2];H[a+16>>2]=H[e+8>>2];H[a+20>>2]=b;b=H[e+20>>2];H[a+24>>2]=H[e+16>>2];H[a+28>>2]=b;H[a+40>>2]=0;H[a+32>>2]=0;H[a+36>>2]=0;d=H[e+24>>2];f=H[e+28>>2];if((d|0)!=(f|0)){g=f-d|0;if((g|0)>2]=b;H[a+40>>2]=(g&-4)+b;while(1){H[b>>2]=H[d>>2];b=b+4|0;d=d+4|0;if((f|0)!=(d|0)){continue}break}H[a+36>>2]=b}b=H[c+4>>2];H[a+44>>2]=H[c>>2];H[a+48>>2]=b;b=H[c+12>>2];H[a+52>>2]=H[c+8>>2];H[a+56>>2]=b;H[a+60>>2]=0;H[a+64>>2]=0;H[a>>2]=3812;H[a+68>>2]=0;H[a+72>>2]=0;H[a+76>>2]=0;H[a+80>>2]=0;H[a+84>>2]=0;H[a+88>>2]=j;break e;case 4:a=pa(104);H[a+4>>2]=d;H[a>>2]=3272;b=H[e+4>>2];H[a+8>>2]=H[e>>2];H[a+12>>2]=b;b=H[e+12>>2];H[a+16>>2]=H[e+8>>2];H[a+20>>2]=b;b=H[e+20>>2];H[a+24>>2]=H[e+16>>2];H[a+28>>2]=b;H[a+40>>2]=0;H[a+32>>2]=0;H[a+36>>2]=0;d=H[e+24>>2];f=H[e+28>>2];if((d|0)!=(f|0)){g=f-d|0;if((g|0)>2]=b;H[a+40>>2]=(g&-4)+b;while(1){H[b>>2]=H[d>>2];b=b+4|0;d=d+4|0;if((f|0)!=(d|0)){continue}break}H[a+36>>2]=b}b=H[c+4>>2];H[a+44>>2]=H[c>>2];H[a+48>>2]=b;b=H[c+12>>2];H[a+52>>2]=H[c+8>>2];H[a+56>>2]=b;H[a+84>>2]=0;H[a+76>>2]=0;H[a+80>>2]=0;H[a+60>>2]=0;H[a+64>>2]=0;H[a>>2]=4040;b=H[c+4>>2];H[a+88>>2]=H[c>>2];H[a+92>>2]=b;b=H[c+12>>2];H[a+96>>2]=H[c+8>>2];H[a+100>>2]=b;break e;case 5:break f;default:break e}}a=pa(128);H[a+4>>2]=d;H[a>>2]=3272;b=H[e+4>>2];H[a+8>>2]=H[e>>2];H[a+12>>2]=b;b=H[e+12>>2];H[a+16>>2]=H[e+8>>2];H[a+20>>2]=b;b=H[e+20>>2];H[a+24>>2]=H[e+16>>2];H[a+28>>2]=b;H[a+40>>2]=0;H[a+32>>2]=0;H[a+36>>2]=0;g:{b=H[e+28>>2];d=H[e+24>>2];if((b|0)!=(d|0)){d=b-d|0;if((d|0)>2]=b;H[a+32>>2]=b;H[a+40>>2]=(d&-4)+b;d=H[e+24>>2];f=H[e+28>>2];if((d|0)!=(f|0)){while(1){H[b>>2]=H[d>>2];b=b+4|0;d=d+4|0;if((f|0)!=(d|0)){continue}break}}H[a+36>>2]=b}H[a>>2]=3216;b=H[c+4>>2];H[a+44>>2]=H[c>>2];H[a+48>>2]=b;b=H[c+12>>2];H[a+52>>2]=H[c+8>>2];H[a+56>>2]=b;b=a- -64|0;H[b>>2]=0;H[b+4>>2]=0;H[a+60>>2]=4904;H[a>>2]=4276;b=H[c+4>>2];H[a+72>>2]=H[c>>2];H[a+76>>2]=b;b=H[c+12>>2];H[a+80>>2]=H[c+8>>2];H[a+84>>2]=b;H[a+104>>2]=1065353216;H[a+108>>2]=-1;H[a+96>>2]=-1;H[a+100>>2]=-1;H[a+88>>2]=1;H[a+92>>2]=-1;H[a+60>>2]=4512;H[a+112>>2]=0;H[a+116>>2]=0;F[a+117|0]=0;F[a+118|0]=0;F[a+119|0]=0;F[a+120|0]=0;F[a+121|0]=0;F[a+122|0]=0;F[a+123|0]=0;F[a+124|0]=0;break g}}break d}a=H[c+44>>2];H[h+12>>2]=k;H[h+8>>2]=a;H[h+20>>2]=f;H[h+16>>2]=f+12;c=h+8|0;a=0;h:{i:{switch(b-1|0){case 0:a=pa(60);H[a+4>>2]=d;H[a>>2]=3272;b=H[e+4>>2];H[a+8>>2]=H[e>>2];H[a+12>>2]=b;b=H[e+12>>2];H[a+16>>2]=H[e+8>>2];H[a+20>>2]=b;b=H[e+20>>2];H[a+24>>2]=H[e+16>>2];H[a+28>>2]=b;H[a+40>>2]=0;H[a+32>>2]=0;H[a+36>>2]=0;d=H[e+24>>2];f=H[e+28>>2];if((d|0)!=(f|0)){g=f-d|0;if((g|0)>2]=b;H[a+40>>2]=(g&-4)+b;while(1){H[b>>2]=H[d>>2];b=b+4|0;d=d+4|0;if((f|0)!=(d|0)){continue}break}H[a+36>>2]=b}b=H[c+4>>2];H[a+44>>2]=H[c>>2];H[a+48>>2]=b;b=H[c+12>>2];H[a+52>>2]=H[c+8>>2];H[a+56>>2]=b;H[a>>2]=4932;break h;case 1:a=pa(60);H[a+4>>2]=d;H[a>>2]=3272;b=H[e+4>>2];H[a+8>>2]=H[e>>2];H[a+12>>2]=b;b=H[e+12>>2];H[a+16>>2]=H[e+8>>2];H[a+20>>2]=b;b=H[e+20>>2];H[a+24>>2]=H[e+16>>2];H[a+28>>2]=b;H[a+40>>2]=0;H[a+32>>2]=0;H[a+36>>2]=0;d=H[e+24>>2];f=H[e+28>>2];if((d|0)!=(f|0)){g=f-d|0;if((g|0)>2]=b;H[a+40>>2]=(g&-4)+b;while(1){H[b>>2]=H[d>>2];b=b+4|0;d=d+4|0;if((f|0)!=(d|0)){continue}break}H[a+36>>2]=b}b=H[c+4>>2];H[a+44>>2]=H[c>>2];H[a+48>>2]=b;b=H[c+12>>2];H[a+52>>2]=H[c+8>>2];H[a+56>>2]=b;H[a>>2]=5356;break h;case 3:a=pa(112);H[a+4>>2]=d;H[a>>2]=3272;b=H[e+4>>2];H[a+8>>2]=H[e>>2];H[a+12>>2]=b;b=H[e+12>>2];H[a+16>>2]=H[e+8>>2];H[a+20>>2]=b;b=H[e+20>>2];H[a+24>>2]=H[e+16>>2];H[a+28>>2]=b;H[a+40>>2]=0;H[a+32>>2]=0;H[a+36>>2]=0;d=H[e+24>>2];f=H[e+28>>2];if((d|0)!=(f|0)){g=f-d|0;if((g|0)>2]=b;H[a+40>>2]=(g&-4)+b;while(1){H[b>>2]=H[d>>2];b=b+4|0;d=d+4|0;if((f|0)!=(d|0)){continue}break}H[a+36>>2]=b}b=H[c+4>>2];H[a+44>>2]=H[c>>2];H[a+48>>2]=b;b=H[c+12>>2];H[a+52>>2]=H[c+8>>2];H[a+56>>2]=b;H[a+60>>2]=0;H[a+64>>2]=0;H[a>>2]=5580;H[a+68>>2]=0;H[a+72>>2]=0;H[a+76>>2]=0;H[a+80>>2]=0;H[a+84>>2]=0;H[a+88>>2]=0;H[a+92>>2]=0;H[a+96>>2]=0;H[a+100>>2]=0;H[a+104>>2]=0;H[a+108>>2]=0;break h;case 2:a=pa(92);H[a+4>>2]=d;H[a>>2]=3272;b=H[e+4>>2];H[a+8>>2]=H[e>>2];H[a+12>>2]=b;b=H[e+12>>2];H[a+16>>2]=H[e+8>>2];H[a+20>>2]=b;b=H[e+20>>2];H[a+24>>2]=H[e+16>>2];H[a+28>>2]=b;H[a+40>>2]=0;H[a+32>>2]=0;H[a+36>>2]=0;d=H[e+24>>2];f=H[e+28>>2];if((d|0)!=(f|0)){g=f-d|0;if((g|0)>2]=b;H[a+40>>2]=(g&-4)+b;while(1){H[b>>2]=H[d>>2];b=b+4|0;d=d+4|0;if((f|0)!=(d|0)){continue}break}H[a+36>>2]=b}b=H[c+4>>2];H[a+44>>2]=H[c>>2];H[a+48>>2]=b;b=H[c+12>>2];H[a+52>>2]=H[c+8>>2];H[a+56>>2]=b;H[a+60>>2]=0;H[a+64>>2]=0;H[a>>2]=5816;H[a+68>>2]=0;H[a+72>>2]=0;H[a+76>>2]=0;H[a+80>>2]=0;H[a+84>>2]=0;H[a+88>>2]=j;break h;case 4:a=pa(104);H[a+4>>2]=d;H[a>>2]=3272;b=H[e+4>>2];H[a+8>>2]=H[e>>2];H[a+12>>2]=b;b=H[e+12>>2];H[a+16>>2]=H[e+8>>2];H[a+20>>2]=b;b=H[e+20>>2];H[a+24>>2]=H[e+16>>2];H[a+28>>2]=b;H[a+40>>2]=0;H[a+32>>2]=0;H[a+36>>2]=0;d=H[e+24>>2];f=H[e+28>>2];if((d|0)!=(f|0)){g=f-d|0;if((g|0)>2]=b;H[a+40>>2]=(g&-4)+b;while(1){H[b>>2]=H[d>>2];b=b+4|0;d=d+4|0;if((f|0)!=(d|0)){continue}break}H[a+36>>2]=b}b=H[c+4>>2];H[a+44>>2]=H[c>>2];H[a+48>>2]=b;b=H[c+12>>2];H[a+52>>2]=H[c+8>>2];H[a+56>>2]=b;H[a+84>>2]=0;H[a+76>>2]=0;H[a+80>>2]=0;H[a+60>>2]=0;H[a+64>>2]=0;H[a>>2]=6032;b=H[c+4>>2];H[a+88>>2]=H[c>>2];H[a+92>>2]=b;b=H[c+12>>2];H[a+96>>2]=H[c+8>>2];H[a+100>>2]=b;break h;case 5:break i;default:break h}}a=pa(128);H[a+4>>2]=d;H[a>>2]=3272;b=H[e+4>>2];H[a+8>>2]=H[e>>2];H[a+12>>2]=b;b=H[e+12>>2];H[a+16>>2]=H[e+8>>2];H[a+20>>2]=b;b=H[e+20>>2];H[a+24>>2]=H[e+16>>2];H[a+28>>2]=b;H[a+40>>2]=0;H[a+32>>2]=0;H[a+36>>2]=0;j:{b=H[e+28>>2];d=H[e+24>>2];if((b|0)!=(d|0)){d=b-d|0;if((d|0)>2]=b;H[a+32>>2]=b;H[a+40>>2]=(d&-4)+b;d=H[e+24>>2];f=H[e+28>>2];if((d|0)!=(f|0)){while(1){H[b>>2]=H[d>>2];b=b+4|0;d=d+4|0;if((f|0)!=(d|0)){continue}break}}H[a+36>>2]=b}H[a>>2]=5300;b=H[c+4>>2];H[a+44>>2]=H[c>>2];H[a+48>>2]=b;b=H[c+12>>2];H[a+52>>2]=H[c+8>>2];H[a+56>>2]=b;b=a- -64|0;H[b>>2]=0;H[b+4>>2]=0;H[a+60>>2]=6840;H[a>>2]=6256;b=H[c+4>>2];H[a+72>>2]=H[c>>2];H[a+76>>2]=b;b=H[c+12>>2];H[a+80>>2]=H[c+8>>2];H[a+84>>2]=b;H[a+104>>2]=1065353216;H[a+108>>2]=-1;H[a+96>>2]=-1;H[a+100>>2]=-1;H[a+88>>2]=1;H[a+92>>2]=-1;H[a+60>>2]=6476;H[a+112>>2]=0;H[a+116>>2]=0;F[a+117|0]=0;F[a+118|0]=0;F[a+119|0]=0;F[a+120|0]=0;F[a+121|0]=0;F[a+122|0]=0;F[a+123|0]=0;F[a+124|0]=0;break j}}}ca=h+32|0;d=a;if(a){break c}}d=pa(44);H[d+4>>2]=l;H[d>>2]=3272;a=H[e+4>>2];H[d+8>>2]=H[e>>2];H[d+12>>2]=a;a=H[e+12>>2];H[d+16>>2]=H[e+8>>2];H[d+20>>2]=a;a=H[e+20>>2];H[d+24>>2]=H[e+16>>2];H[d+28>>2]=a;H[d+40>>2]=0;H[d+32>>2]=0;H[d+36>>2]=0;c=H[e+24>>2];a=H[e+28>>2];if((c|0)!=(a|0)){b=a-c|0;if((b|0)>2]=e;H[d+40>>2]=(b&-4)+e;while(1){H[e>>2]=H[c>>2];e=e+4|0;c=c+4|0;if((a|0)!=(c|0)){continue}break}H[d+36>>2]=e}H[d>>2]=6868;break c}e=d;a=H[i+32>>2];if(!a){break b}H[i+36>>2]=a;oa(a)}ca=i+48|0;return e|0}sa();v()}function Ec(a){a=a|0;var b=0,c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0;l=ca-16|0;ca=l;a:{b:{c:{d:{e:{f:{g:{h:{i:{if(a>>>0>>0>>3|0;b=g>>>c|0;if(b&3){c=c+((b^-1)&1)|0;a=c2];a=H[d+8>>2];j:{if((b|0)==(a|0)){m=17192,n=Vj(c)&g,H[m>>2]=n;break j}H[a+12>>2]=b;H[b+8>>2]=a}a=d+8|0;b=c2]=b|3;b=b+d|0;H[b+4>>2]=H[b+4>>2]|1;break a}k=H[4300];if(k>>>0>=h>>>0){break i}if(b){a=22]=b;H[b+8>>2]=a}H[e+4>>2]=h|3;c=e+h|0;a=d2]=d|1;H[a+e>>2]=d;if(k){b=(k&-8)+17232|0;f=H[4303];a=1>3);l:{if(!(a&g)){H[4298]=a|g;a=b;break l}a=H[b+8>>2]}H[b+8>>2]=f;H[a+12>>2]=f;H[f+12>>2]=b;H[f+8>>2]=a}a=e+8|0;H[4303]=c;H[4300]=d;break a}j=H[4299];if(!j){break i}c=H[(Qj(0-j&j)2];f=(H[c+4>>2]&-8)-h|0;b=c;while(1){m:{a=H[b+16>>2];if(!a){a=H[b+20>>2];if(!a){break m}}b=(H[a+4>>2]&-8)-h|0;d=b>>>0>>0;f=d?b:f;c=d?a:c;b=a;continue}break}i=H[c+24>>2];d=H[c+12>>2];if((d|0)!=(c|0)){a=H[c+8>>2];H[a+12>>2]=d;H[d+8>>2]=a;break b}b=c+20|0;a=H[b>>2];if(!a){a=H[c+16>>2];if(!a){break h}b=c+16|0}while(1){e=b;d=a;b=a+20|0;a=H[b>>2];if(a){continue}b=d+16|0;a=H[d+16>>2];if(a){continue}break}H[e>>2]=0;break b}h=-1;if(a>>>0>4294967231){break i}a=a+11|0;h=a&-8;j=H[4299];if(!j){break i}f=0-h|0;g=0;n:{if(h>>>0>>0>16777215){break n}a=Q(a>>>8|0);g=((h>>>38-a&1)-(a>2]&-8)-h|0;if(e>>>0>=f>>>0){break r}d=b;f=e;if(e){break r}f=0;a=b;break p}e=H[b+20>>2];b=H[((c>>>29&4)+b|0)+16>>2];a=e?(e|0)==(b|0)?a:e:a;c=c>0>>0;f=c?b:f;d=c?a:d;b=H[a+16>>2];if(b){a=b}else{a=H[a+20>>2]}if(a){continue}break}}if(!d|H[4300]-h>>>0>>0){break i}g=H[d+24>>2];c=H[d+12>>2];if((d|0)!=(c|0)){a=H[d+8>>2];H[a+12>>2]=c;H[c+8>>2]=a;break c}b=d+20|0;a=H[b>>2];if(!a){a=H[d+16>>2];if(!a){break g}b=d+16|0}while(1){e=b;c=a;b=a+20|0;a=H[b>>2];if(a){continue}b=c+16|0;a=H[c+16>>2];if(a){continue}break}H[e>>2]=0;break c}a=H[4300];if(a>>>0>=h>>>0){d=H[4303];b=a-h|0;s:{if(b>>>0>=16){c=d+h|0;H[c+4>>2]=b|1;H[a+d>>2]=b;H[d+4>>2]=h|3;break s}H[d+4>>2]=a|3;a=a+d|0;H[a+4>>2]=H[a+4>>2]|1;c=0;b=0}H[4300]=b;H[4303]=c;a=d+8|0;break a}i=H[4301];if(i>>>0>h>>>0){b=i-h|0;H[4301]=b;c=H[4304];a=c+h|0;H[4304]=a;H[a+4>>2]=b|1;H[c+4>>2]=h|3;a=c+8|0;break a}a=0;j=h+47|0;if(H[4416]){c=H[4418]}else{H[4419]=-1;H[4420]=-1;H[4417]=4096;H[4418]=4096;H[4416]=l+12&-16^1431655768;H[4421]=0;H[4409]=0;c=4096}e=j+c|0;f=0-c|0;b=e&f;if(b>>>0>>0){break a}d=H[4408];if(d){c=H[4406];g=c+b|0;if(d>>>0>>0|c>>>0>=g>>>0){break a}}t:{if(!(I[17636]&4)){u:{v:{w:{x:{d=H[4304];if(d){a=17640;while(1){c=H[a>>2];if(c>>>0>>0&d>>>0>2]>>>0){break x}a=H[a+8>>2];if(a){continue}break}}c=zb(0);if((c|0)==-1){break u}g=b;d=H[4417];a=d-1|0;if(a&c){g=(b-c|0)+(a+c&0-d)|0}if(g>>>0>>0){break u}d=H[4408];if(d){a=H[4406];f=a+g|0;if(d>>>0>>0|a>>>0>=f>>>0){break u}}a=zb(g);if((c|0)!=(a|0)){break w}break t}g=f&e-i;c=zb(g);if((c|0)==(H[a>>2]+H[a+4>>2]|0)){break v}a=c}if((a|0)==-1){break u}if(h+48>>>0>>0){c=a;break t}c=H[4418];c=c+(j-g|0)&0-c;if((zb(c)|0)==-1){break u}g=c+g|0;c=a;break t}if((c|0)!=-1){break t}}H[4409]=H[4409]|4}c=zb(b);a=zb(0);if((c|0)==-1|(a|0)==-1|a>>>0>>0){break d}g=a-c|0;if(g>>>0>>0){break d}}a=H[4406]+g|0;H[4406]=a;if(a>>>0>K[4407]){H[4407]=a}y:{e=H[4304];if(e){a=17640;while(1){d=H[a>>2];b=H[a+4>>2];if((d+b|0)==(c|0)){break y}a=H[a+8>>2];if(a){continue}break}break f}a=H[4302];if(!(a>>>0>>0?a:0)){H[4302]=c}a=0;H[4411]=g;H[4410]=c;H[4306]=-1;H[4307]=H[4416];H[4413]=0;while(1){d=a2]=b;H[d+17244>>2]=b;a=a+1|0;if((a|0)!=32){continue}break}d=g-40|0;a=c+8&7?-8-c&7:0;b=d-a|0;H[4301]=b;a=a+c|0;H[4304]=a;H[a+4>>2]=b|1;H[(c+d|0)+4>>2]=40;H[4305]=H[4420];break e}if(I[a+12|0]&8|d>>>0>e>>>0|c>>>0>>0){break f}H[a+4>>2]=b+g;a=e+8&7?-8-e&7:0;c=a+e|0;H[4304]=c;b=H[4301]+g|0;a=b-a|0;H[4301]=a;H[c+4>>2]=a|1;H[(b+e|0)+4>>2]=40;H[4305]=H[4420];break e}d=0;break b}c=0;break c}if(K[4302]>c>>>0){H[4302]=c}b=c+g|0;a=17640;z:{A:{B:{C:{D:{E:{while(1){if((b|0)!=H[a>>2]){a=H[a+8>>2];if(a){continue}break E}break}if(!(I[a+12|0]&8)){break D}}a=17640;while(1){b=H[a>>2];if(b>>>0>>0){f=b+H[a+4>>2]|0;if(f>>>0>e>>>0){break C}}a=H[a+8>>2];continue}}H[a>>2]=c;H[a+4>>2]=H[a+4>>2]+g;j=(c+8&7?-8-c&7:0)+c|0;H[j+4>>2]=h|3;g=b+(b+8&7?-8-b&7:0)|0;i=h+j|0;a=g-i|0;if((e|0)==(g|0)){H[4304]=i;a=H[4301]+a|0;H[4301]=a;H[i+4>>2]=a|1;break A}if(H[4303]==(g|0)){H[4303]=i;a=H[4300]+a|0;H[4300]=a;H[i+4>>2]=a|1;H[a+i>>2]=a;break A}f=H[g+4>>2];if((f&3)==1){e=f&-8;F:{if(f>>>0>2];b=f>>>3|0;c=H[g+12>>2];if((c|0)==(d|0)){m=17192,n=H[4298]&Vj(b),H[m>>2]=n;break F}H[d+12>>2]=c;H[c+8>>2]=d;break F}h=H[g+24>>2];c=H[g+12>>2];G:{if((g|0)!=(c|0)){b=H[g+8>>2];H[b+12>>2]=c;H[c+8>>2]=b;break G}H:{f=g+20|0;b=H[f>>2];if(b){break H}f=g+16|0;b=H[f>>2];if(b){break H}c=0;break G}while(1){d=f;c=b;f=c+20|0;b=H[f>>2];if(b){continue}f=c+16|0;b=H[c+16>>2];if(b){continue}break}H[d>>2]=0}if(!h){break F}d=H[g+28>>2];b=(d2]==(g|0)){H[b>>2]=c;if(c){break I}m=17196,n=H[4299]&Vj(d),H[m>>2]=n;break F}H[h+(H[h+16>>2]==(g|0)?16:20)>>2]=c;if(!c){break F}}H[c+24>>2]=h;b=H[g+16>>2];if(b){H[c+16>>2]=b;H[b+24>>2]=c}b=H[g+20>>2];if(!b){break F}H[c+20>>2]=b;H[b+24>>2]=c}g=e+g|0;f=H[g+4>>2];a=a+e|0}H[g+4>>2]=f&-2;H[i+4>>2]=a|1;H[a+i>>2]=a;if(a>>>03);J:{if(!(c&a)){H[4298]=a|c;a=b;break J}a=H[b+8>>2]}H[b+8>>2]=i;H[a+12>>2]=i;H[i+12>>2]=b;H[i+8>>2]=a;break A}f=31;if(a>>>0>>8|0);f=((a>>>38-b&1)-(b2]=f;H[i+16>>2]=0;H[i+20>>2]=0;b=(f>2];while(1){b=c;if((H[c+4>>2]&-8)==(a|0)){break B}c=f>>>29|0;f=f2];if(c){continue}break}H[d+16>>2]=i}H[i+24>>2]=b;H[i+12>>2]=i;H[i+8>>2]=i;break A}d=g-40|0;a=c+8&7?-8-c&7:0;b=d-a|0;H[4301]=b;a=a+c|0;H[4304]=a;H[a+4>>2]=b|1;H[(c+d|0)+4>>2]=40;H[4305]=H[4420];a=(f+(f-39&7?39-f&7:0)|0)-47|0;d=a>>>0>>0?e:a;H[d+4>>2]=27;a=H[4413];H[d+16>>2]=H[4412];H[d+20>>2]=a;a=H[4411];H[d+8>>2]=H[4410];H[d+12>>2]=a;H[4412]=d+8;H[4411]=g;H[4410]=c;H[4413]=0;a=d+24|0;while(1){H[a+4>>2]=7;b=a+8|0;a=a+4|0;if(b>>>0>>0){continue}break}if((d|0)==(e|0)){break e}H[d+4>>2]=H[d+4>>2]&-2;f=d-e|0;H[e+4>>2]=f|1;H[d>>2]=f;if(f>>>03);L:{if(!(c&a)){H[4298]=a|c;a=b;break L}a=H[b+8>>2]}H[b+8>>2]=e;H[a+12>>2]=e;H[e+12>>2]=b;H[e+8>>2]=a;break e}a=31;if(f>>>0>>8|0);a=((f>>>38-a&1)-(a2]=a;H[e+16>>2]=0;H[e+20>>2]=0;b=(a>2];while(1){b=d;if((f|0)==(H[b+4>>2]&-8)){break z}c=a>>>29|0;a=a2];if(d){continue}break}H[c+16>>2]=e}H[e+24>>2]=b;H[e+12>>2]=e;H[e+8>>2]=e;break e}a=H[b+8>>2];H[a+12>>2]=i;H[b+8>>2]=i;H[i+24>>2]=0;H[i+12>>2]=b;H[i+8>>2]=a}a=j+8|0;break a}a=H[b+8>>2];H[a+12>>2]=e;H[b+8>>2]=e;H[e+24>>2]=0;H[e+12>>2]=b;H[e+8>>2]=a}a=H[4301];if(a>>>0>>0){break d}b=a-h|0;H[4301]=b;c=H[4304];a=c+h|0;H[4304]=a;H[a+4>>2]=b|1;H[c+4>>2]=h|3;a=c+8|0;break a}H[3992]=48;a=0;break a}N:{if(!g){break N}b=H[d+28>>2];a=(b2]==(d|0)){H[a>>2]=c;if(c){break O}j=Vj(b)&j;H[4299]=j;break N}H[g+(H[g+16>>2]==(d|0)?16:20)>>2]=c;if(!c){break N}}H[c+24>>2]=g;a=H[d+16>>2];if(a){H[c+16>>2]=a;H[a+24>>2]=c}a=H[d+20>>2];if(!a){break N}H[c+20>>2]=a;H[a+24>>2]=c}P:{if(f>>>0>2]=a|3;a=a+d|0;H[a+4>>2]=H[a+4>>2]|1;break P}H[d+4>>2]=h|3;e=d+h|0;H[e+4>>2]=f|1;H[e+f>>2]=f;if(f>>>03);Q:{if(!(c&a)){H[4298]=a|c;a=b;break Q}a=H[b+8>>2]}H[b+8>>2]=e;H[a+12>>2]=e;H[e+12>>2]=b;H[e+8>>2]=a;break P}a=31;if(f>>>0>>8|0);a=((f>>>38-a&1)-(a2]=a;H[e+16>>2]=0;H[e+20>>2]=0;b=(a>2];while(1){b=h;if((H[b+4>>2]&-8)==(f|0)){break R}c=a>>>29|0;a=a2];if(h){continue}break}H[c+16>>2]=e}H[e+24>>2]=b;H[e+12>>2]=e;H[e+8>>2]=e;break P}a=H[b+8>>2];H[a+12>>2]=e;H[b+8>>2]=e;H[e+24>>2]=0;H[e+12>>2]=b;H[e+8>>2]=a}a=d+8|0;break a}T:{if(!i){break T}b=H[c+28>>2];a=(b2]==(c|0)){H[a>>2]=d;if(d){break U}m=17196,n=Vj(b)&j,H[m>>2]=n;break T}H[i+(H[i+16>>2]==(c|0)?16:20)>>2]=d;if(!d){break T}}H[d+24>>2]=i;a=H[c+16>>2];if(a){H[d+16>>2]=a;H[a+24>>2]=d}a=H[c+20>>2];if(!a){break T}H[d+20>>2]=a;H[a+24>>2]=d}V:{if(f>>>0>2]=a|3;a=a+c|0;H[a+4>>2]=H[a+4>>2]|1;break V}H[c+4>>2]=h|3;d=c+h|0;H[d+4>>2]=f|1;H[d+f>>2]=f;if(k){b=(k&-8)+17232|0;e=H[4303];a=1>3);W:{if(!(a&g)){H[4298]=a|g;a=b;break W}a=H[b+8>>2]}H[b+8>>2]=e;H[a+12>>2]=e;H[e+12>>2]=b;H[e+8>>2]=a}H[4303]=d;H[4300]=f}a=c+8|0}ca=l+16|0;return a|0}function ce(a,b){var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,w=0,x=0,y=0,z=0,A=0;m=ca-32|0;ca=m;o=pa(12);H[o+8>>2]=0;H[o+4>>2]=b;H[o>>2]=0;s=o+12|0;b=s;a:{b:{c:{while(1){b=b-12|0;w=H[b+8>>2];j=H[b+4>>2];t=H[b>>2];if(t){if((w|0)>1e3){break a}H[m+24>>2]=0;H[m+16>>2]=0;H[m+20>>2]=0;d=1;c=H[a>>2];e=H[c+8>>2];h=H[c+12>>2];g=H[c+20>>2];f=H[c+16>>2];d:{if((h|0)>>0>=e>>>0|(g|0)>(h|0)){break d}e=I[f+H[c>>2]|0];h=c;c=g;f=f+1|0;c=f?c:c+1|0;H[h+16>>2]=f;H[h+20>>2]=c;Cc(m+16|0,e);if(e){c=H[a>>2];n=Dc(m+16|0);p=H[c+8>>2];g=H[c+12>>2];h=H[c+20>>2];f=H[c+16>>2];k=f+e|0;h=k>>>0>>0?h+1|0:h;if((g|0)>>0>p>>>0|(g|0)>2]|0,e);d=H[c+20>>2];f=e;e=e+H[c+16>>2]|0;d=f>>>0>e>>>0?d+1|0:d;H[c+16>>2]=e;H[c+20>>2]=d}j=pa(24);c=j;H[c+4>>2]=0;H[c+8>>2]=0;c=c+16|0;H[c>>2]=0;H[c+4>>2]=0;H[j>>2]=j+4;H[j+12>>2]=c;e=ca-32|0;ca=e;h=t+12|0;c=m+16|0;u=nb(h,c);i=t+16|0;e:{if((u|0)==(i|0)){H[e+16>>2]=c;f:{g:{d=H[h+4>>2];h:{if(!d){f=h+4|0;c=f;break h}f=I[c+11|0];g=f24>2]:c;g=g?H[c+4>>2]:f;while(1){c=d;d=I[c+27|0];f=d24>2]:d;p=d>>>0>>0;i:{j:{k:{l:{k=p?d:g;m:{if(k){f=f?H[c+16>>2]:c+16|0;q=Fa(n,f,k);if(!q){if(d>>>0>g>>>0){break m}break l}if((q|0)>=0){break l}break m}if(d>>>0>>0){break k}}f=c;d=H[c>>2];if(d){continue}break h}d=Fa(f,n,k);if(d){break j}}if(p){break i}break g}if((d|0)>=0){break g}}d=H[c+4>>2];if(d){continue}break}f=c+4|0}d=pa(32);n=d+16|0;g=H[e+16>>2];n:{if(F[g+11|0]>=0){p=H[g+4>>2];H[n>>2]=H[g>>2];H[n+4>>2]=p;H[n+8>>2]=H[g+8>>2];break n}za(n,H[g>>2],H[g+4>>2])}H[d+8>>2]=c;H[d>>2]=0;H[d+4>>2]=0;H[d+28>>2]=0;H[f>>2]=d;c=d;g=H[H[h>>2]>>2];if(g){H[h>>2]=g;c=H[f>>2]}Sb(H[h+4>>2],c);H[h+8>>2]=H[h+8>>2]+1;c=1;break f}d=c;c=0}F[e+28|0]=c;H[e+24>>2]=d;d=H[e+24>>2];c=H[d+28>>2];H[d+28>>2]=j;if(!c){break e}Ra(c+12|0,H[c+16>>2]);Qa(c,H[c+4>>2]);oa(c);break e}if(!j){break e}Ra(j+12|0,H[j+16>>2]);Qa(j,H[j+4>>2]);oa(j)}ca=e+32|0;d=(i|0)!=(u|0)}if(F[m+27|0]>2])}if(d){break a}}if(!j){break a}H[m+16>>2]=0;if(!Bb(1,m+16|0,H[a>>2])){break a}q=0;x=H[m+16>>2];if(x){while(1){d=0;i=ca-32|0;ca=i;H[i+24>>2]=0;H[i+16>>2]=0;H[i+20>>2]=0;c=H[a>>2];f=H[c+8>>2];o:{p:{h=H[c+12>>2];g=H[c+20>>2];e=H[c+16>>2];q:{if((h|0)>>0>=f>>>0|(g|0)>(h|0)){break q}f=I[e+H[c>>2]|0];h=c;c=g;e=e+1|0;c=e?c:c+1|0;H[h+16>>2]=e;H[h+20>>2]=c;Cc(i+16|0,f);if(f){e=H[a>>2];n=Dc(i+16|0);p=H[e+8>>2];g=H[e+12>>2];c=H[e+20>>2];h=H[e+16>>2];k=h+f|0;c=k>>>0>>0?c+1|0:c;if(k>>>0>p>>>0&(c|0)>=(g|0)|(c|0)>(g|0)){break q}qa(n,h+H[e>>2]|0,f);c=H[e+20>>2];g=f;f=f+H[e+16>>2]|0;c=g>>>0>f>>>0?c+1|0:c;H[e+16>>2]=f;H[e+20>>2]=c}H[i+12>>2]=0;if(!Bb(1,i+12|0,H[a>>2])){break q}f=H[i+12>>2];if(!f){break q}e=H[a>>2];c=H[e+8>>2];h=H[e+16>>2];g=c-h|0;c=H[e+12>>2]-(H[e+20>>2]+(c>>>0>>0)|0)|0;if((c|0)>>0>g>>>0|(c|0)>2]=0;H[i>>2]=0;H[i+4>>2]=0;if((f|0)>2]=d;c=d+f|0;H[i+8>>2]=c;l=ra(d,0,f);H[i+4>>2]=c;h=H[e+12>>2];y=h;p=H[e+8>>2];c=H[e+20>>2];k=H[e+16>>2];g=f+k|0;c=g>>>0>>0?c+1|0:c;u=g;n=c;r:{if((c|0)>>0>>0|(c|0)>2]+k|0,f);d=H[e+20>>2];c=f+H[e+16>>2]|0;d=c>>>0>>0?d+1|0:d;H[e+16>>2]=c;H[e+20>>2]=d;h=ca-48|0;ca=h;e=nb(j,i+16|0);if((e|0)!=(j+4|0)){c=H[e+4>>2];s:{if(!c){c=e;while(1){d=H[c+8>>2];f=H[d>>2]!=(c|0);c=d;if(f){continue}break}break s}while(1){d=c;c=H[c>>2];if(c){continue}break}}if((e|0)==H[j>>2]){H[j>>2]=d}H[j+8>>2]=H[j+8>>2]-1;f=H[j+4>>2];t:{u:{g=e;d=e;e=H[d>>2];if(e){c=H[g+4>>2];if(!c){break u}while(1){d=c;c=H[c>>2];if(c){continue}break}}e=H[d+4>>2];if(e){break u}e=0;k=1;break t}H[e+8>>2]=H[d+8>>2];k=0}l=H[d+8>>2];c=H[l>>2];v:{if((d|0)==(c|0)){H[l>>2]=e;if((d|0)==(f|0)){c=0;f=e;break v}c=H[l+4>>2];break v}H[l+4>>2]=e}r=!I[d+12|0];if((d|0)!=(g|0)){l=H[g+8>>2];H[d+8>>2]=l;H[l+(((g|0)!=H[H[g+8>>2]>>2])2]=d;l=H[g>>2];H[d>>2]=l;H[l+8>>2]=d;l=H[g+4>>2];H[d+4>>2]=l;if(l){H[l+8>>2]=d}F[d+12|0]=I[g+12|0];f=(f|0)==(g|0)?d:f}w:{if(r|!f){break w}if(k){while(1){e=I[c+12|0];x:{d=H[c+8>>2];if(H[d>>2]!=(c|0)){if(!e){F[c+12|0]=1;F[d+12|0]=0;e=H[d+4>>2];k=H[e>>2];H[d+4>>2]=k;if(k){H[k+8>>2]=d}H[e+8>>2]=H[d+8>>2];k=H[d+8>>2];H[(((d|0)!=H[k>>2])2]=e;H[e>>2]=d;H[d+8>>2]=e;d=c;c=H[c>>2];f=(c|0)==(f|0)?d:f;c=H[c+4>>2]}y:{z:{d=H[c>>2];A:{if(!(I[d+12|0]?0:d)){e=H[c+4>>2];if(I[e+12|0]?0:e){break A}F[c+12|0]=0;c=H[c+8>>2];B:{if((f|0)==(c|0)){c=f;break B}if(I[c+12|0]){break x}}F[c+12|0]=1;break w}e=H[c+4>>2];if(!e){break z}}if(I[e+12|0]){break z}d=c;break y}F[d+12|0]=1;F[c+12|0]=0;e=H[d+4>>2];H[c>>2]=e;if(e){H[e+8>>2]=c}H[d+8>>2]=H[c+8>>2];e=H[c+8>>2];H[((H[e>>2]!=(c|0))2]=d;H[d+4>>2]=c;H[c+8>>2]=d;e=c}c=H[d+8>>2];F[d+12|0]=I[c+12|0];F[c+12|0]=1;F[e+12|0]=1;d=H[c+4>>2];e=H[d>>2];H[c+4>>2]=e;if(e){H[e+8>>2]=c}H[d+8>>2]=H[c+8>>2];e=H[c+8>>2];H[(((c|0)!=H[e>>2])2]=d;H[d>>2]=c;H[c+8>>2]=d;break w}if(!e){F[c+12|0]=1;F[d+12|0]=0;e=H[c+4>>2];H[d>>2]=e;if(e){H[e+8>>2]=d}H[c+8>>2]=H[d+8>>2];e=H[d+8>>2];H[(((d|0)!=H[e>>2])2]=c;H[c+4>>2]=d;H[d+8>>2]=c;f=(d|0)==(f|0)?c:f;c=H[d>>2]}e=H[c>>2];C:{if(!(!e|I[e+12|0])){d=c;break C}d=H[c+4>>2];if(!(I[d+12|0]?0:d)){F[c+12|0]=0;c=H[c+8>>2];if((c|0)!=(f|0)?I[c+12|0]:0){break x}F[c+12|0]=1;break w}if(e){if(!I[e+12|0]){d=c;break C}d=H[c+4>>2]}F[d+12|0]=1;F[c+12|0]=0;e=H[d>>2];H[c+4>>2]=e;if(e){H[e+8>>2]=c}H[d+8>>2]=H[c+8>>2];e=H[c+8>>2];H[((H[e>>2]!=(c|0))2]=d;H[d>>2]=c;H[c+8>>2]=d;e=c}c=H[d+8>>2];F[d+12|0]=I[c+12|0];F[c+12|0]=1;F[e+12|0]=1;d=H[c>>2];e=H[d+4>>2];H[c>>2]=e;if(e){H[e+8>>2]=c}H[d+8>>2]=H[c+8>>2];e=H[c+8>>2];H[(((c|0)!=H[e>>2])2]=d;H[d+4>>2]=c;H[c+8>>2]=d;break w}d=c;c=H[c+8>>2];c=H[(((d|0)==H[c>>2])2];continue}}F[e+12|0]=1}c=H[g+28>>2];if(c){H[g+32>>2]=c;oa(c)}if(F[g+27|0]>2])}oa(g)}H[h+8>>2]=0;H[h>>2]=0;H[h+4>>2]=0;c=H[i+4>>2];d=H[i>>2];f=c-d|0;e=0;D:{E:{if((c|0)!=(d|0)){if((f|0)>2]=g;H[h+4>>2]=g;H[h>>2]=c;c=d}qa(e,c,f);F:{if(F[i+27|0]>=0){H[h+24>>2]=H[i+24>>2];c=H[i+20>>2];H[h+16>>2]=H[i+16>>2];H[h+20>>2]=c;break F}za(h+16|0,H[i+16>>2],H[i+20>>2])}ae(h+28|0,h);f=h+16|0;c=f;G:{H:{d=H[j+4>>2];I:{if(!d){e=j+4|0;c=e;break I}e=I[c+11|0];g=e24>2]:c;g=g?H[c+4>>2]:e;while(1){c=d;d=I[c+27|0];e=d24>2]:d;l=d>>>0>>0;J:{K:{L:{M:{r=l?d:g;N:{if(r){e=e?H[c+16>>2]:c+16|0;z=Fa(k,e,r);if(!z){if(d>>>0>g>>>0){break N}break M}if((z|0)>=0){break M}break N}if(d>>>0>>0){break L}}e=c;d=H[c>>2];if(d){continue}break I}d=Fa(e,k,r);if(d){break K}}if(l){break J}break H}if((d|0)>=0){break H}}d=H[c+4>>2];if(d){continue}break}e=c+4|0}d=pa(40);H[d+24>>2]=H[f+8>>2];g=H[f+4>>2];H[d+16>>2]=H[f>>2];H[d+20>>2]=g;H[f>>2]=0;H[f+4>>2]=0;H[f+8>>2]=0;ae(d+28|0,f+12|0);H[d+8>>2]=c;H[d>>2]=0;H[d+4>>2]=0;H[e>>2]=d;c=d;f=H[H[j>>2]>>2];if(f){H[j>>2]=f;c=H[e>>2]}Sb(H[j+4>>2],c);H[j+8>>2]=H[j+8>>2]+1;c=1;break G}d=c;c=0}F[h+44|0]=c;H[h+40>>2]=d;c=H[h+28>>2];if(c){H[h+32>>2]=c;oa(c)}if(F[h+27|0]>2])}c=H[h>>2];if(c){H[h+4>>2]=c;oa(c)}ca=h+48|0;break D}sa();v()}d=H[i>>2];if(!d){break r}}H[i+4>>2]=d;oa(d)}d=(n|0)>>0>=u>>>0|(n|0)2])}ca=i+32|0;break o}sa();v()}if(!d){break a}q=q+1|0;if((x|0)!=(q|0)){continue}break}}H[m+12>>2]=0;if(!Bb(1,m+12|0,H[a>>2])){break a}c=H[a>>2];e=H[c+8>>2];f=H[c+16>>2];h=e-f|0;d=H[m+12>>2];c=H[c+12>>2]-(H[c+20>>2]+(e>>>0>>0)|0)|0;if(h>>>0>>0&(c|0)>0>>0){H[b+8>>2]=h;H[b+4>>2]=0;H[b>>2]=j;b=b+12|0;d=H[m+12>>2];break O}c=b-o|0;g=(c|0)/12|0;b=g+1|0;if(b>>>0>=357913942){break c}e=(s-o|0)/12|0;f=e>0>=178956970?357913941:b>>>0>>0?f:b;if(e){if(e>>>0>=357913942){break b}f=pa(N(e,12))}else{f=0}b=f+N(g,12)|0;H[b+8>>2]=h;H[b+4>>2]=0;H[b>>2]=j;c=va(b+N((c|0)/-12|0,12)|0,o,c);s=f+N(e,12)|0;b=b+12|0;if(o){oa(o)}o=c}q=q+1|0;if(q>>>0>>0){continue}break}}if((b|0)!=(o|0)){continue}break}A=1;break a}sa();v()}wa();v()}if(o){oa(o)}ca=m+32|0;return A}function Af(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=O(0),q=0,r=0;e=ca-720|0;ca=e;a:{b:{c:{d:{e:{f:{g:{h:{i:{if(J[b+38>>1]>=515){H[e+680>>2]=0;H[e+672>>2]=0;H[e+676>>2]=0;if((ea[H[H[a>>2]+24>>2]](a)|0)>2]+20>>2]](a,n)|0;d=H[H[H[(ea[H[H[a>>2]+28>>2]](a)|0)+4>>2]+8>>2]+(c2];if(H[d+28>>2]==9){f=H[e+672>>2];c=H[e+676>>2]-f>>2;k=I[d+24|0];j:{if(c>>>0>>0){ya(e+672|0,k-c|0);break j}if(c>>>0>>0){break j}H[e+676>>2]=f+(k2];h=H[b+12>>2];c=H[b+20>>2];d=k2];l=f+d|0;c=d>>>0>l>>>0?c+1|0:c;if(i>>>0>>0&(c|0)>=(h|0)|(c|0)>(h|0)){break b}qa(H[e+672>>2],f+H[b>>2]|0,d);c=H[b+20>>2];f=d;d=d+H[b+16>>2]|0;c=f>>>0>d>>>0?c+1|0:c;i=d;H[b+16>>2]=d;H[b+20>>2]=c;l=H[b+12>>2];g=H[b+8>>2];h=d+4|0;f=h>>>0>>0>>0&(d|0)>=(l|0)|(d|0)>(l|0)){break b}o=H[b>>2];f=o+i|0;f=I[f|0]|I[f+1|0]>0>>0&(d|0)>=(l|0)|(d|0)>(l|0)){break b}d=I[h+o|0];h=i+5|0;c=h>>>0>2]=h;H[b+20>>2]=c;if(d>>>0>31){break b}p=(A(2,f),B());H[e+20>>2]=-1;H[e+16>>2]=1832;H[e+32>>2]=0;H[e+36>>2]=0;H[e+24>>2]=0;H[e+28>>2]=0;c=H[e+672>>2];o=d-1|0;if(o>>>0>2]=d;k:{h=c+(k2;i=H[e+32>>2];d=H[e+24>>2];if(f>>>0>2>>>0){i=H[e+28>>2]-d|0;l=i>>2;i=f>>>0>l>>>0?c+i|0:h;g=i-c|0;if((c|0)!=(i|0)){va(d,c,g)}if(f>>>0>l>>>0){c=h-i|0;d=H[e+28>>2];if((h|0)!=(i|0)){va(d,i,c)}H[e+28>>2]=c+d;break k}H[e+28>>2]=d+g;break k}if(d){H[e+28>>2]=d;oa(d);H[e+32>>2]=0;H[e+24>>2]=0;H[e+28>>2]=0;i=0}l:{if((l|0)>>1|0;d=i>>>0>=2147483644?1073741823:d>>>0>f>>>0?d:f;if(d>>>0>=1073741824){break l}i=d2]=d;H[e+24>>2]=d;H[e+32>>2]=d+i;if((c|0)!=(h|0)){qa(d,c,l)}H[e+28>>2]=d+(f2]=p}m:{if(o>>>0>=30){break m}if(!Xc(e+16|0,H[H[a+60>>2]+((H[a+40>>2]-H[a+36>>2]|0)/242])){break m}c=H[a+40>>2];n:{if((c|0)!=H[a+44>>2]){H[c>>2]=1832;d=H[e+20>>2];H[c+16>>2]=0;H[c+8>>2]=0;H[c+12>>2]=0;H[c+4>>2]=d;d=H[e+28>>2];f=H[e+24>>2];if((d|0)!=(f|0)){d=d-f|0;if((d|0)>2]=g;H[c+8>>2]=g;H[c+16>>2]=(d&-4)+g;k=H[e+24>>2];d=H[e+28>>2];if((k|0)!=(d|0)){while(1){L[g>>2]=L[k>>2];g=g+4|0;k=k+4|0;if((d|0)!=(k|0)){continue}break}}H[c+12>>2]=g}L[c+20>>2]=L[e+36>>2];H[a+40>>2]=c+24;break n}d=0;o:{p:{q:{r:{j=H[a+40>>2];f=H[a+36>>2];i=(j-f|0)/24|0;c=i+1|0;if(c>>>0>2]-f|0)/24|0;l=h>0>=89478485?178956970:c>>>0>>0?l:c;if(h){if(h>>>0>=178956971){break r}d=pa(N(h,24))}g=N(i,24)+d|0;H[g>>2]=1832;c=H[e+20>>2];H[g+16>>2]=0;H[g+8>>2]=0;H[g+12>>2]=0;H[g+4>>2]=c;c=H[e+24>>2];i=H[e+28>>2];if((c|0)!=(i|0)){l=i-c|0;if((l|0)>2]=k;H[g+16>>2]=(l&-4)+k;while(1){L[k>>2]=L[c>>2];k=k+4|0;c=c+4|0;if((i|0)!=(c|0)){continue}break}H[g+12>>2]=k}c=N(h,24)+d|0;L[g+20>>2]=L[e+36>>2];d=g+24|0;if((f|0)==(j|0)){break p}while(1){g=g-24|0;H[g>>2]=1832;j=j-24|0;H[g+4>>2]=H[j+4>>2];H[g+8>>2]=H[j+8>>2];H[g+12>>2]=H[j+12>>2];H[g+16>>2]=H[j+16>>2];H[j+16>>2]=0;H[j+8>>2]=0;H[j+12>>2]=0;L[g+20>>2]=L[j+20>>2];if((f|0)!=(j|0)){continue}break}H[a+44>>2]=c;k=H[a+40>>2];H[a+40>>2]=d;j=H[a+36>>2];H[a+36>>2]=g;if((j|0)==(k|0)){break o}while(1){k=k-24|0;ea[H[H[k>>2]>>2]](k)|0;if((j|0)!=(k|0)){continue}break}break o}sa();v()}wa();v()}sa();v()}H[a+44>>2]=c;H[a+40>>2]=d;H[a+36>>2]=g}if(j){oa(j)}}j=1}H[e+16>>2]=1832;c=H[e+24>>2];if(c){H[e+28>>2]=c;oa(c)}if(!j){break c}}n=n+1|0;if((ea[H[H[a>>2]+24>>2]](a)|0)>(n|0)){continue}break}break d}k=ea[H[H[a>>2]+24>>2]](a)|0;H[e+712>>2]=0;H[e+704>>2]=0;H[e+708>>2]=0;if(k){if(k>>>0>=214748365){break h}c=N(k,20);d=pa(c);H[e+704>>2]=d;H[e+712>>2]=c+d;c=c-20|0;c=(c-((c>>>0)%20|0)|0)+20|0;q=e,r=ra(d,0,c)+c|0,H[q+708>>2]=r;while(1){c=ea[H[H[a>>2]+20>>2]](a,m)|0;d=H[H[H[(ea[H[H[a>>2]+28>>2]](a)|0)+4>>2]+8>>2]+(c2];f=H[d+28>>2];c=f-1|0;if(c>>>00?c:0;if(h>>>0>4){break f}c=H[e+704>>2]+N(m,20)|0;i=I[d+24|0];H[c+16>>2]=i;H[c+12>>2]=h;H[c+8>>2]=f;H[c+4>>2]=g;H[c>>2]=d;g=g+i|0;m=m+1|0;if((k|0)!=(m|0)){continue}break}}c=ea[H[H[a>>2]+20>>2]](a,0)|0;m=H[H[H[(ea[H[H[a>>2]+28>>2]](a)|0)+4>>2]+8>>2]+(c2];F[m+84|0]=1;H[m+72>>2]=H[m+68>>2];h=H[b+12>>2];c=h;d=H[b+20>>2];f=H[b+8>>2];i=H[b+16>>2];if((c|0)>>0>>0|(c|0)>2];o=I[n+i|0];c=d;l=i+1|0;c=l?c:c+1|0;H[b+16>>2]=l;H[b+20>>2]=c;s:{switch(o|0){case 0:a=H[e+704>>2];if((H[e+708>>2]-a|0)!=20){break e}if(H[a+16>>2]!=3){break f}t:{if(f>>>0>>0&(c|0)>=(h|0)|(c|0)>(h|0)){break t}c=d;a=i+2|0;c=a>>>0>2]=a;H[b+20>>2]=c;c=d;a=i+6|0;c=a>>>0>>0>f>>>0&(c|0)>=(h|0)|(c|0)>(h|0)){break t}d=l+n|0;d=I[d|0]|I[d+1|0]2]=0;H[j+12>>2]=0;H[j+16>>2]=0;H[j>>2]=0;H[j+4>>2]=0;H[j+20>>2]=d;d=Ac(e+16|0,e+704|0);k=0;g=ca-32|0;ca=g;H[g+24>>2]=0;H[g+16>>2]=0;H[g+20>>2]=0;f=H[b+12>>2];m=f;i=H[b+8>>2];c=H[b+20>>2];l=c;h=H[b+16>>2];a=h+4|0;c=a>>>0>>0>i>>>0&(c|0)>=(f|0)|(c|0)>(f|0)){break u}n=H[b>>2];f=n+h|0;f=I[f|0]|I[f+1|0]>>0>=i>>>0|(c|0)>(m|0)){break u}a=F[a+n|0];c=l;f=h+5|0;c=f>>>0>2]=f;H[b+20>>2]=c;H[j+8>>2]=a;if((a|0)==1){if(Ud(j,b,g+16|0)){break v}break u}Rd(1799,23,H[3443]);break u;default:Rd(1774,24,H[3443]);break u;case 0:break w}}if(!Ud(j,b,g+16|0)){break u}}H[g+8>>2]=H[g+16>>2];H[g>>2]=H[g+20>>2];c=ca-32|0;ca=c;a=H[j>>2];p=L[j+4>>2];H[c+24>>2]=1065353216;h=-1>2]=p/O(a|0)}m=H[g+8>>2];n=H[g>>2];if((m|0)!=(n|0)){a=H[d+28>>2];while(1){b=H[m>>2];f=H[m+4>>2];p=L[c+24>>2];L[c+16>>2]=p*O(H[m+8>>2]-h|0);L[c+12>>2]=p*O(f-h|0);L[c+8>>2]=p*O(b-h|0);b=a;i=H[d+16>>2];f=H[i>>2];if(!I[f+84|0]){b=H[H[f+68>>2]+(a2]}if(K[f+80>>2]>b>>>0){a=H[f+40>>2];qa(H[H[f>>2]>>2]+N(a,b)|0,(c+8|0)+(H[i+4>>2]2];a=H[d+28>>2]}a=a+1|0;H[d+28>>2]=a;m=m+12|0;if((n|0)!=(m|0)){continue}break}}ca=c+32|0;k=1}a=H[g+16>>2];if(a){H[g+20>>2]=a;oa(a)}ca=g+32|0;yc(d);j=1;if(k){break f}}j=0;break f;case 1:break s;default:break f}}if(f>>>0>>0&(c|0)>=(h|0)|(c|0)>(h|0)){break f}o=I[l+n|0];c=d;l=i+2|0;c=l>>>0>2]=l;H[b+20>>2]=c;if(o>>>0>=7){H[e>>2]=o;Qd(1651,e);break f}c=d;d=i+6|0;c=d>>>0>>0>f>>>0&(c|0)>=(h|0)|(c|0)>(h|0)){break f}f=l+n|0;f=I[f|0]|I[f+1|0]2]+20>>2]](a,m)|0;c=H[H[H[(ea[H[H[a>>2]+28>>2]](a)|0)+4>>2]+8>>2]+(c2];mb(c,f);F[c+84|0]=1;H[c+72>>2]=H[c+68>>2];m=m+1|0;if((k|0)!=(m|0)){continue}break}}a=Ac(e+672|0,e+704|0);x:{y:{switch(o|0){case 1:c=wb(e+16|0,g);b=zd(c,b,a,-1);xb(c);if(!b){break g}break x;case 2:c=ub(e+16|0,g);b=yd(c,b,a,-1);vb(c);if(!b){break g}break x;case 3:c=ub(e+16|0,g);b=xd(c,b,a,-1);vb(c);if(!b){break g}break x;case 4:c=$a(e+16|0,g);b=wd(c,b,a,-1);ab(c);if(!b){break g}break x;case 5:c=$a(e+16|0,g);b=vd(c,b,a,-1);ab(c);if(!b){break g}break x;case 6:c=$a(e+16|0,g);b=ud(c,b,a,-1);ab(c);if(b){break x}break g;case 0:break y;default:break g}}c=wb(e+16|0,g);b=Bd(c,b,a,-1);xb(c);if(!b){break g}}yc(a);j=1;break f}sa();v()}sa();v()}yc(a)}a=H[e+704>>2]}if(!a){break a}H[e+708>>2]=a;oa(a);break a}j=1;if(H[a+52>>2]==H[a+48>>2]){break b}while(1){if(!td(1,e+16|0,b)){break c}c=H[a+48>>2];d=H[e+16>>2];H[c+(m2]=d>>>1^0-(d&1);m=m+1|0;if(m>>>0>2]-c>>2>>>0){continue}break}break b}j=0}a=H[e+672>>2];if(!a){break a}H[e+676>>2]=a;oa(a)}ca=e+720|0;return j|0}function te(a,b,c,d,e){var f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0;h=ca-32|0;ca=h;H[b+32>>2]=d;H[b+40>>2]=c;H[b+4>>2]=e;nc(a,d,h+16|0);a:{if(H[a>>2]){break a}if(F[a+15|0]>2])}d=I[h+23|0];if((ea[H[H[b>>2]+8>>2]](b)|0)!=(d|0)){b=pa(64);F[b+50|0]=0;c=I[1314]|I[1315]>8;c=I[1310]|I[1311]8;F[b+46|0]=c>>>16;F[b+47|0]=c>>>24;c=I[1302]|I[1303]8;F[b+38|0]=c>>>16;F[b+39|0]=c>>>24;c=I[1294]|I[1295]8;F[b+30|0]=c>>>16;F[b+31|0]=c>>>24;c=I[1286]|I[1287]8;F[b+22|0]=c>>>16;F[b+23|0]=c>>>24;c=I[1278]|I[1279]8;F[b+14|0]=c>>>16;F[b+15|0]=c>>>24;c=I[1270]|I[1271]8;F[b+6|0]=c>>>16;F[b+7|0]=c>>>24;H[a>>2]=-1;za(a+4|0,b,50);oa(b);break a}c=I[h+21|0];F[b+36|0]=c;e=I[h+22|0];F[b+37|0]=e;if((c-3&255)>>>0>>16;F[b+21|0]=c>>>24;c=I[1421]|I[1422]8;F[b+14|0]=c>>>16;F[b+15|0]=c>>>24;c=I[1413]|I[1414]8;F[b+6|0]=c>>>16;F[b+7|0]=c>>>24;H[a>>2]=-5;za(a+4|0,b,22);oa(b);break a}if(!((c|0)!=2|e>>>0>>0)){b=pa(32);F[b+22|0]=0;c=I[1404]|I[1405]8;F[b+20|0]=c>>>16;F[b+21|0]=c>>>24;c=I[1398]|I[1399]8;F[b+14|0]=c>>>16;F[b+15|0]=c>>>24;c=I[1390]|I[1391]8;F[b+6|0]=c>>>16;F[b+7|0]=c>>>24;H[a>>2]=-5;za(a+4|0,b,22);oa(b);break a}c=e|c2]+38>>1]=c;b:{if((c&65535)>>>0>1]>=0){break b}i=ca-16|0;ca=i;e=pa(36);c=e;H[c+4>>2]=0;H[c+8>>2]=0;H[c+24>>2]=0;H[c+28>>2]=0;c=c+16|0;H[c>>2]=0;H[c+4>>2]=0;H[e>>2]=e+4;H[e+32>>2]=0;H[e+12>>2]=c;H[i>>2]=0;d=H[b+32>>2];j=ca-16|0;ca=j;c=0;c:{if(!e){break c}H[i>>2]=d;H[j+12>>2]=0;c=0;if(!Bb(1,j+12|0,d)){break c}m=H[j+12>>2];if(m){while(1){d:{if(Bb(1,j+8|0,H[i>>2])){c=pa(28);H[c+4>>2]=0;H[c+8>>2]=0;d=c+16|0;H[d>>2]=0;H[d+4>>2]=0;H[c>>2]=c+4;H[c+12>>2]=d;H[c+24>>2]=H[j+8>>2];if(ce(i,c)){break d}Ra(c+12|0,H[c+16>>2]);Qa(c,H[c+4>>2]);oa(c)}c=0;break c}f=ca-16|0;ca=f;H[f+8>>2]=c;e:{if(!c){break e}d=H[e+28>>2];f:{if(d>>>0>2]){H[f+8>>2]=0;H[d>>2]=c;H[e+28>>2]=d+4;break f}d=0;g:{h:{i:{g=H[e+24>>2];l=H[e+28>>2]-g>>2;c=l+1|0;if(c>>>0>2]-g|0;k=g>>>1|0;g=g>>>0>=2147483644?1073741823:c>>>0>>0?k:c;if(g){if(g>>>0>=1073741824){break i}d=pa(g2];H[f+8>>2]=0;c=(l2]=k;g=(g2];k=H[e+24>>2];if((d|0)==(k|0)){break h}while(1){d=d-4|0;o=H[d>>2];H[d>>2]=0;c=c-4|0;H[c>>2]=o;if((d|0)!=(k|0)){continue}break}H[e+32>>2]=g;g=H[e+28>>2];H[e+28>>2]=l;d=H[e+24>>2];H[e+24>>2]=c;if((d|0)==(g|0)){break g}while(1){g=g-4|0;c=H[g>>2];H[g>>2]=0;if(c){Ra(c+12|0,H[c+16>>2]);Qa(c,H[c+4>>2]);oa(c)}if((d|0)!=(g|0)){continue}break}break g}sa();v()}wa();v()}H[e+32>>2]=g;H[e+28>>2]=l;H[e+24>>2]=c}if(d){oa(d)}}c=H[f+8>>2];H[f+8>>2]=0;if(!c){break e}Ra(c+12|0,H[c+16>>2]);Qa(c,H[c+4>>2]);oa(c)}ca=f+16|0;n=n+1|0;if((m|0)!=(n|0)){continue}break}}c=ce(i,e)}ca=j+16|0;j:{if(c){d=H[b+4>>2];c=H[d+4>>2];H[d+4>>2]=e;if(c){Uc(c)}H[a>>2]=0;H[a+4>>2]=0;H[a+8>>2]=0;H[a+12>>2]=0;break j}c=pa(32);F[c+26|0]=0;d=I[1579]|I[1580]>8;d=I[1575]|I[1576]8;F[c+22|0]=d>>>16;F[c+23|0]=d>>>24;d=I[1567]|I[1568]8;F[c+14|0]=d>>>16;F[c+15|0]=d>>>24;d=I[1559]|I[1560]8;F[c+6|0]=d>>>16;F[c+7|0]=d>>>24;H[a>>2]=-1;za(a+4|0,c,26);oa(c);H[i+8>>2]=0;Uc(e)}ca=i+16|0;if(H[a>>2]){break a}if(F[a+15|0]>=0){break b}oa(H[a+4>>2])}if(!(ea[H[H[b>>2]+12>>2]](b)|0)){b=pa(48);F[b+33|0]=0;F[b+32|0]=I[1384];c=I[1380]|I[1381]8;F[b+30|0]=c>>>16;F[b+31|0]=c>>>24;c=I[1372]|I[1373]8;F[b+22|0]=c>>>16;F[b+23|0]=c>>>24;c=I[1364]|I[1365]8;F[b+14|0]=c>>>16;F[b+15|0]=c>>>24;c=I[1356]|I[1357]8;F[b+6|0]=c>>>16;F[b+7|0]=c>>>24;H[a>>2]=-1;za(a+4|0,b,33);oa(b);break a}if(!(ea[H[H[b>>2]+20>>2]](b)|0)){b=mc(h,1582);H[a>>2]=-1;a=a+4|0;if(F[b+11|0]>=0){c=H[b+4>>2];H[a>>2]=H[b>>2];H[a+4>>2]=c;H[a+8>>2]=H[b+8>>2];break a}za(a,H[b>>2],H[b+4>>2]);if(F[b+11|0]>=0){break a}oa(H[b>>2]);break a}if(!(ea[H[H[b>>2]+24>>2]](b)|0)){b=mc(h,1317);H[a>>2]=-1;a=a+4|0;if(F[b+11|0]>=0){c=H[b+4>>2];H[a>>2]=H[b>>2];H[a+4>>2]=c;H[a+8>>2]=H[b+8>>2];break a}za(a,H[b>>2],H[b+4>>2]);if(F[b+11|0]>=0){break a}oa(H[b>>2]);break a}H[a>>2]=0;H[a+4>>2]=0;H[a+8>>2]=0;H[a+12>>2]=0}ca=h+32|0}function pg(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,w=0,x=0,y=0,z=0,A=0;m=ca-16|0;ca=m;H[m+12>>2]=b;b=pa(32);H[m>>2]=b;H[m+4>>2]=24;H[m+8>>2]=-2147483616;c=I[1206]|I[1207]8;F[b+22|0]=c>>>16;F[b+23|0]=c>>>24;c=I[1198]|I[1199]8;F[b+14|0]=c>>>16;F[b+15|0]=c>>>24;c=I[1190]|I[1191]8;F[b+6|0]=c>>>16;F[b+7|0]=c>>>24;F[b+24|0]=0;l=ca-48|0;ca=l;f=H[m+12>>2];d=a;a=a+16|0;b=H[a>>2];a:{b:{if(!b){break b}c=a;while(1){e=(f|0)>H[b+16>>2];c=e?c:b;b=H[(e?b+4|0:b)>>2];if(b){continue}break}if((a|0)==(c|0)){break b}if((f|0)>=H[c+16>>2]){break a}}H[l+28>>2]=0;H[l+32>>2]=0;y=l+24|0;H[l+24>>2]=y|4;a=l+16|0;H[a>>2]=0;H[a+4>>2]=0;H[l+8>>2]=f;H[l+12>>2]=a;t=l+8|0;a=t;x=ca-16|0;ca=x;u=d+12|0;c=H[u+4>>2];c:{d:{if(!c){o=u+4|0;d=o;break d}a=H[a>>2];while(1){d=c;b=H[c+16>>2];if((b|0)>(a|0)){o=d;c=H[d>>2];if(c){continue}break d}if((a|0)>2];if(c){continue}break}o=d+4|0}g=pa(32);b=H[t>>2];q=g+24|0;a=q;H[a>>2]=0;H[a+4>>2]=0;H[g+16>>2]=b;r=g+20|0;H[r>>2]=a;c=H[t+4>>2];z=t+8|0;if((c|0)!=(z|0)){while(1){p=ca-16|0;ca=p;a=p+8|0;k=c+16|0;e:{f:{g:{h:{i:{j:{k:{f=q;e=r+4|0;l:{if((f|0)==(e|0)){break l}b=I[f+27|0];h=b242]:i;b=h?H[f+20>>2]:b;s=i>>>0>b>>>0;w=s?b:i;if(w){j=j?H[k>>2]:k;h=h?H[f+16>>2]:f+16|0;A=Fa(j,h,w);if(!A){if(b>>>0>i>>>0){break l}break k}if((A|0)>=0){break k}break l}if(b>>>0>>0){break j}}h=H[f>>2];m:{a=f;n:{if((a|0)==H[r>>2]){break n}o:{if(!h){b=f;while(1){a=H[b+8>>2];i=H[a>>2]==(b|0);b=a;if(i){continue}break}break o}b=h;while(1){a=b;b=H[b+4>>2];if(b){continue}break}}i=I[k+11|0];s=i24;b=(s|0)2]:i;j=n?H[a+20>>2]:j;w=i>>>0>>0?i:j;if(w){b=Fa(n?H[a+16>>2]:a+16|0,b?H[k>>2]:k,w);if(b){break p}}if(i>>>0>j>>>0){break n}break m}if((b|0)>=0){break m}}if(!h){H[p+12>>2]=f;a=f;break e}H[p+12>>2]=a;a=a+4|0;break e}b=H[e>>2];if(!b){H[p+12>>2]=e;a=e;break e}h=(s|0)>2]:k;f=e;while(1){a=b;b=I[b+27|0];e=b24>2]:b;k=b>>>0>>0;q:{r:{s:{t:{n=k?b:i;u:{if(n){e=e?H[a+16>>2]:a+16|0;j=Fa(h,e,n);if(!j){if(b>>>0>i>>>0){break u}break t}if((j|0)>=0){break t}break u}if(b>>>0>>0){break s}}f=a;b=H[a>>2];if(b){continue}break g}b=Fa(e,h,n);if(b){break r}}if(k){break q}break g}if((b|0)>=0){break g}}f=a+4|0;b=H[a+4>>2];if(b){continue}break}break g}b=Fa(h,j,w);if(b){break i}}if(s){break h}break f}if((b|0)>=0){break f}}h=H[f+4>>2];v:{if(!h){b=f;while(1){a=H[b+8>>2];j=H[a>>2]!=(b|0);b=a;if(j){continue}break}break v}b=h;while(1){a=b;b=H[b>>2];if(b){continue}break}}w:{x:{if((a|0)==(e|0)){break x}j=I[a+27|0];b=j24>2]:j;s=i>>>0>j>>>0?j:i;if(s){b=Fa((n|0)>2]:k,b?H[a+16>>2]:a+16|0,s);if(b){break y}}if(i>>>0>>0){break x}break w}if((b|0)>=0){break w}}if(!h){H[p+12>>2]=f;a=f+4|0;break e}H[p+12>>2]=a;break e}b=H[e>>2];if(!b){H[p+12>>2]=e;a=e;break e}h=(n|0)>2]:k;f=e;while(1){a=b;b=I[b+27|0];e=b24>2]:b;k=b>>>0>>0;z:{A:{B:{C:{n=k?b:i;D:{if(n){e=e?H[a+16>>2]:a+16|0;j=Fa(h,e,n);if(!j){if(b>>>0>i>>>0){break D}break C}if((j|0)>=0){break C}break D}if(b>>>0>>0){break B}}f=a;b=H[a>>2];if(b){continue}break g}b=Fa(e,h,n);if(b){break A}}if(k){break z}break g}if((b|0)>=0){break g}}f=a+4|0;b=H[a+4>>2];if(b){continue}break}}H[p+12>>2]=a;a=f;break e}H[p+12>>2]=f;H[a>>2]=f}f=a;a=H[a>>2];if(a){b=0}else{a=pa(40);b=a+16|0;E:{if(F[c+27|0]>=0){e=H[c+20>>2];H[b>>2]=H[c+16>>2];H[b+4>>2]=e;H[b+8>>2]=H[c+24>>2];break E}za(b,H[c+16>>2],H[c+20>>2])}b=a+28|0;F:{if(F[c+39|0]>=0){e=H[c+32>>2];H[b>>2]=H[c+28>>2];H[b+4>>2]=e;H[b+8>>2]=H[c+36>>2];break F}za(b,H[c+28>>2],H[c+32>>2])}H[a+8>>2]=H[p+12>>2];H[a>>2]=0;H[a+4>>2]=0;H[f>>2]=a;b=a;e=H[H[r>>2]>>2];if(e){H[r>>2]=e;b=H[f>>2]}Sb(H[r+4>>2],b);H[r+8>>2]=H[r+8>>2]+1;b=1}F[x+12|0]=b;H[x+8>>2]=a;ca=p+16|0;b=H[c+4>>2];G:{if(b){while(1){c=b;b=H[b>>2];if(b){continue}break G}}while(1){a=c;c=H[c+8>>2];if((a|0)!=H[c>>2]){continue}break}}if((c|0)!=(z|0)){continue}break}}H[g+8>>2]=d;H[g>>2]=0;H[g+4>>2]=0;H[o>>2]=g;c=g;a=H[H[u>>2]>>2];if(a){H[u>>2]=a;c=H[o>>2]}Sb(H[u+4>>2],c);H[u+8>>2]=H[u+8>>2]+1;a=1}F[l+44|0]=a;H[l+40>>2]=g;ca=x+16|0;c=H[l+40>>2];Kb(t|4,H[l+16>>2]);Kb(y,H[l+28>>2])}f=ca-48|0;ca=f;d=f+8|0;g=ca-32|0;ca=g;o=g+32|0;b=o;a=g+21|0;H:{if((b|0)==(a|0)){break H}}e=b-a|0;I:{if((e|0)>2]=b;h=ca-16|0;ca=h;e=ca-16|0;ca=e;J:{q=H[g+8>>2];g=q-a|0;if(g>>>0>>0>>0>=11){k=g+16&-16;b=k-1|0;b=(b|0)==11?k:b}else{b=10}Zb(t,b+1|0);b=H[e+8>>2];H[d>>2]=b;H[d+8>>2]=H[d+8>>2]&-2147483648|H[e+12>>2]&2147483647;H[d+8>>2]=H[d+8>>2]|-2147483648;H[d+4>>2]=g}while(1){if((a|0)!=(q|0)){F[b|0]=I[a|0];b=b+1|0;a=a+1|0;continue}break}F[e+7|0]=0;F[b|0]=I[e+7|0];ca=e+16|0;break J}Na();v()}ca=h+16|0;ca=o;H[f+32>>2]=m;L:{M:{a=c+20|0;d=H[a+4>>2];N:{if(!d){g=a+4|0;c=g;break N}b=I[m+11|0];c=b24>2]:m;b=c?H[m+4>>2]:b;while(1){c=d;d=I[c+27|0];g=d24>2]:d;o=d>>>0>>0;O:{P:{Q:{R:{h=o?d:b;S:{if(h){g=g?H[c+16>>2]:c+16|0;q=Fa(e,g,h);if(!q){if(b>>>0>>0){break S}break R}if((q|0)>=0){break R}break S}if(b>>>0>=d>>>0){break Q}}g=c;d=H[c>>2];if(d){continue}break N}d=Fa(g,e,h);if(d){break P}}if(o){break O}break M}if((d|0)>=0){break M}}d=H[c+4>>2];if(d){continue}break}g=c+4|0}d=pa(40);e=d+16|0;b=H[f+32>>2];T:{if(F[b+11|0]>=0){o=H[b+4>>2];H[e>>2]=H[b>>2];H[e+4>>2]=o;H[e+8>>2]=H[b+8>>2];break T}za(e,H[b>>2],H[b+4>>2])}H[d+8>>2]=c;H[d>>2]=0;H[d+4>>2]=0;H[d+36>>2]=0;H[d+28>>2]=0;H[d+32>>2]=0;H[g>>2]=d;c=d;b=H[H[a>>2]>>2];if(b){H[a>>2]=b;c=H[g>>2]}Sb(H[a+4>>2],c);H[a+8>>2]=H[a+8>>2]+1;a=1;break L}d=c;a=0}F[f+44|0]=a;H[f+40>>2]=d;a=H[f+40>>2];if(F[a+39|0]>2])}b=H[f+12>>2];H[a+28>>2]=H[f+8>>2];H[a+32>>2]=b;H[a+36>>2]=H[f+16>>2];ca=f+48|0;ca=l+48|0;if(F[m+11|0]>2])}ca=m+16|0}function Bd(a,b,c,d){var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0;j=H[b+8>>2];e=H[b+12>>2];g=H[b+20>>2];h=H[b+16>>2];k=h+4|0;g=k>>>0>>0>>0&(e|0)2]|0;H[a>>2]=I[h|0]|I[h+1|0]>0>2]=g;H[b+20>>2]=h;if(K[a>>2]>32){break a}l=H[b+8>>2];k=H[b+12>>2];h=e;e=j+8|0;h=e>>>0>>0>l>>>0&(h|0)>=(k|0)|(h|0)>(k|0)){break a}h=H[b>>2]+g|0;g=I[h|0]|I[h+1|0]2]+4|0;h=e>>>0>2]=e;H[b+20>>2]=h;if(!g){return 1}if(d>>>0>>0){break a}H[a+8>>2]=0;if(!ua(a+16|0,b)){break a}if(!ua(a+36|0,b)){break a}if(!ua(a+56|0,b)){break a}if(!ua(a+76|0,b)){break a}s=H[a+4>>2];h=c;b=0;g=0;e=ca-32|0;ca=e;d=a;a=H[a+12>>2];H[e+16>>2]=0;H[e+8>>2]=0;H[e+12>>2]=0;b:{c:{if(a){if(a>>>0>=1073741824){break c}c=a2]=b;g=b+c|0;H[e+16>>2]=g;ra(b,0,c);H[e+12>>2]=g}c=H[d+120>>2];i=H[c>>2];if(i){H[c+4>>2]=i;oa(i);g=H[e+12>>2];b=H[e+8>>2];a=H[d+12>>2]}H[c+4>>2]=g;H[c>>2]=b;H[c+8>>2]=H[e+16>>2];b=0;H[e+16>>2]=0;H[e+8>>2]=0;H[e+12>>2]=0;d:{if(a){if(a>>>0>=1073741824){break d}a=a2]=f;b=a+f|0;H[e+16>>2]=b;ra(f,0,a);H[e+12>>2]=b}a=H[d+132>>2];c=H[a>>2];if(c){H[a+4>>2]=c;oa(c);f=H[e+8>>2];b=H[e+12>>2]}H[a+4>>2]=b;H[a>>2]=f;H[a+8>>2]=H[e+16>>2];H[e+24>>2]=0;H[e+28>>2]=0;H[e+16>>2]=0;H[e+20>>2]=0;H[e+8>>2]=0;H[e+12>>2]=0;xa(e+8|0);a=H[e+24>>2]+H[e+28>>2]|0;b=(a>>>0)/341|0;a=H[H[e+12>>2]+(b2]+N(a-N(b,341)|0,12)|0;H[a+4>>2]=0;H[a+8>>2]=0;H[a>>2]=s;c=1;a=H[e+28>>2]+1|0;H[e+28>>2]=a;e:{if(!a){break e}while(1){b=H[e+12>>2];f=H[e+24>>2];k=a-1|0;c=f+k|0;i=(c>>>0)/341|0;c=H[b+(i2]+N(c-N(i,341)|0,12)|0;g=H[c+8>>2];i=H[c+4>>2];j=H[c>>2];H[e+28>>2]=k;c=H[e+16>>2];if((((b|0)!=(c|0)?N(c-b>>2,341)-1|0:0)-(a+f|0)|0)+1>>>0>=682){oa(H[c-4>>2]);H[e+16>>2]=H[e+16>>2]-4}c=0;if(j>>>0>s>>>0){break e}b=H[d+12>>2];a=(b-1|0)!=(i|0)?i+1|0:0;if(a>>>0>=b>>>0){break e}f=N(g,12);o=f+H[d+132>>2]|0;k=f+H[d+120>>2]|0;i=H[d>>2];l=a2]>>2];f:{g:{if((i|0)==(m|0)){if(!j){break g}o=0;b=H[h+20>>2];g=H[h+16>>2];if((b|0)==(g|0)){a=H[d+8>>2];H[h+28>>2]=j+H[h+28>>2];H[d+8>>2]=a+j;break g}while(1){c=(b|0)==(g|0);a=b;i=0;b=g;h:{if(c){break h}while(1){f=H[h+28>>2];b=a;c=N(i,20)+g|0;l=H[c>>2];if(!I[l+84|0]){f=H[H[l+68>>2]+(f2]}if(K[l+80>>2]>>0){break h}m=H[k>>2]+(H[c+4>>2]2];b=m;i:{if(g>>>0>3){break i}a=0;b=H[h+12>>2];if(!H[c+16>>2]){break i}while(1){b=qa(b,m+(a2];b=b+g|0;a=a+1|0;if(a>>>0>2]){continue}break}b=H[h+12>>2]}a=H[l+40>>2];qa(H[H[l>>2]>>2]+N(a,f)|0,b,a);i=i+1|0;a=H[h+20>>2];b=a;g=H[h+16>>2];if(i>>>0>>0){continue}break}}H[h+28>>2]=H[h+28>>2]+1;H[d+8>>2]=H[d+8>>2]+1;o=o+1|0;if((j|0)!=(o|0)){continue}break}break g}j:{k:{l:{m:{if(j>>>0>2];H[c>>2]=a;f=1;b=H[d+12>>2];if(b>>>0>1){break m}break j}if(K[d+8>>2]>K[d+4>>2]){break e}b=H[d+120>>2];n=g+1|0;o=N(n,12);p=b+o|0;if((p|0)!=(k|0)){Aa(p,H[k>>2],H[k+4>>2]);b=H[d+120>>2]}b=l+H[b+o>>2]|0;H[b>>2]=H[b>>2]+(12];m=32-i|0;n:{if((b|0)>2];if((k|0)==H[d+20>>2]){break l}m=H[k>>2];p=b+i|0;H[d+32>>2]=p;b=m>32-b|0;if((p|0)!=32){break n}H[d+32>>2]=0;H[d+28>>2]=k+4;break n}k=H[d+28>>2];p=k+4|0;if((p|0)==H[d+20>>2]){break l}r=H[k>>2];H[d+28>>2]=p;m=b-m|0;H[d+32>>2]=m;b=H[k+4>>2]>>>32-m|r>32-b}i=j>>>1|0;if(i>>>0>>0){break e}break k}while(1){a=(b-1|0)!=(a|0)?a+1|0:0;H[c+(f2]=a;b=H[d+12>>2];f=f+1|0;if(b>>>0>f>>>0){continue}break}break j}i=j>>>1|0;b=0}o:{p:{b=i-b|0;c=j-b|0;q:{if((c|0)==(b|0)){c=b;break q}i=H[d+88>>2];if((i|0)==H[d+80>>2]){break p}j=H[i>>2];k=H[d+92>>2];m=k+1|0;H[d+92>>2]=m;j=j&-2147483648>>>k;r:{if((m|0)==32){H[d+92>>2]=0;H[d+88>>2]=i+4;if(j){break r}break p}if(!j){break p}}}i=c;c=b;break o}i=b}b=H[d+132>>2];j=b+f|0;f=H[j>>2];k=f+l|0;H[k>>2]=H[k>>2]+1;Aa(b+o|0,f,H[j+4>>2]);if(c){b=H[e+28>>2]+H[e+24>>2]|0;j=H[e+16>>2];f=H[e+12>>2];if((b|0)==(((f|0)!=(j|0)?N(j-f>>2,341)-1|0:0)|0)){xa(e+8|0);f=H[e+12>>2];b=H[e+24>>2]+H[e+28>>2]|0}j=(b>>>0)/341|0;b=H[(j2]+N(b-N(j,341)|0,12)|0;H[b+8>>2]=g;H[b+4>>2]=a;H[b>>2]=c;H[e+28>>2]=H[e+28>>2]+1}if(!i){break g}b=H[e+28>>2]+H[e+24>>2]|0;c=H[e+16>>2];f=H[e+12>>2];if((b|0)==(((c|0)!=(f|0)?N(c-f>>2,341)-1|0:0)|0)){xa(e+8|0);f=H[e+12>>2];b=H[e+24>>2]+H[e+28>>2]|0}c=(b>>>0)/341|0;b=H[(c2]+N(b-N(c,341)|0,12)|0;H[b+8>>2]=n;H[b+4>>2]=a;H[b>>2]=i;a=H[e+28>>2]+1|0;H[e+28>>2]=a;break f}m=0;if(!j){break g}while(1){if(H[d+12>>2]){i=H[d+40>>2];p=H[o>>2];c=H[d+96>>2];r=H[d+108>>2];a=0;while(1){g=r+(a2]2]=0;b=H[d>>2];f=H[g>>2]2];s:{if((b|0)==(l|0)){break s}f=c+f|0;b=b-l|0;l=H[d+52>>2];q=32-l|0;if((b|0)>2];if((n|0)==(i|0)){c=0;break e}H[f>>2]=H[n>>2]>32-b;b=b+H[d+52>>2]|0;H[d+52>>2]=b;if((b|0)!=32){break s}H[d+52>>2]=0;H[d+48>>2]=n+4;break s}n=H[d+48>>2];t=n+4|0;if((i|0)==(t|0)){c=0;break e}u=H[n>>2];H[d+48>>2]=t;q=b-q|0;H[d+52>>2]=q;H[f>>2]=H[n+4>>2]>>>32-q|u>32-b}b=H[g>>2]2]=H[g>>2]|H[b+H[k>>2]>>2];a=a+1|0;if(a>>>0>2]){continue}break}}i=0;a=H[h+16>>2];t:{if((a|0)==H[h+20>>2]){break t}while(1){f=H[h+28>>2];c=N(i,20)+a|0;l=H[c>>2];if(!I[l+84|0]){f=H[H[l+68>>2]+(f2]}if(K[l+80>>2]>>0){break t}n=H[d+96>>2]+(H[c+4>>2]2];b=n;u:{if(g>>>0>3){break u}a=0;b=H[h+12>>2];if(!H[c+16>>2]){break u}while(1){b=qa(b,n+(a2];b=b+g|0;a=a+1|0;if(a>>>0>2]){continue}break}b=H[h+12>>2]}a=H[l+40>>2];qa(H[H[l>>2]>>2]+N(a,f)|0,b,a);i=i+1|0;a=H[h+16>>2];if(i>>>0>2]-a|0)/20>>>0){continue}break}}H[h+28>>2]=H[h+28>>2]+1;H[d+8>>2]=H[d+8>>2]+1;m=m+1|0;if((j|0)!=(m|0)){continue}break}}a=H[e+28>>2]}if(a){continue}break}c=1}H[e+28>>2]=0;f=H[e+16>>2];a=H[e+12>>2];b=f-a|0;if(b>>>0>=9){while(1){oa(H[a>>2]);a=H[e+12>>2]+4|0;H[e+12>>2]=a;f=H[e+16>>2];b=f-a|0;if(b>>>0>8){continue}break}}g=170;v:{switch((b>>>2|0)-1|0){case 1:g=341;case 0:H[e+24>>2]=g;break;default:break v}}w:{if((a|0)==(f|0)){break w}while(1){oa(H[a>>2]);a=a+4|0;if((f|0)!=(a|0)){continue}break}a=H[e+16>>2];b=H[e+12>>2];if((a|0)==(b|0)){break w}H[e+16>>2]=a+((b-a|0)+3&-4)}a=H[e+8>>2];if(a){oa(a)}ca=e+32|0;break b}sa();v()}sa();v()}i=c}return i}function zd(a,b,c,d){var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0;j=H[b+8>>2];l=H[b+12>>2];k=H[b+20>>2];i=H[b+16>>2];f=i+4|0;k=f>>>0>>0>j>>>0&(k|0)>=(l|0)|(k|0)>(l|0)){break a}i=i+H[b>>2]|0;H[a>>2]=I[i|0]|I[i+1|0]>0>2]=i;H[b+20>>2]=l;if(K[a>>2]>32){break a}l=H[b+8>>2];k=H[b+12>>2];f=f+8|0;j=f>>>0>0>l>>>0|(k|0)>2]+i|0;f=I[i|0]|I[i+1|0]2]+4|0;j=i>>>0>2]=i;H[b+20>>2]=j;if(!f){return 1}if(d>>>0>>0){break a}H[a+8>>2]=0;if(!ua(a+16|0,b)){break a}if(!ua(a+36|0,b)){break a}if(!ua(a+56|0,b)){break a}if(!ua(a+76|0,b)){break a}t=H[a+4>>2];i=c;b=0;c=0;e=ca-32|0;ca=e;f=a;a=H[a+12>>2];H[e+16>>2]=0;H[e+8>>2]=0;H[e+12>>2]=0;b:{c:{if(a){if(a>>>0>=1073741824){break c}d=a2]=b;c=b+d|0;H[e+16>>2]=c;ra(b,0,d);H[e+12>>2]=c}g=H[f+120>>2];d=H[g>>2];if(d){H[g+4>>2]=d;oa(d);c=H[e+12>>2];b=H[e+8>>2];a=H[f+12>>2]}H[g+4>>2]=c;H[g>>2]=b;H[g+8>>2]=H[e+16>>2];b=0;H[e+16>>2]=0;H[e+8>>2]=0;H[e+12>>2]=0;d:{if(a){if(a>>>0>=1073741824){break d}a=a2]=h;b=a+h|0;H[e+16>>2]=b;ra(h,0,a);H[e+12>>2]=b}c=H[f+132>>2];a=H[c>>2];if(a){H[c+4>>2]=a;oa(a);h=H[e+8>>2];b=H[e+12>>2]}H[c+4>>2]=b;H[c>>2]=h;H[c+8>>2]=H[e+16>>2];H[e+24>>2]=0;H[e+28>>2]=0;H[e+16>>2]=0;H[e+20>>2]=0;H[e+8>>2]=0;H[e+12>>2]=0;xa(e+8|0);b=H[e+24>>2]+H[e+28>>2]|0;a=(b>>>0)/341|0;a=H[H[e+12>>2]+(a2]+N(b-N(a,341)|0,12)|0;H[a+4>>2]=0;H[a+8>>2]=0;H[a>>2]=t;d=1;a=H[e+28>>2]+1|0;H[e+28>>2]=a;e:{if(!a){break e}while(1){j=H[e+12>>2];g=H[e+24>>2];d=a-1|0;c=g+d|0;b=(c>>>0)/341|0;b=H[j+(b2]+N(c-N(b,341)|0,12)|0;n=H[b+8>>2];c=H[b+4>>2];m=H[b>>2];H[e+28>>2]=d;b=H[e+16>>2];if((((b|0)!=(j|0)?N(b-j>>2,341)-1|0:0)-(a+g|0)|0)+1>>>0>=682){oa(H[b-4>>2]);H[e+16>>2]=H[e+16>>2]-4}if(m>>>0>t>>>0){d=0;break e}d=0;b=H[f+12>>2];a=(c|0)!=(b-1|0)?c+1|0:0;if(a>>>0>=b>>>0){break e}b=H[f+120>>2];o=N(n,12);q=b+o|0;g=H[f>>2];h=a2]|0;c=H[h+H[l>>2]>>2];f:{g:{if((g|0)==(c|0)){if(!m){break g}h=0;b=H[i+20>>2];c=H[i+16>>2];if((b|0)==(c|0)){a=H[f+8>>2];H[i+28>>2]=m+H[i+28>>2];H[f+8>>2]=a+m;break g}while(1){d=(b|0)==(c|0);a=b;g=0;b=c;h:{if(d){break h}while(1){d=H[i+28>>2];b=a;k=N(g,20)+c|0;l=H[k>>2];if(!I[l+84|0]){d=H[H[l+68>>2]+(d2]}if(K[l+80>>2]>>0){break h}j=H[q>>2]+(H[k+4>>2]2];b=j;i:{if(c>>>0>3){break i}a=0;b=H[i+12>>2];if(!H[k+16>>2]){break i}while(1){b=qa(b,j+(a2];b=b+c|0;a=a+1|0;if(a>>>0>2]){continue}break}b=H[i+12>>2]}a=H[l+40>>2];qa(H[H[l>>2]>>2]+N(a,d)|0,b,a);g=g+1|0;a=H[i+20>>2];b=a;c=H[i+16>>2];if(g>>>0>>0){continue}break}}H[i+28>>2]=H[i+28>>2]+1;H[f+8>>2]=H[f+8>>2]+1;h=h+1|0;if((m|0)!=(h|0)){continue}break}break g}j:{k:{l:{m:{if(m>>>0>2];H[c>>2]=a;h=1;b=H[f+12>>2];if(b>>>0>1){break m}break j}if(K[f+8>>2]>K[f+4>>2]){break e}j=b;b=o+12|0;Aa(j+b|0,H[q>>2],H[q+4>>2]);b=h+H[b+H[f+120>>2]>>2]|0;H[b>>2]=H[b>>2]+(12];g=32-l|0;n:{if((k|0)>2];if((g|0)==H[f+20>>2]){break l}c=H[g>>2];b=k+l|0;H[f+32>>2]=b;c=c>32-k|0;if((b|0)!=32){break n}H[f+32>>2]=0;H[f+28>>2]=g+4;break n}j=H[f+28>>2];b=j+4|0;if((b|0)==H[f+20>>2]){break l}c=H[j>>2];H[f+28>>2]=b;b=k-g|0;H[f+32>>2]=b;c=H[j+4>>2]>>>32-b|c>32-k}g=m>>>1|0;if(g>>>0>>0){break e}break k}while(1){a=(b-1|0)!=(a|0)?a+1|0:0;H[c+(h2]=a;b=H[f+12>>2];h=h+1|0;if(b>>>0>h>>>0){continue}break}break j}g=m>>>1|0;c=0}k=n+1|0;o:{p:{b=g-c|0;c=m-b|0;q:{if((c|0)==(b|0)){c=b;break q}l=H[f+88>>2];if((l|0)==H[f+80>>2]){break p}j=H[l>>2];g=H[f+92>>2];d=g+1|0;H[f+92>>2]=d;g=j&-2147483648>>>g;r:{if((d|0)==32){H[f+92>>2]=0;H[f+88>>2]=l+4;if(g){break r}break p}if(!g){break p}}}g=c;c=b;break o}g=b}l=H[f+132>>2];j=l+o|0;d=H[j>>2];b=d+h|0;H[b>>2]=H[b>>2]+1;Aa(l+N(k,12)|0,d,H[j+4>>2]);if(c){b=H[e+28>>2]+H[e+24>>2]|0;d=H[e+16>>2];h=H[e+12>>2];if((b|0)==(((d|0)!=(h|0)?N(d-h>>2,341)-1|0:0)|0)){xa(e+8|0);h=H[e+12>>2];b=H[e+24>>2]+H[e+28>>2]|0}d=(b>>>0)/341|0;b=H[(d2]+N(b-N(d,341)|0,12)|0;H[b+8>>2]=n;H[b+4>>2]=a;H[b>>2]=c;H[e+28>>2]=H[e+28>>2]+1}if(!g){break g}b=H[e+28>>2]+H[e+24>>2]|0;c=H[e+16>>2];h=H[e+12>>2];if((b|0)==(((c|0)!=(h|0)?N(c-h>>2,341)-1|0:0)|0)){xa(e+8|0);h=H[e+12>>2];b=H[e+24>>2]+H[e+28>>2]|0}c=(b>>>0)/341|0;b=H[(c2]+N(b-N(c,341)|0,12)|0;H[b+8>>2]=k;H[b+4>>2]=a;H[b>>2]=g;a=H[e+28>>2]+1|0;H[e+28>>2]=a;break f}r=0;if(!m){break g}while(1){if(H[f+12>>2]){u=H[f+40>>2];j=H[l>>2];s=H[f+96>>2];g=H[f+108>>2];a=0;while(1){n=(a2]2]=0;d=H[f>>2];c=H[n>>2]2];s:{if((d|0)==(b|0)){break s}o=c+s|0;p=d-b|0;h=H[f+52>>2];d=32-h|0;if((p|0)>2];if((c|0)==(u|0)){d=0;break e}H[o>>2]=H[c>>2]>32-p;b=p+H[f+52>>2]|0;H[f+52>>2]=b;if((b|0)!=32){break s}H[f+52>>2]=0;H[f+48>>2]=c+4;break s}k=H[f+48>>2];b=k+4|0;if((u|0)==(b|0)){d=0;break e}c=H[k>>2];H[f+48>>2]=b;b=p-d|0;H[f+52>>2]=b;H[o>>2]=H[k+4>>2]>>>32-b|c>32-p}c=H[n>>2]2]=H[b>>2]|H[c+H[q>>2]>>2];a=a+1|0;if(a>>>0>2]){continue}break}}g=0;a=H[i+16>>2];t:{if((a|0)==H[i+20>>2]){break t}while(1){d=H[i+28>>2];h=N(g,20)+a|0;k=H[h>>2];if(!I[k+84|0]){d=H[H[k+68>>2]+(d2]}if(K[k+80>>2]>>0){break t}j=H[f+96>>2]+(H[h+4>>2]2];b=j;u:{if(c>>>0>3){break u}a=0;b=H[i+12>>2];if(!H[h+16>>2]){break u}while(1){b=qa(b,j+(a2];b=b+c|0;a=a+1|0;if(a>>>0>2]){continue}break}b=H[i+12>>2]}a=H[k+40>>2];qa(H[H[k>>2]>>2]+N(a,d)|0,b,a);g=g+1|0;a=H[i+16>>2];if(g>>>0>2]-a|0)/20>>>0){continue}break}}H[i+28>>2]=H[i+28>>2]+1;H[f+8>>2]=H[f+8>>2]+1;r=r+1|0;if((m|0)!=(r|0)){continue}break}}a=H[e+28>>2]}if(a){continue}break}d=1}H[e+28>>2]=0;h=H[e+16>>2];a=H[e+12>>2];b=h-a|0;if(b>>>0>=9){while(1){oa(H[a>>2]);a=H[e+12>>2]+4|0;H[e+12>>2]=a;h=H[e+16>>2];b=h-a|0;if(b>>>0>8){continue}break}}c=170;v:{switch((b>>>2|0)-1|0){case 1:c=341;case 0:H[e+24>>2]=c;break;default:break v}}w:{if((a|0)==(h|0)){break w}while(1){oa(H[a>>2]);a=a+4|0;if((h|0)!=(a|0)){continue}break}b=H[e+16>>2];a=H[e+12>>2];if((b|0)==(a|0)){break w}H[e+16>>2]=b+((a-b|0)+3&-4)}a=H[e+8>>2];if(a){oa(a)}ca=e+32|0;g=d;break b}sa();v()}sa();v()}}return g}function wd(a,b,c,d){var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,w=0;i=H[b+8>>2];j=H[b+12>>2];n=H[b+20>>2];e=H[b+16>>2];h=e+4|0;n=h>>>0>>0>>0&(j|0)2]|0;H[a>>2]=I[e|0]|I[e+1|0]>0>2]=e;H[b+20>>2]=j;if(K[a>>2]>32){break a}j=H[b+8>>2];n=H[b+12>>2];h=h+8|0;i=h>>>0>>0>j>>>0&(i|0)>=(n|0)|(i|0)>(n|0)){break a}e=H[b>>2]+e|0;h=I[e|0]|I[e+1|0]2]+4|0;i=e>>>0>2]=e;H[b+20>>2]=i;if(!h){return 1}if(d>>>0>>0){break a}H[a+8>>2]=0;if(!sb(a+16|0,b)){break a}if(!ua(a+544|0,b)){break a}if(!ua(a+564|0,b)){break a}if(!ua(a+584|0,b)){break a}u=H[a+4>>2];d=c;b=0;c=0;f=ca-32|0;ca=f;g=a;a=H[a+12>>2];H[f+16>>2]=0;H[f+8>>2]=0;H[f+12>>2]=0;b:{c:{if(a){if(a>>>0>=1073741824){break c}e=a2]=b;c=b+e|0;H[f+16>>2]=c;ra(b,0,e);H[f+12>>2]=c}h=H[g+628>>2];e=H[h>>2];if(e){H[h+4>>2]=e;oa(e);c=H[f+12>>2];b=H[f+8>>2];a=H[g+12>>2]}H[h+4>>2]=c;H[h>>2]=b;H[h+8>>2]=H[f+16>>2];b=0;H[f+16>>2]=0;H[f+8>>2]=0;H[f+12>>2]=0;d:{if(a){if(a>>>0>=1073741824){break d}a=a2]=k;b=a+k|0;H[f+16>>2]=b;ra(k,0,a);H[f+12>>2]=b}c=H[g+640>>2];a=H[c>>2];if(a){H[c+4>>2]=a;oa(a);k=H[f+8>>2];b=H[f+12>>2]}H[c+4>>2]=b;H[c>>2]=k;H[c+8>>2]=H[f+16>>2];H[f+24>>2]=0;H[f+28>>2]=0;H[f+16>>2]=0;H[f+20>>2]=0;H[f+8>>2]=0;H[f+12>>2]=0;xa(f+8|0);b=H[f+24>>2]+H[f+28>>2]|0;a=(b>>>0)/341|0;a=H[H[f+12>>2]+(a2]+N(b-N(a,341)|0,12)|0;H[a+4>>2]=0;H[a+8>>2]=0;H[a>>2]=u;c=1;a=H[f+28>>2]+1|0;H[f+28>>2]=a;e:{if(!a){break e}n=g+16|0;while(1){j=H[f+12>>2];h=H[f+24>>2];e=a-1|0;c=h+e|0;b=(c>>>0)/341|0;b=H[j+(b2]+N(c-N(b,341)|0,12)|0;q=H[b+8>>2];i=H[b+4>>2];o=H[b>>2];H[f+28>>2]=e;b=H[f+16>>2];if((((b|0)!=(j|0)?N(b-j>>2,341)-1|0:0)-(a+h|0)|0)+1>>>0>=682){oa(H[b-4>>2]);H[f+16>>2]=H[f+16>>2]-4}c=0;if(o>>>0>u>>>0){break e}a=H[g+12>>2];k=(i|0)!=(a-1|0)?i+1|0:0;if(k>>>0>=a>>>0){break e}p=N(q,12);w=p+H[g+640>>2]|0;r=p+H[g+628>>2]|0;h=H[g>>2];l=k2]>>2];f:{g:{if((h|0)==(e|0)){if(!o){break g}c=H[d+16>>2];b=H[d+20>>2];m=0;while(1){e=(b|0)==(c|0);a=b;j=0;b=c;h:{if(e){break h}while(1){l=H[d+28>>2];b=a;i=N(j,20)+c|0;h=H[i>>2];if(!I[h+84|0]){l=H[H[h+68>>2]+(l2]}if(K[h+80>>2]>>0){break h}e=H[r>>2]+(H[i+4>>2]2];b=e;i:{if(c>>>0>3){break i}a=0;b=H[d+12>>2];if(!H[i+16>>2]){break i}while(1){b=qa(b,e+(a2];b=b+c|0;a=a+1|0;if(a>>>0>2]){continue}break}b=H[d+12>>2]}a=H[h+40>>2];qa(H[H[h>>2]>>2]+N(a,l)|0,b,a);a=H[d+20>>2];b=a;j=j+1|0;c=H[d+16>>2];if(j>>>0>>0){continue}break}}H[d+28>>2]=H[d+28>>2]+1;H[g+8>>2]=H[g+8>>2]+1;m=m+1|0;if((o|0)!=(m|0)){continue}break}break g}j:{k:{l:{if(o>>>0>2];H[c>>2]=k;a=1;b=H[g+12>>2];if(b>>>0>1){break l}break j}if(K[g+8>>2]>K[g+4>>2]){break e}a=H[g+628>>2];j=q+1|0;m=N(j,12);b=a+m|0;if((b|0)!=(r|0)){Aa(b,H[r>>2],H[r+4>>2]);a=H[g+628>>2]}a=l+H[a+m>>2]|0;H[a>>2]=H[a>>2]+(1>1|0;break k}while(1){b=Ba((a>>0>>0){break k}c=0;break e}while(1){k=(b-1|0)!=(k|0)?k+1|0:0;H[c+(a2]=k;a=a+1|0;b=H[g+12>>2];if(a>>>0>>0){continue}break}break j}m:{n:{b=a-b|0;a=o-b|0;o:{if((a|0)==(b|0)){a=b;break o}i=H[g+596>>2];if((i|0)==H[g+588>>2]){break n}h=H[i>>2];e=H[g+600>>2];c=e+1|0;H[g+600>>2]=c;e=h&-2147483648>>>e;p:{if((c|0)==32){H[g+600>>2]=0;H[g+596>>2]=i+4;if(e){break p}break n}if(!e){break n}}}c=a;a=b;break m}c=b}i=H[g+640>>2];h=i+p|0;e=H[h>>2];b=e+l|0;H[b>>2]=H[b>>2]+1;Aa(i+m|0,e,H[h+4>>2]);if(a){m=H[f+28>>2]+H[f+24>>2]|0;e=H[f+16>>2];b=H[f+12>>2];if((m|0)==(((b|0)!=(e|0)?N(e-b>>2,341)-1|0:0)|0)){xa(f+8|0);m=H[f+24>>2]+H[f+28>>2]|0;e=H[f+12>>2]}else{e=b}b=(m>>>0)/341|0;b=H[e+(b2]+N(m-N(b,341)|0,12)|0;H[b+8>>2]=q;H[b+4>>2]=k;H[b>>2]=a;H[f+28>>2]=H[f+28>>2]+1}if(!c){break g}b=H[f+28>>2]+H[f+24>>2]|0;e=H[f+16>>2];a=H[f+12>>2];if((b|0)==(((a|0)!=(e|0)?N(e-a>>2,341)-1|0:0)|0)){xa(f+8|0);b=H[f+24>>2]+H[f+28>>2]|0;e=H[f+12>>2]}else{e=a}a=(b>>>0)/341|0;a=H[e+(a2]+N(b-N(a,341)|0,12)|0;H[a+8>>2]=j;H[a+4>>2]=k;H[a>>2]=c;a=H[f+28>>2]+1|0;H[f+28>>2]=a;break f}k=0;if(!o){break g}while(1){if(H[g+12>>2]){q=H[g+548>>2];i=H[w>>2];t=H[g+604>>2];h=H[g+616>>2];a=0;while(1){p=(a2]2]=0;e=H[g>>2];c=H[p>>2]2];q:{if((e|0)==(b|0)){break q}l=c+t|0;s=e-b|0;m=H[g+560>>2];e=32-m|0;if((s|0)>2];if((c|0)==(q|0)){c=0;break e}H[l>>2]=H[c>>2]>32-s;b=s+H[g+560>>2]|0;H[g+560>>2]=b;if((b|0)!=32){break q}H[g+560>>2]=0;H[g+556>>2]=c+4;break q}j=H[g+556>>2];b=j+4|0;if((q|0)==(b|0)){c=0;break e}c=H[j>>2];H[g+556>>2]=b;b=s-e|0;H[g+560>>2]=b;H[l>>2]=H[j+4>>2]>>>32-b|c>32-s}c=H[p>>2]2]=H[b>>2]|H[c+H[r>>2]>>2];a=a+1|0;if(a>>>0>2]){continue}break}}j=0;a=H[d+16>>2];r:{if((a|0)==H[d+20>>2]){break r}while(1){l=H[d+28>>2];i=N(j,20)+a|0;h=H[i>>2];if(!I[h+84|0]){l=H[H[h+68>>2]+(l2]}if(K[h+80>>2]>>0){break r}e=H[g+604>>2]+(H[i+4>>2]2];b=e;s:{if(c>>>0>3){break s}a=0;b=H[d+12>>2];if(!H[i+16>>2]){break s}while(1){b=qa(b,e+(a2];b=b+c|0;a=a+1|0;if(a>>>0>2]){continue}break}b=H[d+12>>2]}a=H[h+40>>2];qa(H[H[h>>2]>>2]+N(a,l)|0,b,a);j=j+1|0;a=H[d+16>>2];if(j>>>0>2]-a|0)/20>>>0){continue}break}}H[d+28>>2]=H[d+28>>2]+1;H[g+8>>2]=H[g+8>>2]+1;k=k+1|0;if((o|0)!=(k|0)){continue}break}}a=H[f+28>>2]}if(a){continue}break}c=1}H[f+28>>2]=0;k=H[f+16>>2];a=H[f+12>>2];b=k-a|0;if(b>>>0>=9){while(1){oa(H[a>>2]);a=H[f+12>>2]+4|0;H[f+12>>2]=a;k=H[f+16>>2];b=k-a|0;if(b>>>0>8){continue}break}}d=170;t:{switch((b>>>2|0)-1|0){case 1:d=341;case 0:H[f+24>>2]=d;break;default:break t}}u:{if((a|0)==(k|0)){break u}while(1){oa(H[a>>2]);a=a+4|0;if((k|0)!=(a|0)){continue}break}b=H[f+16>>2];a=H[f+12>>2];if((b|0)==(a|0)){break u}H[f+16>>2]=b+((a-b|0)+3&-4)}a=H[f+8>>2];if(a){oa(a)}ca=f+32|0;break b}sa();v()}sa();v()}g=c}return g}function ud(a,b,c,d){var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,w=0;i=H[b+8>>2];k=H[b+12>>2];o=H[b+20>>2];e=H[b+16>>2];h=e+4|0;o=h>>>0>>0>>0&(k|0)2]|0;H[a>>2]=I[e|0]|I[e+1|0]>0>2]=e;H[b+20>>2]=k;if(K[a>>2]>32){break a}k=H[b+8>>2];o=H[b+12>>2];h=h+8|0;i=h>>>0>>0>k>>>0&(i|0)>=(o|0)|(i|0)>(o|0)){break a}e=H[b>>2]+e|0;h=I[e|0]|I[e+1|0]2]+4|0;i=e>>>0>2]=e;H[b+20>>2]=i;if(!h){return 1}if(d>>>0>>0){break a}H[a+8>>2]=0;if(!sb(a+16|0,b)){break a}if(!ua(a+544|0,b)){break a}if(!ua(a+564|0,b)){break a}if(!ua(a+584|0,b)){break a}w=H[a+4>>2];d=c;b=0;c=0;f=ca-32|0;ca=f;g=a;a=H[a+12>>2];H[f+16>>2]=0;H[f+8>>2]=0;H[f+12>>2]=0;b:{c:{if(a){if(a>>>0>=1073741824){break c}e=a2]=b;c=b+e|0;H[f+16>>2]=c;ra(b,0,e);H[f+12>>2]=c}h=H[g+628>>2];e=H[h>>2];if(e){H[h+4>>2]=e;oa(e);c=H[f+12>>2];b=H[f+8>>2];a=H[g+12>>2]}H[h+4>>2]=c;H[h>>2]=b;H[h+8>>2]=H[f+16>>2];b=0;H[f+16>>2]=0;H[f+8>>2]=0;H[f+12>>2]=0;d:{if(a){if(a>>>0>=1073741824){break d}a=a2]=j;b=a+j|0;H[f+16>>2]=b;ra(j,0,a);H[f+12>>2]=b}c=H[g+640>>2];a=H[c>>2];if(a){H[c+4>>2]=a;oa(a);j=H[f+8>>2];b=H[f+12>>2]}H[c+4>>2]=b;H[c>>2]=j;H[c+8>>2]=H[f+16>>2];H[f+24>>2]=0;H[f+28>>2]=0;H[f+16>>2]=0;H[f+20>>2]=0;H[f+8>>2]=0;H[f+12>>2]=0;xa(f+8|0);b=H[f+24>>2]+H[f+28>>2]|0;a=(b>>>0)/341|0;a=H[H[f+12>>2]+(a2]+N(b-N(a,341)|0,12)|0;H[a+4>>2]=0;H[a+8>>2]=0;H[a>>2]=w;c=1;a=H[f+28>>2]+1|0;H[f+28>>2]=a;e:{if(!a){break e}o=g+16|0;while(1){i=H[f+12>>2];h=H[f+24>>2];e=a-1|0;c=h+e|0;b=(c>>>0)/341|0;b=H[i+(b2]+N(c-N(b,341)|0,12)|0;q=H[b+8>>2];n=H[b>>2];H[f+28>>2]=e;b=H[f+16>>2];if((((b|0)!=(i|0)?N(b-i>>2,341)-1|0:0)-(a+h|0)|0)+1>>>0>=682){oa(H[b-4>>2]);H[f+16>>2]=H[f+16>>2]-4}c=0;if(n>>>0>w>>>0){break e}a=H[g+628>>2];p=N(q,12);t=p+H[g+640>>2]|0;j=Vd(g,n,t);if(j>>>0>=K[g+12>>2]){break e}r=a+p|0;h=H[g>>2];l=j2]>>2];f:{g:{if((h|0)==(e|0)){if(!n){break g}c=H[d+16>>2];b=H[d+20>>2];m=0;while(1){e=(b|0)==(c|0);a=b;k=0;b=c;h:{if(e){break h}while(1){l=H[d+28>>2];b=a;i=N(k,20)+c|0;h=H[i>>2];if(!I[h+84|0]){l=H[H[h+68>>2]+(l2]}if(K[h+80>>2]>>0){break h}e=H[r>>2]+(H[i+4>>2]2];b=e;i:{if(c>>>0>3){break i}a=0;b=H[d+12>>2];if(!H[i+16>>2]){break i}while(1){b=qa(b,e+(a2];b=b+c|0;a=a+1|0;if(a>>>0>2]){continue}break}b=H[d+12>>2]}a=H[h+40>>2];qa(H[H[h>>2]>>2]+N(a,l)|0,b,a);a=H[d+20>>2];b=a;k=k+1|0;c=H[d+16>>2];if(k>>>0>>0){continue}break}}H[d+28>>2]=H[d+28>>2]+1;H[g+8>>2]=H[g+8>>2]+1;m=m+1|0;if((n|0)!=(m|0)){continue}break}break g}j:{k:{l:{if(n>>>0>2];H[c>>2]=j;a=1;b=H[g+12>>2];if(b>>>0>1){break l}break j}if(K[g+8>>2]>K[g+4>>2]){break e}a=H[g+628>>2];k=q+1|0;m=N(k,12);b=a+m|0;if((b|0)!=(r|0)){Aa(b,H[r>>2],H[r+4>>2]);a=H[g+628>>2]}a=l+H[a+m>>2]|0;H[a>>2]=H[a>>2]+(1>1|0;break k}while(1){b=Ba((a>>0>>0){break k}c=0;break e}while(1){j=(b-1|0)!=(j|0)?j+1|0:0;H[c+(a2]=j;a=a+1|0;b=H[g+12>>2];if(a>>>0>>0){continue}break}break j}m:{n:{b=a-b|0;a=n-b|0;o:{if((a|0)==(b|0)){a=b;break o}i=H[g+596>>2];if((i|0)==H[g+588>>2]){break n}h=H[i>>2];e=H[g+600>>2];c=e+1|0;H[g+600>>2]=c;e=h&-2147483648>>>e;p:{if((c|0)==32){H[g+600>>2]=0;H[g+596>>2]=i+4;if(e){break p}break n}if(!e){break n}}}c=a;a=b;break m}c=b}i=H[g+640>>2];h=i+p|0;e=H[h>>2];b=e+l|0;H[b>>2]=H[b>>2]+1;Aa(i+m|0,e,H[h+4>>2]);if(a){m=H[f+28>>2]+H[f+24>>2]|0;e=H[f+16>>2];b=H[f+12>>2];if((m|0)==(((b|0)!=(e|0)?N(e-b>>2,341)-1|0:0)|0)){xa(f+8|0);m=H[f+24>>2]+H[f+28>>2]|0;e=H[f+12>>2]}else{e=b}b=(m>>>0)/341|0;b=H[e+(b2]+N(m-N(b,341)|0,12)|0;H[b+8>>2]=q;H[b+4>>2]=j;H[b>>2]=a;H[f+28>>2]=H[f+28>>2]+1}if(!c){break g}b=H[f+28>>2]+H[f+24>>2]|0;e=H[f+16>>2];a=H[f+12>>2];if((b|0)==(((a|0)!=(e|0)?N(e-a>>2,341)-1|0:0)|0)){xa(f+8|0);b=H[f+24>>2]+H[f+28>>2]|0;e=H[f+12>>2]}else{e=a}a=(b>>>0)/341|0;a=H[e+(a2]+N(b-N(a,341)|0,12)|0;H[a+8>>2]=k;H[a+4>>2]=j;H[a>>2]=c;a=H[f+28>>2]+1|0;H[f+28>>2]=a;break f}j=0;if(!n){break g}while(1){if(H[g+12>>2]){q=H[g+548>>2];i=H[t>>2];u=H[g+604>>2];h=H[g+616>>2];a=0;while(1){p=(a2]2]=0;e=H[g>>2];c=H[p>>2]2];q:{if((e|0)==(b|0)){break q}l=c+u|0;s=e-b|0;m=H[g+560>>2];e=32-m|0;if((s|0)>2];if((c|0)==(q|0)){c=0;break e}H[l>>2]=H[c>>2]>32-s;b=s+H[g+560>>2]|0;H[g+560>>2]=b;if((b|0)!=32){break q}H[g+560>>2]=0;H[g+556>>2]=c+4;break q}k=H[g+556>>2];b=k+4|0;if((q|0)==(b|0)){c=0;break e}c=H[k>>2];H[g+556>>2]=b;b=s-e|0;H[g+560>>2]=b;H[l>>2]=H[k+4>>2]>>>32-b|c>32-s}c=H[p>>2]2]=H[b>>2]|H[c+H[r>>2]>>2];a=a+1|0;if(a>>>0>2]){continue}break}}k=0;a=H[d+16>>2];r:{if((a|0)==H[d+20>>2]){break r}while(1){l=H[d+28>>2];i=N(k,20)+a|0;h=H[i>>2];if(!I[h+84|0]){l=H[H[h+68>>2]+(l2]}if(K[h+80>>2]>>0){break r}e=H[g+604>>2]+(H[i+4>>2]2];b=e;s:{if(c>>>0>3){break s}a=0;b=H[d+12>>2];if(!H[i+16>>2]){break s}while(1){b=qa(b,e+(a2];b=b+c|0;a=a+1|0;if(a>>>0>2]){continue}break}b=H[d+12>>2]}a=H[h+40>>2];qa(H[H[h>>2]>>2]+N(a,l)|0,b,a);k=k+1|0;a=H[d+16>>2];if(k>>>0>2]-a|0)/20>>>0){continue}break}}H[d+28>>2]=H[d+28>>2]+1;H[g+8>>2]=H[g+8>>2]+1;j=j+1|0;if((n|0)!=(j|0)){continue}break}}a=H[f+28>>2]}if(a){continue}break}c=1}H[f+28>>2]=0;j=H[f+16>>2];a=H[f+12>>2];b=j-a|0;if(b>>>0>=9){while(1){oa(H[a>>2]);a=H[f+12>>2]+4|0;H[f+12>>2]=a;j=H[f+16>>2];b=j-a|0;if(b>>>0>8){continue}break}}d=170;t:{switch((b>>>2|0)-1|0){case 1:d=341;case 0:H[f+24>>2]=d;break;default:break t}}u:{if((a|0)==(j|0)){break u}while(1){oa(H[a>>2]);a=a+4|0;if((j|0)!=(a|0)){continue}break}b=H[f+16>>2];a=H[f+12>>2];if((b|0)==(a|0)){break u}H[f+16>>2]=b+((a-b|0)+3&-4)}a=H[f+8>>2];if(a){oa(a)}ca=f+32|0;break b}sa();v()}sa();v()}g=c}return g}function vd(a,b,c,d){var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,w=0;i=H[b+8>>2];k=H[b+12>>2];m=H[b+20>>2];f=H[b+16>>2];h=f+4|0;m=h>>>0>>0>>0&(k|0)2]|0;H[a>>2]=I[f|0]|I[f+1|0]>0>2]=f;H[b+20>>2]=k;if(K[a>>2]>32){break a}k=H[b+8>>2];m=H[b+12>>2];h=h+8|0;i=h>>>0>>0>k>>>0&(i|0)>=(m|0)|(i|0)>(m|0)){break a}f=f+H[b>>2]|0;h=I[f|0]|I[f+1|0]2]+4|0;i=f>>>0>2]=f;H[b+20>>2]=i;if(!h){return 1}if(d>>>0>>0){break a}H[a+8>>2]=0;if(!sb(a+16|0,b)){break a}if(!ua(a+544|0,b)){break a}if(!ua(a+564|0,b)){break a}if(!ua(a+584|0,b)){break a}u=H[a+4>>2];b=0;e=ca-32|0;ca=e;f=a;a=H[a+12>>2];H[e+16>>2]=0;H[e+8>>2]=0;H[e+12>>2]=0;b:{c:{if(a){if(a>>>0>=1073741824){break c}d=a2]=b;g=b+d|0;H[e+16>>2]=g;ra(b,0,d);H[e+12>>2]=g}h=H[f+628>>2];d=H[h>>2];if(d){H[h+4>>2]=d;oa(d);g=H[e+12>>2];b=H[e+8>>2];a=H[f+12>>2]}H[h+4>>2]=g;H[h>>2]=b;H[h+8>>2]=H[e+16>>2];b=0;H[e+16>>2]=0;H[e+8>>2]=0;H[e+12>>2]=0;d:{if(a){if(a>>>0>=1073741824){break d}a=a2]=j;b=a+j|0;H[e+16>>2]=b;ra(j,0,a);H[e+12>>2]=b}d=H[f+640>>2];a=H[d>>2];if(a){H[d+4>>2]=a;oa(a);j=H[e+8>>2];b=H[e+12>>2]}H[d+4>>2]=b;H[d>>2]=j;H[d+8>>2]=H[e+16>>2];H[e+24>>2]=0;H[e+28>>2]=0;H[e+16>>2]=0;H[e+20>>2]=0;H[e+8>>2]=0;H[e+12>>2]=0;xa(e+8|0);b=H[e+24>>2]+H[e+28>>2]|0;a=(b>>>0)/341|0;a=H[H[e+12>>2]+(a2]+N(b-N(a,341)|0,12)|0;H[a+4>>2]=0;H[a+8>>2]=0;H[a>>2]=u;d=1;a=H[e+28>>2]+1|0;H[e+28>>2]=a;e:{if(!a){break e}m=f+16|0;while(1){k=H[e+12>>2];h=H[e+24>>2];g=a-1|0;d=h+g|0;b=(d>>>0)/341|0;b=H[k+(b2]+N(d-N(b,341)|0,12)|0;q=H[b+8>>2];i=H[b+4>>2];n=H[b>>2];H[e+28>>2]=g;b=H[e+16>>2];if((((b|0)!=(k|0)?N(b-k>>2,341)-1|0:0)-(a+h|0)|0)+1>>>0>=682){oa(H[b-4>>2]);H[e+16>>2]=H[e+16>>2]-4}if(n>>>0>u>>>0){d=0;break e}d=0;a=H[f+12>>2];j=(i|0)!=(a-1|0)?i+1|0:0;if(j>>>0>=a>>>0){break e}a=H[f+628>>2];o=N(q,12);s=a+o|0;g=H[f>>2];l=j2]|0;b=H[l+H[k>>2]>>2];f:{g:{if((g|0)==(b|0)){if(!n){break g}g=H[c+16>>2];b=H[c+20>>2];p=0;while(1){d=(b|0)==(g|0);a=b;j=0;b=g;h:{if(d){break h}while(1){d=H[c+28>>2];b=a;k=N(j,20)+g|0;i=H[k>>2];if(!I[i+84|0]){d=H[H[i+68>>2]+(d2]}if(K[i+80>>2]>>0){break h}h=H[s>>2]+(H[k+4>>2]2];b=h;i:{if(g>>>0>3){break i}a=0;b=H[c+12>>2];if(!H[k+16>>2]){break i}while(1){b=qa(b,h+(a2];b=b+g|0;a=a+1|0;if(a>>>0>2]){continue}break}b=H[c+12>>2]}a=H[i+40>>2];qa(H[H[i>>2]>>2]+N(a,d)|0,b,a);a=H[c+20>>2];b=a;j=j+1|0;g=H[c+16>>2];if(j>>>0>>0){continue}break}}H[c+28>>2]=H[c+28>>2]+1;H[f+8>>2]=H[f+8>>2]+1;p=p+1|0;if((p|0)!=(n|0)){continue}break}break g}j:{k:{l:{if(n>>>0>2];H[d>>2]=j;a=1;b=H[f+12>>2];if(b>>>0>1){break l}break j}if(K[f+8>>2]>K[f+4>>2]){break e}d=a;a=o+12|0;Aa(d+a|0,H[s>>2],H[s+4>>2]);a=l+H[a+H[f+628>>2]>>2]|0;H[a>>2]=H[a>>2]+(1>1|0;break k}while(1){b=Ba((a>>0>>0){break k}d=0;break e}while(1){j=(b-1|0)!=(j|0)?j+1|0:0;H[d+(a2]=j;a=a+1|0;b=H[f+12>>2];if(a>>>0>>0){continue}break}break j}k=q+1|0;m:{n:{b=a-b|0;a=n-b|0;o:{if((a|0)==(b|0)){a=b;break o}i=H[f+596>>2];if((i|0)==H[f+588>>2]){break n}h=H[i>>2];g=H[f+600>>2];d=g+1|0;H[f+600>>2]=d;g=h&-2147483648>>>g;p:{if((d|0)==32){H[f+600>>2]=0;H[f+596>>2]=i+4;if(g){break p}break n}if(!g){break n}}}d=a;a=b;break m}d=b}i=H[f+640>>2];h=i+o|0;g=H[h>>2];b=g+l|0;H[b>>2]=H[b>>2]+1;Aa(i+N(k,12)|0,g,H[h+4>>2]);if(a){h=H[e+28>>2]+H[e+24>>2]|0;g=H[e+16>>2];b=H[e+12>>2];if((h|0)==(((b|0)!=(g|0)?N(g-b>>2,341)-1|0:0)|0)){xa(e+8|0);h=H[e+24>>2]+H[e+28>>2]|0;g=H[e+12>>2]}else{g=b}b=(h>>>0)/341|0;b=H[g+(b2]+N(h-N(b,341)|0,12)|0;H[b+8>>2]=q;H[b+4>>2]=j;H[b>>2]=a;H[e+28>>2]=H[e+28>>2]+1}if(!d){break g}b=H[e+28>>2]+H[e+24>>2]|0;g=H[e+16>>2];a=H[e+12>>2];if((b|0)==(((a|0)!=(g|0)?N(g-a>>2,341)-1|0:0)|0)){xa(e+8|0);b=H[e+24>>2]+H[e+28>>2]|0;g=H[e+12>>2]}else{g=a}a=(b>>>0)/341|0;a=H[g+(a2]+N(b-N(a,341)|0,12)|0;H[a+8>>2]=k;H[a+4>>2]=j;H[a>>2]=d;a=H[e+28>>2]+1|0;H[e+28>>2]=a;break f}p=0;if(!n){break g}while(1){if(H[f+12>>2]){w=H[f+548>>2];i=H[k>>2];t=H[f+604>>2];h=H[f+616>>2];a=0;while(1){j=h+(a2]2]=0;g=H[f>>2];d=H[j>>2]2];q:{if((g|0)==(b|0)){break q}q=d+t|0;r=g-b|0;o=H[f+560>>2];g=32-o|0;if((r|0)>2];if((d|0)==(w|0)){d=0;break e}H[q>>2]=H[d>>2]>32-r;b=H[f+560>>2]+r|0;H[f+560>>2]=b;if((b|0)!=32){break q}H[f+560>>2]=0;H[f+556>>2]=d+4;break q}l=H[f+556>>2];b=l+4|0;if((b|0)==(w|0)){d=0;break e}d=H[l>>2];H[f+556>>2]=b;b=r-g|0;H[f+560>>2]=b;H[q>>2]=H[l+4>>2]>>>32-b|d>32-r}d=H[j>>2]2]=H[b>>2]|H[d+H[s>>2]>>2];a=a+1|0;if(a>>>0>2]){continue}break}}j=0;a=H[c+16>>2];r:{if((a|0)==H[c+20>>2]){break r}while(1){d=H[c+28>>2];l=N(j,20)+a|0;i=H[l>>2];if(!I[i+84|0]){d=H[H[i+68>>2]+(d2]}if(K[i+80>>2]>>0){break r}h=H[f+604>>2]+(H[l+4>>2]2];b=h;s:{if(g>>>0>3){break s}a=0;b=H[c+12>>2];if(!H[l+16>>2]){break s}while(1){b=qa(b,h+(a2];b=b+g|0;a=a+1|0;if(a>>>0>2]){continue}break}b=H[c+12>>2]}a=H[i+40>>2];qa(H[H[i>>2]>>2]+N(a,d)|0,b,a);j=j+1|0;a=H[c+16>>2];if(j>>>0>2]-a|0)/20>>>0){continue}break}}H[c+28>>2]=H[c+28>>2]+1;H[f+8>>2]=H[f+8>>2]+1;p=p+1|0;if((p|0)!=(n|0)){continue}break}}a=H[e+28>>2]}if(a){continue}break}d=1}H[e+28>>2]=0;j=H[e+16>>2];a=H[e+12>>2];b=j-a|0;if(b>>>0>=9){while(1){oa(H[a>>2]);a=H[e+12>>2]+4|0;H[e+12>>2]=a;j=H[e+16>>2];b=j-a|0;if(b>>>0>8){continue}break}}g=170;t:{switch((b>>>2|0)-1|0){case 1:g=341;case 0:H[e+24>>2]=g;break;default:break t}}u:{if((a|0)==(j|0)){break u}while(1){oa(H[a>>2]);a=a+4|0;if((j|0)!=(a|0)){continue}break}b=H[e+16>>2];a=H[e+12>>2];if((b|0)==(a|0)){break u}H[e+16>>2]=b+((a-b|0)+3&-4)}a=H[e+8>>2];if(a){oa(a)}ca=e+32|0;break b}sa();v()}sa();v()}g=d}return g}function yd(a,b,c,d){var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,w=0;j=H[b+8>>2];e=H[b+12>>2];g=H[b+20>>2];h=H[b+16>>2];l=h+4|0;g=l>>>0>>0>>0&(e|0)2]|0;H[a>>2]=I[h|0]|I[h+1|0]>0>2]=g;H[b+20>>2]=h;if(K[a>>2]>32){break a}k=H[b+8>>2];l=H[b+12>>2];h=e;e=j+8|0;h=e>>>0>>0>k>>>0&(h|0)>=(l|0)|(h|0)>(l|0)){break a}h=H[b>>2]+g|0;g=I[h|0]|I[h+1|0]2]+4|0;h=e>>>0>2]=e;H[b+20>>2]=h;if(!g){return 1}if(d>>>0>>0){break a}H[a+8>>2]=0;if(!ta(a+16|0,b)){break a}if(!ua(a+32|0,b)){break a}if(!ua(a+52|0,b)){break a}if(!ua(a+72|0,b)){break a}r=H[a+4>>2];h=c;b=0;g=0;e=ca-32|0;ca=e;d=a;a=H[a+12>>2];H[e+16>>2]=0;H[e+8>>2]=0;H[e+12>>2]=0;b:{c:{if(a){if(a>>>0>=1073741824){break c}c=a2]=b;g=b+c|0;H[e+16>>2]=g;ra(b,0,c);H[e+12>>2]=g}c=H[d+116>>2];i=H[c>>2];if(i){H[c+4>>2]=i;oa(i);g=H[e+12>>2];b=H[e+8>>2];a=H[d+12>>2]}H[c+4>>2]=g;H[c>>2]=b;H[c+8>>2]=H[e+16>>2];b=0;H[e+16>>2]=0;H[e+8>>2]=0;H[e+12>>2]=0;d:{if(a){if(a>>>0>=1073741824){break d}a=a2]=f;b=a+f|0;H[e+16>>2]=b;ra(f,0,a);H[e+12>>2]=b}a=H[d+128>>2];c=H[a>>2];if(c){H[a+4>>2]=c;oa(c);f=H[e+8>>2];b=H[e+12>>2]}H[a+4>>2]=b;H[a>>2]=f;H[a+8>>2]=H[e+16>>2];H[e+24>>2]=0;H[e+28>>2]=0;H[e+16>>2]=0;H[e+20>>2]=0;H[e+8>>2]=0;H[e+12>>2]=0;xa(e+8|0);a=H[e+24>>2]+H[e+28>>2]|0;b=(a>>>0)/341|0;a=H[H[e+12>>2]+(b2]+N(a-N(b,341)|0,12)|0;H[a+4>>2]=0;H[a+8>>2]=0;H[a>>2]=r;c=1;a=H[e+28>>2]+1|0;H[e+28>>2]=a;e:{if(!a){break e}t=d+16|0;while(1){b=H[e+12>>2];f=H[e+24>>2];l=a-1|0;c=f+l|0;i=(c>>>0)/341|0;c=H[b+(i2]+N(c-N(i,341)|0,12)|0;g=H[c+8>>2];i=H[c+4>>2];j=H[c>>2];H[e+28>>2]=l;c=H[e+16>>2];if((((b|0)!=(c|0)?N(c-b>>2,341)-1|0:0)-(a+f|0)|0)+1>>>0>=682){oa(H[c-4>>2]);H[e+16>>2]=H[e+16>>2]-4}c=0;if(j>>>0>r>>>0){break e}b=H[d+12>>2];a=(b-1|0)!=(i|0)?i+1|0:0;if(a>>>0>=b>>>0){break e}f=N(g,12);o=f+H[d+128>>2]|0;l=f+H[d+116>>2]|0;i=H[d>>2];k=a2]>>2];f:{if((i|0)==(n|0)){if(!j){break f}o=0;b=H[h+20>>2];g=H[h+16>>2];if((b|0)==(g|0)){a=H[d+8>>2];H[h+28>>2]=j+H[h+28>>2];H[d+8>>2]=a+j;break f}while(1){c=(b|0)==(g|0);a=b;i=0;b=g;g:{if(c){break g}while(1){f=H[h+28>>2];b=a;c=N(i,20)+g|0;k=H[c>>2];if(!I[k+84|0]){f=H[H[k+68>>2]+(f2]}if(K[k+80>>2]>>0){break g}n=H[l>>2]+(H[c+4>>2]2];b=n;h:{if(g>>>0>3){break h}a=0;b=H[h+12>>2];if(!H[c+16>>2]){break h}while(1){b=qa(b,n+(a2];b=b+g|0;a=a+1|0;if(a>>>0>2]){continue}break}b=H[h+12>>2]}a=H[k+40>>2];qa(H[H[k>>2]>>2]+N(a,f)|0,b,a);i=i+1|0;a=H[h+20>>2];b=a;g=H[h+16>>2];if(i>>>0>>0){continue}break}}H[h+28>>2]=H[h+28>>2]+1;H[d+8>>2]=H[d+8>>2]+1;o=o+1|0;if((j|0)!=(o|0)){continue}break}break f}i:{j:{k:{l:{if(j>>>0>2];H[c>>2]=a;f=1;b=H[d+12>>2];if(b>>>0>1){break l}break i}if(K[d+8>>2]>K[d+4>>2]){break e}b=H[d+116>>2];m=g+1|0;o=N(m,12);q=b+o|0;if((q|0)!=(l|0)){Aa(q,H[l>>2],H[l+4>>2]);b=H[d+116>>2]}b=k+H[b+o>>2]|0;H[b>>2]=H[b>>2]+(12]=0;pc(t,Q(j)^31,e+4|0);b=j>>>1|0;i=H[e+4>>2];if(b>>>0>>0){break e}b=b-i|0;c=j-b|0;m:{if((c|0)==(b|0)){c=b;break m}i=H[d+84>>2];if((i|0)==H[d+76>>2]){break k}j=H[i>>2];l=H[d+88>>2];n=l+1|0;H[d+88>>2]=n;j=j&-2147483648>>>l;n:{if((n|0)==32){H[d+88>>2]=0;H[d+84>>2]=i+4;if(j){break n}break k}if(!j){break k}}}i=c;c=b;break j}while(1){a=(b-1|0)!=(a|0)?a+1|0:0;H[c+(f2]=a;b=H[d+12>>2];f=f+1|0;if(b>>>0>f>>>0){continue}break}break i}i=b}b=H[d+128>>2];j=b+f|0;f=H[j>>2];l=f+k|0;H[l>>2]=H[l>>2]+1;Aa(b+o|0,f,H[j+4>>2]);if(c){b=H[e+28>>2]+H[e+24>>2]|0;j=H[e+16>>2];f=H[e+12>>2];if((b|0)==(((f|0)!=(j|0)?N(j-f>>2,341)-1|0:0)|0)){xa(e+8|0);f=H[e+12>>2];b=H[e+24>>2]+H[e+28>>2]|0}j=(b>>>0)/341|0;b=H[(j2]+N(b-N(j,341)|0,12)|0;H[b+8>>2]=g;H[b+4>>2]=a;H[b>>2]=c;H[e+28>>2]=H[e+28>>2]+1}if(!i){break f}b=H[e+28>>2]+H[e+24>>2]|0;c=H[e+16>>2];f=H[e+12>>2];if((b|0)==(((c|0)!=(f|0)?N(c-f>>2,341)-1|0:0)|0)){xa(e+8|0);f=H[e+12>>2];b=H[e+24>>2]+H[e+28>>2]|0}c=(b>>>0)/341|0;b=H[(c2]+N(b-N(c,341)|0,12)|0;H[b+8>>2]=m;H[b+4>>2]=a;H[b>>2]=i;H[e+28>>2]=H[e+28>>2]+1;break f}n=0;if(!j){break f}while(1){if(H[d+12>>2]){i=H[d+36>>2];q=H[o>>2];c=H[d+92>>2];u=H[d+104>>2];a=0;while(1){g=(a2]2]=0;b=H[d>>2];f=H[g>>2]2];o:{if((b|0)==(k|0)){break o}f=c+f|0;b=b-k|0;k=H[d+48>>2];p=32-k|0;if((b|0)>2];if((m|0)==(i|0)){c=0;break e}H[f>>2]=H[m>>2]>32-b;b=b+H[d+48>>2]|0;H[d+48>>2]=b;if((b|0)!=32){break o}H[d+48>>2]=0;H[d+44>>2]=m+4;break o}m=H[d+44>>2];s=m+4|0;if((i|0)==(s|0)){c=0;break e}w=H[m>>2];H[d+44>>2]=s;p=b-p|0;H[d+48>>2]=p;H[f>>2]=H[m+4>>2]>>>32-p|w>32-b}b=H[g>>2]2]=H[g>>2]|H[b+H[l>>2]>>2];a=a+1|0;if(a>>>0>2]){continue}break}}i=0;a=H[h+16>>2];p:{if((a|0)==H[h+20>>2]){break p}while(1){f=H[h+28>>2];c=N(i,20)+a|0;k=H[c>>2];if(!I[k+84|0]){f=H[H[k+68>>2]+(f2]}if(K[k+80>>2]>>0){break p}m=H[d+92>>2]+(H[c+4>>2]2];b=m;q:{if(g>>>0>3){break q}a=0;b=H[h+12>>2];if(!H[c+16>>2]){break q}while(1){b=qa(b,m+(a2];b=b+g|0;a=a+1|0;if(a>>>0>2]){continue}break}b=H[h+12>>2]}a=H[k+40>>2];qa(H[H[k>>2]>>2]+N(a,f)|0,b,a);i=i+1|0;a=H[h+16>>2];if(i>>>0>2]-a|0)/20>>>0){continue}break}}H[h+28>>2]=H[h+28>>2]+1;H[d+8>>2]=H[d+8>>2]+1;n=n+1|0;if((j|0)!=(n|0)){continue}break}}a=H[e+28>>2];if(a){continue}break}c=1}H[e+28>>2]=0;f=H[e+16>>2];a=H[e+12>>2];b=f-a|0;if(b>>>0>=9){while(1){oa(H[a>>2]);a=H[e+12>>2]+4|0;H[e+12>>2]=a;f=H[e+16>>2];b=f-a|0;if(b>>>0>8){continue}break}}g=170;r:{switch((b>>>2|0)-1|0){case 1:g=341;case 0:H[e+24>>2]=g;break;default:break r}}s:{if((a|0)==(f|0)){break s}while(1){oa(H[a>>2]);a=a+4|0;if((f|0)!=(a|0)){continue}break}a=H[e+16>>2];b=H[e+12>>2];if((a|0)==(b|0)){break s}H[e+16>>2]=a+((b-a|0)+3&-4)}a=H[e+8>>2];if(a){oa(a)}ca=e+32|0;break b}sa();v()}sa();v()}i=c}return i}function xd(a,b,c,d){var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,w=0;i=H[b+8>>2];k=H[b+12>>2];n=H[b+20>>2];h=H[b+16>>2];f=h+4|0;n=f>>>0>0>i>>>0|(k|0)>2]|0;H[a>>2]=I[h|0]|I[h+1|0]>0>2]=h;H[b+20>>2]=k;if(K[a>>2]>32){break a}k=H[b+8>>2];n=H[b+12>>2];f=f+8|0;i=f>>>0>>0>k>>>0&(i|0)>=(n|0)|(i|0)>(n|0)){break a}h=H[b>>2]+h|0;f=I[h|0]|I[h+1|0]2]+4|0;i=h>>>0>2]=h;H[b+20>>2]=i;if(!f){return 1}if(d>>>0>>0){break a}H[a+8>>2]=0;if(!ta(a+16|0,b)){break a}if(!ua(a+32|0,b)){break a}if(!ua(a+52|0,b)){break a}if(!ua(a+72|0,b)){break a}u=H[a+4>>2];h=c;b=0;c=0;e=ca-32|0;ca=e;f=a;a=H[a+12>>2];H[e+16>>2]=0;H[e+8>>2]=0;H[e+12>>2]=0;b:{c:{if(a){if(a>>>0>=1073741824){break c}d=a2]=b;c=b+d|0;H[e+16>>2]=c;ra(b,0,d);H[e+12>>2]=c}j=H[f+116>>2];d=H[j>>2];if(d){H[j+4>>2]=d;oa(d);c=H[e+12>>2];b=H[e+8>>2];a=H[f+12>>2]}H[j+4>>2]=c;H[j>>2]=b;H[j+8>>2]=H[e+16>>2];b=0;H[e+16>>2]=0;H[e+8>>2]=0;H[e+12>>2]=0;d:{if(a){if(a>>>0>=1073741824){break d}a=a2]=g;b=a+g|0;H[e+16>>2]=b;ra(g,0,a);H[e+12>>2]=b}c=H[f+128>>2];a=H[c>>2];if(a){H[c+4>>2]=a;oa(a);g=H[e+8>>2];b=H[e+12>>2]}H[c+4>>2]=b;H[c>>2]=g;H[c+8>>2]=H[e+16>>2];H[e+24>>2]=0;H[e+28>>2]=0;H[e+16>>2]=0;H[e+20>>2]=0;H[e+8>>2]=0;H[e+12>>2]=0;xa(e+8|0);b=H[e+24>>2]+H[e+28>>2]|0;a=(b>>>0)/341|0;a=H[H[e+12>>2]+(a2]+N(b-N(a,341)|0,12)|0;H[a+4>>2]=0;H[a+8>>2]=0;H[a>>2]=u;d=1;a=H[e+28>>2]+1|0;H[e+28>>2]=a;e:{if(!a){break e}n=f+16|0;while(1){i=H[e+12>>2];j=H[e+24>>2];d=a-1|0;c=j+d|0;b=(c>>>0)/341|0;b=H[i+(b2]+N(c-N(b,341)|0,12)|0;o=H[b+8>>2];c=H[b+4>>2];m=H[b>>2];H[e+28>>2]=d;b=H[e+16>>2];if((((b|0)!=(i|0)?N(b-i>>2,341)-1|0:0)-(a+j|0)|0)+1>>>0>=682){oa(H[b-4>>2]);H[e+16>>2]=H[e+16>>2]-4}if(m>>>0>u>>>0){d=0;break e}d=0;b=H[f+12>>2];a=(c|0)!=(b-1|0)?c+1|0:0;if(a>>>0>=b>>>0){break e}b=H[f+116>>2];p=N(o,12);r=b+p|0;j=H[f>>2];g=a2]|0;c=H[g+H[k>>2]>>2];f:{if((j|0)==(c|0)){if(!m){break f}b=H[h+20>>2];c=H[h+16>>2];if((b|0)==(c|0)){a=H[f+8>>2];H[h+28>>2]=m+H[h+28>>2];H[f+8>>2]=a+m;break f}while(1){i=(b|0)==(c|0);a=b;j=0;b=c;g:{if(i){break g}while(1){g=H[h+28>>2];b=a;l=N(j,20)+c|0;k=H[l>>2];if(!I[k+84|0]){g=H[H[k+68>>2]+(g2]}if(K[k+80>>2]>>0){break g}i=H[r>>2]+(H[l+4>>2]2];b=i;h:{if(c>>>0>3){break h}a=0;b=H[h+12>>2];if(!H[l+16>>2]){break h}while(1){b=qa(b,i+(a2];b=b+c|0;a=a+1|0;if(a>>>0>2]){continue}break}b=H[h+12>>2]}a=H[k+40>>2];qa(H[H[k>>2]>>2]+N(a,g)|0,b,a);j=j+1|0;a=H[h+20>>2];b=a;c=H[h+16>>2];if(j>>>0>>0){continue}break}}H[h+28>>2]=H[h+28>>2]+1;H[f+8>>2]=H[f+8>>2]+1;d=d+1|0;if((m|0)!=(d|0)){continue}break}break f}i:{j:{k:{l:{if(m>>>0>2];H[c>>2]=a;g=1;b=H[f+12>>2];if(b>>>0>1){break l}break i}if(K[f+8>>2]>K[f+4>>2]){break e}i=b;b=p+12|0;Aa(i+b|0,H[r>>2],H[r+4>>2]);b=g+H[b+H[f+116>>2]>>2]|0;H[b>>2]=H[b>>2]+(12]=0;pc(n,Q(m)^31,e+4|0);c=m>>>1|0;b=H[e+4>>2];if(c>>>0>>0){break e}l=o+1|0;b=c-b|0;c=m-b|0;m:{if((c|0)==(b|0)){c=b;break m}k=H[f+84>>2];if((k|0)==H[f+76>>2]){break k}i=H[k>>2];j=H[f+88>>2];d=j+1|0;H[f+88>>2]=d;j=i&-2147483648>>>j;n:{if((d|0)==32){H[f+88>>2]=0;H[f+84>>2]=k+4;if(j){break n}break k}if(!j){break k}}}j=c;c=b;break j}while(1){a=(b-1|0)!=(a|0)?a+1|0:0;H[c+(g2]=a;b=H[f+12>>2];g=g+1|0;if(b>>>0>g>>>0){continue}break}break i}j=b}k=H[f+128>>2];i=k+p|0;d=H[i>>2];b=d+g|0;H[b>>2]=H[b>>2]+1;Aa(k+N(l,12)|0,d,H[i+4>>2]);if(c){b=H[e+28>>2]+H[e+24>>2]|0;d=H[e+16>>2];g=H[e+12>>2];if((b|0)==(((d|0)!=(g|0)?N(d-g>>2,341)-1|0:0)|0)){xa(e+8|0);g=H[e+12>>2];b=H[e+24>>2]+H[e+28>>2]|0}d=(b>>>0)/341|0;b=H[(d2]+N(b-N(d,341)|0,12)|0;H[b+8>>2]=o;H[b+4>>2]=a;H[b>>2]=c;H[e+28>>2]=H[e+28>>2]+1}if(!j){break f}b=H[e+28>>2]+H[e+24>>2]|0;c=H[e+16>>2];g=H[e+12>>2];if((b|0)==(((c|0)!=(g|0)?N(c-g>>2,341)-1|0:0)|0)){xa(e+8|0);g=H[e+12>>2];b=H[e+24>>2]+H[e+28>>2]|0}c=(b>>>0)/341|0;b=H[(c2]+N(b-N(c,341)|0,12)|0;H[b+8>>2]=l;H[b+4>>2]=a;H[b>>2]=j;H[e+28>>2]=H[e+28>>2]+1;break f}s=0;if(!m){break f}while(1){if(H[f+12>>2]){w=H[f+36>>2];i=H[k>>2];t=H[f+92>>2];j=H[f+104>>2];a=0;while(1){o=(a2]2]=0;d=H[f>>2];c=H[o>>2]2];o:{if((d|0)==(b|0)){break o}p=c+t|0;q=d-b|0;g=H[f+48>>2];d=32-g|0;if((q|0)>2];if((c|0)==(w|0)){d=0;break e}H[p>>2]=H[c>>2]>32-q;b=q+H[f+48>>2]|0;H[f+48>>2]=b;if((b|0)!=32){break o}H[f+48>>2]=0;H[f+44>>2]=c+4;break o}l=H[f+44>>2];b=l+4|0;if((w|0)==(b|0)){d=0;break e}c=H[l>>2];H[f+44>>2]=b;b=q-d|0;H[f+48>>2]=b;H[p>>2]=H[l+4>>2]>>>32-b|c>32-q}c=H[o>>2]2]=H[b>>2]|H[c+H[r>>2]>>2];a=a+1|0;if(a>>>0>2]){continue}break}}j=0;a=H[h+16>>2];p:{if((a|0)==H[h+20>>2]){break p}while(1){g=H[h+28>>2];l=N(j,20)+a|0;i=H[l>>2];if(!I[i+84|0]){g=H[H[i+68>>2]+(g2]}if(K[i+80>>2]>>0){break p}d=H[f+92>>2]+(H[l+4>>2]2];b=d;q:{if(c>>>0>3){break q}a=0;b=H[h+12>>2];if(!H[l+16>>2]){break q}while(1){b=qa(b,d+(a2];b=b+c|0;a=a+1|0;if(a>>>0>2]){continue}break}b=H[h+12>>2]}a=H[i+40>>2];qa(H[H[i>>2]>>2]+N(a,g)|0,b,a);j=j+1|0;a=H[h+16>>2];if(j>>>0>2]-a|0)/20>>>0){continue}break}}H[h+28>>2]=H[h+28>>2]+1;H[f+8>>2]=H[f+8>>2]+1;s=s+1|0;if((m|0)!=(s|0)){continue}break}}a=H[e+28>>2];if(a){continue}break}d=1}H[e+28>>2]=0;g=H[e+16>>2];a=H[e+12>>2];b=g-a|0;if(b>>>0>=9){while(1){oa(H[a>>2]);a=H[e+12>>2]+4|0;H[e+12>>2]=a;g=H[e+16>>2];b=g-a|0;if(b>>>0>8){continue}break}}c=170;r:{switch((b>>>2|0)-1|0){case 1:c=341;case 0:H[e+24>>2]=c;break;default:break r}}s:{if((a|0)==(g|0)){break s}while(1){oa(H[a>>2]);a=a+4|0;if((g|0)!=(a|0)){continue}break}b=H[e+16>>2];a=H[e+12>>2];if((b|0)==(a|0)){break s}H[e+16>>2]=b+((a-b|0)+3&-4)}a=H[e+8>>2];if(a){oa(a)}ca=e+32|0;j=d;break b}sa();v()}sa();v()}}return j}function $c(a,b){var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,w=0;h=ca-32|0;ca=h;g=H[H[a+4>>2]+44>>2];c=H[a+8>>2];d=H[c>>2];c=H[c+4>>2];H[h+24>>2]=0;H[h+16>>2]=0;H[h+20>>2]=0;d=(c-d>>2>>>0)/3|0;c=H[g+96>>2];f=(H[g+100>>2]-c|0)/12|0;a:{if(d>>>0>f>>>0){e=d-f|0;i=H[g+104>>2];c=H[g+100>>2];if(e>>>0>>0){b:{if(!e){break b}d=c;f=N(e,12)-12|0;i=((f>>>0)/12|0)+1&3;if(i){while(1){l=H[h+20>>2];H[d>>2]=H[h+16>>2];H[d+4>>2]=l;H[d+8>>2]=H[h+24>>2];d=d+12|0;j=j+1|0;if((i|0)!=(j|0)){continue}break}}c=N(e,12)+c|0;if(f>>>0>2];H[d>>2]=H[h+16>>2];H[d+4>>2]=f;H[d+8>>2]=H[h+24>>2];H[d+20>>2]=H[h+24>>2];f=H[h+20>>2];H[d+12>>2]=H[h+16>>2];H[d+16>>2]=f;H[d+32>>2]=H[h+24>>2];f=H[h+20>>2];H[d+24>>2]=H[h+16>>2];H[d+28>>2]=f;f=H[h+20>>2];H[d+36>>2]=H[h+16>>2];H[d+40>>2]=f;H[d+44>>2]=H[h+24>>2];d=d+48|0;if((d|0)!=(c|0)){continue}break}}H[g+100>>2]=c;break a}c:{f=H[g+96>>2];n=(c-f|0)/12|0;d=n+e|0;if(d>>>00>=178956970?357913941:d>>>0>>0?i:d;if(i){if(i>>>0>=357913942){break c}l=pa(N(i,12))}f=N(n,12)+l|0;d=f;e=N(e,12);n=e-12|0;q=((n>>>0)/12|0)+1&3;if(q){while(1){r=H[h+20>>2];H[d>>2]=H[h+16>>2];H[d+4>>2]=r;H[d+8>>2]=H[h+24>>2];d=d+12|0;j=j+1|0;if((q|0)!=(j|0)){continue}break}}e=e+f|0;if(n>>>0>=36){while(1){j=H[h+20>>2];H[d>>2]=H[h+16>>2];H[d+4>>2]=j;H[d+8>>2]=H[h+24>>2];H[d+20>>2]=H[h+24>>2];j=H[h+20>>2];H[d+12>>2]=H[h+16>>2];H[d+16>>2]=j;H[d+32>>2]=H[h+24>>2];j=H[h+20>>2];H[d+24>>2]=H[h+16>>2];H[d+28>>2]=j;j=H[h+20>>2];H[d+36>>2]=H[h+16>>2];H[d+40>>2]=j;H[d+44>>2]=H[h+24>>2];d=d+48|0;if((e|0)!=(d|0)){continue}break}}j=H[g+96>>2];if((j|0)!=(c|0)){while(1){c=c-12|0;n=H[c+4>>2];f=f-12|0;d=f;H[d>>2]=H[c>>2];H[d+4>>2]=n;H[d+8>>2]=H[c+8>>2];if((c|0)!=(j|0)){continue}break}c=H[g+96>>2]}H[g+104>>2]=N(i,12)+l;H[g+100>>2]=e;H[g+96>>2]=f;if(c){oa(c)}break a}sa();v()}wa();v()}if(d>>>0>=f>>>0){break a}H[g+100>>2]=c+N(d,12)}d:{if(H[a+216>>2]==H[a+220>>2]){j=H[a+4>>2];c=H[j+44>>2];d=H[c+100>>2];f=H[c+96>>2];if((d|0)!=(f|0)){c=(d-f|0)/12|0;o=c>>>0>2];i=f+N(c,12)|0;g=N(c,3);e:{f:{if((g|0)==-1){e=H[(H[d>>2]+(g2];k=-1;g=1;break f}e=-1;k=H[H[d>>2]+(g2];l=g+1|0;if((l|0)==-1){g=0;break f}e=H[H[d>>2]+(l2];g=g+2|0;m=-1;if((g|0)==-1){break e}}m=H[H[d>>2]+(g2]}H[i+8>>2]=m;H[i+4>>2]=e;H[i>>2]=k;c=c+1|0;if((o|0)!=(c|0)){continue}break}}H[H[j+4>>2]+80>>2]=b;c=1;break d}d=0;H[h+24>>2]=0;H[h+16>>2]=0;H[h+20>>2]=0;l=H[a+8>>2];c=H[l>>2];g=H[l+4>>2];H[h+8>>2]=0;H[h>>2]=0;H[h+4>>2]=0;b=0;g:{h:{i:{j:{k:{l:{if((c|0)!=(g|0)){c=g-c|0;if((c|0)>2]=b;H[h+8>>2]=(c&-4)+b;u=h,w=ra(b,0,c)+c|0,H[u+4>>2]=w}c=H[l+24>>2];if((H[l+28>>2]-c|0)>2]+(p>>>3&536870908)>>2]>>>p&1){break n}n=H[a+216>>2];c=H[a+220>>2];if((n|0)==(c|0)){break n}e=g+2|0;i=(g>>>0)%3|0;q=i?g-1|0:e;c=(c-n|0)/144|0;r=c>>>0>2]>>2];o:{if(!(H[H[i+16>>2]+(c>>>3&536870908)>>2]>>>c&1)){break o}c=-1;p:{if(!t){break p}e=H[H[l+12>>2]+(q2];c=-1;if((e|0)==-1){break p}c=e-1|0;if((e>>>0)%3|0){break p}c=e+2|0}if((g|0)==(c|0)){break o}e=s;s=H[i+32>>2];i=H[e+s>>2];while(1){e=0;if((c|0)==-1){break g}if((i|0)!=H[s+(c2]){g=c;break n}q:{r:{if((c>>>0)%3|0){e=c-1|0;break r}e=c+2|0;m=-1;if((e|0)==-1){break q}}c=H[H[l+12>>2]+(e2];m=-1;if((c|0)==-1){break q}m=c-1|0;if((c>>>0)%3|0){break q}m=c+2|0}c=m;if((g|0)!=(c|0)){continue}break}}j=j+1|0;if((r|0)!=(j|0)){continue}break}}i=k-f|0;e=i>>2;H[(g2]=e;s:{if(k>>>0>>0){H[k>>2]=g;k=k+4|0;H[h+20>>2]=k;break s}c=e+1|0;if(c>>>0>=1073741824){break k}d=o-f|0;k=d>>>1|0;c=d>>>0>=2147483644?1073741823:c>>>0>>0?k:c;if(c){if(c>>>0>=1073741824){break j}d=pa(c2]=k;H[h+16>>2]=c;if(f){oa(f);l=H[a+8>>2]}f=c}if((g|0)==-1){break m}t:{if((g>>>0)%3|0){c=g-1|0;break t}c=g+2|0;if((c|0)==-1){break m}}c=H[H[l+12>>2]+(c2];if((c|0)==-1){break m}c=c+((c>>>0)%3|0?-1:2)|0;if((c|0)==-1){break m}e=g;if((c|0)==(g|0)){break m}while(1){i=c;u:{v:{c=H[a+220>>2];j=H[a+216>>2];if((c|0)==(j|0)){break v}c=(c-j|0)/144|0;n=c>>>0>2];r=i2]==H[q+(e2]){c=c+1|0;if((n|0)!=(c|0)){continue}break v}break}j=k-d|0;e=j>>2;H[b+r>>2]=e;if(k>>>0>>0){H[k>>2]=i;k=k+4|0;H[h+20>>2]=k;f=d;break u}c=e+1|0;if(c>>>0>=1073741824){break i}f=o-d|0;k=f>>>1|0;c=f>>>0>=2147483644?1073741823:c>>>0>>0?k:c;if(c){if(c>>>0>=1073741824){break j}f=pa(c2]=k;H[h+16>>2]=c;if(!d){d=c;break u}oa(d);l=H[a+8>>2];d=c;break u}H[(i2]=H[(e2]}if((i|0)==-1){break m}w:{if((i>>>0)%3|0){c=i-1|0;break w}c=i+2|0;if((c|0)==-1){break m}}c=H[H[l+12>>2]+(c2];if((c|0)==-1){break m}c=c+((c>>>0)%3|0?-1:2)|0;if((c|0)==-1){break m}e=i;if((c|0)!=(g|0)){continue}break}}p=p+1|0;c=H[l+24>>2];if((p|0)>2]-c>>2){continue}break}break h}sa();v()}sa();v()}wa();v()}sa();v()}i=H[a+4>>2];a=H[i+44>>2];c=H[a+100>>2];a=H[a+96>>2];x:{if((c|0)==(a|0)){break x}g=(c-a|0)/12|0;f=g>>>0>>0>=2){j=f&-2;g=0;while(1){e=N(c,12);f=e+b|0;o=H[f>>2];p=H[f+4>>2];e=a+e|0;H[e+8>>2]=H[f+8>>2];H[e>>2]=o;H[e+4>>2]=p;e=N(c|1,12);f=e+b|0;o=H[f>>2];p=H[f+4>>2];e=a+e|0;H[e+8>>2]=H[f+8>>2];H[e>>2]=o;H[e+4>>2]=p;c=c+2|0;g=g+2|0;if((j|0)!=(g|0)){continue}break}}if(!l){break x}g=N(c,12);c=g+b|0;f=H[c>>2];e=H[c+4>>2];a=a+g|0;H[a+8>>2]=H[c+8>>2];H[a>>2]=f;H[a+4>>2]=e}H[H[i+4>>2]+80>>2]=k-d>>2;e=1}c=e;if(b){oa(b)}if(!d){break d}H[h+20>>2]=d;oa(d)}ca=h+32|0;return c}function Fj(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,I=0,J=0,K=0,L=0,M=0,O=0,P=0;g=ca+-64|0;ca=g;H[a+8>>2]=e;y=a+32|0;f=H[y>>2];d=H[a+36>>2]-f>>2;a:{b:{if(d>>>0>>0){ya(y,e-d|0);H[g+56>>2]=0;H[g+60>>2]=0;H[g+48>>2]=0;H[g+52>>2]=0;H[g+40>>2]=0;H[g+44>>2]=0;H[g+32>>2]=0;H[g+36>>2]=0;H[g+24>>2]=0;H[g+28>>2]=0;H[g+16>>2]=0;H[g+20>>2]=0;H[g>>2]=0;break b}if(d>>>0>e>>>0){H[a+36>>2]=f+(e2]=0;H[g+60>>2]=0;H[g+48>>2]=0;H[g+52>>2]=0;H[g+40>>2]=0;H[g+44>>2]=0;H[g+32>>2]=0;H[g+36>>2]=0;H[g+24>>2]=0;H[g+28>>2]=0;H[g+16>>2]=0;H[g+20>>2]=0;H[g>>2]=0;d=0;if(!e){break a}}Pa(g+16|0,e,g);h=H[g+28>>2];d=H[g+32>>2]}H[g>>2]=0;d=d-h>>2;c:{if(d>>>0>=e>>>0){if(d>>>0>>0){break c}H[g+32>>2]=(e2]=0;f=H[g+40>>2];d=H[g+44>>2]-f>>2;d:{if(d>>>0>=e>>>0){if(d>>>0>>0){break d}H[g+44>>2]=f+(e2]=0;f=H[g+52>>2];d=H[g+56>>2]-f>>2;e:{if(d>>>0>=e>>>0){if(d>>>0>>0){break e}H[g+56>>2]=f+(e2]>2];j=H[a+32>>2];h=0;while(1){d=h2];m=H[a+16>>2];g:{if((f|0)>(m|0)){H[d+j>>2]=m;break g}d=d+j|0;m=H[a+12>>2];if((m|0)>(f|0)){H[d>>2]=m;break g}H[d>>2]=f}h=h+1|0;d=H[a+8>>2];if((h|0)2]|0;H[f>>2]=i;h:{if((i|0)>H[a+16>>2]){i=i-H[a+20>>2]|0}else{if((i|0)>=H[a+12>>2]){break h}i=i+H[a+20>>2]|0}H[f>>2]=i}d=d+1|0;if((d|0)>2]){continue}break}}G=H[a+52>>2];t=H[a+48>>2];z=pa(16);d=z;H[d>>2]=0;H[d+4>>2]=0;H[d+8>>2]=0;H[d+12>>2]=0;H[g+8>>2]=0;H[g>>2]=0;H[g+4>>2]=0;i:{if(e){if(e>>>0>=1073741824){break i}d=e2]=r;H[g+8>>2]=d+r;ra(r,0,d)}A=1;d=H[a+56>>2];B=H[d>>2];d=H[d+4>>2]-B|0;j:{if((d|0)>2;I=(w|0)>>00>>0)%3|0;x=j?f-1|0:d;s=12];O=n+(x>>>3&536870908)|0;i=0;P=(j|0)!=0|(d|0)!=-1;d=f;q:{while(1){r:{if(H[n+(d>>>3&536870908)>>2]>>>d&1){break r}j=H[H[H[t+64>>2]+12>>2]+(d2];if((j|0)==-1){break r}l=H[G>>2];h=H[t+28>>2];p=H[l+(H[h+(j2]2];if((p|0)>=(m|0)){break r}q=j+1|0;q=H[l+(H[h+(((q>>>0)%3|0?q:j-2|0)2]2];if((q|0)>=(m|0)){break r}h=H[l+(H[h+(j+((j>>>0)%3|0?-1:2)2]2];if((h|0)>=(m|0)){break r}s:{if(!e){break s}j=H[(g+16|0)+N(i,12)>>2];l=N(e,h);q=N(e,q);p=N(e,p);h=0;o=0;if(F){while(1){H[j+(h2]=(H[(h+l2]+H[(h+q2]|0)-H[(h+p2];u=h|1;H[j+(u2]=(H[(l+u2]+H[(q+u2]|0)-H[(p+u2];h=h+2|0;o=o+2|0;if((C|0)!=(o|0)){continue}break}}if(!D){break s}H[j+(h2]=(H[(h+l2]+H[(h+q2]|0)-H[(h+p2]}j=4;i=i+1|0;if((i|0)==4){break q}}t:{if(k&1){h=d-2|0;j=d+1|0;d=-1;j=(j>>>0)%3|0?j:h;if((j|0)==-1|H[n+(j>>>3&536870908)>>2]>>>j&1){break t}j=H[H[H[t+64>>2]+12>>2]+(j2];if((j|0)==-1){break t}d=j+1|0;d=(d>>>0)%3|0?d:j-2|0;break t}u:{if((d>>>0)%3|0){h=d-1|0;break u}h=d+2|0;d=-1;if((h|0)==-1){break t}}d=-1;if(H[n+(h>>>3&536870908)>>2]>>>h&1){break t}j=H[H[H[t+64>>2]+12>>2]+(h2];if((j|0)==-1){break t}if((j>>>0)%3|0){d=j-1|0;break t}d=j+2|0}v:{if((d|0)==(f|0)){break v}if((d|0)==-1&k){if(!P|s&H[O>>2]){break v}d=H[H[H[t+64>>2]+12>>2]+(x2];if((d|0)==-1){break v}k=0;d=(d>>>0)%3|0?d-1|0:d+2|0}if((d|0)!=-1){continue}}break}j=i;if((j|0)>2];f=0;while(1){i=H[q>>2];H[q>>2]=i+1;if(i>>>0>=x>>>0){break j}w:{if(H[H[u+60>>2]+(i>>>3&536870908)>>2]>>>i&1){break w}f=f+1|0;if(!e){break w}n=H[(g+16|0)+N(k,12)>>2];i=0;h=0;p=0;if(!M){while(1){l=h2]=H[l+n>>2]+H[o>>2];o=l|4;s=o+d|0;H[s>>2]=H[n+o>>2]+H[s>>2];o=l|8;s=o+d|0;H[s>>2]=H[n+o>>2]+H[s>>2];l=l|12;o=l+d|0;H[o>>2]=H[l+n>>2]+H[o>>2];h=h+4|0;p=p+4|0;if((K|0)!=(p|0)){continue}break}}if(!E){break w}while(1){l=h2]=H[l+n>>2]+H[p>>2];h=h+1|0;i=i+1|0;if((E|0)!=(i|0)){continue}break}}k=k+1|0;if((k|0)!=(j|0)){continue}break}i=N(e,m);if(!f){break o}if(!e){break l}h=0;d=0;if(F){break n}break m}i=N(e,m)}if(H[a+8>>2]>2];x:{if((f|0)>(n|0)){H[d+j>>2]=n;break x}d=d+j|0;n=H[a+12>>2];if((n|0)>(f|0)){H[d>>2]=n;break x}H[d>>2]=f}h=h+1|0;f=H[a+8>>2];if((h|0)2]=i;y:{if((i|0)>H[a+16>>2]){i=i-H[a+20>>2]|0}else{if((i|0)>=H[a+12>>2]){break y}i=i+H[a+20>>2]|0}H[f>>2]=i}d=d+1|0;if((d|0)>2]){continue}break}break k}Ca();v()}while(1){j=h2]=H[k>>2]/(f|0);j=(j|4)+r|0;H[j>>2]=H[j>>2]/(f|0);h=h+2|0;d=d+2|0;if((C|0)!=(d|0)){continue}break}}if(!D){break l}d=(h2]=H[d>>2]/(f|0)}if(H[a+8>>2]>2];h=0;while(1){d=h2];k=H[a+16>>2];z:{if((f|0)>(k|0)){H[d+j>>2]=k;break z}d=d+j|0;k=H[a+12>>2];if((k|0)>(f|0)){H[d>>2]=k;break z}H[d>>2]=f}h=h+1|0;f=H[a+8>>2];if((h|0)2]=i;A:{if((i|0)>H[a+16>>2]){i=i-H[a+20>>2]|0}else{if((i|0)>=H[a+12>>2]){break A}i=i+H[a+20>>2]|0}H[f>>2]=i}d=d+1|0;if((d|0)>2]){continue}break}}m=m+1|0;A=(w|0)>2];if(a){oa(a)}oa(z);a=H[g+52>>2];if(a){H[g+56>>2]=a;oa(a)}a=H[g+40>>2];if(a){H[g+44>>2]=a;oa(a)}a=H[g+28>>2];if(a){H[g+32>>2]=a;oa(a)}a=H[g+16>>2];if(a){H[g+20>>2]=a;oa(a)}ca=g- -64|0;return A|0}sa();v()}function oj(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,I=0,J=0,K=0,L=0,M=0;h=ca+-64|0;ca=h;H[a+8>>2]=e;x=a+32|0;f=H[x>>2];d=H[a+36>>2]-f>>2;a:{b:{if(d>>>0>>0){ya(x,e-d|0);H[h+56>>2]=0;H[h+60>>2]=0;H[h+48>>2]=0;H[h+52>>2]=0;H[h+40>>2]=0;H[h+44>>2]=0;H[h+32>>2]=0;H[h+36>>2]=0;H[h+24>>2]=0;H[h+28>>2]=0;H[h+16>>2]=0;H[h+20>>2]=0;H[h>>2]=0;break b}if(d>>>0>e>>>0){H[a+36>>2]=f+(e2]=0;H[h+60>>2]=0;H[h+48>>2]=0;H[h+52>>2]=0;H[h+40>>2]=0;H[h+44>>2]=0;H[h+32>>2]=0;H[h+36>>2]=0;H[h+24>>2]=0;H[h+28>>2]=0;H[h+16>>2]=0;H[h+20>>2]=0;H[h>>2]=0;d=0;if(!e){break a}}Pa(h+16|0,e,h);i=H[h+28>>2];d=H[h+32>>2]}H[h>>2]=0;d=d-i>>2;c:{if(d>>>0>=e>>>0){if(d>>>0>>0){break c}H[h+32>>2]=(e2]=0;f=H[h+40>>2];d=H[h+44>>2]-f>>2;d:{if(d>>>0>=e>>>0){if(d>>>0>>0){break d}H[h+44>>2]=f+(e2]=0;f=H[h+52>>2];d=H[h+56>>2]-f>>2;e:{if(d>>>0>=e>>>0){if(d>>>0>>0){break e}H[h+56>>2]=f+(e2]>2];j=H[a+32>>2];i=0;while(1){d=i2];m=H[a+16>>2];g:{if((f|0)>(m|0)){H[d+j>>2]=m;break g}d=d+j|0;m=H[a+12>>2];if((m|0)>(f|0)){H[d>>2]=m;break g}H[d>>2]=f}i=i+1|0;d=H[a+8>>2];if((i|0)2]|0;H[f>>2]=g;h:{if((g|0)>H[a+16>>2]){g=g-H[a+20>>2]|0}else{if((g|0)>=H[a+12>>2]){break h}g=g+H[a+20>>2]|0}H[f>>2]=g}d=d+1|0;if((d|0)>2]){continue}break}}G=H[a+52>>2];A=H[a+48>>2];y=pa(16);d=y;H[d>>2]=0;H[d+4>>2]=0;H[d+8>>2]=0;H[d+12>>2]=0;H[h+8>>2]=0;H[h>>2]=0;H[h+4>>2]=0;i:{if(e){if(e>>>0>=1073741824){break i}d=e2]=t;H[h+8>>2]=d+t;ra(t,0,d)}z=1;d=H[a+56>>2];B=H[d>>2];d=H[d+4>>2]-B|0;j:{if((d|0)>2;I=(w|0)>>00>2];d=f+2|0;g=(f>>>0)%3|0;q=n+((g?f-1|0:d)2];r=H[A>>2];i=p+(H[r+(g2]>0)%3|0?o:g-2|0;if((o|0)!=-1){l=H[r+(o2]}o=H[i>>2];s:{t:{if((g>>>0)%3|0){i=g-1|0;break t}i=g+2|0;s=-1;if((i|0)==-1){break s}}s=H[r+(i2]}if((m|0)=(m|0)){break r}l=H[p+(s2];if((l|0)>=(m|0)){break r}g=H[(h+16|0)+N(j,12)>>2];u:{if(!e){break u}l=N(e,l);r=N(e,i);p=N(e,o);i=0;s=0;if(F){while(1){H[g+(i2]=(H[(i+l2]+H[(i+r2]|0)-H[(i+p2];o=i|1;H[g+(o2]=(H[(l+o2]+H[(o+r2]|0)-H[(o+p2];i=i+2|0;s=s+2|0;if((C|0)!=(s|0)){continue}break}}if(!D){break u}H[g+(i2]=(H[(i+l2]+H[(i+r2]|0)-H[(i+p2]}g=4;j=j+1|0;if((j|0)==4){break q}}v:{if(k&1){i=d+1|0;d=(i>>>0)%3|0?i:d-2|0;g=-1;if((d|0)==-1){break v}d=H[n+(d2];g=-1;if((d|0)==-1){break v}g=d+1|0;g=(g>>>0)%3|0?g:d-2|0;break v}w:{if((d>>>0)%3|0){i=d-1|0;break w}i=d+2|0;g=-1;if((i|0)==-1){break v}}d=H[n+(i2];g=-1;if((d|0)==-1){break v}g=d-1|0;if((d>>>0)%3|0){break v}g=d+2|0}d=g;x:{if((f|0)==(d|0)){break x}if((d|0)==-1&k){if(!u){break x}d=H[q>>2];if((d|0)==-1){break x}k=0;d=(d>>>0)%3|0?d-1|0:d+2|0}if((d|0)!=-1){continue}}break}g=j;if((g|0)>2];f=0;while(1){j=H[r>>2];H[r>>2]=j+1;if(j>>>0>=s>>>0){break j}y:{if(H[H[o+60>>2]+(j>>>3&536870908)>>2]>>>j&1){break y}f=f+1|0;if(!e){break y}j=H[(h+16|0)+N(k,12)>>2];l=0;i=0;p=0;if(!M){while(1){n=i2]=H[j+n>>2]+H[q>>2];q=n|4;u=q+d|0;H[u>>2]=H[j+q>>2]+H[u>>2];q=n|8;u=q+d|0;H[u>>2]=H[j+q>>2]+H[u>>2];n=n|12;q=n+d|0;H[q>>2]=H[j+n>>2]+H[q>>2];i=i+4|0;p=p+4|0;if((K|0)!=(p|0)){continue}break}}if(!E){break y}while(1){n=i2]=H[j+n>>2]+H[p>>2];i=i+1|0;l=l+1|0;if((E|0)!=(l|0)){continue}break}}k=k+1|0;if((k|0)!=(g|0)){continue}break}g=N(e,m);if(!f){break o}if(!e){break l}i=0;d=0;if(F){break n}break m}g=N(e,m)}if(H[a+8>>2]>2];z:{if((f|0)>(l|0)){H[d+j>>2]=l;break z}d=d+j|0;l=H[a+12>>2];if((l|0)>(f|0)){H[d>>2]=l;break z}H[d>>2]=f}i=i+1|0;f=H[a+8>>2];if((i|0)2]=g;A:{if((g|0)>H[a+16>>2]){g=g-H[a+20>>2]|0}else{if((g|0)>=H[a+12>>2]){break A}g=g+H[a+20>>2]|0}H[f>>2]=g}d=d+1|0;if((d|0)>2]){continue}break}break k}Ca();v()}while(1){j=i2]=H[k>>2]/(f|0);j=(j|4)+t|0;H[j>>2]=H[j>>2]/(f|0);i=i+2|0;d=d+2|0;if((C|0)!=(d|0)){continue}break}}if(!D){break l}d=(i2]=H[d>>2]/(f|0)}if(H[a+8>>2]>2];i=0;while(1){d=i2];k=H[a+16>>2];B:{if((f|0)>(k|0)){H[d+j>>2]=k;break B}d=d+j|0;k=H[a+12>>2];if((k|0)>(f|0)){H[d>>2]=k;break B}H[d>>2]=f}i=i+1|0;f=H[a+8>>2];if((i|0)2]=g;C:{if((g|0)>H[a+16>>2]){g=g-H[a+20>>2]|0}else{if((g|0)>=H[a+12>>2]){break C}g=g+H[a+20>>2]|0}H[f>>2]=g}d=d+1|0;if((d|0)>2]){continue}break}}m=m+1|0;z=(w|0)>2];if(a){oa(a)}oa(y);a=H[h+52>>2];if(a){H[h+56>>2]=a;oa(a)}a=H[h+40>>2];if(a){H[h+44>>2]=a;oa(a)}a=H[h+28>>2];if(a){H[h+32>>2]=a;oa(a)}a=H[h+16>>2];if(a){H[h+20>>2]=a;oa(a)}ca=h- -64|0;return z|0}sa();v()}function Od(a,b,c,d,e){var f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,w=0,x=0,y=0,z=0,A=0,B=0;i=ca-80|0;ca=i;H[i+76>>2]=b;y=i+55|0;r=i+56|0;a:{b:{c:{d:{e:while(1){h=b;if((o^2147483647)(x|0)){break d}if(a){Ab(a,h,f)}if(f){continue e}H[i+76>>2]=b;f=b+1|0;p=-1;if(!(I[b+2|0]!=36|F[b+1|0]-48>>>0>=10)){p=F[b+1|0]-48|0;s=1;f=b+3|0}H[i+76>>2]=f;n=0;g=F[f|0];b=g-32|0;k:{if(b>>>0>31){k=f;break k}k=f;b=12]=k;n=b|n;g=F[f+1|0];b=g-32|0;if(b>>>0>=32){break k}f=k;b=1>0>=10)){H[((F[k+1|0]2]=10;g=k+3|0;s=1;b=H[((F[k+1|0]2];break m}if(s){break h}g=k+1|0;if(!a){H[i+76>>2]=g;s=0;q=0;break l}b=H[c>>2];H[c>>2]=b+4;s=0;b=H[b>>2]}H[i+76>>2]=g;q=b;if((b|0)>=0){break l}q=0-q|0;n=n|8192;break l}q=Nd(i+76|0);if((q|0)>2]}f=0;m=-1;n:{if(I[g|0]!=46){b=g;u=0;break n}if(I[g+1|0]==42){o:{if(!(I[g+3|0]!=36|F[g+2|0]-48>>>0>=10)){H[((F[g+2|0]2]=10;b=g+4|0;m=H[((F[g+2|0]2];break o}if(s){break h}b=g+2|0;m=0;if(!a){break o}j=H[c>>2];H[c>>2]=j+4;m=H[j>>2]}H[i+76>>2]=b;u=(m^-1)>>>31|0;break n}H[i+76>>2]=g+1;m=Nd(i+76|0);b=H[i+76>>2];u=1}while(1){g=f;k=28;l=b;f=F[b|0];if(f-123>>>0>>0>2]=b;p:{q:{if((f|0)!=27){if(!f){break c}if((p|0)>=0){H[(p2]=f;j=(p2];H[i+64>>2]=H[j>>2];H[i+68>>2]=f;break q}if(!a){break f}Md(i- -64|0,f,c);break p}if((p|0)>=0){break c}}f=0;if(!a){continue e}}j=n&-65537;n=n&8192?j:n;p=0;t=1132;k=r;r:{s:{t:{u:{v:{w:{x:{y:{z:{A:{B:{C:{D:{E:{F:{G:{f=F[l|0];f=g?(f&15)==3?f&-33:f:f;switch(f-88|0){case 11:break r;case 9:case 13:case 14:case 15:break s;case 27:break x;case 12:case 17:break A;case 23:break B;case 0:case 32:break C;case 24:break D;case 22:break E;case 29:break F;case 1:case 2:case 3:case 4:case 5:case 6:case 7:case 8:case 10:case 16:case 18:case 19:case 20:case 21:case 25:case 26:case 28:case 30:case 31:break g;default:break G}}H:{switch(f-65|0){case 0:case 4:case 5:case 6:break s;case 2:break v;case 1:case 3:break g;default:break H}}if((f|0)==83){break w}break g}l=H[i+64>>2];j=H[i+68>>2];t=1132;break z}f=0;I:{switch(g&255){case 0:H[H[i+64>>2]>>2]=o;continue e;case 1:H[H[i+64>>2]>>2]=o;continue e;case 2:h=H[i+64>>2];H[h>>2]=o;H[h+4>>2]=o>>31;continue e;case 3:G[H[i+64>>2]>>1]=o;continue e;case 4:F[H[i+64>>2]]=o;continue e;case 6:H[H[i+64>>2]>>2]=o;continue e;case 7:break I;default:continue e}}h=H[i+64>>2];H[h>>2]=o;H[h+4>>2]=o>>31;continue e}m=m>>>0>2];j=H[i+68>>2];if(l|j){z=f&32;while(1){h=h-1|0;F[h|0]=z|I[(l&15)+14240|0];w=!j&l>>>0>15|(j|0)!=0;g=j;j=g>>>4|0;l=(g&15)>4;if(w){continue}break}}if(!(H[i+64>>2]|H[i+68>>2])|!(n&8)){break y}t=(f>>>4|0)+1132|0;p=2;break y}f=r;h=H[i+68>>2];j=h;l=H[i+64>>2];if(h|l){while(1){f=f-1|0;F[f|0]=l&7|48;g=!j&l>>>0>7|(j|0)!=0;h=j;j=h>>>3|0;l=(h&7)>3;if(g){continue}break}}h=f;if(!(n&8)){break y}f=r-h|0;m=(f|0)>2];h=H[i+68>>2];j=h;if((h|0)>2]=l;H[i+68>>2]=f;p=1;t=1132;break z}if(n&2048){p=1;t=1133;break z}p=n&1;t=p?1134:1132}g=r;if(j){while(1){g=g-1|0;f=j;w=Tj(l,f,10,0);h=da;A=g,B=l-Rj(w,h,10,0)|48,F[A|0]=B;l=w;j=h;if(f>>>0>9){continue}break}}h=l;if(h){while(1){g=g-1|0;f=(h>>>0)/10|0;F[g|0]=h-N(f,10)|48;j=h>>>0>9;h=f;if(j){continue}break}}h=g}if((m|0)>2];j=H[i+68>>2];if(!(m|(f|j)!=0)){h=r;m=0;break g}f=!(f|j)+(r-h|0)|0;m=(f|0)>>0>=2147483647?2147483647:m;k=g;n=(g|0)!=0;h=H[i+64>>2];h=h?h:1614;f=h;J:{K:{L:{M:{if(!(f&3)|!g){break M}while(1){if(!I[f|0]){break L}k=k-1|0;n=(k|0)!=0;f=f+1|0;if(!(f&3)){break M}if(k){continue}break}}if(!n){break K}if(!(!I[f|0]|k>>>0>2];if((l^-1)&l-16843009&-2139062144){break L}f=f+4|0;k=k-4|0;if(k>>>0>3){continue}break}}if(!k){break K}}while(1){if(!I[f|0]){break J}f=f+1|0;k=k-1|0;if(k){continue}break}}f=0}f=f?f-h|0:g;k=f+h|0;if((m|0)>=0){n=j;m=f;break g}n=j;m=f;if(I[k|0]){break d}break g}if(m){g=H[i+64>>2];break u}f=0;ib(a,32,q,0,n);break t}H[i+12>>2]=0;H[i+8>>2]=H[i+64>>2];g=i+8|0;H[i+64>>2]=g;m=-1}f=0;N:{while(1){h=H[g>>2];if(!h){break N}j=Ld(i+4|0,h);h=(j|0)>>0>m-f>>>0)){g=g+4|0;f=f+j|0;if(m>>>0>f>>>0){continue}break N}break}if(h){break b}}k=61;if((f|0)>2];while(1){h=H[g>>2];if(!h){break t}h=Ld(i+4|0,h);k=h+k|0;if(k>>>0>f>>>0){break t}Ab(a,i+4|0,h);g=g+4|0;if(f>>>0>k>>>0){continue}break}}ib(a,32,q,f,n^8192);f=(f|0)2];m=1;h=y;n=j;break g}g=I[f+1|0];f=f+1|0;continue}}if(a){break a}if(!s){break f}f=1;while(1){a=H[(f2];if(a){Md((f>0>=10){break a}while(1){if(H[(f2]){break h}f=f+1|0;if((f|0)!=10){continue}break}break a}k=28;break c}l=k-h|0;j=(m|0)>(l|0)?m:l;if((j|0)>(p^2147483647)){break d}k=61;g=j+p|0;f=(g|0)2]=2;H[a- -64>>2]=f;M=a+32|0;e=H[M>>2];d=H[a+36>>2]-e|0;c:{if(d>>>0>>2|0)|0);break c}if((d|0)==8){break c}H[a+36>>2]=e+8}i=1;d=H[a+56>>2];d=H[d+4>>2]-H[d>>2]|0;if((d|0)>>2|0;X=d>>>0>2];e=H[f>>2];if(H[f+4>>2]-e>>2>>>0>>0){break a}k=ca-80|0;ca=k;f=-1;d:{e:{e=H[e+(d2];if((e|0)==-1){break e}i=H[o+32>>2];g=e+1|0;g=(g>>>0)%3|0?g:e-2|0;if((g|0)!=-1){f=H[H[i>>2]+(g2]}p=-1;e=e+((e>>>0)%3|0?-1:2)|0;if((e|0)!=-1){p=H[H[i>>2]+(e2]}i=H[o+36>>2];e=H[i>>2];i=H[i+4>>2]-e>>2;if(i>>>0>>0|i>>>0>>0){break e}f:{g:{h:{i:{j:{k:{j=H[e+(p2];f=H[e+(f2];if((j|0)>=(d|0)|(f|0)>=(d|0)){break k}i=(j2];g=(f2];l=H[i>>2];i=H[g>>2];if(!((l|0)!=(i|0)|(e|0)!=(w|0))){H[o+8>>2]=i;H[o+12>>2]=e;break j}p=H[H[o+4>>2]+(d2];H[k+72>>2]=0;H[k+76>>2]=0;g=k- -64|0;H[g>>2]=0;H[g+4>>2]=0;H[k+56>>2]=0;H[k+60>>2]=0;g=H[o>>2];if(!I[g+84|0]){p=H[H[g+68>>2]+(p2]}Sa(g,p,F[g+24|0],k+56|0);p=H[H[o+4>>2]+(f2];H[k+48>>2]=0;H[k+52>>2]=0;H[k+40>>2]=0;H[k+44>>2]=0;H[k+32>>2]=0;H[k+36>>2]=0;g=H[o>>2];if(!I[g+84|0]){p=H[H[g+68>>2]+(p2]}Sa(g,p,F[g+24|0],k+32|0);p=H[H[o+4>>2]+(j2];H[k+24>>2]=0;H[k+28>>2]=0;H[k+16>>2]=0;H[k+20>>2]=0;H[k+8>>2]=0;H[k+12>>2]=0;g=H[o>>2];if(!I[g+84|0]){p=H[H[g+68>>2]+(p2]}Sa(g,p,F[g+24|0],k+8|0);g=H[k+16>>2];n=H[k+40>>2];x=g-n|0;N=H[k+44>>2];g=H[k+20>>2]-(N+(g>>>0>>0)|0)|0;E=g;j=Rj(x,g,x,g);q=da;g=H[k+8>>2];z=H[k+32>>2];A=g-z|0;O=H[k+36>>2];g=H[k+12>>2]-(O+(g>>>0>>0)|0)|0;G=g;h=j;j=Rj(A,g,A,g);g=h+j|0;h=da+q|0;h=g>>>0>>0?h+1|0:h;j=H[k+24>>2];B=H[k+48>>2];C=j-B|0;P=H[k+52>>2];j=H[k+28>>2]-(P+(j>>>0>>0)|0)|0;J=j;m=g;g=Rj(C,j,C,j);r=m+g|0;h=da+h|0;s=g>>>0>r>>>0?h+1|0:h;if(!(s|r)){break k}p=0;D=Tj(-1,2147483647,r,s);f=i>>31;R=f;h=f>>31;Q=i;g=h;q=i^g;i=q-g|0;f=(f^g)-((g>>>0>q>>>0)+g|0)|0;g=f;f=e>>31;S=f;K=e;e=f>>31;q=K^e;m=q-e|0;h=f>>31;e=(h^f)-((e>>>0>q>>>0)+h|0)|0;f=(g|0)==(e|0)&i>>>0>m>>>0|e>>>0>>0;i=f?i:m;j=da;e=f?g:e;if((j|0)==(e|0)&i>>>0>D>>>0|e>>>0>j>>>0){break f}i=H[k+64>>2];T=H[k+68>>2];e=Rj(i-n|0,T-((i>>>0>>0)+N|0)|0,x,E);f=da;g=H[k+56>>2];U=H[k+60>>2];j=Rj(g-z|0,U-((g>>>0>>0)+O|0)|0,A,G);e=j+e|0;h=da+f|0;h=e>>>0>>0?h+1|0:h;f=e;m=H[k+72>>2];V=H[k+76>>2];e=Rj(m-B|0,V-((m>>>0>>0)+P|0)|0,C,J);j=f+e|0;f=da+h|0;q=e>>>0>j>>>0?f+1|0:f;e=l;D=e-Q|0;e=(e>>31)-((e>>>0>>0)+R|0)|0;W=e;l=e>>31;y=l^D;f=y-l|0;h=e>>31;e=(h^e)-((l>>>0>y>>>0)+h|0)|0;h=e;y=w-K|0;e=(w>>31)-((w>>>0>>0)+S|0)|0;w=e;l=f;t=e>>31;u=t^y;L=u-t|0;f=e>>31;e=(f^e)-((t>>>0>u>>>0)+f|0)|0;f=(h|0)==(e|0)&l>>>0>L>>>0|e>>>0>>0;f=Tj(-1,2147483647,f?l:L,f?h:e)>>>0>>0;e=da;if(f&(e|0)31;f=e;l=e^A;e=l-e|0;f=(f^G)-((f>>>0>l>>>0)+f|0)|0;h=E>>31;t=h^x;u=t-h|0;l=(h^E)-((h>>>0>t>>>0)+h|0)|0;h=(f|0)==(l|0)&e>>>0>u>>>0|f>>>0>l>>>0;e=h?e:u;f=h?f:l;h=J>>31;L=e;t=h^C;u=t-h|0;l=(h^J)-((h>>>0>t>>>0)+h|0)|0;e=(f|0)==(l|0)&e>>>0>u>>>0|f>>>0>l>>>0;f=Tj(-1,2147483647,e?L:u,e?f:l)>>>0>>0;e=da;if(f&(e|0)>0>>0?h+1|0:h;n=i-f|0;f=T-((f>>>0>i>>>0)+h|0)|0;n=Rj(n,f,n,f);x=da;f=g;h=Sj(Rj(j,q,A,G),da,r,s);i=h+z|0;g=da+O|0;g=h>>>0>i>>>0?g+1|0:g;h=f-i|0;f=U-((f>>>0>>0)+g|0)|0;g=Rj(h,f,h,f);i=g+n|0;f=da+x|0;f=g>>>0>i>>>0?f+1|0:f;n=i;g=Sj(Rj(j,q,C,J),da,r,s);i=g+B|0;h=da+P|0;h=g>>>0>i>>>0?h+1|0:h;g=m-i|0;i=V-((i>>>0>m>>>0)+h|0)|0;m=Rj(g,i,g,i);i=m+n|0;g=da+f|0;f=Rj(i,i>>>0>>0?g+1|0:g,r,s);i=da;m=i;if(!i&f>>>031;l=l>0>7|(i|0)!=0;h=(i&3)>2;i=i>>>2|0;if(n){continue}break}break h}if((d|0)>(f|0)){e=f>2]=0;break j}e=(d2];H[o+12>>2]=H[e+4>>2]}p=1;break f}e=m;l=f;if(f-1|0){break g}}while(1){i=Tj(f,m,l,e);h=e+da|0;e=i+l|0;h=e>>>0>>0?h+1|0:h;l=(h&1)>1;e=h>>>1|0;i=Rj(l,e,l,e);g=da;if((m|0)==(g|0)&f>>>0>>0|g>>>0>m>>>0){continue}break}}f=H[o+20>>2];if(!f){break f}g=f-1|0;h=H[H[o+16>>2]+(g>>>3&536870908)>>2];H[o+20>>2]=g;p=1;f=Rj(j,q,y,w);i=da;n=Rj(r,s,K,S);m=n+f|0;f=da+i|0;f=m>>>0>>0?f+1|0:f;i=Rj(l,e,D,W);g=h>>>g&1;h=g?0-i|0:i;m=h+m|0;n=f;f=da;i=n+(g?0-(f+((i|0)!=0)|0)|0:f)|0;Z=o,_=Sj(m,h>>>0>m>>>0?i+1|0:i,r,s),H[Z+12>>2]=_;f=Rj(j,q,D,W);i=da;j=Rj(r,s,Q,R);f=j+f|0;h=da+i|0;e=Rj(l,e,y,w);i=0-e|0;l=da;h=(f>>>0>>0?h+1|0:h)+(g?l:0-(((e|0)!=0)+l|0)|0)|0;i=g?e:i;f=i+f|0;Z=o,_=Sj(f,f>>>0>>0?h+1|0:h,r,s),H[Z+8>>2]=_}ca=k+80|0;e=p;break d}Ca();v()}i=e;if(!e){return 0}l:{if(H[a+8>>2]>2];e=0;while(1){f=e2];j=H[a+16>>2];m:{if((g|0)>(j|0)){H[f+l>>2]=j;break m}f=f+l|0;j=H[a+12>>2];if((j|0)>(g|0)){H[f>>2]=j;break m}H[f>>2]=g}e=e+1|0;g=H[a+8>>2];if((e|0)2]=g;n:{if((g|0)>H[a+16>>2]){g=g-H[a+20>>2]|0}else{if((g|0)>=H[a+12>>2]){break n}g=g+H[a+20>>2]|0}H[e>>2]=g}f=f+1|0;if((f|0)>2]){continue}break}}d=d+1|0;if((X|0)!=(d|0)){continue}break}}return i|0}Ca();v()}function xj(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,G=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0;a:{b:{if((e|0)!=2){break b}H[a+8>>2]=2;H[a- -64>>2]=f;M=a+32|0;e=H[M>>2];d=H[a+36>>2]-e|0;c:{if(d>>>0>>2|0)|0);break c}if((d|0)==8){break c}H[a+36>>2]=e+8}p=1;d=H[a+56>>2];d=H[d+4>>2]-H[d>>2]|0;if((d|0)>>2|0;X=d>>>0>2];h=H[e>>2];if(H[e+4>>2]-h>>2>>>0>>0){break a}k=ca-80|0;ca=k;f=-1;h=H[h+(d2];e=-1;d:{if((h|0)==-1){break d}e=h+1|0;f=(e>>>0)%3|0?e:h-2|0;e=h-1|0;if((h>>>0)%3|0){break d}e=h+2|0}g=H[o+36>>2];h=H[g>>2];e:{f:{g:{h:{i:{g=H[g+4>>2]-h>>2;i=f2]+28>>2];j=H[i+f>>2];if(g>>>0>>0){break i}e=H[f+(e2];if(e>>>0>=g>>>0){break i}j:{k:{l=H[h+(e2];f=H[h+(j2];if((l|0)>=(d|0)|(f|0)>=(d|0)){break k}h=(l2];g=(f2];j=H[h>>2];h=H[g>>2];if(!((j|0)!=(h|0)|(e|0)!=(w|0))){H[o+8>>2]=h;H[o+12>>2]=e;break j}p=H[H[o+4>>2]+(d2];H[k+72>>2]=0;H[k+76>>2]=0;g=k- -64|0;H[g>>2]=0;H[g+4>>2]=0;H[k+56>>2]=0;H[k+60>>2]=0;g=H[o>>2];if(!I[g+84|0]){p=H[H[g+68>>2]+(p2]}Sa(g,p,F[g+24|0],k+56|0);p=H[H[o+4>>2]+(f2];H[k+48>>2]=0;H[k+52>>2]=0;H[k+40>>2]=0;H[k+44>>2]=0;H[k+32>>2]=0;H[k+36>>2]=0;g=H[o>>2];if(!I[g+84|0]){p=H[H[g+68>>2]+(p2]}Sa(g,p,F[g+24|0],k+32|0);p=H[H[o+4>>2]+(l2];H[k+24>>2]=0;H[k+28>>2]=0;H[k+16>>2]=0;H[k+20>>2]=0;H[k+8>>2]=0;H[k+12>>2]=0;g=H[o>>2];if(!I[g+84|0]){p=H[H[g+68>>2]+(p2]}Sa(g,p,F[g+24|0],k+8|0);g=H[k+16>>2];n=H[k+40>>2];x=g-n|0;N=H[k+44>>2];g=H[k+20>>2]-(N+(g>>>0>>0)|0)|0;E=g;l=Rj(x,g,x,g);q=da;g=H[k+8>>2];z=H[k+32>>2];A=g-z|0;O=H[k+36>>2];g=H[k+12>>2]-(O+(g>>>0>>0)|0)|0;G=g;i=l;l=Rj(A,g,A,g);g=i+l|0;i=da+q|0;i=g>>>0>>0?i+1|0:i;l=H[k+24>>2];B=H[k+48>>2];C=l-B|0;P=H[k+52>>2];l=H[k+28>>2]-(P+(l>>>0>>0)|0)|0;J=l;m=g;g=Rj(C,l,C,l);r=m+g|0;i=da+i|0;s=g>>>0>r>>>0?i+1|0:i;if(!(s|r)){break k}p=0;D=Tj(-1,2147483647,r,s);f=h>>31;R=f;i=f>>31;Q=h;g=i;q=h^g;h=q-g|0;f=(f^g)-((g>>>0>q>>>0)+g|0)|0;g=f;f=e>>31;S=f;K=e;e=f>>31;q=K^e;m=q-e|0;i=f>>31;e=(i^f)-((e>>>0>q>>>0)+i|0)|0;f=(g|0)==(e|0)&h>>>0>m>>>0|e>>>0>>0;h=f?h:m;l=da;e=f?g:e;if((l|0)==(e|0)&h>>>0>D>>>0|e>>>0>l>>>0){break e}h=H[k+64>>2];T=H[k+68>>2];e=Rj(h-n|0,T-((h>>>0>>0)+N|0)|0,x,E);f=da;g=H[k+56>>2];U=H[k+60>>2];l=Rj(g-z|0,U-((g>>>0>>0)+O|0)|0,A,G);e=l+e|0;i=da+f|0;i=e>>>0>>0?i+1|0:i;f=e;m=H[k+72>>2];V=H[k+76>>2];e=Rj(m-B|0,V-((m>>>0>>0)+P|0)|0,C,J);l=f+e|0;f=da+i|0;q=e>>>0>l>>>0?f+1|0:f;e=j;D=e-Q|0;e=(e>>31)-((e>>>0>>0)+R|0)|0;W=e;j=e>>31;y=j^D;f=y-j|0;i=e>>31;e=(i^e)-((j>>>0>y>>>0)+i|0)|0;i=e;y=w-K|0;e=(w>>31)-((w>>>0>>0)+S|0)|0;w=e;j=f;t=e>>31;u=t^y;L=u-t|0;f=e>>31;e=(f^e)-((t>>>0>u>>>0)+f|0)|0;f=(i|0)==(e|0)&j>>>0>L>>>0|e>>>0>>0;f=Tj(-1,2147483647,f?j:L,f?i:e)>>>0>>0;e=da;if(f&(e|0)31;f=e;j=e^A;e=j-e|0;f=(f^G)-((f>>>0>j>>>0)+f|0)|0;i=E>>31;t=i^x;u=t-i|0;j=(i^E)-((i>>>0>t>>>0)+i|0)|0;i=(f|0)==(j|0)&e>>>0>u>>>0|f>>>0>j>>>0;e=i?e:u;f=i?f:j;i=J>>31;L=e;t=i^C;u=t-i|0;j=(i^J)-((i>>>0>t>>>0)+i|0)|0;e=(f|0)==(j|0)&e>>>0>u>>>0|f>>>0>j>>>0;f=Tj(-1,2147483647,e?L:u,e?f:j)>>>0>>0;e=da;if(f&(e|0)>0>>0?i+1|0:i;n=h-f|0;f=T-((f>>>0>h>>>0)+i|0)|0;n=Rj(n,f,n,f);x=da;f=g;i=Sj(Rj(l,q,A,G),da,r,s);h=i+z|0;g=da+O|0;g=h>>>0>>0?g+1|0:g;i=f-h|0;f=U-((f>>>0>>0)+g|0)|0;g=Rj(i,f,i,f);h=g+n|0;f=da+x|0;f=h>>>0>>0?f+1|0:f;n=h;g=Sj(Rj(l,q,C,J),da,r,s);h=g+B|0;i=da+P|0;i=h>>>0>>0?i+1|0:i;g=m-h|0;h=V-((h>>>0>m>>>0)+i|0)|0;m=Rj(g,h,g,h);h=m+n|0;g=da+f|0;f=Rj(h,h>>>0>>0?g+1|0:g,r,s);h=da;m=h;if(!h&f>>>031;j=j>0>7|(h|0)!=0;i=(h&3)>2;h=h>>>2|0;if(n){continue}break}break g}if((d|0)>(f|0)){e=f>2]=0;break j}e=(d2];H[o+12>>2]=H[e+4>>2]}p=1;break e}Ca();v()}e=m;j=f;if(f-1|0){break f}}while(1){h=Tj(f,m,j,e);i=e+da|0;e=h+j|0;i=e>>>0>>0?i+1|0:i;j=(i&1)>1;e=i>>>1|0;h=Rj(j,e,j,e);g=da;if((m|0)==(g|0)&f>>>0>>0|g>>>0>m>>>0){continue}break}}f=H[o+20>>2];if(!f){break e}g=f-1|0;i=H[H[o+16>>2]+(g>>>3&536870908)>>2];H[o+20>>2]=g;p=1;f=Rj(l,q,y,w);h=da;n=Rj(r,s,K,S);m=n+f|0;f=da+h|0;f=m>>>0>>0?f+1|0:f;h=Rj(j,e,D,W);g=i>>>g&1;i=g?0-h|0:h;m=i+m|0;n=f;f=da;h=n+(g?0-(f+((h|0)!=0)|0)|0:f)|0;Z=o,_=Sj(m,i>>>0>m>>>0?h+1|0:h,r,s),H[Z+12>>2]=_;f=Rj(l,q,D,W);h=da;l=Rj(r,s,Q,R);f=l+f|0;i=da+h|0;e=Rj(j,e,y,w);h=0-e|0;j=da;i=(f>>>0>>0?i+1|0:i)+(g?j:0-(((e|0)!=0)+j|0)|0)|0;h=g?e:h;f=h+f|0;Z=o,_=Sj(f,f>>>0>>0?i+1|0:i,r,s),H[Z+8>>2]=_}ca=k+80|0;if(!p){return 0}l:{if(H[a+8>>2]>2];e=0;while(1){f=e2];j=H[a+16>>2];m:{if((h|0)>(j|0)){H[f+g>>2]=j;break m}f=f+g|0;j=H[a+12>>2];if((j|0)>(h|0)){H[f>>2]=j;break m}H[f>>2]=h}e=e+1|0;h=H[a+8>>2];if((e|0)2]=h;n:{if((h|0)>H[a+16>>2]){i=h-H[a+20>>2]|0}else{if((h|0)>=H[a+12>>2]){break n}i=h+H[a+20>>2]|0}H[e>>2]=i}f=f+1|0;if((f|0)>2]){continue}break}}d=d+1|0;if((X|0)!=(d|0)){continue}break}}return p|0}Ca();v()}function $a(a,b){var c=0,d=0,e=0,f=0,g=0;e=ca-16|0;ca=e;H[a+12>>2]=b;H[a+8>>2]=0;H[a>>2]=0;H[a+4>>2]=0;d=a+16|0;H[d>>2]=0;H[d+4>>2]=0;F[d+5|0]=0;F[d+6|0]=0;F[d+7|0]=0;F[d+8|0]=0;F[d+9|0]=0;F[d+10|0]=0;F[d+11|0]=0;F[d+12|0]=0;c=d+16|0;H[c>>2]=0;H[c+4>>2]=0;F[c+5|0]=0;F[c+6|0]=0;F[c+7|0]=0;F[c+8|0]=0;F[c+9|0]=0;F[c+10|0]=0;F[c+11|0]=0;F[c+12|0]=0;c=d+32|0;H[c>>2]=0;H[c+4>>2]=0;F[c+5|0]=0;F[c+6|0]=0;F[c+7|0]=0;F[c+8|0]=0;F[c+9|0]=0;F[c+10|0]=0;F[c+11|0]=0;F[c+12|0]=0;c=d+48|0;H[c>>2]=0;H[c+4>>2]=0;F[c+5|0]=0;F[c+6|0]=0;F[c+7|0]=0;F[c+8|0]=0;F[c+9|0]=0;F[c+10|0]=0;F[c+11|0]=0;F[c+12|0]=0;c=d- -64|0;H[c>>2]=0;H[c+4>>2]=0;F[c+5|0]=0;F[c+6|0]=0;F[c+7|0]=0;F[c+8|0]=0;F[c+9|0]=0;F[c+10|0]=0;F[c+11|0]=0;F[c+12|0]=0;c=d+80|0;H[c>>2]=0;H[c+4>>2]=0;F[c+5|0]=0;F[c+6|0]=0;F[c+7|0]=0;F[c+8|0]=0;F[c+9|0]=0;F[c+10|0]=0;F[c+11|0]=0;F[c+12|0]=0;c=d+96|0;H[c>>2]=0;H[c+4>>2]=0;F[c+5|0]=0;F[c+6|0]=0;F[c+7|0]=0;F[c+8|0]=0;F[c+9|0]=0;F[c+10|0]=0;F[c+11|0]=0;F[c+12|0]=0;c=d+112|0;H[c>>2]=0;H[c+4>>2]=0;F[c+5|0]=0;F[c+6|0]=0;F[c+7|0]=0;F[c+8|0]=0;F[c+9|0]=0;F[c+10|0]=0;F[c+11|0]=0;F[c+12|0]=0;c=d+128|0;H[c>>2]=0;H[c+4>>2]=0;F[c+5|0]=0;F[c+6|0]=0;F[c+7|0]=0;F[c+8|0]=0;F[c+9|0]=0;F[c+10|0]=0;F[c+11|0]=0;F[c+12|0]=0;c=d+144|0;H[c>>2]=0;H[c+4>>2]=0;F[c+5|0]=0;F[c+6|0]=0;F[c+7|0]=0;F[c+8|0]=0;F[c+9|0]=0;F[c+10|0]=0;F[c+11|0]=0;F[c+12|0]=0;c=d+160|0;H[c>>2]=0;H[c+4>>2]=0;F[c+5|0]=0;F[c+6|0]=0;F[c+7|0]=0;F[c+8|0]=0;F[c+9|0]=0;F[c+10|0]=0;F[c+11|0]=0;F[c+12|0]=0;c=d+176|0;H[c>>2]=0;H[c+4>>2]=0;F[c+5|0]=0;F[c+6|0]=0;F[c+7|0]=0;F[c+8|0]=0;F[c+9|0]=0;F[c+10|0]=0;F[c+11|0]=0;F[c+12|0]=0;c=d+192|0;H[c>>2]=0;H[c+4>>2]=0;F[c+5|0]=0;F[c+6|0]=0;F[c+7|0]=0;F[c+8|0]=0;F[c+9|0]=0;F[c+10|0]=0;F[c+11|0]=0;F[c+12|0]=0;c=d+208|0;H[c>>2]=0;H[c+4>>2]=0;F[c+5|0]=0;F[c+6|0]=0;F[c+7|0]=0;F[c+8|0]=0;F[c+9|0]=0;F[c+10|0]=0;F[c+11|0]=0;F[c+12|0]=0;c=d+224|0;H[c>>2]=0;H[c+4>>2]=0;F[c+5|0]=0;F[c+6|0]=0;F[c+7|0]=0;F[c+8|0]=0;F[c+9|0]=0;F[c+10|0]=0;F[c+11|0]=0;F[c+12|0]=0;c=d+240|0;H[c>>2]=0;H[c+4>>2]=0;F[c+5|0]=0;F[c+6|0]=0;F[c+7|0]=0;F[c+8|0]=0;F[c+9|0]=0;F[c+10|0]=0;F[c+11|0]=0;F[c+12|0]=0;c=d+256|0;H[c>>2]=0;H[c+4>>2]=0;F[c+5|0]=0;F[c+6|0]=0;F[c+7|0]=0;F[c+8|0]=0;F[c+9|0]=0;F[c+10|0]=0;F[c+11|0]=0;F[c+12|0]=0;c=d+272|0;H[c>>2]=0;H[c+4>>2]=0;F[c+5|0]=0;F[c+6|0]=0;F[c+7|0]=0;F[c+8|0]=0;F[c+9|0]=0;F[c+10|0]=0;F[c+11|0]=0;F[c+12|0]=0;c=d+288|0;H[c>>2]=0;H[c+4>>2]=0;F[c+5|0]=0;F[c+6|0]=0;F[c+7|0]=0;F[c+8|0]=0;F[c+9|0]=0;F[c+10|0]=0;F[c+11|0]=0;F[c+12|0]=0;c=d+304|0;H[c>>2]=0;H[c+4>>2]=0;F[c+5|0]=0;F[c+6|0]=0;F[c+7|0]=0;F[c+8|0]=0;F[c+9|0]=0;F[c+10|0]=0;F[c+11|0]=0;F[c+12|0]=0;c=d+320|0;H[c>>2]=0;H[c+4>>2]=0;F[c+5|0]=0;F[c+6|0]=0;F[c+7|0]=0;F[c+8|0]=0;F[c+9|0]=0;F[c+10|0]=0;F[c+11|0]=0;F[c+12|0]=0;c=d+336|0;H[c>>2]=0;H[c+4>>2]=0;F[c+5|0]=0;F[c+6|0]=0;F[c+7|0]=0;F[c+8|0]=0;F[c+9|0]=0;F[c+10|0]=0;F[c+11|0]=0;F[c+12|0]=0;c=d+352|0;H[c>>2]=0;H[c+4>>2]=0;F[c+5|0]=0;F[c+6|0]=0;F[c+7|0]=0;F[c+8|0]=0;F[c+9|0]=0;F[c+10|0]=0;F[c+11|0]=0;F[c+12|0]=0;c=d+368|0;H[c>>2]=0;H[c+4>>2]=0;F[c+5|0]=0;F[c+6|0]=0;F[c+7|0]=0;F[c+8|0]=0;F[c+9|0]=0;F[c+10|0]=0;F[c+11|0]=0;F[c+12|0]=0;c=d+384|0;H[c>>2]=0;H[c+4>>2]=0;F[c+5|0]=0;F[c+6|0]=0;F[c+7|0]=0;F[c+8|0]=0;F[c+9|0]=0;F[c+10|0]=0;F[c+11|0]=0;F[c+12|0]=0;c=d+400|0;H[c>>2]=0;H[c+4>>2]=0;F[c+5|0]=0;F[c+6|0]=0;F[c+7|0]=0;F[c+8|0]=0;F[c+9|0]=0;F[c+10|0]=0;F[c+11|0]=0;F[c+12|0]=0;c=d+416|0;H[c>>2]=0;H[c+4>>2]=0;F[c+5|0]=0;F[c+6|0]=0;F[c+7|0]=0;F[c+8|0]=0;F[c+9|0]=0;F[c+10|0]=0;F[c+11|0]=0;F[c+12|0]=0;c=d+432|0;H[c>>2]=0;H[c+4>>2]=0;F[c+5|0]=0;F[c+6|0]=0;F[c+7|0]=0;F[c+8|0]=0;F[c+9|0]=0;F[c+10|0]=0;F[c+11|0]=0;F[c+12|0]=0;c=d+448|0;H[c>>2]=0;H[c+4>>2]=0;F[c+5|0]=0;F[c+6|0]=0;F[c+7|0]=0;F[c+8|0]=0;F[c+9|0]=0;F[c+10|0]=0;F[c+11|0]=0;F[c+12|0]=0;c=d+464|0;H[c>>2]=0;H[c+4>>2]=0;F[c+5|0]=0;F[c+6|0]=0;F[c+7|0]=0;F[c+8|0]=0;F[c+9|0]=0;F[c+10|0]=0;F[c+11|0]=0;F[c+12|0]=0;c=d+480|0;H[c>>2]=0;H[c+4>>2]=0;F[c+5|0]=0;F[c+6|0]=0;F[c+7|0]=0;F[c+8|0]=0;F[c+9|0]=0;F[c+10|0]=0;F[c+11|0]=0;F[c+12|0]=0;d=d+496|0;H[d>>2]=0;H[d+4>>2]=0;F[d+5|0]=0;F[d+6|0]=0;F[d+7|0]=0;F[d+8|0]=0;F[d+9|0]=0;F[d+10|0]=0;F[d+11|0]=0;F[d+12|0]=0;H[a+528>>2]=0;H[a+532>>2]=0;F[a+533|0]=0;F[a+534|0]=0;F[a+535|0]=0;F[a+536|0]=0;F[a+537|0]=0;F[a+538|0]=0;F[a+539|0]=0;F[a+540|0]=0;H[a+544>>2]=0;H[a+548>>2]=0;H[a+560>>2]=0;H[a+552>>2]=0;H[a+556>>2]=0;H[a+564>>2]=0;H[a+568>>2]=0;H[a+580>>2]=0;H[a+572>>2]=0;H[a+576>>2]=0;H[a+584>>2]=0;H[a+588>>2]=0;H[a+600>>2]=0;H[a+592>>2]=0;H[a+596>>2]=0;H[a+612>>2]=0;H[a+604>>2]=0;H[a+608>>2]=0;g=a+628|0;a:{b:{if(b){if(b>>>0>2]=0;H[a+620>>2]=0;H[a+624>>2]=0;H[e+8>>2]=0;H[e>>2]=0;H[e+4>>2]=0;d=1;break a}d=b2]=c;f=c+d|0;H[a+612>>2]=f;ra(c,0,d);H[a+624>>2]=0;H[a+616>>2]=0;H[a+620>>2]=0;H[a+608>>2]=f;c=pa(d);H[a+616>>2]=c;f=c+d|0;H[a+624>>2]=f;ra(c,0,d);H[a+620>>2]=f;c=pa(d);H[e>>2]=c;f=c+d|0;H[e+8>>2]=f;ra(c,0,d);H[e+4>>2]=f;d=b2];if(c){H[e+4>>2]=c;oa(c)}H[e+8>>2]=0;H[e>>2]=0;H[e+4>>2]=0;if(b){b=b2]=c;f=b+c|0;H[e+8>>2]=f;ra(c,0,b);H[e+4>>2]=f}tb(a+640|0,d,e);b=H[e>>2];if(b){H[e+4>>2]=b;oa(b)}ca=e+16|0;return a}function gc(a,b,c,d){var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=O(0),n=O(0),o=0;a:{b:{if(!d){break b}c:{switch(H[a+28>>2]-1|0){case 0:e=I[a+24|0];f=c&255;if(e>>>0>>0?e:f){e=H[a>>2];h=H[e>>2];k=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);i=b;b=b+k|0;b=b+h|0;h=H[e+4>>2];while(1){if(b>>>0>=h>>>0){break b}G[(g1]=F[b|0];b=b+1|0;g=g+1|0;e=I[a+24|0];if(g>>>0>>0>>0?e:f)>>>0){continue}break}}j=1;if(e>>>0>=f>>>0){break b}break a;case 1:e=I[a+24|0];f=c&255;if(e>>>0>>0?e:f){e=H[a>>2];h=H[e>>2];k=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);i=b;b=b+k|0;b=b+h|0;h=H[e+4>>2];while(1){if(b>>>0>=h>>>0){break b}G[(g1]=I[b|0];b=b+1|0;g=g+1|0;e=I[a+24|0];if(g>>>0>>0>>0?e:f)>>>0){continue}break}}j=1;if(e>>>0>=f>>>0){break b}break a;case 2:e=I[a+24|0];f=c&255;if(e>>>0>>0?e:f){e=H[a>>2];h=H[e>>2];k=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);i=b;b=b+k|0;b=b+h|0;h=H[e+4>>2];while(1){if(b>>>0>=h>>>0){break b}G[(g1]=J[b>>1];b=b+2|0;g=g+1|0;e=I[a+24|0];if(g>>>0>>0>>0?e:f)>>>0){continue}break}}j=1;if(e>>>0>=f>>>0){break b}break a;case 3:e=I[a+24|0];f=c&255;if(e>>>0>>0?e:f){e=H[a>>2];h=H[e>>2];k=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);i=b;b=b+k|0;b=b+h|0;h=H[e+4>>2];while(1){if(b>>>0>=h>>>0){return 0}e=G[b>>1];if((e|0)>>0>>0>>0?e:f)>>>0){continue}break}}j=1;if(e>>>0>=f>>>0){break b}break a;case 4:e=I[a+24|0];f=c&255;if(e>>>0>>0?e:f){e=H[a>>2];h=H[e>>2];k=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);i=b;b=b+k|0;b=b+h|0;h=H[e+4>>2];while(1){if(b>>>0>=h>>>0){break b}e=H[b>>2];if(e+32768>>>0>65535){break b}G[(g1]=e;b=b+4|0;g=g+1|0;e=I[a+24|0];if(g>>>0>>0>>0?e:f)>>>0){continue}break}}j=1;if(e>>>0>=f>>>0){break b}break a;case 5:e=I[a+24|0];f=c&255;if(e>>>0>>0?e:f){e=H[a>>2];h=H[e>>2];k=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);i=b;b=b+k|0;b=b+h|0;h=H[e+4>>2];while(1){if(b>>>0>=h>>>0){break b}e=H[b>>2];if(e>>>0>32767){break b}G[(g1]=e;b=b+4|0;g=g+1|0;e=I[a+24|0];if(g>>>0>>0>>0?e:f)>>>0){continue}break}}j=1;if(e>>>0>=f>>>0){break b}break a;case 6:e=I[a+24|0];f=c&255;if(e>>>0>>0?e:f){e=H[a>>2];h=H[e>>2];k=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);i=b;b=b+k|0;b=b+h|0;k=H[e+4>>2];while(1){if(b>>>0>=k>>>0){break b}h=H[b+4>>2];e=H[b>>2];i=e+32768|0;h=i>>>0>>0>65535|h){break b}G[(g1]=e;b=b+8|0;g=g+1|0;e=I[a+24|0];if(g>>>0>>0>>0?e:f)>>>0){continue}break}}j=1;if(e>>>0>=f>>>0){break b}break a;case 7:e=I[a+24|0];f=c&255;if(e>>>0>>0?e:f){e=H[a>>2];h=H[e>>2];k=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);i=b;b=b+k|0;b=b+h|0;h=H[e+4>>2];while(1){if(b>>>0>=h>>>0){break b}k=H[b+4>>2];e=H[b>>2];if(!k&e>>>0>32767|k){break b}G[(g1]=e;b=b+8|0;g=g+1|0;e=I[a+24|0];if(g>>>0>>0>>0?e:f)>>>0){continue}break}}j=1;if(e>>>0>=f>>>0){break b}break a;case 8:d:{e:{e=I[a+24|0];c=c&255;if(!(c>>>0>e>>>0?e:c)){break e}e=H[a>>2];j=H[e>>2];g=j;f=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);i=b;b=b+f|0;g=b+g|0;f=H[e+4>>2];e=f-j|0;if(!I[a+32|0]){j=0;if((b|0)>=(e|0)){break d}b=0;while(1){m=L[g>>2];if(m>=O(32767)|m>0>=(c>>>0>e>>>0?e:c)>>>0){break e}g=g+4|0;if(f>>>0>g>>>0){continue}break}break d}j=0;if((b|0)>=(e|0)){break d}b=0;while(1){m=L[g>>2];if(m>=O(32767)|m>0>=(c>>>0>e>>>0?e:c)>>>0){break e}g=g+4|0;if(f>>>0>g>>>0){continue}break}break d}j=1;if(c>>>0>>0){break d}ra((ee>>>0?e:c)){break h}e=H[a>>2];j=H[e>>2];g=j;f=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);i=b;b=b+f|0;g=b+g|0;f=H[e+4>>2];e=f-j|0;if(!I[a+32|0]){j=0;if((b|0)>=(e|0)){break g}b=0;while(1){l=M[g>>3];if(l>=32767|l>0>=(c>>>0>e>>>0?e:c)>>>0){break h}g=g+8|0;if(f>>>0>g>>>0){continue}break}break g}j=0;if((b|0)>=(e|0)){break g}b=0;while(1){l=M[g>>3];if(l>=32767|l>0>=(c>>>0>e>>>0?e:c)>>>0){break h}g=g+8|0;if(f>>>0>g>>>0){continue}break}break g}j=1;if(c>>>0>>0){break g}ra((e>0?e:f){e=H[a>>2];h=H[e>>2];k=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);i=b;b=b+k|0;b=b+h|0;h=H[e+4>>2];while(1){if(b>>>0>=h>>>0){break b}G[(g1]=I[b|0];b=b+1|0;g=g+1|0;e=I[a+24|0];if(g>>>0>>0>>0?e:f)>>>0){continue}break}}j=1;if(e>>>0>=f>>>0){break b}ra((e>2];h=H[e>>2];k=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);i=b;b=b+k|0;b=b+h|0;h=H[e+4>>2];while(1){if(b>>>0>=h>>>0){break b}H[(g2]=F[b|0];b=b+1|0;g=g+1|0;e=I[a+24|0];if(g>>>0>>0>>0?e:f)>>>0){continue}break}}j=1;if(e>>>0>=f>>>0){break b}break a;case 1:e=I[a+24|0];f=c&255;if(e>>>0>>0?e:f){e=H[a>>2];h=H[e>>2];k=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);i=b;b=b+k|0;b=b+h|0;h=H[e+4>>2];while(1){if(b>>>0>=h>>>0){break b}H[(g2]=I[b|0];b=b+1|0;g=g+1|0;e=I[a+24|0];if(g>>>0>>0>>0?e:f)>>>0){continue}break}}j=1;if(e>>>0>=f>>>0){break b}break a;case 2:e=I[a+24|0];f=c&255;if(e>>>0>>0?e:f){e=H[a>>2];h=H[e>>2];k=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);i=b;b=b+k|0;b=b+h|0;h=H[e+4>>2];while(1){if(b>>>0>=h>>>0){break b}H[(g2]=G[b>>1];b=b+2|0;g=g+1|0;e=I[a+24|0];if(g>>>0>>0>>0?e:f)>>>0){continue}break}}j=1;if(e>>>0>=f>>>0){break b}break a;case 3:e=I[a+24|0];f=c&255;if(e>>>0>>0?e:f){e=H[a>>2];h=H[e>>2];k=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);i=b;b=b+k|0;b=b+h|0;h=H[e+4>>2];while(1){if(b>>>0>=h>>>0){break b}H[(g2]=J[b>>1];b=b+2|0;g=g+1|0;e=I[a+24|0];if(g>>>0>>0>>0?e:f)>>>0){continue}break}}j=1;if(e>>>0>=f>>>0){break b}break a;case 4:e=I[a+24|0];f=c&255;if(e>>>0>>0?e:f){e=H[a>>2];h=H[e>>2];k=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);i=b;b=b+k|0;b=b+h|0;h=H[e+4>>2];while(1){if(b>>>0>=h>>>0){break b}H[(g2]=H[b>>2];b=b+4|0;g=g+1|0;e=I[a+24|0];if(g>>>0>>0>>0?e:f)>>>0){continue}break}}j=1;if(e>>>0>=f>>>0){break b}break a;case 5:e=I[a+24|0];f=c&255;if(e>>>0>>0?e:f){e=H[a>>2];h=H[e>>2];k=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);i=b;b=b+k|0;b=b+h|0;h=H[e+4>>2];while(1){if(b>>>0>=h>>>0){return 0}e=H[b>>2];if((e|0)>>0>>0>>0?e:f)>>>0){continue}break}}j=1;if(e>>>0>=f>>>0){break b}break a;case 6:e=I[a+24|0];f=c&255;if(e>>>0>>0?e:f){e=H[a>>2];h=H[e>>2];k=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);i=b;b=b+k|0;b=b+h|0;k=H[e+4>>2];while(1){if(b>>>0>=k>>>0){break b}h=H[b+4>>2];e=H[b>>2];if(e- -2147483648>>>0>>0>>0>>0?e:f)>>>0){continue}break}}j=1;if(e>>>0>=f>>>0){break b}break a;case 7:e=I[a+24|0];f=c&255;if(e>>>0>>0?e:f){e=H[a>>2];h=H[e>>2];k=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);i=b;b=b+k|0;b=b+h|0;h=H[e+4>>2];while(1){if(b>>>0>=h>>>0){break b}k=H[b+4>>2];e=H[b>>2];if(!k&e>>>0>2147483647|k){break b}H[(g2]=e;b=b+8|0;g=g+1|0;e=I[a+24|0];if(g>>>0>>0>>0?e:f)>>>0){continue}break}}j=1;if(e>>>0>=f>>>0){break b}break a;case 8:d:{e:{e=I[a+24|0];c=c&255;if(!(c>>>0>e>>>0?e:c)){break e}e=H[a>>2];j=H[e>>2];g=j;f=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);i=b;b=b+f|0;g=b+g|0;f=H[e+4>>2];e=f-j|0;if(!I[a+32|0]){j=0;if((b|0)>=(e|0)){break d}b=0;while(1){m=L[g>>2];if(m>=O(2147483648)|m>0>=(c>>>0>e>>>0?e:c)>>>0){break e}g=g+4|0;if(f>>>0>g>>>0){continue}break}break d}j=0;if((b|0)>=(e|0)){break d}b=0;while(1){m=L[g>>2];if(m>=O(2147483648)|m>0>=(c>>>0>e>>>0?e:c)>>>0){break e}g=g+4|0;if(f>>>0>g>>>0){continue}break}break d}j=1;if(c>>>0>>0){break d}ra((ee>>>0?e:c)){break h}e=H[a>>2];j=H[e>>2];g=j;f=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);i=b;b=b+f|0;g=b+g|0;f=H[e+4>>2];e=f-j|0;if(!I[a+32|0]){j=0;if((b|0)>=(e|0)){break g}b=0;while(1){l=M[g>>3];if(l>=2147483647|l>0>=(c>>>0>e>>>0?e:c)>>>0){break h}g=g+8|0;if(f>>>0>g>>>0){continue}break}break g}j=0;if((b|0)>=(e|0)){break g}b=0;while(1){l=M[g>>3];if(l>=2147483647|l>0>=(c>>>0>e>>>0?e:c)>>>0){break h}g=g+8|0;if(f>>>0>g>>>0){continue}break}break g}j=1;if(c>>>0>>0){break g}ra((e>0?e:f){e=H[a>>2];h=H[e>>2];k=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);i=b;b=b+k|0;b=b+h|0;h=H[e+4>>2];while(1){if(b>>>0>=h>>>0){break b}H[(g2]=I[b|0];b=b+1|0;g=g+1|0;e=I[a+24|0];if(g>>>0>>0>>0?e:f)>>>0){continue}break}}j=1;if(e>>>0>=f>>>0){break b}ra((e>2];h=H[e>>2];k=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);i=b;b=b+k|0;b=b+h|0;h=H[e+4>>2];while(1){if(b>>>0>=h>>>0){return 0}e=F[b|0];if((e|0)>>0>>0>>0?e:f)>>>0){continue}break}}l=1;if(e>>>0>=f>>>0){break b}break a;case 1:e=I[a+24|0];f=c&255;if(e>>>0>>0?e:f){e=H[a>>2];h=H[e>>2];k=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);i=b;b=b+k|0;b=b+h|0;h=H[e+4>>2];while(1){if(b>>>0>=h>>>0){break b}G[(g1]=I[b|0];b=b+1|0;g=g+1|0;e=I[a+24|0];if(g>>>0>>0>>0?e:f)>>>0){continue}break}}l=1;if(e>>>0>=f>>>0){break b}break a;case 2:e=I[a+24|0];f=c&255;if(e>>>0>>0?e:f){e=H[a>>2];h=H[e>>2];k=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);i=b;b=b+k|0;b=b+h|0;h=H[e+4>>2];while(1){if(b>>>0>=h>>>0){return 0}e=G[b>>1];if((e|0)>>0>>0>>0?e:f)>>>0){continue}break}}l=1;if(e>>>0>=f>>>0){break b}break a;case 3:e=I[a+24|0];f=c&255;if(e>>>0>>0?e:f){e=H[a>>2];h=H[e>>2];k=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);i=b;b=b+k|0;b=b+h|0;h=H[e+4>>2];while(1){if(b>>>0>=h>>>0){break b}G[(g1]=J[b>>1];b=b+2|0;g=g+1|0;e=I[a+24|0];if(g>>>0>>0>>0?e:f)>>>0){continue}break}}l=1;if(e>>>0>=f>>>0){break b}break a;case 4:e=I[a+24|0];f=c&255;if(e>>>0>>0?e:f){e=H[a>>2];h=H[e>>2];k=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);i=b;b=b+k|0;b=b+h|0;h=H[e+4>>2];while(1){if(b>>>0>=h>>>0){break b}e=H[b>>2];if(e>>>0>65535){break b}G[(g1]=e;b=b+4|0;g=g+1|0;e=I[a+24|0];if(g>>>0>>0>>0?e:f)>>>0){continue}break}}l=1;if(e>>>0>=f>>>0){break b}break a;case 5:e=I[a+24|0];f=c&255;if(e>>>0>>0?e:f){e=H[a>>2];h=H[e>>2];k=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);i=b;b=b+k|0;b=b+h|0;h=H[e+4>>2];while(1){if(b>>>0>=h>>>0){break b}e=H[b>>2];if(e>>>0>65535){break b}G[(g1]=e;b=b+4|0;g=g+1|0;e=I[a+24|0];if(g>>>0>>0>>0?e:f)>>>0){continue}break}}l=1;if(e>>>0>=f>>>0){break b}break a;case 6:e=I[a+24|0];f=c&255;if(e>>>0>>0?e:f){e=H[a>>2];h=H[e>>2];k=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);i=b;b=b+k|0;b=b+h|0;h=H[e+4>>2];while(1){if(b>>>0>=h>>>0){break b}k=H[b+4>>2];e=H[b>>2];if(!k&e>>>0>65535|k){break b}G[(g1]=e;b=b+8|0;g=g+1|0;e=I[a+24|0];if(g>>>0>>0>>0?e:f)>>>0){continue}break}}l=1;if(e>>>0>=f>>>0){break b}break a;case 7:e=I[a+24|0];f=c&255;if(e>>>0>>0?e:f){e=H[a>>2];h=H[e>>2];k=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);i=b;b=b+k|0;b=b+h|0;h=H[e+4>>2];while(1){if(b>>>0>=h>>>0){break b}k=H[b+4>>2];e=H[b>>2];if(!k&e>>>0>65535|k){break b}G[(g1]=e;b=b+8|0;g=g+1|0;e=I[a+24|0];if(g>>>0>>0>>0?e:f)>>>0){continue}break}}l=1;if(e>>>0>=f>>>0){break b}break a;case 8:d:{e:{e=I[a+24|0];c=c&255;if(!(c>>>0>e>>>0?e:c)){break e}e=H[a>>2];l=H[e>>2];g=l;f=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);i=b;b=b+f|0;g=b+g|0;f=H[e+4>>2];e=f-l|0;if(!I[a+32|0]){l=0;if((b|0)>=(e|0)){break d}b=0;while(1){m=L[g>>2];if(m>=O(65535)|m0}else{i=0}G[e>>1]=i;b=b+1|0;e=I[a+24|0];if(b>>>0>=(c>>>0>e>>>0?e:c)>>>0){break e}g=g+4|0;if(f>>>0>g>>>0){continue}break}break d}l=0;if((b|0)>=(e|0)){break d}b=0;while(1){m=L[g>>2];if(m>=O(65535)|mO(1)){break d}e=(b>0;break f}i=0}G[e>>1]=i;b=b+1|0;e=I[a+24|0];if(b>>>0>=(c>>>0>e>>>0?e:c)>>>0){break e}g=g+4|0;if(f>>>0>g>>>0){continue}break}break d}l=1;if(c>>>0>>0){break d}ra((ee>>>0?e:c)){break h}e=H[a>>2];l=H[e>>2];g=l;f=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);i=b;b=b+f|0;g=b+g|0;f=H[e+4>>2];e=f-l|0;if(!I[a+32|0]){l=0;if((b|0)>=(e|0)){break g}b=0;while(1){j=M[g>>3];if(j>=65535|j0}else{i=0}G[e>>1]=i;b=b+1|0;e=I[a+24|0];if(b>>>0>=(c>>>0>e>>>0?e:c)>>>0){break h}g=g+8|0;if(f>>>0>g>>>0){continue}break}break g}l=0;if((b|0)>=(e|0)){break g}b=0;while(1){j=M[g>>3];if(j>=65535|j1){break g}e=(b>0;break i}i=0}G[e>>1]=i;b=b+1|0;e=I[a+24|0];if(b>>>0>=(c>>>0>e>>>0?e:c)>>>0){break h}g=g+8|0;if(f>>>0>g>>>0){continue}break}break g}l=1;if(c>>>0>>0){break g}ra((e>0?e:f){e=H[a>>2];h=H[e>>2];k=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);i=b;b=b+k|0;b=b+h|0;h=H[e+4>>2];while(1){if(b>>>0>=h>>>0){break b}G[(g1]=I[b|0];b=b+1|0;g=g+1|0;e=I[a+24|0];if(g>>>0>>0>>0?e:f)>>>0){continue}break}}l=1;if(e>>>0>=f>>>0){break b}ra((e>2];h=H[e>>2];i=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);j=b;b=b+i|0;b=b+h|0;h=H[e+4>>2];while(1){if(b>>>0>=h>>>0){break a}e=(g2]=i;H[e+4>>2]=i>>31;b=b+1|0;g=g+1|0;e=I[a+24|0];if(g>>>0>>0>>0?e:f)>>>0){continue}break}}if(e>>>0>=f>>>0){break a}d=(e>0>>0?e:f){e=H[a>>2];h=H[e>>2];i=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);j=b;b=b+i|0;b=b+h|0;h=H[e+4>>2];while(1){if(b>>>0>=h>>>0){break a}e=(g2]=I[b|0];H[e+4>>2]=0;b=b+1|0;g=g+1|0;e=I[a+24|0];if(g>>>0>>0>>0?e:f)>>>0){continue}break}}if(e>>>0>=f>>>0){break a}d=(e>0>>0?e:f){e=H[a>>2];h=H[e>>2];i=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);j=b;b=b+i|0;b=b+h|0;h=H[e+4>>2];while(1){if(b>>>0>=h>>>0){break a}e=(g1];H[e>>2]=i;H[e+4>>2]=i>>31;b=b+2|0;g=g+1|0;e=I[a+24|0];if(g>>>0>>0>>0?e:f)>>>0){continue}break}}if(e>>>0>=f>>>0){break a}d=(e>0>>0?e:f){e=H[a>>2];h=H[e>>2];i=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);j=b;b=b+i|0;b=b+h|0;h=H[e+4>>2];while(1){if(b>>>0>=h>>>0){break a}e=(g2]=J[b>>1];H[e+4>>2]=0;b=b+2|0;g=g+1|0;e=I[a+24|0];if(g>>>0>>0>>0?e:f)>>>0){continue}break}}if(e>>>0>=f>>>0){break a}d=(e>0>>0?e:f){e=H[a>>2];h=H[e>>2];i=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);j=b;b=b+i|0;b=b+h|0;h=H[e+4>>2];while(1){if(b>>>0>=h>>>0){break a}e=(g2];H[e>>2]=i;H[e+4>>2]=i>>31;b=b+4|0;g=g+1|0;e=I[a+24|0];if(g>>>0>>0>>0?e:f)>>>0){continue}break}}if(e>>>0>=f>>>0){break a}d=(e>0>>0?e:f){e=H[a>>2];h=H[e>>2];i=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);j=b;b=b+i|0;b=b+h|0;h=H[e+4>>2];while(1){if(b>>>0>=h>>>0){break a}e=(g2]=H[b>>2];H[e+4>>2]=0;b=b+4|0;g=g+1|0;e=I[a+24|0];if(g>>>0>>0>>0?e:f)>>>0){continue}break}}if(e>>>0>=f>>>0){break a}d=(e>0>>0?e:f){e=H[a>>2];h=H[e>>2];i=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);j=b;b=b+i|0;b=b+h|0;h=H[e+4>>2];while(1){if(b>>>0>=h>>>0){break a}i=H[b+4>>2];e=(g2]=H[b>>2];H[e+4>>2]=i;b=b+8|0;g=g+1|0;e=I[a+24|0];if(g>>>0>>0>>0?e:f)>>>0){continue}break}}if(e>>>0>=f>>>0){break a}d=(e>0>>0?e:f){e=H[a>>2];h=H[e>>2];i=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);j=b;b=b+i|0;b=b+h|0;h=H[e+4>>2];while(1){if(b>>>0>=h>>>0){break a}e=H[b>>2];i=H[b+4>>2];if((i|0)>2]=i;b=b+8|0;g=g+1|0;e=I[a+24|0];if(g>>>0>>0>>0?e:f)>>>0){continue}break}}if(e>>>0>=f>>>0){break a}d=(e>0>>0?e:f)){break d}if(I[a+32|0]){break a}e=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);j=b;b=b+e|0;e=H[a>>2];i=H[e+4>>2];e=H[e>>2];if((b|0)>=(i-e|0)){break a}g=b+e|0;h=c&255;b=0;while(1){k=L[g>>2];if(k>=O(0x8000000000000000)|k>0>>>0))*O(2.3283064365386963e-10)))))>>>0:0;m=~~k>>>0;break e}j=-2147483648;m=0}H[e>>2]=m;H[e+4>>2]=j;b=b+1|0;e=I[a+24|0];if(b>>>0>=(e>>>0>>0?e:h)>>>0){break d}g=g+4|0;if(i>>>0>g>>>0){continue}break}break a}if(e>>>0>=f>>>0){break a}d=(e>0>>0?e:f)){break f}if(I[a+32|0]){break a}e=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);j=b;b=b+e|0;e=H[a>>2];i=H[e+4>>2];e=H[e>>2];if((b|0)>=(i-e|0)){break a}g=b+e|0;h=c&255;b=0;while(1){l=M[g>>3];if(l>=0x8000000000000000|l>0>>>0))*2.3283064365386963e-10))>>>0:0;m=~~l>>>0;break g}j=-2147483648;m=0}H[e>>2]=m;H[e+4>>2]=j;b=b+1|0;e=I[a+24|0];if(b>>>0>=(e>>>0>>0?e:h)>>>0){break f}g=g+8|0;if(i>>>0>g>>>0){continue}break}break a}if(e>>>0>=f>>>0){break a}d=(e>0>>0?e:f){e=H[a>>2];h=H[e>>2];i=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);j=b;b=b+i|0;b=b+h|0;h=H[e+4>>2];while(1){if(b>>>0>=h>>>0){break a}e=(g2]=I[b|0];H[e+4>>2]=0;b=b+1|0;g=g+1|0;e=I[a+24|0];if(g>>>0>>0>>0?e:f)>>>0){continue}break}}if(e>>>0>=f>>>0){break a}d=(e2]-1|0){case 4:break c;case 5:break d;case 2:break e;case 3:break f;case 0:break g;case 1:break h;default:break a}}f=I[a+24|0];c=pa(f);a=H[j+16>>2];if(H[a+80>>2]){g=H[H[a>>2]>>2]+H[a+48>>2]|0}else{g=0}if(!b){break b}if(f){o=f&252;l=f&3;h=f>>>0>2];F[(a|2)+c|0]=H[k+8>>2];F[(a|3)+c|0]=H[k+12>>2];a=a+4|0;d=d+4|0;e=e+4|0;if((o|0)!=(e|0)){continue}break}}e=0;if(l){while(1){F[a+c|0]=H[g+(d2];a=a+1|0;d=d+1|0;e=e+1|0;if((l|0)!=(e|0)){continue}break}}qa(H[H[H[j+8>>2]+64>>2]>>2]+m|0,c,f);m=f+m|0;n=n+1|0;if((n|0)!=(b|0)){continue}break}break b}a=0;if((b|0)!=1){g=b&-2;while(1){qa(H[H[H[j+8>>2]+64>>2]>>2]+a|0,c,f);a=a+f|0;qa(a+H[H[H[j+8>>2]+64>>2]>>2]|0,c,f);a=a+f|0;d=d+2|0;if((g|0)!=(d|0)){continue}break}}if(!(b&1)){break b}qa(H[H[H[j+8>>2]+64>>2]>>2]+a|0,c,f);break b}f=I[a+24|0];c=pa(f);a=H[j+16>>2];if(H[a+80>>2]){g=H[H[a>>2]>>2]+H[a+48>>2]|0}else{g=0}if(!b){break b}if(f){o=f&252;l=f&3;h=f>>>0>2];F[(a|2)+c|0]=H[k+8>>2];F[(a|3)+c|0]=H[k+12>>2];a=a+4|0;d=d+4|0;e=e+4|0;if((o|0)!=(e|0)){continue}break}}e=0;if(l){while(1){F[a+c|0]=H[g+(d2];a=a+1|0;d=d+1|0;e=e+1|0;if((l|0)!=(e|0)){continue}break}}qa(H[H[H[j+8>>2]+64>>2]>>2]+m|0,c,f);m=f+m|0;n=n+1|0;if((n|0)!=(b|0)){continue}break}break b}a=0;if((b|0)!=1){g=b&-2;while(1){qa(H[H[H[j+8>>2]+64>>2]>>2]+a|0,c,f);a=a+f|0;qa(a+H[H[H[j+8>>2]+64>>2]>>2]|0,c,f);a=a+f|0;d=d+2|0;if((g|0)!=(d|0)){continue}break}}if(!(b&1)){break b}qa(H[H[H[j+8>>2]+64>>2]>>2]+a|0,c,f);break b}h=I[a+24|0];i=h2];if(H[a+80>>2]){g=H[H[a>>2]>>2]+H[a+48>>2]|0}else{g=0}if(!b){break b}if(h){o=h&252;l=h&3;h=h>>>0>1]=H[k+4>>2];G[(f|4)+c>>1]=H[k+8>>2];G[(f|6)+c>>1]=H[k+12>>2];a=a+4|0;d=d+4|0;e=e+4|0;if((o|0)!=(e|0)){continue}break}}e=0;if(l){while(1){G[(a1]=H[g+(d2];a=a+1|0;d=d+1|0;e=e+1|0;if((l|0)!=(e|0)){continue}break}}qa(H[H[H[j+8>>2]+64>>2]>>2]+n|0,c,i);n=i+n|0;m=m+1|0;if((m|0)!=(b|0)){continue}break}break b}a=0;if((b|0)!=1){g=b&-2;while(1){qa(H[H[H[j+8>>2]+64>>2]>>2]+a|0,c,i);a=a+i|0;qa(a+H[H[H[j+8>>2]+64>>2]>>2]|0,c,i);a=a+i|0;d=d+2|0;if((g|0)!=(d|0)){continue}break}}if(!(b&1)){break b}qa(H[H[H[j+8>>2]+64>>2]>>2]+a|0,c,i);break b}h=I[a+24|0];i=h2];if(H[a+80>>2]){g=H[H[a>>2]>>2]+H[a+48>>2]|0}else{g=0}if(!b){break b}if(h){o=h&252;l=h&3;h=h>>>0>1]=H[k+4>>2];G[(f|4)+c>>1]=H[k+8>>2];G[(f|6)+c>>1]=H[k+12>>2];a=a+4|0;d=d+4|0;e=e+4|0;if((o|0)!=(e|0)){continue}break}}e=0;if(l){while(1){G[(a1]=H[g+(d2];a=a+1|0;d=d+1|0;e=e+1|0;if((l|0)!=(e|0)){continue}break}}qa(H[H[H[j+8>>2]+64>>2]>>2]+n|0,c,i);n=i+n|0;m=m+1|0;if((m|0)!=(b|0)){continue}break}break b}a=0;if((b|0)!=1){g=b&-2;while(1){qa(H[H[H[j+8>>2]+64>>2]>>2]+a|0,c,i);a=a+i|0;qa(a+H[H[H[j+8>>2]+64>>2]>>2]|0,c,i);a=a+i|0;d=d+2|0;if((g|0)!=(d|0)){continue}break}}if(!(b&1)){break b}qa(H[H[H[j+8>>2]+64>>2]>>2]+a|0,c,i);break b}h=I[a+24|0];i=h2];if(H[a+80>>2]){g=H[H[a>>2]>>2]+H[a+48>>2]|0}else{g=0}if(!b){break b}if(h){o=h&252;l=h&3;h=h>>>0>2]=H[k+4>>2];H[(f|8)+c>>2]=H[k+8>>2];H[(f|12)+c>>2]=H[k+12>>2];a=a+4|0;d=d+4|0;e=e+4|0;if((o|0)!=(e|0)){continue}break}}e=0;if(l){while(1){H[(a2]=H[g+(d2];a=a+1|0;d=d+1|0;e=e+1|0;if((l|0)!=(e|0)){continue}break}}qa(H[H[H[j+8>>2]+64>>2]>>2]+n|0,c,i);n=i+n|0;m=m+1|0;if((m|0)!=(b|0)){continue}break}break b}a=0;if((b|0)!=1){g=b&-2;while(1){qa(H[H[H[j+8>>2]+64>>2]>>2]+a|0,c,i);a=a+i|0;qa(a+H[H[H[j+8>>2]+64>>2]>>2]|0,c,i);a=a+i|0;d=d+2|0;if((g|0)!=(d|0)){continue}break}}if(!(b&1)){break b}qa(H[H[H[j+8>>2]+64>>2]>>2]+a|0,c,i);break b}h=I[a+24|0];i=h2];if(H[a+80>>2]){g=H[H[a>>2]>>2]+H[a+48>>2]|0}else{g=0}if(!b){break b}if(h){o=h&252;l=h&3;h=h>>>0>2]=H[k+4>>2];H[(f|8)+c>>2]=H[k+8>>2];H[(f|12)+c>>2]=H[k+12>>2];a=a+4|0;d=d+4|0;e=e+4|0;if((o|0)!=(e|0)){continue}break}}e=0;if(l){while(1){H[(a2]=H[g+(d2];a=a+1|0;d=d+1|0;e=e+1|0;if((l|0)!=(e|0)){continue}break}}qa(H[H[H[j+8>>2]+64>>2]>>2]+n|0,c,i);n=i+n|0;m=m+1|0;if((m|0)!=(b|0)){continue}break}break b}a=0;if((b|0)!=1){g=b&-2;while(1){qa(H[H[H[j+8>>2]+64>>2]>>2]+a|0,c,i);a=a+i|0;qa(a+H[H[H[j+8>>2]+64>>2]>>2]|0,c,i);a=a+i|0;d=d+2|0;if((g|0)!=(d|0)){continue}break}}if(!(b&1)){break b}qa(H[H[H[j+8>>2]+64>>2]>>2]+a|0,c,i)}oa(c);c=1}return c|0}function dc(a,b,c,d){var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=O(0);a:{b:{if(!d){break b}c:{switch(H[a+28>>2]-1|0){case 0:e=I[a+24|0];f=c&255;if(e>>>0>>0?e:f){e=H[a>>2];h=H[e>>2];l=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);i=b;b=b+l|0;b=b+h|0;h=H[e+4>>2];while(1){if(b>>>0>=h>>>0){break b}H[(g2]=F[b|0];b=b+1|0;g=g+1|0;e=I[a+24|0];if(g>>>0>>0>>0?e:f)>>>0){continue}break}}k=1;if(e>>>0>=f>>>0){break b}break a;case 1:e=I[a+24|0];f=c&255;if(e>>>0>>0?e:f){e=H[a>>2];h=H[e>>2];l=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);i=b;b=b+l|0;b=b+h|0;h=H[e+4>>2];while(1){if(b>>>0>=h>>>0){break b}H[(g2]=I[b|0];b=b+1|0;g=g+1|0;e=I[a+24|0];if(g>>>0>>0>>0?e:f)>>>0){continue}break}}k=1;if(e>>>0>=f>>>0){break b}break a;case 2:e=I[a+24|0];f=c&255;if(e>>>0>>0?e:f){e=H[a>>2];h=H[e>>2];l=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);i=b;b=b+l|0;b=b+h|0;h=H[e+4>>2];while(1){if(b>>>0>=h>>>0){break b}H[(g2]=G[b>>1];b=b+2|0;g=g+1|0;e=I[a+24|0];if(g>>>0>>0>>0?e:f)>>>0){continue}break}}k=1;if(e>>>0>=f>>>0){break b}break a;case 3:e=I[a+24|0];f=c&255;if(e>>>0>>0?e:f){e=H[a>>2];h=H[e>>2];l=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);i=b;b=b+l|0;b=b+h|0;h=H[e+4>>2];while(1){if(b>>>0>=h>>>0){break b}H[(g2]=J[b>>1];b=b+2|0;g=g+1|0;e=I[a+24|0];if(g>>>0>>0>>0?e:f)>>>0){continue}break}}k=1;if(e>>>0>=f>>>0){break b}break a;case 4:e=I[a+24|0];f=c&255;if(e>>>0>>0?e:f){e=H[a>>2];h=H[e>>2];l=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);i=b;b=b+l|0;b=b+h|0;h=H[e+4>>2];while(1){if(b>>>0>=h>>>0){break b}H[(g2]=H[b>>2];b=b+4|0;g=g+1|0;e=I[a+24|0];if(g>>>0>>0>>0?e:f)>>>0){continue}break}}k=1;if(e>>>0>=f>>>0){break b}break a;case 5:e=I[a+24|0];f=c&255;if(e>>>0>>0?e:f){e=H[a>>2];h=H[e>>2];l=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);i=b;b=b+l|0;b=b+h|0;h=H[e+4>>2];while(1){if(b>>>0>=h>>>0){break b}H[(g2]=H[b>>2];b=b+4|0;g=g+1|0;e=I[a+24|0];if(g>>>0>>0>>0?e:f)>>>0){continue}break}}k=1;if(e>>>0>=f>>>0){break b}break a;case 6:e=I[a+24|0];f=c&255;if(e>>>0>>0?e:f){e=H[a>>2];h=H[e>>2];l=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);i=b;b=b+l|0;b=b+h|0;h=H[e+4>>2];while(1){if(b>>>0>=h>>>0){break b}e=H[b>>2];if(H[b+4>>2]){break b}H[(g2]=e;b=b+8|0;g=g+1|0;e=I[a+24|0];if(g>>>0>>0>>0?e:f)>>>0){continue}break}}k=1;if(e>>>0>=f>>>0){break b}break a;case 7:e=I[a+24|0];f=c&255;if(e>>>0>>0?e:f){e=H[a>>2];h=H[e>>2];l=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);i=b;b=b+l|0;b=b+h|0;h=H[e+4>>2];while(1){if(b>>>0>=h>>>0){break b}e=H[b>>2];if(H[b+4>>2]){break b}H[(g2]=e;b=b+8|0;g=g+1|0;e=I[a+24|0];if(g>>>0>>0>>0?e:f)>>>0){continue}break}}k=1;if(e>>>0>=f>>>0){break b}break a;case 8:d:{e:{e=I[a+24|0];c=c&255;if(!(c>>>0>e>>>0?e:c)){break e}e=H[a>>2];k=H[e>>2];g=k;f=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);i=b;b=b+f|0;g=b+g|0;f=H[e+4>>2];e=f-k|0;if(!I[a+32|0]){k=0;if((b|0)>=(e|0)){break d}b=0;while(1){m=L[g>>2];if(m>=O(4294967296)|m0}else{i=0}H[e>>2]=i;b=b+1|0;e=I[a+24|0];if(b>>>0>=(c>>>0>e>>>0?e:c)>>>0){break e}g=g+4|0;if(f>>>0>g>>>0){continue}break}break d}k=0;if((b|0)>=(e|0)){break d}b=0;while(1){m=L[g>>2];if(m>=O(4294967296)|mO(1)){break d}e=(b>0;break f}i=0}H[e>>2]=i;b=b+1|0;e=I[a+24|0];if(b>>>0>=(c>>>0>e>>>0?e:c)>>>0){break e}g=g+4|0;if(f>>>0>g>>>0){continue}break}break d}k=1;if(c>>>0>>0){break d}ra((ee>>>0?e:c)){break h}e=H[a>>2];k=H[e>>2];g=k;f=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);i=b;b=b+f|0;g=b+g|0;f=H[e+4>>2];e=f-k|0;if(!I[a+32|0]){k=0;if((b|0)>=(e|0)){break g}b=0;while(1){j=M[g>>3];if(j>=4294967295|j0}else{i=0}H[e>>2]=i;b=b+1|0;e=I[a+24|0];if(b>>>0>=(c>>>0>e>>>0?e:c)>>>0){break h}g=g+8|0;if(f>>>0>g>>>0){continue}break}break g}k=0;if((b|0)>=(e|0)){break g}b=0;while(1){j=M[g>>3];if(j>=4294967295|j1){break g}e=(b>0;break i}i=0}H[e>>2]=i;b=b+1|0;e=I[a+24|0];if(b>>>0>=(c>>>0>e>>>0?e:c)>>>0){break h}g=g+8|0;if(f>>>0>g>>>0){continue}break}break g}k=1;if(c>>>0>>0){break g}ra((e>0?e:f){e=H[a>>2];h=H[e>>2];l=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);i=b;b=b+l|0;b=b+h|0;h=H[e+4>>2];while(1){if(b>>>0>=h>>>0){break b}H[(g2]=I[b|0];b=b+1|0;g=g+1|0;e=I[a+24|0];if(g>>>0>>0>>0?e:f)>>>0){continue}break}}k=1;if(e>>>0>=f>>>0){break b}ra((e2]){H[c>>2]=b;H[a+52>>2]=c+4;break f}h=H[a+48>>2];g=c-h|0;d=g>>2;f=d+1|0;if(f>>>0>=1073741824){break a}e=g>>>1|0;g=g>>>0>=2147483644?1073741823:f>>>0>>0?e:f;if(g){if(g>>>0>=1073741824){break d}e=pa(g2]=H[c>>2];if((c|0)!=(h|0)){continue}break}}H[a+56>>2]=e+(g2]=d;H[a+48>>2]=f;if(!h){break f}oa(h)}H[a+84>>2]=0;c=-1;e=-1;g:{if((b|0)==-1){break g}d=H[a+4>>2];e=b+1|0;e=(e>>>0)%3|0?e:b-2|0;if((e|0)!=-1){c=H[H[d>>2]+(e2]}h:{if((b>>>0)%3|0){l=b-1|0;break h}l=b+2|0;e=-1;if((l|0)==-1){break g}}e=H[H[d>>2]+(l2]}i=e>>>3&536870908;d=H[a+36>>2];h=d+(c>>>3&536870908)|0;g=H[h>>2];f=12]=f|g;f=a+8|0;if((b|0)!=-1){d=b+1|0;d=(d>>>0)%3|0?d:b-2|0}else{d=-1}Ua(f,c,d);d=H[a+36>>2]}f=d+i|0;d=H[f>>2];c=12]=c|d;d=a+8|0;c=-1;i:{if((b|0)==-1){break i}c=b-1|0;if((b>>>0)%3|0){break i}c=b+2|0}Ua(d,e,c)}c=-1;c=(b|0)!=-1?H[H[H[a+4>>2]>>2]+(b2]:c;f=H[a+36>>2]+(c>>>3&536870908)|0;d=H[f>>2];e=12]=d|e;Ua(a+8|0,c,b)}d=H[a+84>>2];if((d|0)>2){break e}while(1){e=N(d,12)+a|0;b=H[e+52>>2];if((b|0)==H[e+48>>2]){d=d+1|0;if((d|0)!=3){continue}break e}b=b-4|0;c=H[b>>2];H[e+52>>2]=b;H[a+84>>2]=d;if((c|0)==-1){break e}f=H[a+24>>2];b=(c>>>0)/3|0;j:{if(H[f+(b>>>3&268435452)>>2]>>>b&1){break j}k:{while(1){k=(c>>>0)/3|0;b=(k>>>3&268435452)+f|0;H[b>>2]=H[b>>2]|12]>>2]+(c2]:d;f=H[a+36>>2]+(d>>>3&536870908)|0;e=H[f>>2];b=12]=b|e;i=H[(H[H[a+16>>2]+96>>2]+N(k,12)|0)+((c>>>0)%32];l=H[H[a+20>>2]+4>>2];f=H[l+4>>2];t:{if((f|0)!=H[l+8>>2]){H[f>>2]=i;H[l+4>>2]=f+4;break t}j=H[l>>2];h=f-j|0;g=h>>2;e=g+1|0;if(e>>>0>=1073741824){break s}b=h>>>1|0;h=h>>>0>=2147483644?1073741823:b>>>0>e>>>0?b:e;if(h){if(h>>>0>=1073741824){break d}e=pa(h2]=H[f>>2];if((f|0)!=(j|0)){continue}break}}H[l+8>>2]=e+(h2]=g;H[l>>2]=b;if(!j){break t}oa(j)}j=H[a+12>>2];f=H[j+4>>2];u:{if((f|0)!=H[j+8>>2]){H[f>>2]=c;H[j+4>>2]=f+4;break u}i=H[j>>2];h=f-i|0;g=h>>2;e=g+1|0;if(e>>>0>=1073741824){break r}b=h>>>1|0;h=h>>>0>=2147483644?1073741823:b>>>0>e>>>0?b:e;if(h){if(h>>>0>=1073741824){break d}e=pa(h2]=H[f>>2];if((f|0)!=(i|0)){continue}break}}H[j+8>>2]=e+(h2]=g;H[j>>2]=b;if(!i){break u}oa(i)}b=H[a+12>>2];H[H[b+12>>2]+(d2]=H[b+24>>2];H[b+24>>2]=H[b+24>>2]+1}if((c|0)==-1){break k}g=H[a+4>>2];f=-1;b=c+1|0;b=(b>>>0)%3|0?b:c-2|0;if((b|0)!=-1){f=H[H[g+12>>2]+(b2]}v:{w:{if((N(k,3)|0)!=(c|0)){d=c-1|0;break w}d=c+2|0;c=-1;if((d|0)==-1){break v}}c=H[H[g+12>>2]+(d2]}d=(c|0)==-1;e=(c>>>0)/3|0;if((f|0)!=-1){b=(f>>>0)/3|0;b=H[H[a+24>>2]+(b>>>3&268435452)>>2]&12]+(b>>>3&536870908)>>2]>>>b&1){break x}k=0;b=H[H[g>>2]+(c2];if(!(H[H[a+36>>2]+(b>>>3&536870908)>>2]>>>b&1)){b=H[a+88>>2]+(b2];H[b>>2]=e+1;k=(e|0)>2]>=(k|0)&l){break m}j=N(k,12)+a|0;b=H[j+52>>2];y:{if((b|0)!=H[j+56>>2]){H[b>>2]=c;H[j+52>>2]=b+4;break y}i=H[j+48>>2];h=b-i|0;d=h>>2;g=d+1|0;if(g>>>0>=1073741824){break c}e=h>>>1|0;g=h>>>0>=2147483644?1073741823:e>>>0>g>>>0?e:g;if(g){if(g>>>0>=1073741824){break d}e=pa(g2]=H[b>>2];if((b|0)!=(i|0)){continue}break}}H[j+48>>2]=d;H[j+52>>2]=c;H[j+56>>2]=e+(g2]>2]=k}if(l){break k}c=-1;if((f|0)==-1){break n}}c=H[H[H[a+4>>2]>>2]+(f2]}b=0;if(!(H[H[a+36>>2]+(c>>>3&536870908)>>2]>>>c&1)){b=H[a+88>>2]+(c2];H[b>>2]=c+1;b=(c|0)>2]>2];continue}break}k=N(b,12)+a|0;c=H[k+52>>2];z:{if((c|0)!=H[k+56>>2]){H[c>>2]=f;H[k+52>>2]=c+4;break z}i=H[k+48>>2];h=c-i|0;d=h>>2;g=d+1|0;if(g>>>0>=1073741824){break b}e=h>>>1|0;g=h>>>0>=2147483644?1073741823:e>>>0>g>>>0?e:g;if(g){if(g>>>0>=1073741824){break d}e=pa(g2]=H[c>>2];if((c|0)!=(i|0)){continue}break}}H[k+48>>2]=d;H[k+52>>2]=f;H[k+56>>2]=e+(g2];if((d|0)>2]=b;d=b;break j}d=H[a+84>>2]}if((d|0)>2];d=H[o+32>>2];i=H[d+8>>2];j=H[d+12>>2];e=j;c=H[d+20>>2];f=H[d+16>>2];a:{if((e|0)>>0>=i>>>0|(c|0)>(e|0)){break a}p=H[d>>2];g=I[p+f|0];h=f+1|0;e=h?c:c+1|0;H[d+16>>2]=h;H[d+20>>2]=e;if((e|0)>=(j|0)&h>>>0>=i>>>0|(e|0)>(j|0)){break a}m=I[h+p|0];h=f+2|0;e=h>>>0>2]=h;H[d+20>>2]=e;l=g24;b:{if((l|0)>=0){k=H[a+216>>2];if(g>>>0>=(H[a+220>>2]-k|0)/144>>>0){break a}k=k+N(g,144)|0;if(H[k>>2]>2]>=0){break a}k=a+212|0}H[k>>2]=b;c:{d:{e:{f:{g:{h:{k=J[o+36>>1];i:{if(((k>8)&65535)>>>0>=258){if((e|0)>=(j|0)&h>>>0>=i>>>0|(e|0)>(j|0)){break a}e=I[h+p|0];f=f+3|0;c=f>>>0>2]=f;H[d+20>>2]=c;if(e>>>0>1){break a}d=e>>>02]+N(g,144)|0;F[c+100|0]=0;e=c+104|0}if((d|0)!=1){break e}c=ca-112|0;ca=c;h=H[H[a+4>>2]+44>>2];d=pa(120);H[d>>2]=12172;H[d+4>>2]=0;H[d+116>>2]=0;H[d+112>>2]=e;H[d+108>>2]=h;H[d+12>>2]=0;H[d+16>>2]=0;H[d+20>>2]=0;H[d+24>>2]=0;H[d+28>>2]=0;H[d+32>>2]=0;H[d+36>>2]=0;H[d+40>>2]=0;H[d+44>>2]=0;H[d+48>>2]=0;H[d+52>>2]=0;H[d+56>>2]=0;H[d+60>>2]=0;H[d+8>>2]=12384;f=d- -64|0;H[f>>2]=0;H[f+4>>2]=0;H[d+72>>2]=0;H[d+76>>2]=0;H[d+80>>2]=0;H[d+84>>2]=0;H[d+88>>2]=0;H[d+104>>2]=0;H[d+96>>2]=0;H[d+100>>2]=0;f=H[a+8>>2];H[c+48>>2]=0;H[c+52>>2]=0;H[c+40>>2]=0;H[c+44>>2]=0;i=c+32|0;H[i>>2]=0;H[i+4>>2]=0;H[c+24>>2]=0;H[c+28>>2]=0;g=c- -64|0;H[g>>2]=0;H[g+4>>2]=0;H[c+72>>2]=0;H[c+76>>2]=0;H[c+80>>2]=0;H[c+84>>2]=0;H[c+88>>2]=0;H[c+104>>2]=0;H[c+16>>2]=0;H[c+20>>2]=0;H[c+56>>2]=0;H[c+60>>2]=0;H[c+8>>2]=12384;H[c+96>>2]=0;H[c+100>>2]=0;H[c+12>>2]=f;g=H[f>>2];j=H[f+4>>2];F[c+111|0]=0;m=i;i=c+111|0;Oa(m,(j-g>>2>>>0)/3|0,i);g=H[c+12>>2];j=H[g+28>>2];g=H[g+24>>2];F[c+111|0]=0;Oa(c+44|0,j-g>>2,i);H[c+28>>2]=d;H[c+24>>2]=h;H[c+20>>2]=e;H[c+16>>2]=f;f=d+8|0;e=c+8|0;fd(f,e);j:{if((e|0)==(f|0)){H[d+92>>2]=H[e+84>>2];break j}Cb(d+56|0,H[e+48>>2],H[e+52>>2]);Cb(d+68|0,H[e+60>>2],H[e- -64>>2]);Cb(d+80|0,H[e+72>>2],H[e+76>>2]);H[d+92>>2]=H[e+84>>2];Aa(d+96|0,H[e+88>>2],H[e+92>>2])}H[c+8>>2]=12384;e=H[c+96>>2];if(e){H[c+100>>2]=e;oa(e)}e=H[c+80>>2];if(e){H[c+84>>2]=e;oa(e)}e=H[c+68>>2];if(e){H[c+72>>2]=e;oa(e)}e=H[c+56>>2];if(e){H[c+60>>2]=e;oa(e)}H[c+8>>2]=12620;e=H[c+44>>2];if(e){oa(e)}e=H[c+32>>2];if(e){oa(e)}ca=c+112|0;break d}if((l|0)>=0){break f}break a}if((l|0)>2];c=H[o+44>>2];d=pa(80);H[d>>2]=12932;H[d+4>>2]=0;H[d+76>>2]=0;H[d+68>>2]=c;H[d+8>>2]=11872;H[d+12>>2]=0;H[d+16>>2]=0;H[d+20>>2]=0;H[d+24>>2]=0;H[d+28>>2]=0;H[d+32>>2]=0;H[d+36>>2]=0;H[d+40>>2]=0;H[d+44>>2]=0;H[d+48>>2]=0;H[d+52>>2]=0;e=e+N(g,144)|0;f=e+104|0;H[d+72>>2]=f;H[d- -64>>2]=0;H[d+56>>2]=0;H[d+60>>2]=0;H[n+24>>2]=c;c=n;H[c+68>>2]=0;H[c+72>>2]=0;H[c+60>>2]=0;H[c+64>>2]=0;H[c+52>>2]=0;H[c+56>>2]=0;H[c+44>>2]=0;H[c+48>>2]=0;H[c+84>>2]=0;H[c+88>>2]=0;H[c+76>>2]=0;H[c+80>>2]=0;H[c+28>>2]=d;h=H[c+28>>2];H[c+8>>2]=H[c+24>>2];H[c+12>>2]=h;H[c+20>>2]=f;f=e+4|0;H[c+16>>2]=f;H[c+36>>2]=0;H[c+40>>2]=0;H[c+32>>2]=11872;e=H[c+20>>2];H[c>>2]=H[c+16>>2];H[c+4>>2]=e;e=c+32|0;Ie(e,f,c);c=d+8|0;fd(c,e);if((c|0)!=(e|0)){Cb(d+56|0,H[e+48>>2],H[e+52>>2])}He(e);break c}c=ca+-64|0;ca=c;h=H[H[a+4>>2]+44>>2];d=pa(80);H[d>>2]=12640;H[d+4>>2]=0;H[d+76>>2]=0;H[d+72>>2]=e;H[d+68>>2]=h;H[d+8>>2]=12804;H[d+12>>2]=0;H[d+16>>2]=0;H[d+20>>2]=0;H[d+24>>2]=0;H[d+28>>2]=0;H[d+32>>2]=0;H[d+36>>2]=0;H[d+40>>2]=0;H[d+44>>2]=0;H[d+48>>2]=0;H[d+52>>2]=0;H[d- -64>>2]=0;i=d+56|0;f=i;H[f>>2]=0;H[f+4>>2]=0;f=H[a+8>>2];H[c+40>>2]=0;H[c+44>>2]=0;H[c+32>>2]=0;H[c+36>>2]=0;g=c+24|0;H[g>>2]=0;H[g+4>>2]=0;H[c+16>>2]=0;H[c+20>>2]=0;H[c+56>>2]=0;H[c+8>>2]=0;H[c+12>>2]=0;H[c+48>>2]=0;H[c+52>>2]=0;H[c>>2]=12804;H[c+4>>2]=f;j=H[f>>2];l=H[f+4>>2];F[c+63|0]=0;m=g;g=c+63|0;Oa(m,(l-j>>2>>>0)/3|0,g);j=H[c+4>>2];l=H[j+28>>2];j=H[j+24>>2];F[c+63|0]=0;Oa(c+36|0,l-j>>2,g);H[c+20>>2]=d;H[c+16>>2]=h;H[c+12>>2]=e;H[c+8>>2]=f;fd(d+8|0,c);Cb(i,H[c+48>>2],H[c+52>>2]);H[c>>2]=12804;e=H[c+48>>2];if(e){H[c+52>>2]=e;oa(e)}H[c>>2]=12620;e=H[c+36>>2];if(e){oa(e)}e=H[c+24>>2];if(e){oa(e)}ca=c- -64|0}if(!d){break a}}d=od(pa(64),d);c=H[a+4>>2];a=d;d=b;k:{l:{if((d|0)>=0){h=c+8|0;b=H[c+12>>2];i=H[c+8>>2];e=b-i>>2;m:{if((e|0)>(d|0)){break m}f=d+1|0;if(d>>>0>=e>>>0){Vb(h,f-e|0);break m}if(e>>>0>>0){break m}f=i+(f2];H[b>>2]=0;if(e){ea[H[H[e>>2]+4>>2]](e)}if((b|0)!=(f|0)){continue}break}}H[c+12>>2]=f}c=H[h>>2]+(d2];H[c>>2]=a;if(b){break l}break k}b=a;if(!a){break k}}ea[H[H[b>>2]+4>>2]](b)}q=(d^-1)>>>31|0}ca=n+96|0;return q|0}function Kd(a){var b=0,c=0,d=0,e=0,f=0,g=0;e=ca-16|0;ca=e;H[e+12>>2]=a;a:{if(a>>>0>2];break a}if(a>>>0>=4294967292){X();v()}f=(a>>>0)/210|0;d=N(f,210);H[e+8>>2]=a-d;g=Jd(14448,14640,e+8|0)-14448>>2;while(1){d=H[(g2]+d|0;a=5;while(1){b:{if((a|0)==47){a=211;while(1){b=(d>>>0)/(a>>>0)|0;if(b>>>0>>0){break a}if((N(a,b)|0)==(d|0)){break b}b=a+10|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((N(b,c)|0)==(d|0)){break b}b=a+12|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((N(b,c)|0)==(d|0)){break b}b=a+16|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((N(b,c)|0)==(d|0)){break b}b=a+18|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((N(b,c)|0)==(d|0)){break b}b=a+22|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((N(b,c)|0)==(d|0)){break b}b=a+28|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((N(b,c)|0)==(d|0)){break b}b=a+30|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((N(b,c)|0)==(d|0)){break b}b=a+36|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((N(b,c)|0)==(d|0)){break b}b=a+40|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((N(b,c)|0)==(d|0)){break b}b=a+42|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((N(b,c)|0)==(d|0)){break b}b=a+46|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((N(b,c)|0)==(d|0)){break b}b=a+52|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((N(b,c)|0)==(d|0)){break b}b=a+58|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((N(b,c)|0)==(d|0)){break b}b=a+60|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((N(b,c)|0)==(d|0)){break b}b=a+66|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((N(b,c)|0)==(d|0)){break b}b=a+70|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((N(b,c)|0)==(d|0)){break b}b=a+72|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((N(b,c)|0)==(d|0)){break b}b=a+78|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((N(b,c)|0)==(d|0)){break b}b=a+82|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((N(b,c)|0)==(d|0)){break b}b=a+88|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((N(b,c)|0)==(d|0)){break b}b=a+96|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((N(b,c)|0)==(d|0)){break b}b=a+100|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((N(b,c)|0)==(d|0)){break b}b=a+102|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((N(b,c)|0)==(d|0)){break b}b=a+106|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((N(b,c)|0)==(d|0)){break b}b=a+108|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((N(b,c)|0)==(d|0)){break b}b=a+112|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((N(b,c)|0)==(d|0)){break b}b=a+120|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((N(b,c)|0)==(d|0)){break b}b=a+126|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((N(b,c)|0)==(d|0)){break b}b=a+130|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((N(b,c)|0)==(d|0)){break b}b=a+136|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((N(b,c)|0)==(d|0)){break b}b=a+138|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((N(b,c)|0)==(d|0)){break b}b=a+142|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((N(b,c)|0)==(d|0)){break b}b=a+148|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((N(b,c)|0)==(d|0)){break b}b=a+150|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((N(b,c)|0)==(d|0)){break b}b=a+156|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((N(b,c)|0)==(d|0)){break b}b=a+162|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((N(b,c)|0)==(d|0)){break b}b=a+166|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((N(b,c)|0)==(d|0)){break b}b=a+168|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((N(b,c)|0)==(d|0)){break b}b=a+172|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((N(b,c)|0)==(d|0)){break b}b=a+178|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((N(b,c)|0)==(d|0)){break b}b=a+180|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((N(b,c)|0)==(d|0)){break b}b=a+186|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((N(b,c)|0)==(d|0)){break b}b=a+190|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((N(b,c)|0)==(d|0)){break b}b=a+192|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((N(b,c)|0)==(d|0)){break b}b=a+196|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((N(b,c)|0)==(d|0)){break b}b=a+198|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((N(b,c)|0)==(d|0)){break b}b=a+208|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}a=a+210|0;if((N(b,c)|0)!=(d|0)){continue}break}break b}b=H[(a2];c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}a=a+1|0;if((N(b,c)|0)!=(d|0)){continue}}break}d=g+1|0;a=(d|0)==48;g=a?0:d;f=a+f|0;d=N(f,210);continue}}ca=e+16|0;return d}function Ib(a,b){var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0;j=ca-16|0;ca=j;a:{b:{c:{d:{if(I[H[a+4>>2]+36|0]>2];d=H[b+16>>2];e=d+4|0;c=e>>>0>2];if(K[b+8>>2]>>0&(g|0)(g|0)){break c}d=d+H[b>>2]|0;l=I[d|0]|I[d+1|0]2]=c;break d}k=-1;if(!Ea(1,j+12|0,b)){break c}l=H[j+12>>2]}e:{f:{g:{h:{i:{if(!l){break i}c=H[a+8>>2];if((H[c+4>>2]-H[c>>2]>>2>>>0)/3>>>0>>0){break c}c=J[H[a+4>>2]+36>>1];if(((c>8)&65535)>>>0>=258){j:{while(1){if(!Ea(1,j+8|0,b)){break c}c=H[j+8>>2];if(!Ea(1,j+8|0,b)){break c}f=c+f|0;c=H[j+8>>2];if(f>>>0>>0){break c}g=f-c|0;c=H[a+40>>2];k:{if((c|0)!=H[a+44>>2]){H[c+4>>2]=f;H[c>>2]=g;H[a+40>>2]=c+12;l=H[j+12>>2];break k}m=H[a+36>>2];d=c-m|0;o=(d|0)/12|0;e=o+1|0;if(e>>>0>=357913942){break j}c=o>0>=178956970?357913941:c>>>0>e>>>0?c:e;if(h){if(h>>>0>=357913942){break b}i=pa(N(h,12))}else{i=0}e=i+N(o,12)|0;H[e+4>>2]=f;H[e>>2]=g;c=va(e+N((d|0)/-12|0,12)|0,m,d);H[a+44>>2]=i+N(h,12);H[a+40>>2]=e+12;H[a+36>>2]=c;if(!m){break k}oa(m)}p=p+1|0;if(l>>>0>p>>>0){continue}break}k=0;Db(b,0,0);if(l){while(1){e=I[b+36|0];c=J[H[a+4>>2]+36>>1];l:{m:{if(((c>8)&65535)>>>0>2];n=c>>>3|0;g=H[b+24>>2];e=n+g|0;d=H[b+28>>2];n:{if(e>>>0>=d>>>0){f=c;break n}e=I[e|0];f=c+1|0;H[b+32>>2]=f;n=f>>>3|0;p=e>>>(c&7)&1}if(d>>>0>g+n>>>0){break m}break l}if(!e){break l}p=0;f=H[b+32>>2];c=H[b+24>>2]+(f>>>3|0)|0;if(c>>>0>=K[b+28>>2]){break l}p=I[c|0]>>>(f&7)&1}H[b+32>>2]=f+1}c=H[a+36>>2]+N(k,12)|0;F[c+8|0]=I[c+8|0]&254|p&1;k=k+1|0;if((k|0)!=(l|0)){continue}break}}F[b+36|0]=0;f=H[b+20>>2];e=0;d=H[b+32>>2]+7|0;e=d>>>0>>3|0;e=(e&7)>3;d=e+H[b+16>>2]|0;c=c+f|0;H[b+16>>2]=d;H[b+20>>2]=d>>>0>>0?c+1|0:c;break i}sa();v()}while(1){d=H[b+8>>2];c=H[b+12>>2];g=c;c=H[b+20>>2];e=c;h=H[b+16>>2];f=h+4|0;c=f>>>0>>0>d>>>0&(c|0)>=(g|0)|(c|0)>(g|0)){break c}m=H[b>>2];f=m+h|0;o=I[f|0]|I[f+1|0]>0>>0>>0&(c|0)>=(g|0)|(c|0)>(g|0)){break c}i=i+m|0;i=I[i|0]|I[i+1|0]>0>>0&(c|0)>=(g|0)|(c|0)>(g|0)){break c}d=I[f+m|0];c=h+9|0;e=c>>>0>2]=c;H[b+20>>2]=e;f=d&1;c=H[a+40>>2];o:{if((c|0)!=H[a+44>>2]){F[c+8|0]=f;H[c+4>>2]=i;H[c>>2]=o;H[a+40>>2]=c+12;l=H[j+12>>2];break o}m=H[a+36>>2];d=c-m|0;h=(d|0)/12|0;e=h+1|0;if(e>>>0>=357913942){break h}c=h>0>=178956970?357913941:c>>>0>e>>>0?c:e;if(g){if(g>>>0>=357913942){break b}e=pa(N(g,12))}else{e=0}h=e+N(h,12)|0;F[h+8|0]=f;H[h+4>>2]=i;H[h>>2]=o;c=va(h+N((d|0)/-12|0,12)|0,m,d);H[a+44>>2]=e+N(g,12);H[a+40>>2]=h+12;H[a+36>>2]=c;if(!m){break o}oa(m)}n=n+1|0;if(l>>>0>n>>>0){continue}break}}H[j+8>>2]=0;c=J[H[a+4>>2]+36>>1];c=(c>8)&65535;p:{if(c>>>0>2];d=H[b+16>>2];e=d+4|0;c=e>>>0>2];if(K[b+8>>2]>>0&(f|0)(f|0)){break c}d=d+H[b>>2]|0;f=I[d|0]|I[d+1|0]2]}if(!f){break e}c=J[H[a+4>>2]+36>>1];if(((c>8)&65535)>>>0>2]+l|0;c=H[a+52>>2];q:{if((c|0)!=H[a+56>>2]){H[c>>2]=l;H[a+52>>2]=c+4;break q}i=H[a+48>>2];g=c-i|0;e=g>>2;d=e+1|0;if(d>>>0>=1073741824){break g}c=g>>>1|0;d=g>>>0>=2147483644?1073741823:c>>>0>d>>>0?c:d;if(d){if(d>>>0>=1073741824){break b}c=pa(d2]=c+(d2]=e+4;H[a+48>>2]=c;if(!i){break q}oa(i)}n=n+1|0;if((n|0)!=(f|0)){continue}break}break e}sa();v()}sa();v()}k=0;while(1){c=H[b+20>>2];d=H[b+16>>2];e=d+4|0;c=e>>>0>2];if(K[b+8>>2]>>0&(g|0)(g|0)){k=-1;break c}d=d+H[b>>2]|0;g=I[d|0]|I[d+1|0]2];r:{if((c|0)!=H[a+56>>2]){H[c>>2]=g;H[a+52>>2]=c+4;break r}h=H[a+48>>2];i=c-h|0;e=i>>2;d=e+1|0;if(d>>>0>=1073741824){break a}c=i>>>1|0;d=i>>>0>=2147483644?1073741823:c>>>0>d>>>0?c:d;if(d){if(d>>>0>=1073741824){break b}c=pa(d2]=c+(d2]=e+4;H[a+48>>2]=c;if(!h){break r}oa(h)}k=k+1|0;if((k|0)!=(f|0)){continue}break}}k=H[b+16>>2]}ca=j+16|0;return k}wa();v()}sa();v()}function Va(a,b,c,d){var e=0,f=0,g=0,h=0,i=0,j=O(0),k=0,l=0;a:{if(!d){break a}b:{c:{switch(H[a+28>>2]-1|0){case 0:e=I[a+24|0];f=c&255;if(e>>>0>>0?e:f){e=H[a>>2];g=H[e>>2];i=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);k=b;b=b+i|0;b=b+g|0;g=H[e+4>>2];i=I[a+32|0];while(1){if(b>>>0>=g>>>0){break a}j=O(F[b|0]);L[(h2]=i?O(j/O(127)):j;b=b+1|0;h=h+1|0;e=I[a+24|0];if(h>>>0>>0>>0?e:f)>>>0){continue}break}}l=1;if(e>>>0>=f>>>0){break a}d=(e>0>>0?e:f){e=H[a>>2];g=H[e>>2];i=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);k=b;b=b+i|0;b=b+g|0;g=H[e+4>>2];i=I[a+32|0];while(1){if(b>>>0>=g>>>0){break a}j=O(I[b|0]);L[(h2]=i?O(j/O(255)):j;b=b+1|0;h=h+1|0;e=I[a+24|0];if(h>>>0>>0>>0?e:f)>>>0){continue}break}}l=1;if(e>>>0>=f>>>0){break a}d=(e>0>>0?e:f){e=H[a>>2];g=H[e>>2];i=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);k=b;b=b+i|0;b=b+g|0;g=H[e+4>>2];i=I[a+32|0];while(1){if(b>>>0>=g>>>0){break a}j=O(G[b>>1]);L[(h2]=i?O(j/O(32767)):j;b=b+2|0;h=h+1|0;e=I[a+24|0];if(h>>>0>>0>>0?e:f)>>>0){continue}break}}l=1;if(e>>>0>=f>>>0){break a}d=(e>0>>0?e:f){e=H[a>>2];g=H[e>>2];i=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);k=b;b=b+i|0;b=b+g|0;g=H[e+4>>2];i=I[a+32|0];while(1){if(b>>>0>=g>>>0){break a}j=O(J[b>>1]);L[(h2]=i?O(j/O(65535)):j;b=b+2|0;h=h+1|0;e=I[a+24|0];if(h>>>0>>0>>0?e:f)>>>0){continue}break}}l=1;if(e>>>0>=f>>>0){break a}d=(e>0>>0?e:f){e=H[a>>2];g=H[e>>2];i=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);k=b;b=b+i|0;b=b+g|0;g=H[e+4>>2];i=I[a+32|0];while(1){if(b>>>0>=g>>>0){break a}j=O(H[b>>2]);L[(h2]=i?O(j*O(4.656612873077393e-10)):j;b=b+4|0;h=h+1|0;e=I[a+24|0];if(h>>>0>>0>>0?e:f)>>>0){continue}break}}l=1;if(e>>>0>=f>>>0){break a}d=(e>0>>0?e:f){e=H[a>>2];g=H[e>>2];i=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);k=b;b=b+i|0;b=b+g|0;g=H[e+4>>2];i=I[a+32|0];while(1){if(b>>>0>=g>>>0){break a}j=O(K[b>>2]);L[(h2]=i?O(j*O(2.3283064365386963e-10)):j;b=b+4|0;h=h+1|0;e=I[a+24|0];if(h>>>0>>0>>0?e:f)>>>0){continue}break}}l=1;if(e>>>0>=f>>>0){break a}d=(e>0>>0?e:f){e=H[a>>2];g=H[e>>2];i=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);k=b;b=b+i|0;b=b+g|0;g=H[e+4>>2];i=I[a+32|0];while(1){if(b>>>0>=g>>>0){break a}j=O(+K[b>>2]+ +H[b+4>>2]*4294967296);L[(h2]=i?O(j*O(10842021724855044e-35)):j;b=b+8|0;h=h+1|0;e=I[a+24|0];if(h>>>0>>0>>0?e:f)>>>0){continue}break}}l=1;if(e>>>0>=f>>>0){break a}d=(e>0>>0?e:f){e=H[a>>2];g=H[e>>2];i=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);k=b;b=b+i|0;b=b+g|0;g=H[e+4>>2];i=I[a+32|0];while(1){if(b>>>0>=g>>>0){break a}j=O(+K[b>>2]+ +K[b+4>>2]*4294967296);L[(h2]=i?O(j*O(5.421010862427522e-20)):j;b=b+8|0;h=h+1|0;e=I[a+24|0];if(h>>>0>>0>>0?e:f)>>>0){continue}break}}l=1;if(e>>>0>=f>>>0){break a}d=(e>0>>0?e:f){e=H[a>>2];g=H[e>>2];i=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);k=b;b=b+i|0;b=b+g|0;g=H[e+4>>2];while(1){if(b>>>0>=g>>>0){break a}L[(h2]=L[b>>2];b=b+4|0;h=h+1|0;e=I[a+24|0];if(h>>>0>>0>>0?e:f)>>>0){continue}break}}l=1;if(e>>>0>=f>>>0){break a}d=(e>0>>0?e:f){e=H[a>>2];g=H[e>>2];i=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);k=b;b=b+i|0;b=b+g|0;g=H[e+4>>2];while(1){if(b>>>0>=g>>>0){break a}L[(h2]=M[b>>3];b=b+8|0;h=h+1|0;e=I[a+24|0];if(h>>>0>>0>>0?e:f)>>>0){continue}break}}l=1;if(e>>>0>=f>>>0){break a}d=(e>0>>0?e:f){e=H[a>>2];g=H[e>>2];i=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);k=b;b=b+i|0;b=b+g|0;g=H[e+4>>2];while(1){if(b>>>0>=g>>>0){break a}L[(h2]=I[b|0]?O(1):O(0);b=b+1|0;h=h+1|0;e=I[a+24|0];if(h>>>0>>0>>0?e:f)>>>0){continue}break}}l=1;if(e>>>0>=f>>>0){break a}d=(e>0>>0?e:f){e=H[H[a>>2]>>2];i=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);h=b;b=b+i|0;b=b+e|0;while(1){if(K[H[a>>2]+4>>2]>>0){break b}F[d+g|0]=I[b|0];b=b+1|0;g=g+1|0;e=I[a+24|0];if(g>>>0>>0>>0?e:f)>>>0){continue}break}}k=1;if(e>>>0>=f>>>0){break b}break a;case 1:e=I[a+24|0];f=c&255;if(e>>>0>>0?e:f){e=H[H[a>>2]>>2];i=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);h=b;b=b+i|0;b=b+e|0;while(1){if(K[H[a>>2]+4>>2]>>0){return 0}e=F[b|0];if((e|0)>>0>>0>>0?e:f)>>>0){continue}break}}k=1;if(e>>>0>=f>>>0){break b}break a;case 2:e=I[a+24|0];f=c&255;if(e>>>0>>0?e:f){e=H[H[a>>2]>>2];i=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);h=b;b=b+i|0;b=b+e|0;while(1){if(K[H[a>>2]+4>>2]>>0){break b}e=J[b>>1];if((e+128&65535)>>>0>255){break b}F[d+g|0]=e;b=b+2|0;g=g+1|0;e=I[a+24|0];if(g>>>0>>0>>0?e:f)>>>0){continue}break}}k=1;if(e>>>0>=f>>>0){break b}break a;case 3:e=I[a+24|0];f=c&255;if(e>>>0>>0?e:f){e=H[H[a>>2]>>2];i=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);h=b;b=b+i|0;b=b+e|0;while(1){if(K[H[a>>2]+4>>2]>>0){break b}e=J[b>>1];if(e>>>0>127){break b}F[d+g|0]=e;b=b+2|0;g=g+1|0;e=I[a+24|0];if(g>>>0>>0>>0?e:f)>>>0){continue}break}}k=1;if(e>>>0>=f>>>0){break b}break a;case 4:e=I[a+24|0];f=c&255;if(e>>>0>>0?e:f){e=H[H[a>>2]>>2];i=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);h=b;b=b+i|0;b=b+e|0;while(1){if(K[H[a>>2]+4>>2]>>0){break b}e=H[b>>2];if(e+128>>>0>255){break b}F[d+g|0]=e;b=b+4|0;g=g+1|0;e=I[a+24|0];if(g>>>0>>0>>0?e:f)>>>0){continue}break}}k=1;if(e>>>0>=f>>>0){break b}break a;case 5:e=I[a+24|0];f=c&255;if(e>>>0>>0?e:f){e=H[H[a>>2]>>2];i=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);h=b;b=b+i|0;b=b+e|0;while(1){if(K[H[a>>2]+4>>2]>>0){break b}e=H[b>>2];if(e>>>0>127){break b}F[d+g|0]=e;b=b+4|0;g=g+1|0;e=I[a+24|0];if(g>>>0>>0>>0?e:f)>>>0){continue}break}}k=1;if(e>>>0>=f>>>0){break b}break a;case 6:e=I[a+24|0];f=c&255;if(e>>>0>>0?e:f){e=H[H[a>>2]>>2];i=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);h=b;b=b+i|0;b=b+e|0;while(1){if(K[H[a>>2]+4>>2]>>0){break b}i=H[b+4>>2];e=H[b>>2];h=e+128|0;i=h>>>0>>0>255|i){break b}F[d+g|0]=e;b=b+8|0;g=g+1|0;e=I[a+24|0];if(g>>>0>>0>>0?e:f)>>>0){continue}break}}k=1;if(e>>>0>=f>>>0){break b}break a;case 7:e=I[a+24|0];f=c&255;if(e>>>0>>0?e:f){e=H[H[a>>2]>>2];i=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);h=b;b=b+i|0;b=b+e|0;while(1){if(K[H[a>>2]+4>>2]>>0){break b}i=H[b+4>>2];e=H[b>>2];if(!i&e>>>0>127|i){break b}F[d+g|0]=e;b=b+8|0;g=g+1|0;e=I[a+24|0];if(g>>>0>>0>>0?e:f)>>>0){continue}break}}k=1;if(e>>>0>=f>>>0){break b}break a;case 8:e=I[a+24|0];c=c&255;d:{if(c>>>0>e>>>0?e:c){e=H[H[a>>2]>>2];f=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);h=b;b=b+f|0;b=b+e|0;while(1){if(K[H[a>>2]+4>>2]>>0){break d}l=L[b>>2];if(l>=O(127)|l0>>0>e>>>0?e:c)>>>0){continue}break}}k=1;if(c>>>0>>0){break d}ra(d+e|0,0,c-e|0)}return k;case 9:e=I[a+24|0];f=c&255;if(e>>>0>>0?e:f){e=H[H[a>>2]>>2];i=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);h=b;b=b+i|0;b=b+e|0;while(1){if(K[H[a>>2]+4>>2]>>0){break b}j=M[b>>3];if(j>=127|j>0>>0>>0?e:f)>>>0){continue}break}}k=1;if(e>>>0>=f>>>0){break b}break a;case 10:break c;default:break b}}e=I[a+24|0];f=c&255;if(e>>>0>>0?e:f){e=H[H[a>>2]>>2];i=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);h=b;b=b+i|0;b=b+e|0;while(1){if(K[H[a>>2]+4>>2]>>0){break b}F[d+g|0]=I[b|0];b=b+1|0;g=g+1|0;e=I[a+24|0];if(g>>>0>>0>>0?e:f)>>>0){continue}break}}k=1;if(e>>>0>=f>>>0){break b}ra(d+e|0,0,(c&255)-e|0)}return k}ra(d+e|0,0,(c&255)-e|0);return 1}function hc(a,b,c,d){var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=O(0);a:{b:{if(!d){break b}c:{switch(H[a+28>>2]-1|0){case 0:e=I[a+24|0];f=c&255;if(e>>>0>>0?e:f){e=H[H[a>>2]>>2];i=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);h=b;b=b+i|0;b=b+e|0;while(1){if(K[H[a>>2]+4>>2]>>0){return 0}e=F[b|0];if((e|0)>>0>>0>>0?e:f)>>>0){continue}break}}k=1;if(e>>>0>=f>>>0){break b}break a;case 1:e=I[a+24|0];f=c&255;if(e>>>0>>0?e:f){e=H[H[a>>2]>>2];i=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);h=b;b=b+i|0;b=b+e|0;while(1){if(K[H[a>>2]+4>>2]>>0){break b}F[d+g|0]=I[b|0];b=b+1|0;g=g+1|0;e=I[a+24|0];if(g>>>0>>0>>0?e:f)>>>0){continue}break}}k=1;if(e>>>0>=f>>>0){break b}break a;case 2:e=I[a+24|0];f=c&255;if(e>>>0>>0?e:f){e=H[H[a>>2]>>2];i=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);h=b;b=b+i|0;b=b+e|0;while(1){if(K[H[a>>2]+4>>2]>>0){break b}e=J[b>>1];if(e>>>0>255){break b}F[d+g|0]=e;b=b+2|0;g=g+1|0;e=I[a+24|0];if(g>>>0>>0>>0?e:f)>>>0){continue}break}}k=1;if(e>>>0>=f>>>0){break b}break a;case 3:e=I[a+24|0];f=c&255;if(e>>>0>>0?e:f){e=H[H[a>>2]>>2];i=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);h=b;b=b+i|0;b=b+e|0;while(1){if(K[H[a>>2]+4>>2]>>0){break b}e=J[b>>1];if(e>>>0>255){break b}F[d+g|0]=e;b=b+2|0;g=g+1|0;e=I[a+24|0];if(g>>>0>>0>>0?e:f)>>>0){continue}break}}k=1;if(e>>>0>=f>>>0){break b}break a;case 4:e=I[a+24|0];f=c&255;if(e>>>0>>0?e:f){e=H[H[a>>2]>>2];i=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);h=b;b=b+i|0;b=b+e|0;while(1){if(K[H[a>>2]+4>>2]>>0){break b}e=H[b>>2];if(e>>>0>255){break b}F[d+g|0]=e;b=b+4|0;g=g+1|0;e=I[a+24|0];if(g>>>0>>0>>0?e:f)>>>0){continue}break}}k=1;if(e>>>0>=f>>>0){break b}break a;case 5:e=I[a+24|0];f=c&255;if(e>>>0>>0?e:f){e=H[H[a>>2]>>2];i=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);h=b;b=b+i|0;b=b+e|0;while(1){if(K[H[a>>2]+4>>2]>>0){break b}e=H[b>>2];if(e>>>0>255){break b}F[d+g|0]=e;b=b+4|0;g=g+1|0;e=I[a+24|0];if(g>>>0>>0>>0?e:f)>>>0){continue}break}}k=1;if(e>>>0>=f>>>0){break b}break a;case 6:e=I[a+24|0];f=c&255;if(e>>>0>>0?e:f){e=H[H[a>>2]>>2];i=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);h=b;b=b+i|0;b=b+e|0;while(1){if(K[H[a>>2]+4>>2]>>0){break b}i=H[b+4>>2];e=H[b>>2];if(!i&e>>>0>255|i){break b}F[d+g|0]=e;b=b+8|0;g=g+1|0;e=I[a+24|0];if(g>>>0>>0>>0?e:f)>>>0){continue}break}}k=1;if(e>>>0>=f>>>0){break b}break a;case 7:e=I[a+24|0];f=c&255;if(e>>>0>>0?e:f){e=H[H[a>>2]>>2];i=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);h=b;b=b+i|0;b=b+e|0;while(1){if(K[H[a>>2]+4>>2]>>0){break b}i=H[b+4>>2];e=H[b>>2];if(!i&e>>>0>255|i){break b}F[d+g|0]=e;b=b+8|0;g=g+1|0;e=I[a+24|0];if(g>>>0>>0>>0?e:f)>>>0){continue}break}}k=1;if(e>>>0>=f>>>0){break b}break a;case 8:e=I[a+24|0];c=c&255;d:{if(c>>>0>e>>>0?e:c){e=H[H[a>>2]>>2];f=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);h=b;b=b+f|0;b=b+e|0;while(1){if(K[H[a>>2]+4>>2]>>0){break d}l=L[b>>2];if(l>=O(255)|lO(1)){break d}j=T(+l*255+.5);if(!(j=0)){break f}h=~~j>>>0;break e}if(!(l=O(0))){break f}h=~~l>>>0;break e}h=0}F[e|0]=h;b=b+4|0;g=g+1|0;e=I[a+24|0];if(g>>>0>>0>e>>>0?e:c)>>>0){continue}break}}k=1;if(c>>>0>>0){break d}ra(d+e|0,0,c-e|0)}return k;case 9:e=I[a+24|0];f=c&255;if(e>>>0>>0?e:f){e=H[H[a>>2]>>2];i=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);h=b;b=b+i|0;b=b+e|0;while(1){if(K[H[a>>2]+4>>2]>>0){break b}j=M[b>>3];if(j>=255|j1){break b}j=T(j*255+.5)}g:{if(j=0){h=~~j>>>0;break g}h=0}F[e|0]=h;b=b+8|0;g=g+1|0;e=I[a+24|0];if(g>>>0>>0>>0?e:f)>>>0){continue}break}}k=1;if(e>>>0>=f>>>0){break b}break a;case 10:break c;default:break b}}e=I[a+24|0];f=c&255;if(e>>>0>>0?e:f){e=H[H[a>>2]>>2];i=H[a+48>>2];b=Rj(H[a+40>>2],H[a+44>>2],b,0);h=b;b=b+i|0;b=b+e|0;while(1){if(K[H[a>>2]+4>>2]>>0){break b}F[d+g|0]=I[b|0];b=b+1|0;g=g+1|0;e=I[a+24|0];if(g>>>0>>0>>0?e:f)>>>0){continue}break}}k=1;if(e>>>0>=f>>>0){break b}ra(d+e|0,0,(c&255)-e|0)}return k}ra(d+e|0,0,(c&255)-e|0);return 1}function Hh(a){a=a|0;var b=0,c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0;g=ca-32|0;ca=g;i=H[a+32>>2];b=J[a+36>>1];a:{b:{if(((b>8)&65535)>>>0>2];d=H[i+12>>2];c=b;b=H[i+20>>2];e=b;j=H[i+16>>2];f=j+4|0;b=f>>>0>>0>>0&(b|0)>=(d|0)|(b|0)>(d|0)){break a}n=H[i>>2];k=n+j|0;k=I[k|0]|I[k+1|0]>0>>0>h>>>0&(b|0)>=(c|0)|(b|0)>(c|0)){break a}c=f+n|0;n=I[c|0]|I[c+1|0]2])){break a}k=H[g+28>>2];n=H[g+24>>2]}if(k>>>0>1431655765){break a}d=H[a+32>>2];b=d;j=H[b+8>>2];c=H[b+16>>2];f=H[b+12>>2];b=H[b+20>>2];e=Sj(j-c|0,f-(b+(c>>>0>j>>>0)|0)|0,3,0);if(!da&e>>>0>>0){break a}e=Rj(k,0,3,0);if(!da&e>>>0>>0|((b|0)>=(f|0)&c>>>0>=j>>>0|(b|0)>(f|0))){break a}j=I[c+H[d>>2]|0];c=c+1|0;b=c?b:b+1|0;H[d+16>>2]=c;H[d+20>>2]=b;c:{d:{if(!j){d=0;c=ca-32|0;ca=c;H[c+24>>2]=0;H[c+16>>2]=0;H[c+20>>2]=0;e:{f:{b=N(k,3);if(b){if(b>>>0>=1073741824){break f}j=N(k,12);d=pa(j);ra(d,0,j)}b=kd(b,1,H[a+32>>2],d);g:{h:{if(!(!k|!b)){j=0;while(1){i:{b=(j2];e=f>>>1|0;f=(f&1?0-e|0:e)+l|0;if((f|0)>2]=f;e=H[b+4>>2];h=e>>>1|0;f=f+(e&1?0-h|0:h)|0;if((f|0)>2]=f;b=H[b+8>>2];e=b>>>1|0;l=f+(b&1?0-e|0:e)|0;if((l|0)>2]=l;Rb(H[a+44>>2]+96|0,c);j=j+3|0;b=1;o=o+1|0;if((o|0)!=(k|0)){continue}break h}break}b=0;break h}if(!d){break g}}oa(d)}ca=c+32|0;break e}sa();v()}if(b){break d}break a}if(n>>>0>2]=0;H[g+8>>2]=0;H[g+12>>2]=0;d=H[a+32>>2];b=d;j=H[b+16>>2];e=H[b+8>>2];c=H[b+20>>2];h=H[b+12>>2];b=h;if(e>>>0>>0&(c|0)>=(b|0)|(b|0)>2];l=I[i+j|0];b=c;f=j+1|0;b=f?b:b+1|0;H[d+16>>2]=f;H[d+20>>2]=b;H[g+8>>2]=l;l=e>>>0>>0&(c|0)>=(h|0)|(c|0)>(h|0);e=l?j:e;h=l?c:h;if((e|0)==(f|0)&(h|0)==(b|0)){break j}l=I[f+i|0];b=c;f=j+2|0;b=f>>>0>2]=f;H[d+20>>2]=b;H[g+12>>2]=l;if((e|0)==(f|0)&(b|0)==(h|0)){break j}f=I[f+i|0];b=c;c=j+3|0;b=c>>>0>2]=c;H[d+20>>2]=b;H[g+16>>2]=f;Rb(H[a+44>>2]+96|0,g+8|0);m=m+1|0;if((m|0)!=(k|0)){continue}break d}break}m=0;break a}if(n>>>0>2]=0;H[g+8>>2]=0;H[g+12>>2]=0;i=H[a+32>>2];b=i;c=H[b+8>>2];d=H[b+12>>2];f=H[b+16>>2];b=H[b+20>>2];j=b;e=f+2|0;b=e>>>0>>0>>0&(b|0)>=(d|0)|(b|0)>(d|0)){break k}l=H[i>>2];h=l+f|0;h=I[h|0]|I[h+1|0]2]=e;H[i+20>>2]=b;H[g+8>>2]=h;b=j;h=f+4|0;b=h>>>0>>0>>0&(b|0)>=(d|0)|(b|0)>(d|0)){break k}e=e+l|0;e=I[e|0]|I[e+1|0]2]=h;H[i+20>>2]=b;H[g+12>>2]=e;e=c;b=j;c=f+6|0;b=c>>>0>>0>e>>>0&(b|0)>=(d|0)|(b|0)>(d|0)){break k}d=h+l|0;d=I[d|0]|I[d+1|0]2]=c;H[i+20>>2]=b;H[g+16>>2]=d;Rb(H[a+44>>2]+96|0,g+8|0);m=m+1|0;if((m|0)!=(k|0)){continue}break d}break}m=0;break a}l:{if(n>>>0>2097151){break l}b=J[a+36>>1];if(((b>8)&65535)>>>0>2]=0;H[g+8>>2]=0;H[g+12>>2]=0;if(!Fb(1,g+4|0,H[a+32>>2])){break m}H[g+8>>2]=H[g+4>>2];if(!Fb(1,g+4|0,H[a+32>>2])){break m}H[g+12>>2]=H[g+4>>2];if(!Fb(1,g+4|0,H[a+32>>2])){break m}H[g+16>>2]=H[g+4>>2];Rb(H[a+44>>2]+96|0,g+8|0);m=m+1|0;if((m|0)!=(k|0)){continue}break d}break}m=0;break a}if(!k){break d}while(1){H[g+16>>2]=0;H[g+8>>2]=0;H[g+12>>2]=0;i=H[a+32>>2];b=i;c=H[b+8>>2];d=H[b+12>>2];f=H[b+16>>2];b=H[b+20>>2];j=b;e=f+4|0;b=e>>>0>>0>>0&(b|0)>=(d|0)|(b|0)>(d|0)){break c}l=H[i>>2];h=l+f|0;h=I[h|0]|I[h+1|0]2]=h;b=j;h=f+8|0;b=h>>>0>>0>>0&(b|0)>=(d|0)|(b|0)>(d|0)){break c}e=e+l|0;e=I[e|0]|I[e+1|0]2]=e;e=c;b=j;c=f+12|0;b=c>>>0>>0>e>>>0&(b|0)>=(d|0)|(b|0)>(d|0)){break c}d=h+l|0;d=I[d|0]|I[d+1|0]2]=d;Rb(H[a+44>>2]+96|0,g+8|0);m=m+1|0;if((m|0)!=(k|0)){continue}break}}H[H[a+4>>2]+80>>2]=n;m=1;break a}m=0}ca=g+32|0;return m|0}function zf(a){a=a|0;var b=0,c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=O(0),w=0;p=ca-16|0;ca=p;a:{if(!(H[a+60>>2]!=H[a- -64>>2]|H[a+48>>2]!=H[a+52>>2])){j=1;break a}j=1;if((ea[H[H[a>>2]+24>>2]](a)|0)>2]+20>>2]](a,w)|0;c:{d:{e:{f=H[H[H[(ea[H[H[a>>2]+28>>2]](a)|0)+4>>2]+8>>2]+(b2];switch(H[f+28>>2]-1|0){case 8:break d;case 0:case 2:case 4:break e;default:break c}}b=I[f+24|0];f:{if(!b){n=0;j=0;break f}j=0;b=b2];c=H[o>>2];m=H[f+48>>2];e=H[f+40>>2];l=Rj(e,H[f+44>>2],d,b);m=m+l|0;s=c+m|0;c=e;m=qa(h,s,c);l=I[f+24|0];if(l){t=H[a+48>>2];e=0;while(1){r=e2];if((s|0)>2]=s+H[t+(e+u2];e=e+1|0;if((l|0)!=(e|0)){continue}break}}qa(H[o>>2]+N(d,c)|0,g,c);d=d+1|0;b=d?b:b+1|0;if(!b&K[f+80>>2]>d>>>0){continue}break}}k=1}if(g){oa(g)}if(h){oa(h)}if(k){break h}break g;case 2:g=0;e=0;d=0;b=0;c=I[f+24|0];if(c){c=c2]){while(1){l=H[f>>2];h=H[l>>2];i=H[f+48>>2];c=H[f+40>>2];k=Rj(c,H[f+44>>2],d,b);i=i+k|0;k=qa(e,h+i|0,c);o=I[f+24|0];l:{if(!o){break l}m=H[a+48>>2];h=0;if((o|0)!=1){t=o&254;i=0;while(1){r=h1]=J[k+r>>1]+J[m+(h+u1];r=h|1;s=r1]=J[k+s>>1]+J[m+(r+u1];h=h+2|0;i=i+2|0;if((t|0)!=(i|0)){continue}break}}if(!(o&1)){break l}i=h1]=J[i+k>>1]+J[m+(h+u1]}qa(H[l>>2]+N(d,c)|0,g,c);d=d+1|0;b=d?b:b+1|0;if(!b&K[f+80>>2]>d>>>0){continue}break}}if(g){oa(g)}if(e){oa(e)}break h;case 0:break i;default:break h}}h=0;e=0;d=0;b=0;c=I[f+24|0];if(c){e=pa(c);ra(e,0,c);h=pa(c);ra(h,0,c)}if(H[f+80>>2]){while(1){t=H[f>>2];g=H[t>>2];i=H[f+48>>2];c=H[f+40>>2];k=Rj(c,H[f+44>>2],d,b);i=i+k|0;k=qa(e,g+i|0,c);o=I[f+24|0];m:{if(!o){break m}m=H[a+48>>2];g=0;if((o|0)!=1){r=o&254;i=0;while(1){F[g+h|0]=I[g+k|0]+I[m+(g+u>>0){continue}break}}if(h){oa(h)}if(e){oa(e)}}u=I[f+24|0]+u|0;i=1}if(j){oa(j)}if(n){oa(n)}if(i){break c}j=0;break a}e=H[H[a+60>>2]+(q2];h=H[a+36>>2];g=H[(ea[H[H[a>>2]+28>>2]](a)|0)+40>>2];H[p+12>>2]=H[f+56>>2];b=pa(32);H[p>>2]=b;H[p+4>>2]=24;H[p+8>>2]=-2147483616;d=I[1206]|I[1207]8;F[b+22|0]=d>>>16;F[b+23|0]=d>>>24;d=I[1198]|I[1199]8;F[b+14|0]=d>>>16;F[b+15|0]=d>>>24;d=I[1190]|I[1191]8;F[b+6|0]=d>>>16;F[b+7|0]=d>>>24;F[b+24|0]=0;d=sd(g,p+12|0,p);if(F[p+11|0]>2])}b=q+1|0;n:{if(d){oe(f,e);break n}g=h+N(q,24)|0;q=H[g+4>>2];c=I[f+24|0];h=c2]=1065353216;v=L[g+20>>2];q=-1>2]=v/O(q|0)}if((q|0)>2]){break o}if(!c){n=0;j=0;while(1){qa(H[H[f+64>>2]>>2]+j|0,d,h);j=h+j|0;n=n+1|0;if(n>>>0>2]){continue}break}break o}o=H[H[e>>2]>>2]+H[e+48>>2]|0;t=c&254;r=c&1;i=0;k=0;j=0;while(1){q=H[g+8>>2];v=L[p>>2];n=0;m=0;if((c|0)!=1){while(1){l=n2]))+L[l+q>>2];l=l|4;L[l+d>>2]=O(v*O(H[s+4>>2]))+L[l+q>>2];n=n+2|0;j=j+2|0;m=m+2|0;if((t|0)!=(m|0)){continue}break}}if(r){n=n2]=O(v*O(H[o+(j2]))+L[n+q>>2];j=j+1|0}qa(H[H[f+64>>2]>>2]+k|0,d,h);k=h+k|0;i=i+1|0;if(i>>>0>2]){continue}break}}oa(d)}q=b}j=1;w=w+1|0;if((ea[H[H[a>>2]+24>>2]](a)|0)>(w|0)){continue}break a}break}oa(d);j=0}ca=p+16|0;return j|0}function Le(a,b,c){var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0;g=ca+-64|0;ca=g;H[g+56>>2]=0;H[g+48>>2]=0;H[g+52>>2]=0;H[g+40>>2]=0;H[g+44>>2]=0;H[g+32>>2]=0;H[g+36>>2]=0;H[g+24>>2]=0;H[g+28>>2]=0;H[g+16>>2]=0;H[g+20>>2]=0;H[g+8>>2]=0;H[g+12>>2]=0;j=g+8|0;d=J[b+38>>1];a:{b:{if(!d){break b}c:{if(d>>>0>2];f=H[b+12>>2];e=H[b+20>>2];d=H[b+16>>2];i=d+4|0;e=i>>>0>>0>>0&(e|0)>=(f|0)|(e|0)>(f|0)){break b}d=d+H[b>>2]|0;l=I[d|0]|I[d+1|0]2]+4|0;e=d>>>0>2]=d;H[b+20>>2]=e;break c}if(!hb(1,j+12|0,b)){break b}d=H[b+16>>2];e=H[b+20>>2];l=H[j+12>>2]}f=H[b+8>>2];i=f-d|0;d=H[b+12>>2]-((d>>>0>f>>>0)+e|0)|0;if(i>>>0>>6>>>0&(d|0)2];d=H[j+4>>2]-e>>2;d:{if(d>>>0>>0){ya(j,l-d|0);l=H[j+12>>2];break d}if(d>>>0>>0){break d}H[j+4>>2]=e+(l2];e=H[b+20>>2];r=H[j>>2];k=H[b+8>>2];o=H[b+12>>2];h=0;while(1){i=0;if((e|0)>=(o|0)&d>>>0>=k>>>0|(e|0)>(o|0)){break a}i=H[b>>2];p=I[i+d|0];d=d+1|0;e=d?e:e+1|0;H[b+16>>2]=d;H[b+20>>2]=e;f=p>>>2|0;m=0;e:{f:{g:{h:{s=p&3;switch(s|0){case 0:break f;case 3:break h;default:break g}}f=f+h|0;i=0;if(f>>>0>=l>>>0){break a}ra(r+(h2]=d;H[b+20>>2]=e;f=l>0>h>>>0){continue}break}d=j+16|0;o=H[j>>2];f=H[j+16>>2];e=H[j+20>>2]-f|0;i:{if(e>>>0>>2|0)|0);break i}if((e|0)==4194304){break i}H[j+20>>2]=f+4194304}e=j+28|0;h=H[e>>2];f=H[j+32>>2]-h>>3;j:{if(f>>>0>>0){ob(e,l-f|0);h=H[e>>2];break j}if(f>>>0>l>>>0){H[j+32>>2]=(l2];d=0;i=0;while(1){e=o+(d2];m=(d2]=f;H[m>>2]=j;e=H[e>>2];i=e+f|0;if(i>>>0>1048576){break b}k:{if(f>>>0>=i>>>0){break k}m=0;j=e&7;if(j){while(1){H[k+(f2]=d;f=f+1|0;m=m+1|0;if((j|0)!=(m|0)){continue}break}}if(e-1>>>0>2]=d;H[e+24>>2]=d;H[e+20>>2]=d;H[e+16>>2]=d;H[e+12>>2]=d;H[e+8>>2]=d;H[e+4>>2]=d;f=f+8|0;if((i|0)!=(f|0)){continue}break}}d=d+1|0;if((l|0)!=(d|0)){continue}break}n=(i|0)==1048576}i=n}l:{if(!i|(H[g+20>>2]?0:a)){break l}i=0;n=ca-16|0;ca=n;m:{n:{if(J[b+38>>1]>2];f=H[b+12>>2];j=f;e=H[b+20>>2];k=H[b+16>>2];d=k+8|0;e=d>>>0>>0>h>>>0&(e|0)>=(f|0)|(e|0)>(f|0)){break m}k=k+H[b>>2]|0;f=I[k|0]|I[k+1|0]2];f=H[n+8>>2];k=H[n+12>>2]}l=h-d|0;h=j-((d>>>0>h>>>0)+e|0)|0;if((h|0)==(k|0)&f>>>0>l>>>0|h>>>0>>0){break m}e=e+k|0;h=d+f|0;e=h>>>0>>0?e+1|0:e;H[b+16>>2]=h;H[b+20>>2]=e;if((f|0)>2]+d|0;H[g+48>>2]=b;d=f-1|0;e=d+b|0;h=I[e|0];o:{if(h>>>0>2]=d;b=I[e|0]&63;break o}p:{switch((h>>>6|0)-1|0){case 0:if(f>>>0>2]=d;b=b+d|0;b=I[b+1|0]>0>2]=d;b=b+d|0;b=I[b+1|0]2];d=H[g+36>>2];e=H[g+48>>2];h=H[g+24>>2];while(1){q:{if(f>>>0>4194303){break q}while(1){if((b|0)>2]=b;f=I[b+e|0]|f2]=f;if(f>>>0>>20|0)+i|0)-H[n+4>>2]|0;H[g+56>>2]=f;H[(q2]=k;t=1;q=q+1|0;if((q|0)!=(a|0)){continue}break}}a=H[g+36>>2];if(a){H[g+40>>2]=a;oa(a)}a=H[g+24>>2];if(a){H[g+28>>2]=a;oa(a)}a=H[g+8>>2];if(a){H[g+12>>2]=a;oa(a)}ca=g- -64|0;return t}function nc(a,b,c){var d=0,e=0,f=0,g=0,h=0,i=0;e=ca-48|0;ca=e;f=J[6677]|J[6678]1]=d>>>16;G[e+42>>1]=f;G[e+44>>1]=f>>>16;d=H[3337];H[e+32>>2]=H[3336];H[e+36>>2]=d;d=H[3335];H[e+24>>2]=H[3334];H[e+28>>2]=d;d=H[3333];H[e+16>>2]=H[3332];H[e+20>>2]=d;g=H[b+8>>2];i=H[b+12>>2];h=H[b+20>>2];d=H[b+16>>2];f=d+5|0;h=f>>>0>>0>>0&(h|0)>=(i|0)|(h|0)>(i|0)){d=Ma(e+16|0);if(d>>>0>=2147483632){break a}c:{d:{if(d>>>0>=11){b=(d|15)+1|0;c=pa(b);H[e+8>>2]=b|-2147483648;H[e>>2]=c;H[e+4>>2]=d;b=c+d|0;break d}F[e+11|0]=d;b=d+e|0;c=e;if(!d){break c}}qa(c,e+16|0,d)}F[b|0]=0;H[a>>2]=-2;b=a+4|0;if(F[e+11|0]>=0){a=H[e+4>>2];H[b>>2]=H[e>>2];H[b+4>>2]=a;H[b+8>>2]=H[e+8>>2];break b}za(b,H[e>>2],H[e+4>>2]);if(F[e+11|0]>=0){break b}oa(H[e>>2]);break b}f=d+H[b>>2]|0;d=I[f|0]|I[f+1|0]16;F[c+3|0]=d>>>24;F[c+4|0]=I[f+4|0];d=H[b+20>>2];f=H[b+16>>2]+5|0;d=f>>>0>2]=f;H[b+20>>2]=d;if(Fa(c,1260,5)){d=pa(32);F[d+17|0]=0;F[d+16|0]=I[1496];c=I[1492]|I[1493]8;F[d+14|0]=c>>>16;F[d+15|0]=c>>>24;c=I[1484]|I[1485]8;F[d+6|0]=c>>>16;F[d+7|0]=c>>>24;H[a>>2]=-1;za(a+4|0,d,17);oa(d);break b}g=H[b+12>>2];if((g|0)>2]>>0|(d|0)>(g|0)){d=Ma(e+16|0);if(d>>>0>=2147483632){break a}e:{f:{if(d>>>0>=11){b=(d|15)+1|0;c=pa(b);H[e+8>>2]=b|-2147483648;H[e>>2]=c;H[e+4>>2]=d;b=c+d|0;break f}F[e+11|0]=d;b=d+e|0;c=e;if(!d){break e}}qa(c,e+16|0,d)}F[b|0]=0;H[a>>2]=-2;b=a+4|0;if(F[e+11|0]>=0){a=H[e+4>>2];H[b>>2]=H[e>>2];H[b+4>>2]=a;H[b+8>>2]=H[e+8>>2];break b}za(b,H[e>>2],H[e+4>>2]);if(F[e+11|0]>=0){break b}oa(H[e>>2]);break b}F[c+5|0]=I[f+H[b>>2]|0];g=H[b+20>>2];d=H[b+16>>2]+1|0;g=d?g:g+1|0;H[b+16>>2]=d;H[b+20>>2]=g;f=H[b+12>>2];if((f|0)>2]>>0|(g|0)>(f|0)){d=Ma(e+16|0);if(d>>>0>=2147483632){break a}g:{h:{if(d>>>0>=11){b=(d|15)+1|0;c=pa(b);H[e+8>>2]=b|-2147483648;H[e>>2]=c;H[e+4>>2]=d;b=c+d|0;break h}F[e+11|0]=d;b=d+e|0;c=e;if(!d){break g}}qa(c,e+16|0,d)}F[b|0]=0;H[a>>2]=-2;b=a+4|0;if(F[e+11|0]>=0){a=H[e+4>>2];H[b>>2]=H[e>>2];H[b+4>>2]=a;H[b+8>>2]=H[e+8>>2];break b}za(b,H[e>>2],H[e+4>>2]);if(F[e+11|0]>=0){break b}oa(H[e>>2]);break b}F[c+6|0]=I[d+H[b>>2]|0];h=H[b+20>>2];d=H[b+16>>2]+1|0;h=d?h:h+1|0;H[b+16>>2]=d;H[b+20>>2]=h;f=H[b+12>>2];if((f|0)>2]>>0|(f|0)>>0>=2147483632){break a}i:{j:{if(d>>>0>=11){b=(d|15)+1|0;c=pa(b);H[e+8>>2]=b|-2147483648;H[e>>2]=c;H[e+4>>2]=d;b=c+d|0;break j}F[e+11|0]=d;b=d+e|0;c=e;if(!d){break i}}qa(c,e+16|0,d)}F[b|0]=0;H[a>>2]=-2;b=a+4|0;if(F[e+11|0]>=0){a=H[e+4>>2];H[b>>2]=H[e>>2];H[b+4>>2]=a;H[b+8>>2]=H[e+8>>2];break b}za(b,H[e>>2],H[e+4>>2]);if(F[e+11|0]>=0){break b}oa(H[e>>2]);break b}F[c+7|0]=I[d+H[b>>2]|0];g=H[b+20>>2];d=H[b+16>>2]+1|0;g=d?g:g+1|0;H[b+16>>2]=d;H[b+20>>2]=g;f=H[b+12>>2];if((f|0)>2]>>0|(g|0)>(f|0)){c=mc(e,e+16|0);H[a>>2]=-2;b=a+4|0;if(F[c+11|0]>=0){a=H[c+4>>2];H[b>>2]=H[c>>2];H[b+4>>2]=a;H[b+8>>2]=H[c+8>>2];break b}za(b,H[c>>2],H[c+4>>2]);if(F[c+11|0]>=0){break b}oa(H[c>>2]);break b}F[c+8|0]=I[d+H[b>>2]|0];d=H[b+20>>2];g=H[b+16>>2];f=g+1|0;i=f?d:d+1|0;H[b+16>>2]=f;H[b+20>>2]=i;i=H[b+8>>2];h=H[b+12>>2];g=g+3|0;d=g>>>0>>0>i>>>0&(d|0)>=(h|0)|(d|0)>(h|0)){c=mc(e,e+16|0);H[a>>2]=-2;b=a+4|0;if(F[c+11|0]>=0){a=H[c+4>>2];H[b>>2]=H[c>>2];H[b+4>>2]=a;H[b+8>>2]=H[c+8>>2];break b}za(b,H[c>>2],H[c+4>>2]);if(F[c+11|0]>=0){break b}oa(H[c>>2]);break b}d=c;c=H[b>>2]+f|0;G[d+10>>1]=I[c|0]|I[c+1|0]2];c=H[b+16>>2]+2|0;g=c>>>0>2]=c;H[b+20>>2]=g;H[a+8>>2]=0;H[a+12>>2]=0;H[a>>2]=0;H[a+4>>2]=0}ca=e+48|0;return}Na();v()}function Nb(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,w=0,x=0,y=0;e=ca-96|0;ca=e;f=H[a+16>>2];F[e+92|0]=1;H[e+88>>2]=b;H[e+84>>2]=b;H[e+80>>2]=f;j=H[a+20>>2];d=H[j>>2];a:{b:{f=H[H[f+28>>2]+(b2];if(f>>>0>2]-d>>2>>>0){d=H[H[a+8>>2]+(H[d+(f2]2];f=H[a+4>>2];if(!I[f+84|0]){d=H[H[f+68>>2]+(d2]}H[e+72>>2]=0;H[e+76>>2]=0;j=e- -64|0;H[j>>2]=0;H[j+4>>2]=0;H[e+56>>2]=0;H[e+60>>2]=0;Sa(f,d,F[f+24|0],e+56|0);if((b|0)!=-1){f=b+1|0;j=(f>>>0)%3|0?f:b-2|0;m=((b>>>0)%3|0?-1:2)+b|0;while(1){d=j;f=m;c:{if(!H[a+28>>2]){break c}f=b+1|0;d=(f>>>0)%3|0?f:b-2|0;f=b-1|0;if((b>>>0)%3|0){break c}f=b+2|0}n=H[a+20>>2];b=H[n>>2];d=H[H[H[a+16>>2]+28>>2]+(d2];if(d>>>0>=H[n+4>>2]-b>>2>>>0){break b}d=H[H[a+8>>2]+(H[b+(d2]2];b=H[a+4>>2];if(!I[b+84|0]){d=H[H[b+68>>2]+(d2]}H[e+48>>2]=0;H[e+52>>2]=0;H[e+40>>2]=0;H[e+44>>2]=0;H[e+32>>2]=0;H[e+36>>2]=0;Sa(b,d,F[b+24|0],e+32|0);d=H[a+20>>2];b=H[d>>2];f=H[H[H[a+16>>2]+28>>2]+(f2];if(f>>>0>=H[d+4>>2]-b>>2>>>0){break a}d=H[H[a+8>>2]+(H[b+(f2]2];b=H[a+4>>2];if(!I[b+84|0]){d=H[H[b+68>>2]+(d2]}H[e+24>>2]=0;H[e+28>>2]=0;H[e+16>>2]=0;H[e+20>>2]=0;H[e+8>>2]=0;H[e+12>>2]=0;Sa(b,d,F[b+24|0],e+8|0);g=H[e+8>>2];b=H[e+56>>2];d=g-b|0;p=H[e+60>>2];t=H[e+12>>2]-(p+(b>>>0>g>>>0)|0)|0;h=H[e+40>>2];f=H[e+64>>2];n=h-f|0;u=H[e+68>>2];y=H[e+44>>2]-(u+(f>>>0>h>>>0)|0)|0;g=Rj(d,t,n,y);w=o-g|0;x=i-(da+(g>>>0>o>>>0)|0)|0;i=w;h=H[e+16>>2];g=h-f|0;u=H[e+20>>2]-((f>>>0>h>>>0)+u|0)|0;k=H[e+32>>2];h=k-b|0;w=H[e+36>>2]-((b>>>0>k>>>0)+p|0)|0;b=Rj(g,u,h,w);o=i+b|0;i=da+x|0;i=b>>>0>o>>>0?i+1|0:i;b=l;l=d;p=t;k=H[e+48>>2];f=H[e+72>>2];d=k-f|0;t=H[e+76>>2];x=H[e+52>>2]-(t+(f>>>0>k>>>0)|0)|0;l=Rj(l,p,d,x);k=b+l|0;b=da+q|0;b=k>>>0>>0?b+1|0:b;l=H[e+24>>2];p=l-f|0;f=H[e+28>>2]-((f>>>0>l>>>0)+t|0)|0;q=Rj(p,f,h,w);l=k-q|0;q=b-(da+(k>>>0>>0)|0)|0;b=Rj(g,u,d,x);d=r-b|0;b=s-(da+(b>>>0>r>>>0)|0)|0;s=Rj(p,f,n,y);r=s+d|0;b=da+b|0;s=r>>>0>>0?b+1|0:b;b=H[e+88>>2];f=H[e+80>>2];d:{if(I[e+92|0]){e:{f:{g:{h:{if((b|0)==-1){break h}d=b+1|0;b=(d>>>0)%3|0?d:b-2|0;if((b|0)==-1|H[H[f>>2]+(b>>>3&536870908)>>2]>>>b&1){break h}b=H[H[H[f+64>>2]+12>>2]+(b2];if((b|0)!=-1){break g}}H[e+88>>2]=-1;break f}d=b+1|0;b=(d>>>0)%3|0?d:b-2|0;H[e+88>>2]=b;if((b|0)!=-1){break e}}b=H[e+84>>2];d=-1;i:{if((b|0)==-1){break i}j:{if((b>>>0)%3|0){b=b-1|0;break j}b=b+2|0;d=-1;if((b|0)==-1){break i}}d=-1;if(H[H[f>>2]+(b>>>3&536870908)>>2]>>>b&1){break i}b=H[H[H[f+64>>2]+12>>2]+(b2];d=-1;if((b|0)==-1){break i}d=b-1|0;if((b>>>0)%3|0){break i}d=b+2|0}F[e+92|0]=0;H[e+88>>2]=d;break d}if((b|0)!=H[e+84>>2]){break d}H[e+88>>2]=-1;break d}d=-1;k:{if((b|0)==-1){break k}l:{if((b>>>0)%3|0){b=b-1|0;break l}b=b+2|0;d=-1;if((b|0)==-1){break k}}d=-1;if(H[H[f>>2]+(b>>>3&536870908)>>2]>>>b&1){break k}b=H[H[H[f+64>>2]+12>>2]+(b2];d=-1;if((b|0)==-1){break k}d=b-1|0;if((b>>>0)%3|0){break k}d=b+2|0}H[e+88>>2]=d}b=H[e+88>>2];if((b|0)!=-1){continue}break}}b=s>>31;f=b^r;d=f-b|0;b=(b^s)-((b>>>0>f>>>0)+b|0)|0;m=-1;f=2147483647;g=q>>31;h=g^l;j=h-g|0;n=(g^q)-((h>>>0>>0)+g|0)|0;h=n;k=j^-1;g=h^2147483647;n=i;m:{n:{if(!H[a+28>>2]){if((b|0)==(g|0)&d>>>0>k>>>0|b>>>0>g>>>0){break m}b=b+h|0;a=d+j|0;b=a>>>0>>0?b+1|0:b;f=a;g=i;a=g>>31;d=a;m=d^o;a=m-d|0;i=a;d=(d^g)-((d>>>0>m>>>0)+d|0)|0;a=a+f|0;d=d^2147483647;i=(d|0)==(b|0)&(i^-1)>>>0>>0|b>>>0>d>>>0;a=i?-1:a;if(!(i&0)&(a|0)>29|0;break n}o:{if((b|0)==(g|0)&d>>>0>k>>>0|b>>>0>g>>>0){break o}b=b+h|0;a=d+j|0;b=a>>>0>>0?b+1|0:b;k=i;d=i>>31;h=d^o;i=h-d|0;j=(d^k)-((d>>>0>h>>>0)+d|0)|0;g=j^2147483647;d=a;a=i;if((g|0)==(b|0)&d>>>0>(a^-1)>>>0|b>>>0>g>>>0){break o}b=b+j|0;m=a+d|0;b=m>>>0>>0?b+1|0:b;f=b;if(!b&m>>>0>>29|0;a=(f&536870911)>29}o=Sj(o,n,a,b);l=Sj(l,q,a,b);r=Sj(r,s,a,b)}H[c+8>>2]=o;H[c+4>>2]=l;H[c>>2]=r;ca=e+96|0;return}Ca();v()}Ca();v()}Ca();v()}function Jj(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0;H[a+8>>2]=e;r=a+32|0;g=H[r>>2];f=H[a+36>>2]-g>>2;a:{if(f>>>0>>0){ya(r,e-f|0);d=H[a+8>>2];break a}d=e;if(d>>>0>=f>>>0){break a}H[a+36>>2]=g+(e1073741823?-1:w;m=ra(pa(f),0,f);p=ra(pa(f),0,f);b:{if((d|0)>2];while(1){d=h2];g=H[a+16>>2];c:{if((f|0)>(g|0)){H[d+i>>2]=g;break c}d=d+i|0;g=H[a+12>>2];if((g|0)>(f|0)){H[d>>2]=g;break c}H[d>>2]=f}d=H[a+8>>2];h=h+1|0;if((d|0)>(h|0)){continue}break}if((d|0)>2]|0;H[d>>2]=g;d:{if((g|0)>H[a+16>>2]){g=g-H[a+20>>2]|0}else{if((g|0)>=H[a+12>>2]){break d}g=g+H[a+20>>2]|0}H[d>>2]=g}d=H[a+8>>2];f=f+1|0;if((d|0)>(f|0)){continue}break}}f=H[a+56>>2];x=H[f>>2];f=H[f+4>>2]-x|0;if((f|0)>=5){D=H[a+52>>2];s=H[a+48>>2];u=f>>>2|0;E=u>>>02];l=0;f=g;while(1){i:{if(H[(f>>>3&536870908)+C>>2]>>>f&1){break i}i=H[H[H[s+64>>2]+12>>2]+(f2];if((i|0)==-1){break i}j=H[D>>2];h=H[s+28>>2];o=H[j+(H[h+(i2]2];if((o|0)>=(n|0)){break i}k=i+1|0;k=H[j+(H[h+(((k>>>0)%3|0?k:i-2|0)2]2];if((k|0)>=(n|0)){break i}i=H[j+(H[h+(i+((i>>>0)%3|0?-1:2)2]2];if((i|0)>=(n|0)){break i}j:{if(t){break j}i=N(e,i);j=N(e,k);o=N(e,o);h=0;q=0;if(B){while(1){H[(h2]=(H[(h+i2]+H[(h+j2]|0)-H[(h+o2];k=h|1;H[(k2]=(H[(i+k2]+H[(j+k2]|0)-H[(k+o2];h=h+2|0;q=q+2|0;if((y|0)!=(q|0)){continue}break}}if(z){H[(h2]=(H[(h+i2]+H[(h+j2]|0)-H[(h+o2]}if(t){break j}o=0;h=0;i=0;if(e>>>0>3){while(1){j=h2]=H[j+p>>2]+H[k>>2];k=j|4;q=k+m|0;H[q>>2]=H[k+p>>2]+H[q>>2];k=j|8;q=k+m|0;H[q>>2]=H[k+p>>2]+H[q>>2];j=j|12;k=j+m|0;H[k>>2]=H[j+p>>2]+H[k>>2];h=h+4|0;i=i+4|0;if((F|0)!=(i|0)){continue}break}}if(!A){break j}while(1){i=h2]=H[i+p>>2]+H[j>>2];h=h+1|0;o=o+1|0;if((A|0)!=(o|0)){continue}break}}l=l+1|0}k:{l:{if((f>>>0)%3|0){h=f-1|0;break l}h=f+2|0;i=-1;if((h|0)==-1){break k}}i=-1;if(H[(h>>>3&536870908)+C>>2]>>>h&1){break k}f=H[H[H[s+64>>2]+12>>2]+(h2];i=-1;if((f|0)==-1){break k}i=f-1|0;if((f>>>0)%3|0){break k}i=f+2|0}f=i;if((g|0)!=(f|0)&(f|0)!=-1){continue}break}i=N(e,n);if(!l){break f}if(t){break g}h=0;f=0;if(!B){break h}while(1){g=h2]=H[j>>2]/(l|0);g=(g|4)+m|0;H[g>>2]=H[g>>2]/(l|0);h=h+2|0;f=f+2|0;if((y|0)!=(f|0)){continue}break}break h}Ca();v()}if(!z){break g}f=(h2]=H[f>>2]/(l|0)}if((d|0)>2];h=0;while(1){d=h2];g=H[a+16>>2];m:{if((f|0)>(g|0)){H[d+l>>2]=g;break m}d=d+l|0;g=H[a+12>>2];if((g|0)>(f|0)){H[d>>2]=g;break m}H[d>>2]=f}d=H[a+8>>2];h=h+1|0;if((d|0)>(h|0)){continue}break}f=0;if((d|0)>2]=g;n:{if((g|0)>H[a+16>>2]){g=g-H[a+20>>2]|0}else{if((g|0)>=H[a+12>>2]){break n}g=g+H[a+20>>2]|0}H[d>>2]=g}d=H[a+8>>2];f=f+1|0;if((d|0)>(f|0)){continue}break}break e}if((d|0)>2];o:{if((f|0)>(j|0)){H[d+l>>2]=j;break o}d=d+l|0;j=H[a+12>>2];if((j|0)>(f|0)){H[d>>2]=j;break o}H[d>>2]=f}d=H[a+8>>2];h=h+1|0;if((d|0)>(h|0)){continue}break}f=0;if((d|0)>2]=g;p:{if((g|0)>H[a+16>>2]){g=g-H[a+20>>2]|0}else{if((g|0)>=H[a+12>>2]){break p}g=g+H[a+20>>2]|0}H[d>>2]=g}d=H[a+8>>2];f=f+1|0;if((d|0)>(f|0)){continue}break}}n=n+1|0;if((E|0)!=(n|0)){continue}break}}oa(p);oa(m);return 1}function sj(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0;H[a+8>>2]=e;r=a+32|0;f=H[r>>2];j=H[a+36>>2]-f>>2;a:{if(j>>>0>>0){ya(r,e-j|0);d=H[a+8>>2];break a}d=e;if(e>>>0>=j>>>0){break a}H[a+36>>2]=f+(e1073741823?-1:u;m=ra(pa(f),0,f);p=ra(pa(f),0,f);b:{if((d|0)>2];while(1){f=h2];d=H[a+16>>2];c:{if((j|0)>(d|0)){H[f+i>>2]=d;break c}f=f+i|0;d=H[a+12>>2];if((d|0)>(j|0)){H[f>>2]=d;break c}H[f>>2]=j}d=H[a+8>>2];h=h+1|0;if((d|0)>(h|0)){continue}break}if((d|0)>2]|0;H[d>>2]=j;d:{if((j|0)>H[a+16>>2]){j=j-H[a+20>>2]|0}else{if((j|0)>=H[a+12>>2]){break d}j=j+H[a+20>>2]|0}H[d>>2]=j}d=H[a+8>>2];f=f+1|0;if((d|0)>(f|0)){continue}break}}f=H[a+56>>2];w=H[f>>2];f=H[f+4>>2]-w|0;if((f|0)>=5){D=H[a+52>>2];x=H[a+48>>2];t=f>>>2|0;E=t>>>02];q=0;f=j;while(1){h=H[(f2];i:{if((h|0)==-1){break i}o=H[D>>2];l=H[x>>2];k=H[o+(H[l+(h2]2];i=h+1|0;i=(i>>>0)%3|0?i:h-2|0;if((i|0)!=-1){g=H[l+(i2]}else{g=-1}j:{k:{if((h>>>0)%3|0){h=h-1|0;break k}h=h+2|0;i=-1;if((h|0)==-1){break j}}i=H[l+(h2]}if((k|0)>=(n|0)){break i}g=H[(g2];if((g|0)>=(n|0)){break i}i=H[o+(i2];if((i|0)>=(n|0)){break i}l:{if(s){break l}l=N(e,i);o=N(e,g);k=N(e,k);h=0;i=0;if(B){while(1){H[(h2]=(H[(h+l2]+H[(h+o2]|0)-H[(h+k2];g=h|1;H[(g2]=(H[(g+l2]+H[(g+o2]|0)-H[(g+k2];h=h+2|0;i=i+2|0;if((y|0)!=(i|0)){continue}break}}if(z){H[(h2]=(H[(h+l2]+H[(h+o2]|0)-H[(h+k2]}if(s){break l}o=0;h=0;k=0;if(e>>>0>3){while(1){l=h2]=H[l+p>>2]+H[i>>2];g=l|4;i=g+m|0;H[i>>2]=H[g+p>>2]+H[i>>2];g=l|8;i=g+m|0;H[i>>2]=H[g+p>>2]+H[i>>2];g=l|12;i=g+m|0;H[i>>2]=H[g+p>>2]+H[i>>2];h=h+4|0;k=k+4|0;if((F|0)!=(k|0)){continue}break}}if(!A){break l}while(1){g=h2]=H[g+p>>2]+H[i>>2];h=h+1|0;o=o+1|0;if((A|0)!=(o|0)){continue}break}}q=q+1|0}m:{n:{if((f>>>0)%3|0){h=f-1|0;break n}h=f+2|0;g=-1;if((h|0)==-1){break m}}f=H[(h2];g=-1;if((f|0)==-1){break m}g=f-1|0;if((f>>>0)%3|0){break m}g=f+2|0}f=g;if((j|0)!=(f|0)&(f|0)!=-1){continue}break}g=N(e,n);if(!q){break f}if(s){break g}h=0;f=0;if(!B){break h}while(1){i=h2]=H[j>>2]/(q|0);j=(i|4)+m|0;H[j>>2]=H[j>>2]/(q|0);h=h+2|0;f=f+2|0;if((y|0)!=(f|0)){continue}break}break h}Ca();v()}if(!z){break g}f=(h2]=H[f>>2]/(q|0)}if((d|0)>2];h=0;while(1){f=h2];d=H[a+16>>2];o:{if((j|0)>(d|0)){H[f+k>>2]=d;break o}f=f+k|0;d=H[a+12>>2];if((d|0)>(j|0)){H[f>>2]=d;break o}H[f>>2]=j}d=H[a+8>>2];h=h+1|0;if((d|0)>(h|0)){continue}break}f=0;if((d|0)>2]=g;p:{if((g|0)>H[a+16>>2]){g=g-H[a+20>>2]|0}else{if((g|0)>=H[a+12>>2]){break p}g=g+H[a+20>>2]|0}H[d>>2]=g}d=H[a+8>>2];f=f+1|0;if((d|0)>(f|0)){continue}break}break e}if((d|0)>2];q:{if((i|0)>(d|0)){H[j+k>>2]=d;break q}j=j+k|0;d=H[a+12>>2];if((d|0)>(i|0)){H[j>>2]=d;break q}H[j>>2]=i}d=H[a+8>>2];h=h+1|0;if((d|0)>(h|0)){continue}break}f=0;if((d|0)>2]=g;r:{if((g|0)>H[a+16>>2]){g=g-H[a+20>>2]|0}else{if((g|0)>=H[a+12>>2]){break r}g=g+H[a+20>>2]|0}H[d>>2]=g}d=H[a+8>>2];f=f+1|0;if((d|0)>(f|0)){continue}break}}n=n+1|0;if((E|0)!=(n|0)){continue}break}}oa(p);oa(m);return 1}function xa(a){var b=0,c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0;f=ca-32|0;ca=f;a:{b=H[a+16>>2];b:{if(b>>>0>=341){H[a+16>>2]=b-341;b=H[a+4>>2];j=H[b>>2];c=b+4|0;H[a+4>>2]=c;b=H[a+8>>2];c:{if((b|0)!=H[a+12>>2]){d=b;break c}k=H[a>>2];if(k>>>0>>0){e=((c-k>>2)+1|0)/-22]=d;H[a+4>>2]=e+H[a+4>>2];break c}d=(b|0)==(k|0)?1:b-k>>1;if(d>>>0>=1073741824){break a}e=d>2|0)+1&7;e:{if(!g){b=e;break e}d=0;b=e;while(1){H[b>>2]=H[c>>2];c=c+4|0;b=b+4|0;d=d+1|0;if((g|0)!=(d|0)){continue}break}}d=e+m|0;if(i>>>0>2]=H[c>>2];H[b+4>>2]=H[c+4>>2];H[b+8>>2]=H[c+8>>2];H[b+12>>2]=H[c+12>>2];H[b+16>>2]=H[c+16>>2];H[b+20>>2]=H[c+20>>2];H[b+24>>2]=H[c+24>>2];H[b+28>>2]=H[c+28>>2];c=c+32|0;b=b+32|0;if((d|0)!=(b|0)){continue}break}}H[a+12>>2]=l;H[a+8>>2]=d;H[a+4>>2]=e;H[a>>2]=h;if(!k){break c}oa(k);d=H[a+8>>2]}H[d>>2]=j;H[a+8>>2]=H[a+8>>2]+4;break b}c=H[a+8>>2];b=H[a+4>>2];l=c-b|0;h=l>>2;g=H[a+12>>2];d=H[a>>2];e=g-d|0;if(h>>>0>2>>>0){if((c|0)!=(g|0)){n=f,o=pa(4092),H[n+8>>2]=o;d=a;f:{g:{b=H[a+8>>2];h:{if((b|0)!=H[a+12>>2]){e=b;break h}c=H[d+4>>2];h=H[d>>2];if(c>>>0>h>>>0){g=((c-h>>2)+1|0)/-22]=e;H[d+4>>2]=g+H[d+4>>2];break h}e=(b|0)==(h|0)?1:b-h>>1;if(e>>>0>=1073741824){break g}a=e>2|0)+1&7;j:{if(!g){b=a;break j}e=0;b=a;while(1){H[b>>2]=H[c>>2];c=c+4|0;b=b+4|0;e=e+1|0;if((g|0)!=(e|0)){continue}break}}e=a+m|0;if(i>>>0>2]=H[c>>2];H[b+4>>2]=H[c+4>>2];H[b+8>>2]=H[c+8>>2];H[b+12>>2]=H[c+12>>2];H[b+16>>2]=H[c+16>>2];H[b+20>>2]=H[c+20>>2];H[b+24>>2]=H[c+24>>2];H[b+28>>2]=H[c+28>>2];c=c+32|0;b=b+32|0;if((e|0)!=(b|0)){continue}break}}H[d+12>>2]=l;H[d+8>>2]=e;H[d+4>>2]=a;H[d>>2]=j;if(!h){break h}oa(h);e=H[d+8>>2]}H[e>>2]=H[f+8>>2];H[d+8>>2]=H[d+8>>2]+4;break f}wa();v()}break b}n=f,o=pa(4092),H[n+8>>2]=o;qd(a,f+8|0);b=H[a+4>>2];j=H[b>>2];c=b+4|0;H[a+4>>2]=c;b=H[a+8>>2];k:{if((b|0)!=H[a+12>>2]){d=b;break k}k=H[a>>2];if(k>>>0>>0){e=((c-k>>2)+1|0)/-22]=d;H[a+4>>2]=e+H[a+4>>2];break k}d=(b|0)==(k|0)?1:b-k>>1;if(d>>>0>=1073741824){break a}e=d>2|0)+1&7;m:{if(!g){b=e;break m}d=0;b=e;while(1){H[b>>2]=H[c>>2];c=c+4|0;b=b+4|0;d=d+1|0;if((g|0)!=(d|0)){continue}break}}d=e+m|0;if(i>>>0>2]=H[c>>2];H[b+4>>2]=H[c+4>>2];H[b+8>>2]=H[c+8>>2];H[b+12>>2]=H[c+12>>2];H[b+16>>2]=H[c+16>>2];H[b+20>>2]=H[c+20>>2];H[b+24>>2]=H[c+24>>2];H[b+28>>2]=H[c+28>>2];c=c+32|0;b=b+32|0;if((d|0)!=(b|0)){continue}break}}H[a+12>>2]=l;H[a+8>>2]=d;H[a+4>>2]=e;H[a>>2]=h;if(!k){break k}oa(k);d=H[a+8>>2]}H[d>>2]=j;H[a+8>>2]=H[a+8>>2]+4;break b}H[f+24>>2]=a+12;m=(d|0)==(g|0)?1:e>>1;if(m>>>0>=1073741824){break a}e=m2]=g;j=e+g|0;H[f+20>>2]=j;d=(h2]=d;i=pa(4092);n:{if((h|0)!=(m|0)){break n}if((l|0)>0){d=((h+1|0)/-22]=d;break n}d=(b|0)==(c|0)?1:l>>1;if(d>>>0>=1073741824){break a}b=d2]=e;j=b+e|0;H[f+20>>2]=j;d=e+(d&-4)|0;H[f+12>>2]=d;oa(g);b=H[a+4>>2];c=H[a+8>>2];g=e}H[d>>2]=i;i=d+4|0;H[f+16>>2]=i;e=b;if((b|0)!=(c|0)){while(1){c=c-4|0;qd(f+8|0,c);if(H[a+4>>2]!=(c|0)){continue}break}j=H[f+20>>2];i=H[f+16>>2];d=H[f+12>>2];g=H[f+8>>2];e=c;b=H[a+8>>2]}c=H[a>>2];H[a>>2]=g;H[f+8>>2]=c;H[a+4>>2]=d;H[f+12>>2]=e;H[a+8>>2]=i;H[f+16>>2]=b;d=H[a+12>>2];H[a+12>>2]=j;H[f+20>>2]=d;if((b|0)!=(e|0)){H[f+16>>2]=((e-b|0)+3&-4)+b}if(!c){break b}oa(c)}ca=f+32|0;return}wa();v()}function Aj(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=O(0),j=0,k=0,l=0,m=O(0),n=O(0),o=O(0),p=O(0),q=O(0),r=0,s=O(0),t=O(0),u=O(0),w=O(0),x=0,y=O(0),z=O(0),A=O(0),B=0;a:{b:{if((e|0)!=2){break b}H[a+64>>2]=f;H[a+72>>2]=2;e=pa(8);d=H[a+68>>2];H[a+68>>2]=e;if(d){oa(d)}H[a+8>>2]=2;x=a+32|0;e=H[x>>2];d=H[a+36>>2]-e|0;c:{if(d>>>0>>2|0)|0);break c}if((d|0)==8){break c}H[a+36>>2]=e+8}h=1;d=H[a+56>>2];d=H[d+4>>2]-H[d>>2]|0;if((d|0)>>2|0;B=d>>>0>2];h=H[e>>2];if(H[e+4>>2]-h>>2>>>0>>0){break a}q=O(0);g=ca-48|0;ca=g;e=-1;h=H[h+(d2];f=-1;d:{if((h|0)==-1){break d}e=h+1|0;e=(e>>>0)%3|0?e:h-2|0;f=h-1|0;if((h>>>0)%3|0){break d}f=h+2|0}j=H[a+52>>2];h=H[j>>2];e:{f:{j=H[j+4>>2]-h>>2;l=e2]+28>>2];r=H[l+e>>2];if(j>>>0>>0){break f}e=H[e+(f2];if(e>>>0>=j>>>0){break f}j=H[h+(e2];f=H[h+(r2];g:{if(!((j|0)>=(d|0)|(f|0)>=(d|0))){e=H[a+72>>2];h=(N(e,j)2]);e=(N(e,f)2]);y=O(H[e>>2]);n=O(H[h>>2]);if(!(y!=n|m!=p)){h=+m>2147483647;e=H[a+68>>2];if(O(P(m))>2]=m2147483647;if(O(P(n))>2]=n>2]+(d2];H[g+40>>2]=0;H[g+32>>2]=0;H[g+36>>2]=0;h=H[a+60>>2];if(!I[h+84|0]){e=H[H[h+68>>2]+(e2]}Va(h,e,F[h+24|0],g+32|0);f=H[H[a+64>>2]+(f2];H[g+24>>2]=0;H[g+16>>2]=0;H[g+20>>2]=0;e=H[a+60>>2];if(!I[e+84|0]){f=H[H[e+68>>2]+(f2]}Va(e,f,F[e+24|0],g+16|0);f=H[H[a+64>>2]+(j2];H[g+8>>2]=0;H[g>>2]=0;H[g+4>>2]=0;e=H[a+60>>2];if(!I[e+84|0]){f=H[H[e+68>>2]+(f2]}Va(e,f,F[e+24|0],g);o=L[g+24>>2];s=O(L[g+8>>2]-o);t=L[g+20>>2];u=O(L[g+4>>2]-t);A=L[g+16>>2];w=O(L[g>>2]-A);z=O(O(s*s)+O(O(u*u)+O(O(w*w)+O(0))));h:{if(H[a+88>>2]>=258){i=O(0);if(!(z>O(0))){break h}}i=O(L[g+40>>2]-o);o=O(L[g+36>>2]-t);t=O(L[g+32>>2]-A);q=O(O(O(s*i)+O(O(u*o)+O(O(w*t)+O(0))))/z);i=O(i-O(s*q));s=O(i*i);i=O(o-O(u*q));o=O(i*i);i=O(t-O(w*q));i=O(W(O(O(s+O(o+O(O(i*i)+O(0))))/z)))}f=H[a+80>>2];if(f){e=f-1|0;h=H[H[a+76>>2]+(e>>>3&536870908)>>2];H[a+80>>2]=e;m=O(m-p);o=O(O(m*q)+p);n=O(n-y);p=O(n*i);e=h>>>e&1;p=O(o+(e?p:O(-p)));i=O(i*m);k=T(+O(O(O(n*q)+y)+(e?O(-i):i))+.5);i:{if(k2147483647){e=H[a+68>>2];H[e>>2]=-2147483648;break i}e=H[a+68>>2];if(P(k)>2]=h}k=T(+p+.5);j=k>2147483647;if(P(k)>2]=k(f|0)){e=H[a+72>>2];h=N(f,e);break j}if((d|0)>2]>2];e=0;while(1){H[h+(e2]=0;e=e+1|0;if((e|0)>2]){continue}break}break g}e=H[a+72>>2];h=N(e,d-1|0)}f=1;if((e|0)>2];e=0;while(1){H[j+(e2]=H[(e+h2];e=e+1|0;if((e|0)>2]){continue}break}}ca=g+48|0;break e}Ca();v()}h=f;if(!h){return 0}k:{if(H[a+8>>2]>2];j=H[x>>2];e=0;while(1){f=e2];l=H[a+16>>2];l:{if((g|0)>(l|0)){H[f+j>>2]=l;break l}f=f+j|0;l=H[a+12>>2];if((l|0)>(g|0)){H[f>>2]=l;break l}H[f>>2]=g}e=e+1|0;g=H[a+8>>2];if((e|0)2]=g;m:{if((g|0)>H[a+16>>2]){g=g-H[a+20>>2]|0}else{if((g|0)>=H[a+12>>2]){break m}g=g+H[a+20>>2]|0}H[e>>2]=g}f=f+1|0;if((f|0)>2]){continue}break}}d=d+1|0;if((B|0)!=(d|0)){continue}break}}return h|0}Ca();v()}function kj(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=O(0),j=0,k=0,l=O(0),m=O(0),n=O(0),o=O(0),p=0,q=O(0),r=O(0),s=O(0),t=O(0),u=O(0),w=0,x=O(0),y=O(0),z=0,A=O(0),B=0;a:{b:{if((e|0)!=2){break b}H[a+64>>2]=f;H[a+72>>2]=2;e=pa(8);d=H[a+68>>2];H[a+68>>2]=e;if(d){oa(d)}H[a+8>>2]=2;w=a+32|0;e=H[w>>2];d=H[a+36>>2]-e|0;c:{if(d>>>0>>2|0)|0);break c}if((d|0)==8){break c}H[a+36>>2]=e+8}h=1;d=H[a+56>>2];d=H[d+4>>2]-H[d>>2]|0;if((d|0)>>2|0;B=d>>>0>2];e=H[f>>2];if(H[f+4>>2]-e>>2>>>0>>0){break a}q=O(0);g=ca-48|0;ca=g;h=-1;d:{e:{e=H[e+(d2];if((e|0)==-1){break e}j=H[a+48>>2];f=e+1|0;f=(f>>>0)%3|0?f:e-2|0;if((f|0)!=-1){h=H[H[j>>2]+(f2]}f=-1;e=e+((e>>>0)%3|0?-1:2)|0;if((e|0)!=-1){f=H[H[j>>2]+(e2]}e=H[a+52>>2];j=H[e>>2];e=H[e+4>>2]-j>>2;if(e>>>0>>0|e>>>0>>0){break e}e=H[j+(h2];j=H[j+(f2];f:{if(!((d|0)=(d|0))){f=H[a+72>>2];h=(N(f,j)2]);f=(N(e,f)2]);x=O(H[f>>2]);m=O(H[h>>2]);if(!(x!=m|l!=o)){h=+l>2147483647;e=H[a+68>>2];if(O(P(l))>2]=l2147483647;if(O(P(m))>2]=m>2]+(d2];H[g+40>>2]=0;H[g+32>>2]=0;H[g+36>>2]=0;h=H[a+60>>2];if(!I[h+84|0]){f=H[H[h+68>>2]+(f2]}Va(h,f,F[h+24|0],g+32|0);f=H[H[a+64>>2]+(e2];H[g+24>>2]=0;H[g+16>>2]=0;H[g+20>>2]=0;e=H[a+60>>2];if(!I[e+84|0]){f=H[H[e+68>>2]+(f2]}Va(e,f,F[e+24|0],g+16|0);h=H[H[a+64>>2]+(j2];H[g+8>>2]=0;H[g>>2]=0;H[g+4>>2]=0;e=H[a+60>>2];if(!I[e+84|0]){h=H[H[e+68>>2]+(h2]}Va(e,h,F[e+24|0],g);n=L[g+24>>2];r=O(L[g+8>>2]-n);s=L[g+20>>2];t=O(L[g+4>>2]-s);A=L[g+16>>2];u=O(L[g>>2]-A);y=O(O(r*r)+O(O(t*t)+O(O(u*u)+O(0))));g:{if(H[a+88>>2]>=258){i=O(0);if(!(y>O(0))){break g}}i=O(L[g+40>>2]-n);n=O(L[g+36>>2]-s);s=O(L[g+32>>2]-A);q=O(O(O(r*i)+O(O(t*n)+O(O(u*s)+O(0))))/y);i=O(i-O(r*q));r=O(i*i);i=O(n-O(t*q));n=O(i*i);i=O(s-O(u*q));i=O(W(O(O(r+O(n+O(O(i*i)+O(0))))/y)))}e=H[a+80>>2];if(e){f=e-1|0;h=H[H[a+76>>2]+(f>>>3&536870908)>>2];H[a+80>>2]=f;l=O(l-o);n=O(O(l*q)+o);m=O(m-x);o=O(m*i);f=h>>>f&1;o=O(n+(f?o:O(-o)));i=O(i*l);k=T(+O(O(O(m*q)+x)+(f?O(-i):i))+.5);h:{if(k2147483647){h=H[a+68>>2];H[h>>2]=-2147483648;break h}h=H[a+68>>2];if(P(k)>2]=f}k=T(+o+.5);j=k>2147483647;if(P(k)>2]=k(e|0)){f=H[a+72>>2];e=N(e,f);break i}if((d|0)>2]>2];f=0;while(1){H[e+(f2]=0;f=f+1|0;if((f|0)>2]){continue}break}break f}f=H[a+72>>2];e=N(f,d-1|0)}h=1;if((f|0)>2];f=0;while(1){H[j+(f2]=H[(e+f2];f=f+1|0;if((f|0)>2]){continue}break}}ca=g+48|0;break d}Ca();v()}if(!h){return 0}j:{if(H[a+8>>2]>2];j=H[w>>2];e=0;while(1){f=e2];p=H[a+16>>2];k:{if((g|0)>(p|0)){H[f+j>>2]=p;break k}f=f+j|0;p=H[a+12>>2];if((p|0)>(g|0)){H[f>>2]=p;break k}H[f>>2]=g}e=e+1|0;g=H[a+8>>2];if((e|0)2]=g;l:{if((g|0)>H[a+16>>2]){g=g-H[a+20>>2]|0}else{if((g|0)>=H[a+12>>2]){break l}g=g+H[a+20>>2]|0}H[e>>2]=g}f=f+1|0;if((f|0)>2]){continue}break}}d=d+1|0;if((B|0)!=(d|0)){continue}break}}return h|0}Ca();v()}function Of(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0;f=ca-704|0;ca=f;n=1;a:{b:{c:{d:{if(J[b+38>>1]>2];d=H[b+12>>2];g=H[b+16>>2];if((c|0)>=(d|0)&g>>>0>=K[b+8>>2]|(c|0)>(d|0)){break d}p=I[H[b>>2]+g|0];g=g+1|0;c=g?c:c+1|0;H[b+16>>2]=g;H[b+20>>2]=c;g=H[H[(ea[H[H[a>>2]+28>>2]](a)|0)+4>>2]+80>>2];c=ea[H[H[a>>2]+24>>2]](a)|0;H[f+40>>2]=0;H[f+32>>2]=0;H[f+36>>2]=0;if(c){if(c>>>0>=214748365){break c}c=N(c,20);d=pa(c);H[f+32>>2]=d;H[f+40>>2]=c+d;c=c-20|0;c=(c-((c>>>0)%20|0)|0)+20|0;q=f,r=ra(d,0,c)+c|0,H[q+36>>2]=r}e:{if((ea[H[H[a>>2]+24>>2]](a)|0)>0){while(1){c=ea[H[H[a>>2]+20>>2]](a,l)|0;c=H[H[H[(ea[H[H[a>>2]+28>>2]](a)|0)+4>>2]+8>>2]+(c2];mb(c,g);F[c+84|0]=1;H[c+72>>2]=H[c+68>>2];d=H[c+28>>2];if(d>>>0>9){break e}f:{g:{h:{e=12],d,6,0,i,i>>31);c=jc(pa(96),e);H[f>>2]=c;F[c+84|0]=1;H[c+72>>2]=H[c+68>>2];mb(c,g);c=H[a+64>>2];if(c>>>0>=K[a+68>>2]){break h}d=H[f>>2];H[f>>2]=0;H[c>>2]=d;c=c+4|0;H[a+64>>2]=c;break g}j=0;if(!I[c+24|0]){break f}while(1){d=H[a+52>>2];i=H[a+56>>2];i:{if(d>>>0>>0){H[d>>2]=0;H[a+52>>2]=d+4;break i}e=d;d=H[a+48>>2];m=e-d|0;k=m>>2;e=k+1|0;if(e>>>0>=1073741824){break b}o=k>1|0;e=i>>>0>=2147483644?1073741823:e>>>0>>0?k:e;if(e){if(e>>>0>=1073741824){break a}i=pa(e2]=0;o=e2]=o+e;H[a+52>>2]=k+4;H[a+48>>2]=e;if(!d){break i}oa(d)}j=j+1|0;if(j>>>0>2];i=H[a+64>>2]-e>>2;d=i+1|0;if(d>>>0>2]-e|0;j=e>>>1|0;e=e>>>0>=2147483644?1073741823:d>>>0>>0?j:d;if(e){if(e>>>0>=1073741824){break l}c=pa(e2];H[f>>2]=0;d=(i2]=j;e=(e2];j=H[a+60>>2];if((c|0)==(j|0)){break k}while(1){c=c-4|0;m=H[c>>2];H[c>>2]=0;d=d-4|0;H[d>>2]=m;if((c|0)!=(j|0)){continue}break}H[a+68>>2]=e;e=H[a+64>>2];H[a+64>>2]=i;c=H[a+60>>2];H[a+60>>2]=d;if((c|0)==(e|0)){break j}while(1){e=e-4|0;d=H[e>>2];H[e>>2]=0;if(d){Ga(d)}if((c|0)!=(e|0)){continue}break}break j}sa();v()}wa();v()}H[a+68>>2]=e;H[a+64>>2]=i;H[a+60>>2]=d}if(c){oa(c)}c=H[a+64>>2]}c=H[c-4>>2];d=H[f>>2];H[f>>2]=0;if(!d){break f}Ga(d)}i=H[c+28>>2];d=i-1|0;if(d>>>0>2]+N(l,20)|0;j=I[c+24|0];H[d+16>>2]=j;H[d+12>>2]=(e|0)>0?e:0;H[d+8>>2]=i;H[d+4>>2]=h;H[d>>2]=c;h=h+j|0;l=l+1|0;if((ea[H[H[a>>2]+24>>2]](a)|0)>(l|0)){continue}break}}a=Ac(f,f+32|0);m:{n:{o:{switch(p|0){case 0:c=wb(f+48|0,h);b=Bd(c,b,a,g);h=H[c+8>>2];xb(c);if(!b){break m}if((h|0)==(g|0)){break n}break m;case 1:c=wb(f+48|0,h);b=zd(c,b,a,g);h=H[c+8>>2];xb(c);if(!b){break m}if((h|0)==(g|0)){break n}break m;case 2:c=ub(f+48|0,h);b=yd(c,b,a,g);h=H[c+8>>2];vb(c);if(!b){break m}if((h|0)==(g|0)){break n}break m;case 3:c=ub(f+48|0,h);b=xd(c,b,a,g);h=H[c+8>>2];vb(c);if(!b){break m}if((h|0)==(g|0)){break n}break m;case 4:c=$a(f+48|0,h);b=wd(c,b,a,g);h=H[c+8>>2];ab(c);if(!b){break m}if((h|0)==(g|0)){break n}break m;case 5:c=$a(f+48|0,h);b=vd(c,b,a,g);h=H[c+8>>2];ab(c);if(!b){break m}if((h|0)==(g|0)){break n}break m;case 6:break o;default:break m}}c=$a(f+48|0,h);b=ud(c,b,a,g);h=H[c+8>>2];ab(c);if(!b|(h|0)!=(g|0)){break m}}n=1}b=H[a+16>>2];if(b){H[a+20>>2]=b;oa(b)}b=H[a>>2];if(!b){break e}H[a+4>>2]=b;oa(b)}a=H[f+32>>2];if(!a){break d}H[f+36>>2]=a;oa(a)}ca=f+704|0;return n|0}sa();v()}sa();v()}wa();v()}function Zi(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0,i=0;e=ca-32|0;ca=e;a:{b:{switch(c-2|0){case 0:c=H[a+4>>2];f=H[a+12>>2];H[e+24>>2]=-1;H[e+16>>2]=-1;H[e+20>>2]=1065353216;H[e+8>>2]=-1;H[e+12>>2]=-1;if((b|0)==-2){break a}i=H[H[H[c+4>>2]+8>>2]+(f2];if((ea[H[H[c>>2]+8>>2]](c)|0)==1){h=H[H[H[c+4>>2]+8>>2]+(f2];c:{if((ea[H[H[c>>2]+8>>2]](c)|0)!=1|b-1>>>0>5){break c}g=ea[H[H[c>>2]+36>>2]](c)|0;a=ea[H[H[c>>2]+44>>2]](c,f)|0;if(!g|!a){break c}f=ea[H[H[c>>2]+40>>2]](c,f)|0;d:{if(f){if((b|0)!=6){break c}b=H[c+44>>2];d=pa(112);H[d+4>>2]=h;c=H[e+12>>2];H[d+8>>2]=H[e+8>>2];H[d+12>>2]=c;c=H[e+20>>2];H[d+16>>2]=H[e+16>>2];H[d+20>>2]=c;H[d+24>>2]=H[e+24>>2];H[d+40>>2]=a;c=a+12|0;H[d+36>>2]=c;H[d+32>>2]=f;H[d+28>>2]=b;H[d+68>>2]=a;H[d- -64>>2]=c;H[d+60>>2]=f;H[d+56>>2]=b;H[d+48>>2]=0;H[d+52>>2]=0;H[d>>2]=7144;H[d+88>>2]=1065353216;H[d+92>>2]=-1;H[d+80>>2]=-1;H[d+84>>2]=-1;H[d+72>>2]=1;H[d+76>>2]=-1;H[d+44>>2]=7668;a=d+96|0;break d}if((b|0)!=6){break c}b=H[c+44>>2];d=pa(112);H[d+4>>2]=h;c=H[e+12>>2];H[d+8>>2]=H[e+8>>2];H[d+12>>2]=c;c=H[e+20>>2];H[d+16>>2]=H[e+16>>2];H[d+20>>2]=c;H[d+24>>2]=H[e+24>>2];H[d+40>>2]=a;c=a+12|0;H[d+36>>2]=c;H[d+32>>2]=g;H[d+28>>2]=b;H[d+68>>2]=a;H[d- -64>>2]=c;H[d+60>>2]=g;H[d+56>>2]=b;H[d+48>>2]=0;H[d+52>>2]=0;H[d>>2]=8080;H[d+88>>2]=1065353216;H[d+92>>2]=-1;H[d+80>>2]=-1;H[d+84>>2]=-1;H[d+72>>2]=1;H[d+76>>2]=-1;H[d+44>>2]=8472;a=d+96|0}H[a>>2]=0;H[a+4>>2]=0;F[a+5|0]=0;F[a+6|0]=0;F[a+7|0]=0;F[a+8|0]=0;F[a+9|0]=0;F[a+10|0]=0;F[a+11|0]=0;F[a+12|0]=0}if(d){break a}}d=pa(28);H[d+4>>2]=i;a=H[e+12>>2];H[d+8>>2]=H[e+8>>2];H[d+12>>2]=a;a=H[e+20>>2];H[d+16>>2]=H[e+16>>2];H[d+20>>2]=a;H[d+24>>2]=H[e+24>>2];H[d>>2]=8860;break a;case 1:break b;default:break a}}c=H[a+4>>2];f=H[a+12>>2];H[e+24>>2]=-1;H[e+16>>2]=-1;H[e+20>>2]=1065353216;H[e+8>>2]=-1;H[e+12>>2]=-1;if((b|0)==-2){break a}i=H[H[H[c+4>>2]+8>>2]+(f2];if((ea[H[H[c>>2]+8>>2]](c)|0)==1){h=H[H[H[c+4>>2]+8>>2]+(f2];e:{if((ea[H[H[c>>2]+8>>2]](c)|0)!=1|b-1>>>0>5){break e}g=ea[H[H[c>>2]+36>>2]](c)|0;a=ea[H[H[c>>2]+44>>2]](c,f)|0;if(!g|!a){break e}f=ea[H[H[c>>2]+40>>2]](c,f)|0;f:{if(f){if((b|0)!=6){break e}b=H[c+44>>2];d=pa(112);H[d+4>>2]=h;c=H[e+12>>2];H[d+8>>2]=H[e+8>>2];H[d+12>>2]=c;c=H[e+20>>2];H[d+16>>2]=H[e+16>>2];H[d+20>>2]=c;H[d+24>>2]=H[e+24>>2];H[d+40>>2]=a;c=a+12|0;H[d+36>>2]=c;H[d+32>>2]=f;H[d+28>>2]=b;H[d+68>>2]=a;H[d- -64>>2]=c;H[d+60>>2]=f;H[d+56>>2]=b;H[d+48>>2]=0;H[d+52>>2]=0;H[d>>2]=9028;H[d+88>>2]=1065353216;H[d+92>>2]=-1;H[d+80>>2]=-1;H[d+84>>2]=-1;H[d+72>>2]=1;H[d+76>>2]=-1;H[d+44>>2]=9592;a=d+96|0;break f}if((b|0)!=6){break e}b=H[c+44>>2];d=pa(112);H[d+4>>2]=h;c=H[e+12>>2];H[d+8>>2]=H[e+8>>2];H[d+12>>2]=c;c=H[e+20>>2];H[d+16>>2]=H[e+16>>2];H[d+20>>2]=c;H[d+24>>2]=H[e+24>>2];H[d+40>>2]=a;c=a+12|0;H[d+36>>2]=c;H[d+32>>2]=g;H[d+28>>2]=b;H[d+68>>2]=a;H[d- -64>>2]=c;H[d+60>>2]=g;H[d+56>>2]=b;H[d+48>>2]=0;H[d+52>>2]=0;H[d>>2]=10032;H[d+88>>2]=1065353216;H[d+92>>2]=-1;H[d+80>>2]=-1;H[d+84>>2]=-1;H[d+72>>2]=1;H[d+76>>2]=-1;H[d+44>>2]=10452;a=d+96|0}H[a>>2]=0;H[a+4>>2]=0;F[a+5|0]=0;F[a+6|0]=0;F[a+7|0]=0;F[a+8|0]=0;F[a+9|0]=0;F[a+10|0]=0;F[a+11|0]=0;F[a+12|0]=0}if(d){break a}}d=pa(28);H[d+4>>2]=i;a=H[e+12>>2];H[d+8>>2]=H[e+8>>2];H[d+12>>2]=a;a=H[e+20>>2];H[d+16>>2]=H[e+16>>2];H[d+20>>2]=a;H[d+24>>2]=H[e+24>>2];H[d>>2]=10864}ca=e+32|0;return d|0}function Ki(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=O(0),f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=O(0),p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0;if(H[c>>2]==H[c+4>>2]){m=H[d+80>>2];u=ca-16|0;ca=u;g=H[a+4>>2];k=I[b+24|0];h=H[d+48>>2];n=H[H[d>>2]>>2];c=u+8|0;H[c>>2]=1065353216;d=c;L[c>>2]=O(-12];c=pa(k2];n=H[a+8>>2];v=H[b>>2];d=H[b+48>>2];g=H[b+40>>2];w=H[b+44>>2];if(!I[b+84|0]){f=H[b+68>>2];s=k&254;t=k&1;a=0;while(1){b=H[v>>2];l=Rj(g,w,H[f+(i2],0)+d|0;h=qa(c,b+l|0,g);b=0;q=0;if((k|0)!=1){while(1){l=p+(a2]))+O(.5))));b:{if(O(P(e))>2]=r;j=j|4;e=O(T(O(O(o*O(L[j+h>>2]-L[n+j>>2]))+O(.5))));c:{if(O(P(e))>2]=j;b=b+2|0;a=a+2|0;q=q+2|0;if((s|0)!=(q|0)){continue}break}}if(t){l=p+(a2]))+O(.5))));d:{if(O(P(e))>2]=b;a=a+1|0}i=i+1|0;if((m|0)!=(i|0)){continue}break}break a}s=k&254;t=k&1;a=0;while(1){b=H[v>>2];h=Rj(g,w,i,l)+d|0;j=qa(c,b+h|0,g);b=0;q=0;if((k|0)!=1){while(1){h=p+(a2]))+O(.5))));e:{if(O(P(e))>2]=r;f=f|4;e=O(T(O(O(o*O(L[f+j>>2]-L[f+n>>2]))+O(.5))));f:{if(O(P(e))>2]=f;b=b+2|0;a=a+2|0;q=q+2|0;if((s|0)!=(q|0)){continue}break}}if(t){h=p+(a2]))+O(.5))));g:{if(O(P(e))>2]=b;a=a+1|0}b=l;i=i+1|0;b=i?b:b+1|0;l=b;if((i|0)!=(m|0)|b){continue}break}}oa(c);ca=u+16|0;return 1}j=ca-16|0;ca=j;m=H[a+4>>2];i=I[b+24|0];g=H[d+48>>2];h=H[H[d>>2]>>2];d=j+8|0;H[d>>2]=1065353216;l=d;L[d>>2]=O(-12];d=pa(i2];q=H[c>>2];h:{if(!i|(m|0)==(q|0)){break h}n=h+g|0;c=m-q>>2;u=c>>>0>2];h=H[a+8>>2];v=H[b>>2];l=H[b+48>>2];m=H[b+40>>2];w=H[b+44>>2];if(I[b+84|0]){s=i&254;t=i&1;a=0;c=0;while(1){b=H[v>>2];g=Rj(m,w,H[q+(c2],0)+l|0;p=qa(d,b+g|0,m);b=0;k=0;if((i|0)!=1){while(1){g=n+(a2]))+O(.5))));i:{if(O(P(e))>2]=r;f=f|4;e=O(T(O(O(o*O(L[f+p>>2]-L[h+f>>2]))+O(.5))));j:{if(O(P(e))>2]=f;b=b+2|0;a=a+2|0;k=k+2|0;if((s|0)!=(k|0)){continue}break}}if(t){g=n+(a2]))+O(.5))));k:{if(O(P(e))>2]=b;a=a+1|0}c=c+1|0;if((u|0)!=(c|0)){continue}break}break h}s=H[b+68>>2];t=i&254;x=i&1;a=0;c=0;while(1){b=H[v>>2];g=Rj(m,w,H[s+(H[q+(c2]2],0)+l|0;p=qa(d,b+g|0,m);b=0;k=0;if((i|0)!=1){while(1){g=n+(a2]))+O(.5))));l:{if(O(P(e))>2]=r;f=f|4;e=O(T(O(O(o*O(L[f+p>>2]-L[h+f>>2]))+O(.5))));m:{if(O(P(e))>2]=f;b=b+2|0;a=a+2|0;k=k+2|0;if((t|0)!=(k|0)){continue}break}}if(x){g=n+(a2]))+O(.5))));n:{if(O(P(e))>2]=b;a=a+1|0}c=c+1|0;if((u|0)!=(c|0)){continue}break}}oa(d);ca=j+16|0;return 1}function dd(a,b){var c=0,d=0,e=0,f=0,g=0,h=0,i=0;c=H[a+4>>2];e=H[a>>2];f=(c-e|0)/144|0;if(f>>>0>>0){e=a;b=b-f|0;h=H[a+8>>2];c=H[a+4>>2];a:{if(b>>>0>>0){b:{if(!b){break b}a=c;f=b&7;if(f){while(1){Ia(a);a=a+144|0;d=d+1|0;if((f|0)!=(d|0)){continue}break}}c=N(b,144)+c|0;if((b-1&268435455)>>>0>2]=c;break a}c:{d:{e:{a=c;c=H[e>>2];i=(a-c|0)/144|0;a=i+b|0;if(a>>>00>=14913080?29826161:a>>>0>>0?f:a;if(f){if(f>>>0>=29826162){break e}g=pa(N(f,144))}c=N(i,144)+g|0;a=c;h=b&7;if(h){while(1){Ia(a);a=a+144|0;d=d+1|0;if((h|0)!=(d|0)){continue}break}}h=N(b,144)+c|0;if((b-1&268435455)>>>0>=7){while(1){Ia(a);Ia(a+144|0);Ia(a+288|0);Ia(a+432|0);Ia(a+576|0);Ia(a+720|0);Ia(a+864|0);Ia(a+1008|0);a=a+1152|0;if((h|0)!=(a|0)){continue}break}}b=N(f,144)+g|0;d=H[e+4>>2];f=H[e>>2];if((d|0)==(f|0)){break d}while(1){c=c-144|0;d=d-144|0;a=d;H[c>>2]=H[a>>2];H[c+4>>2]=H[a+4>>2];H[c+8>>2]=H[a+8>>2];H[c+12>>2]=H[a+12>>2];H[a+12>>2]=0;H[a+4>>2]=0;H[a+8>>2]=0;H[c+16>>2]=H[a+16>>2];H[c+20>>2]=H[a+20>>2];H[c+24>>2]=H[a+24>>2];H[a+24>>2]=0;H[a+16>>2]=0;H[a+20>>2]=0;g=I[a+28|0];H[c+40>>2]=0;H[c+32>>2]=0;H[c+36>>2]=0;F[c+28|0]=g;H[c+32>>2]=H[a+32>>2];H[c+36>>2]=H[a+36>>2];H[c+40>>2]=H[a+40>>2];H[a+40>>2]=0;H[a+32>>2]=0;H[a+36>>2]=0;H[c+52>>2]=0;H[c+44>>2]=0;H[c+48>>2]=0;H[c+44>>2]=H[a+44>>2];H[c+48>>2]=H[a+48>>2];H[c+52>>2]=H[a+52>>2];H[a+52>>2]=0;H[a+44>>2]=0;H[a+48>>2]=0;g=c- -64|0;H[g>>2]=0;H[c+56>>2]=0;H[c+60>>2]=0;H[c+56>>2]=H[a+56>>2];H[c+60>>2]=H[a+60>>2];i=g;g=a- -64|0;H[i>>2]=H[g>>2];H[g>>2]=0;H[a+56>>2]=0;H[a+60>>2]=0;H[c+68>>2]=H[a+68>>2];g=H[a+72>>2];H[c+84>>2]=0;H[c+76>>2]=0;H[c+80>>2]=0;H[c+72>>2]=g;H[c+76>>2]=H[a+76>>2];H[c+80>>2]=H[a+80>>2];H[c+84>>2]=H[a+84>>2];H[a+84>>2]=0;H[a+76>>2]=0;H[a+80>>2]=0;H[c+96>>2]=0;H[c+88>>2]=0;H[c+92>>2]=0;H[c+88>>2]=H[a+88>>2];H[c+92>>2]=H[a+92>>2];H[c+96>>2]=H[a+96>>2];H[a+96>>2]=0;H[a+88>>2]=0;H[a+92>>2]=0;g=I[a+100|0];H[c+112>>2]=0;H[c+104>>2]=0;H[c+108>>2]=0;F[c+100|0]=g;H[c+104>>2]=H[a+104>>2];H[c+108>>2]=H[a+108>>2];H[c+112>>2]=H[a+112>>2];H[a+112>>2]=0;H[a+104>>2]=0;H[a+108>>2]=0;H[c+124>>2]=0;H[c+116>>2]=0;H[c+120>>2]=0;H[c+116>>2]=H[a+116>>2];H[c+120>>2]=H[a+120>>2];H[c+124>>2]=H[a+124>>2];H[a+124>>2]=0;H[a+116>>2]=0;H[a+120>>2]=0;g=H[a+128>>2];H[c+140>>2]=0;H[c+132>>2]=0;H[c+136>>2]=0;H[c+128>>2]=g;H[c+132>>2]=H[a+132>>2];H[c+136>>2]=H[a+136>>2];H[c+140>>2]=H[a+140>>2];H[a+140>>2]=0;H[a+132>>2]=0;H[a+136>>2]=0;if((a|0)!=(f|0)){continue}break}H[e+8>>2]=b;a=H[e+4>>2];H[e+4>>2]=h;d=H[e>>2];H[e>>2]=c;if((a|0)==(d|0)){break c}while(1){b=a-144|0;c=H[b+132>>2];if(c){H[a-8>>2]=c;oa(c)}c=H[a-28>>2];if(c){H[a-24>>2]=c;oa(c)}c=H[a-40>>2];if(c){H[a-36>>2]=c;oa(c)}oc(a-140|0);a=b;if((d|0)!=(a|0)){continue}break}break c}sa();v()}wa();v()}H[e+8>>2]=b;H[e+4>>2]=h;H[e>>2]=c}if(d){oa(d)}}return}if(b>>>0>>0){e=e+N(b,144)|0;if((e|0)!=(c|0)){while(1){b=c-144|0;d=H[b+132>>2];if(d){H[c-8>>2]=d;oa(d)}d=H[c-28>>2];if(d){H[c-24>>2]=d;oa(d)}d=H[c-40>>2];if(d){H[c-36>>2]=d;oa(d)}oc(c-140|0);c=b;if((e|0)!=(c|0)){continue}break}}H[a+4>>2]=e}}function Pe(a,b,c,d){var e=0,f=0,g=0,h=0,i=0,j=0;f=ca-80|0;ca=f;e=H[c+36>>2];H[f+72>>2]=H[c+32>>2];H[f+76>>2]=e;g=H[c+28>>2];e=f- -64|0;H[e>>2]=H[c+24>>2];H[e+4>>2]=g;e=H[c+20>>2];H[f+56>>2]=H[c+16>>2];H[f+60>>2]=e;e=H[c+12>>2];H[f+48>>2]=H[c+8>>2];H[f+52>>2]=e;e=H[c+4>>2];H[f+40>>2]=H[c>>2];H[f+44>>2]=e;nc(a,f+40|0,f+24|0);a:{if(H[a>>2]){break a}if(F[a+15|0]>2])}if(I[f+31|0]){b=pa(32);F[b+27|0]=0;c=I[1521]|I[1522]16;F[b+26|0]=c>>>24;c=I[1518]|I[1519]8;F[b+22|0]=c>>>16;F[b+23|0]=c>>>24;c=I[1510]|I[1511]8;F[b+14|0]=c>>>16;F[b+15|0]=c>>>24;c=I[1502]|I[1503]8;F[b+6|0]=c>>>16;F[b+7|0]=c>>>24;H[a>>2]=-1;za(a+4|0,b,27);oa(b);break a}i=ca-16|0;ca=i;b:{c:{switch(F[f+32|0]){case 0:e=pa(44);H[e>>2]=0;H[e+4>>2]=0;H[e+40>>2]=0;H[e+32>>2]=0;H[e+36>>2]=0;H[e+24>>2]=0;H[e+28>>2]=0;H[e+16>>2]=0;H[e+20>>2]=0;H[e+8>>2]=0;H[e+12>>2]=0;e=Vc(e);H[e>>2]=13496;H[f+8>>2]=0;H[f+12>>2]=0;H[f>>2]=0;H[f+4>>2]=0;H[f+16>>2]=e;break b;case 1:e=pa(44);H[e>>2]=0;H[e+4>>2]=0;H[e+40>>2]=0;H[e+32>>2]=0;H[e+36>>2]=0;H[e+24>>2]=0;H[e+28>>2]=0;H[e+16>>2]=0;H[e+20>>2]=0;H[e+8>>2]=0;H[e+12>>2]=0;e=Vc(e);H[e>>2]=13404;H[f+8>>2]=0;H[f+12>>2]=0;H[f>>2]=0;H[f+4>>2]=0;H[f+16>>2]=e;break b;default:break c}}g=pa(32);F[g+28|0]=0;e=I[1550]|I[1551]16;F[g+27|0]=e>>>24;e=I[1546]|I[1547]8;F[g+22|0]=e>>>16;F[g+23|0]=e>>>24;e=I[1538]|I[1539]8;F[g+14|0]=e>>>16;F[g+15|0]=e>>>24;e=I[1530]|I[1531]8;F[g+6|0]=e>>>16;F[g+7|0]=e>>>24;H[i>>2]=-1;e=i|4;za(e,g,28);j=F[i+15|0];H[f>>2]=H[i>>2];h=f+4|0;d:{if((j|0)>=0){j=H[e+4>>2];H[h>>2]=H[e>>2];H[h+4>>2]=j;H[h+8>>2]=H[e+8>>2];H[f+16>>2]=0;break d}za(h,H[i+4>>2],H[i+8>>2]);e=F[i+15|0];H[f+16>>2]=0;if((e|0)>=0){break d}oa(H[i+4>>2])}oa(g)}ca=i+16|0;e=H[f>>2];e:{if(e){H[a>>2]=e;a=a+4|0;if(F[f+15|0]>=0){b=f|4;c=H[b+4>>2];H[a>>2]=H[b>>2];H[a+4>>2]=c;H[a+8>>2]=H[b+8>>2];break e}za(a,H[f+4>>2],H[f+8>>2]);break e}e=H[f+16>>2];H[f+16>>2]=0;te(a,e,b,c,d);if(!H[a>>2]){if(F[a+15|0]>2])}H[a>>2]=0;H[a+4>>2]=0;H[a+8>>2]=0;H[a+12>>2]=0}ea[H[H[e>>2]+4>>2]](e)}a=H[f+16>>2];H[f+16>>2]=0;if(a){ea[H[H[a>>2]+4>>2]](a)}if(F[f+15|0]>=0){break a}oa(H[f+4>>2])}ca=f+80|0}function Ic(a){var b=0,c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0;H[a+56>>2]=H[a+52>>2];H[a+44>>2]=H[a+40>>2];b=H[a+64>>2];c=H[b+24>>2];if((c|0)==H[b+28>>2]){return 1}a:{b:{c:{while(1){g=i;i=H[(k2];d:{if((i|0)==-1){i=g;break d}b=H[a+56>>2];e:{if((b|0)!=H[a+60>>2]){H[b>>2]=g;H[a+56>>2]=b+4;break e}d=H[a+52>>2];e=b-d|0;h=e>>2;c=h+1|0;if(c>>>0>=1073741824){break c}f=e>>>1|0;f=e>>>0>=2147483644?1073741823:c>>>0>>0?f:c;if(f){if(f>>>0>=1073741824){break b}e=pa(f2]=H[b>>2];if((b|0)!=(d|0)){continue}break}}H[a+60>>2]=e+(f2]=h;H[a+52>>2]=c;if(!d){break e}oa(d)}f:{g:{if(!(H[H[a+12>>2]+(k>>>3&536870908)>>2]>>>k&1)){break g}e=i+1|0;e=(e>>>0)%3|0?e:i-2|0;if((e|0)==-1|H[H[a>>2]+(e>>>3&536870908)>>2]>>>e&1){break g}e=H[H[H[a+64>>2]+12>>2]+(e2];if((e|0)==-1){break g}b=e+1|0;b=(b>>>0)%3|0?b:e-2|0;if((b|0)==-1){break g}c=H[a+64>>2];f=H[a>>2];while(1){e=b;b=-1;d=e+1|0;d=(d>>>0)%3|0?d:e-2|0;h:{if((d|0)==-1|H[f+(d>>>3&536870908)>>2]>>>d&1){break h}d=H[H[c+12>>2]+(d2];if((d|0)==-1){break h}b=d+1|0;b=(b>>>0)%3|0?b:d-2|0}if((b|0)!=(i|0)){if((b|0)==-1){break f}continue}break}return 0}e=i}H[H[a+28>>2]+(e2]=g;b=H[a+44>>2];i:{if((b|0)!=H[a+48>>2]){H[b>>2]=e;H[a+44>>2]=b+4;break i}d=H[a+40>>2];i=b-d|0;h=i>>2;c=h+1|0;if(c>>>0>=1073741824){break a}f=i>>>1|0;f=i>>>0>=2147483644?1073741823:c>>>0>>0?f:c;if(f){if(f>>>0>=1073741824){break b}i=pa(f2]=H[b>>2];if((b|0)!=(d|0)){continue}break}}H[a+48>>2]=i+(f2]=h;H[a+40>>2]=c;if(!d){break i}oa(d)}i=g+1|0;b=H[a+64>>2];if((e|0)==-1){break d}j:{if((e>>>0)%3|0){c=e-1|0;break j}c=e+2|0;if((c|0)==-1){break d}}d=H[H[b+12>>2]+(c2];if((d|0)==-1){break d}f=d+((d>>>0)%3|0?-1:2)|0;if((f|0)==-1|(e|0)==(f|0)){break d}while(1){b=f+1|0;b=(b>>>0)%3|0?b:f-2|0;if(H[H[a>>2]+(b>>>3&536870908)>>2]>>>b&1){b=H[a+56>>2];k:{if((b|0)!=H[a+60>>2]){H[b>>2]=i;H[a+56>>2]=b+4;break k}d=H[a+52>>2];g=b-d|0;j=g>>2;c=j+1|0;if(c>>>0>=1073741824){break c}h=g>>>1|0;h=g>>>0>=2147483644?1073741823:c>>>0>>0?h:c;if(h){if(h>>>0>=1073741824){break b}g=pa(h2]=H[b>>2];if((b|0)!=(d|0)){continue}break}}H[a+60>>2]=g+(h2]=j;H[a+52>>2]=c;if(!d){break k}oa(d)}d=i+1|0;b=H[a+44>>2];l:{if((b|0)!=H[a+48>>2]){H[b>>2]=f;H[a+44>>2]=b+4;break l}h=H[a+40>>2];g=b-h|0;l=g>>2;c=l+1|0;if(c>>>0>=1073741824){break a}j=g>>>1|0;j=g>>>0>=2147483644?1073741823:c>>>0>>0?j:c;if(j){if(j>>>0>=1073741824){break b}g=pa(j2]=H[b>>2];if((b|0)!=(h|0)){continue}break}}H[a+48>>2]=g+(j2]=l;H[a+40>>2]=c;if(!h){break l}oa(h)}g=i;i=d}H[H[a+28>>2]+(f2]=g;b=H[a+64>>2];m:{if((f>>>0)%3|0){c=f-1|0;break m}c=f+2|0;if((c|0)==-1){break d}}d=H[H[b+12>>2]+(c2];if((d|0)==-1){break d}f=d+((d>>>0)%3|0?-1:2)|0;if((f|0)==-1){break d}if((e|0)!=(f|0)){continue}break}}k=k+1|0;c=H[b+24>>2];if(k>>>0>2]-c>>2>>>0){continue}break}return 1}sa();v()}wa();v()}sa();v()}function ti(a){a=a|0;var b=0,c=0,d=0,e=0;c=H[a+32>>2];d=H[c+16>>2];e=H[c+12>>2];b=H[c+20>>2];if(K[c+8>>2]>d>>>0&(e|0)>=(b|0)|(b|0)>2]+d|0];d=d+1|0;b=d?b:b+1|0;H[c+16>>2]=d;H[c+20>>2]=b;b=H[a+48>>2];H[a+48>>2]=0;if(b){ea[H[H[b>>2]+4>>2]](b)}a:{b:{c:{d:{switch(e|0){case 0:b=pa(384);H[b>>2]=11384;ra(b+4|0,0,80);H[b+96>>2]=0;H[b+100>>2]=0;H[b+92>>2]=-1;H[b+84>>2]=-1;H[b+88>>2]=-1;H[b+104>>2]=0;H[b+108>>2]=0;H[b+112>>2]=0;H[b+116>>2]=0;H[b+120>>2]=0;H[b+124>>2]=0;H[b+128>>2]=0;H[b+132>>2]=0;H[b+136>>2]=0;H[b+140>>2]=0;H[b+144>>2]=0;H[b+148>>2]=0;H[b+156>>2]=0;H[b+160>>2]=0;H[b+152>>2]=1065353216;H[b+164>>2]=0;H[b+168>>2]=0;H[b+172>>2]=0;H[b+176>>2]=0;H[b+180>>2]=0;H[b+184>>2]=0;H[b+188>>2]=0;H[b+192>>2]=0;H[b+196>>2]=0;H[b+200>>2]=0;H[b+204>>2]=0;H[b+208>>2]=0;H[b+212>>2]=-1;H[b+216>>2]=0;H[b+220>>2]=0;H[b+224>>2]=0;Ha(b+232|0);Ha(b+272|0);c=b+312|0;H[c>>2]=0;H[c+4>>2]=0;F[c+5|0]=0;F[c+6|0]=0;F[c+7|0]=0;F[c+8|0]=0;F[c+9|0]=0;F[c+10|0]=0;F[c+11|0]=0;F[c+12|0]=0;Ha(b+328|0);H[b+376>>2]=0;H[b+368>>2]=0;H[b+372>>2]=0;break c;case 1:b=pa(424);H[b>>2]=11436;ra(b+4|0,0,80);H[b+96>>2]=0;H[b+100>>2]=0;H[b+92>>2]=-1;H[b+84>>2]=-1;H[b+88>>2]=-1;H[b+104>>2]=0;H[b+108>>2]=0;H[b+112>>2]=0;H[b+116>>2]=0;H[b+120>>2]=0;H[b+124>>2]=0;H[b+128>>2]=0;H[b+132>>2]=0;H[b+136>>2]=0;H[b+140>>2]=0;H[b+144>>2]=0;H[b+148>>2]=0;H[b+156>>2]=0;H[b+160>>2]=0;H[b+152>>2]=1065353216;H[b+164>>2]=0;H[b+168>>2]=0;H[b+172>>2]=0;H[b+176>>2]=0;H[b+180>>2]=0;H[b+184>>2]=0;H[b+188>>2]=0;H[b+192>>2]=0;H[b+196>>2]=0;H[b+200>>2]=0;H[b+204>>2]=0;H[b+208>>2]=0;H[b+212>>2]=-1;H[b+216>>2]=0;H[b+220>>2]=0;H[b+224>>2]=0;Ha(b+232|0);Ha(b+272|0);c=b+312|0;H[c>>2]=0;H[c+4>>2]=0;F[c+5|0]=0;F[c+6|0]=0;F[c+7|0]=0;F[c+8|0]=0;F[c+9|0]=0;F[c+10|0]=0;F[c+11|0]=0;F[c+12|0]=0;Ha(b+328|0);H[b+392>>2]=0;H[b+396>>2]=0;H[b+384>>2]=0;H[b+388>>2]=0;H[b+376>>2]=0;H[b+380>>2]=0;H[b+368>>2]=0;H[b+372>>2]=0;c=b+400|0;H[c>>2]=0;H[c+4>>2]=0;F[c+5|0]=0;F[c+6|0]=0;F[c+7|0]=0;F[c+8|0]=0;F[c+9|0]=0;F[c+10|0]=0;F[c+11|0]=0;F[c+12|0]=0;H[b+416>>2]=-1;H[b+420>>2]=-1;break c;case 2:break d;default:break b}}b=pa(440);H[b>>2]=11484;ra(b+4|0,0,80);H[b+96>>2]=0;H[b+100>>2]=0;H[b+92>>2]=-1;H[b+84>>2]=-1;H[b+88>>2]=-1;H[b+104>>2]=0;H[b+108>>2]=0;H[b+112>>2]=0;H[b+116>>2]=0;H[b+120>>2]=0;H[b+124>>2]=0;H[b+128>>2]=0;H[b+132>>2]=0;H[b+136>>2]=0;H[b+140>>2]=0;H[b+144>>2]=0;H[b+148>>2]=0;H[b+156>>2]=0;H[b+160>>2]=0;H[b+152>>2]=1065353216;H[b+164>>2]=0;H[b+168>>2]=0;H[b+172>>2]=0;H[b+176>>2]=0;H[b+180>>2]=0;H[b+184>>2]=0;H[b+188>>2]=0;H[b+192>>2]=0;H[b+196>>2]=0;H[b+200>>2]=0;H[b+204>>2]=0;H[b+208>>2]=0;H[b+212>>2]=-1;H[b+216>>2]=0;H[b+220>>2]=0;H[b+224>>2]=0;Ha(b+232|0);Ha(b+272|0);c=b+312|0;H[c>>2]=0;H[c+4>>2]=0;F[c+5|0]=0;F[c+6|0]=0;F[c+7|0]=0;F[c+8|0]=0;F[c+9|0]=0;F[c+10|0]=0;F[c+11|0]=0;F[c+12|0]=0;Ha(b+328|0);H[b+392>>2]=0;H[b+396>>2]=0;H[b+384>>2]=0;H[b+388>>2]=0;H[b+376>>2]=0;H[b+380>>2]=0;H[b+368>>2]=0;H[b+372>>2]=0;H[b+416>>2]=0;H[b+420>>2]=0;H[b+408>>2]=2;H[b+412>>2]=7;H[b+400>>2]=-1;H[b+404>>2]=-1;H[b+424>>2]=0;H[b+428>>2]=0;H[b+432>>2]=0;H[b+436>>2]=0}c=H[a+48>>2];H[a+48>>2]=b;if(!c){break a}ea[H[H[c>>2]+4>>2]](c)}b=H[a+48>>2];if(b){break a}return 0}a=ea[H[H[b>>2]+8>>2]](b,a)|0}else{a=0}return a|0}function Lb(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,w=0,x=0,y=0;f=ca-96|0;ca=f;e=H[a+16>>2];F[f+92|0]=1;H[f+88>>2]=b;H[f+84>>2]=b;H[f+80>>2]=e;a:{if((b|0)==-1){break a}j=H[a+20>>2];d=H[j>>2];e=H[H[e>>2]+(b2];if(e>>>0>=H[j+4>>2]-d>>2>>>0){break a}e=H[H[a+8>>2]+(H[d+(e2]2];d=H[a+4>>2];if(!I[d+84|0]){e=H[H[d+68>>2]+(e2]}H[f+72>>2]=0;H[f+76>>2]=0;j=f- -64|0;H[j>>2]=0;H[j+4>>2]=0;H[f+56>>2]=0;H[f+60>>2]=0;Sa(d,e,F[d+24|0],f+56|0);e=b+1|0;j=(e>>>0)%3|0?e:b-2|0;n=((b>>>0)%3|0?-1:2)+b|0;b:{c:{while(1){d=j;e=n;d:{if(!H[a+28>>2]){break d}e=b+1|0;d=(e>>>0)%3|0?e:b-2|0;e=b-1|0;if((b>>>0)%3|0){break d}e=b+2|0}if((d|0)==-1){break b}m=H[a+20>>2];b=H[m>>2];d=H[H[H[a+16>>2]>>2]+(d2];if(d>>>0>=H[m+4>>2]-b>>2>>>0){break b}d=H[H[a+8>>2]+(H[(d2]2];b=H[a+4>>2];if(!I[b+84|0]){d=H[H[b+68>>2]+(d2]}H[f+48>>2]=0;H[f+52>>2]=0;H[f+40>>2]=0;H[f+44>>2]=0;H[f+32>>2]=0;H[f+36>>2]=0;Sa(b,d,F[b+24|0],f+32|0);if((e|0)==-1){break c}d=H[a+20>>2];b=H[d>>2];e=H[H[H[a+16>>2]>>2]+(e2];if(e>>>0>=H[d+4>>2]-b>>2>>>0){break c}d=H[H[a+8>>2]+(H[b+(e2]2];b=H[a+4>>2];if(!I[b+84|0]){d=H[H[b+68>>2]+(d2]}H[f+24>>2]=0;H[f+28>>2]=0;H[f+16>>2]=0;H[f+20>>2]=0;H[f+8>>2]=0;H[f+12>>2]=0;Sa(b,d,F[b+24|0],f+8|0);g=H[f+8>>2];b=H[f+56>>2];d=g-b|0;p=H[f+60>>2];t=H[f+12>>2]-(p+(b>>>0>g>>>0)|0)|0;i=H[f+40>>2];e=H[f+64>>2];m=i-e|0;u=H[f+68>>2];y=H[f+44>>2]-(u+(e>>>0>i>>>0)|0)|0;g=Rj(d,t,m,y);w=o-g|0;x=h-(da+(g>>>0>o>>>0)|0)|0;h=w;i=H[f+16>>2];g=i-e|0;u=H[f+20>>2]-((e>>>0>i>>>0)+u|0)|0;k=H[f+32>>2];i=k-b|0;w=H[f+36>>2]-((b>>>0>k>>>0)+p|0)|0;b=Rj(g,u,i,w);o=h+b|0;h=da+x|0;h=b>>>0>o>>>0?h+1|0:h;b=l;l=d;p=t;k=H[f+48>>2];e=H[f+72>>2];d=k-e|0;t=H[f+76>>2];x=H[f+52>>2]-(t+(e>>>0>k>>>0)|0)|0;l=Rj(l,p,d,x);k=b+l|0;b=da+q|0;b=k>>>0>>0?b+1|0:b;l=H[f+24>>2];p=l-e|0;e=H[f+28>>2]-((e>>>0>l>>>0)+t|0)|0;q=Rj(p,e,i,w);l=k-q|0;q=b-(da+(k>>>0>>0)|0)|0;b=Rj(g,u,d,x);d=r-b|0;b=s-(da+(b>>>0>r>>>0)|0)|0;s=Rj(p,e,m,y);r=s+d|0;b=da+b|0;s=r>>>0>>0?b+1|0:b;uc(f+80|0);b=H[f+88>>2];if((b|0)!=-1){continue}break}b=s>>31;e=b^r;d=e-b|0;b=(b^s)-((b>>>0>e>>>0)+b|0)|0;n=-1;e=2147483647;m=q>>31;g=m;i=g^l;j=i-g|0;m=(g^q)-((i>>>0>>0)+g|0)|0;i=m;k=j^-1;g=i^2147483647;m=h;e:{f:{if(!H[a+28>>2]){if((b|0)==(g|0)&d>>>0>k>>>0|b>>>0>g>>>0){break e}b=b+i|0;a=d+j|0;b=a>>>0>>0?b+1|0:b;e=a;g=h;a=g>>31;d=a;n=d^o;a=n-d|0;h=a;d=(d^g)-((d>>>0>n>>>0)+d|0)|0;a=a+e|0;d=d^2147483647;h=(d|0)==(b|0)&(h^-1)>>>0>>0|b>>>0>d>>>0;a=h?-1:a;if(!(h&0)&(a|0)>29|0;break f}g:{if((b|0)==(g|0)&d>>>0>k>>>0|b>>>0>g>>>0){break g}b=b+i|0;a=d+j|0;b=a>>>0>>0?b+1|0:b;k=h;h=h>>31;g=h;i=g^o;h=i-g|0;j=(g^k)-((g>>>0>i>>>0)+g|0)|0;g=j^2147483647;d=a;a=h;if((g|0)==(b|0)&d>>>0>(a^-1)>>>0|b>>>0>g>>>0){break g}b=b+j|0;n=a+d|0;b=n>>>0>>0?b+1|0:b;e=b;if(!b&n>>>0>>29|0;a=(e&536870911)>29}o=Sj(o,m,a,b);l=Sj(l,q,a,b);r=Sj(r,s,a,b)}H[c+8>>2]=o;H[c+4>>2]=l;H[c>>2]=r;ca=f+96|0;return}Ca();v()}Ca();v()}Ca();v()}function Wd(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0;a:{if((b|0)>2];d=H[a+8>>2];if(c-d>>2>>>0>>0){break a}d=d+(b2];i=H[e+60>>2];f=H[e+56>>2];e=d+4|0;if((e|0)!=(c|0)){while(1){h=H[e>>2];H[e>>2]=0;g=H[d>>2];H[d>>2]=h;if(g){Ga(g)}d=d+4|0;e=e+4|0;if((e|0)!=(c|0)){continue}break}c=H[a+12>>2]}if((c|0)!=(d|0)){while(1){c=c-4|0;e=H[c>>2];H[c>>2]=0;if(e){Ga(e)}if((c|0)!=(d|0)){continue}break}}H[a+12>>2]=d;g=H[a+4>>2];b:{if(!g|(i|0)>2];d=H[g+28>>2];if((c|0)==(d|0)){break b}while(1){if((i|0)==H[H[c>>2]+24>>2]){d=c+4|0;i=H[g+28>>2];if((d|0)!=(i|0)){while(1){h=H[d>>2];H[d>>2]=0;e=H[c>>2];H[c>>2]=h;if(e){Ra(e+12|0,H[e+16>>2]);Qa(e,H[e+4>>2]);oa(e)}c=c+4|0;d=d+4|0;if((i|0)!=(d|0)){continue}break}d=H[g+28>>2]}if((c|0)!=(d|0)){while(1){d=d-4|0;e=H[d>>2];H[d>>2]=0;if(e){Ra(e+12|0,H[e+16>>2]);Qa(e,H[e+4>>2]);oa(e)}if((c|0)!=(d|0)){continue}break}}H[g+28>>2]=c;break b}c=c+4|0;if((d|0)!=(c|0)){continue}break}}c:{if((f|0)>4){break c}d:{e=N(f,12)+a|0;c=H[e+20>>2];d=H[e+24>>2];if((c|0)==(d|0)){break d}while(1){if(H[c>>2]==(b|0)){break d}c=c+4|0;if((d|0)!=(c|0)){continue}break}break c}if((c|0)==(d|0)){break c}f=c;c=c+4|0;va(f,c,d-c|0);H[e+24>>2]=d-4}c=H[a+24>>2];d=H[a+20>>2];e:{if((c|0)==(d|0)){break e}e=c-d|0;c=e>>2;g=c>>>0>>0>=8){g=g&-2;e=0;while(1){f=c2];if((j|0)>(b|0)){H[h>>2]=j-1}f=d+(f|4)|0;h=H[f>>2];if((h|0)>(b|0)){H[f>>2]=h-1}c=c+2|0;e=e+2|0;if((g|0)!=(e|0)){continue}break}}if(!i){break e}c=d+(c2];if((d|0)>2]=d-1}c=H[a+36>>2];d=H[a+32>>2];f:{if((c|0)==(d|0)){break f}e=c-d|0;c=e>>2;g=c>>>0>>0>=8){g=g&-2;e=0;while(1){f=c2];if((j|0)>(b|0)){H[h>>2]=j-1}f=d+(f|4)|0;h=H[f>>2];if((h|0)>(b|0)){H[f>>2]=h-1}c=c+2|0;e=e+2|0;if((g|0)!=(e|0)){continue}break}}if(!i){break f}c=d+(c2];if((d|0)>2]=d-1}c=H[a+48>>2];d=H[a+44>>2];g:{if((c|0)==(d|0)){break g}e=c-d|0;c=e>>2;g=c>>>0>>0>=8){g=g&-2;e=0;while(1){f=c2];if((j|0)>(b|0)){H[h>>2]=j-1}f=d+(f|4)|0;h=H[f>>2];if((h|0)>(b|0)){H[f>>2]=h-1}c=c+2|0;e=e+2|0;if((g|0)!=(e|0)){continue}break}}if(!i){break g}c=d+(c2];if((d|0)>2]=d-1}c=H[a+60>>2];d=H[a+56>>2];h:{if((c|0)==(d|0)){break h}e=c-d|0;c=e>>2;g=c>>>0>>0>=8){g=g&-2;e=0;while(1){f=c2];if((j|0)>(b|0)){H[h>>2]=j-1}f=d+(f|4)|0;h=H[f>>2];if((h|0)>(b|0)){H[f>>2]=h-1}c=c+2|0;e=e+2|0;if((g|0)!=(e|0)){continue}break}}if(!i){break h}c=d+(c2];if((d|0)>2]=d-1}c=H[a+72>>2];a=H[a+68>>2];if((c|0)==(a|0)){break a}d=c-a|0;c=d>>2;e=c>>>0>>0>=8){d=e&-2;e=0;while(1){i=c2];if((h|0)>(b|0)){H[f>>2]=h-1}i=a+(i|4)|0;f=H[i>>2];if((f|0)>(b|0)){H[i>>2]=f-1}c=c+2|0;e=e+2|0;if((d|0)!=(e|0)){continue}break}}if(!g){break a}f=b;a=a+(c2];if((f|0)>=(b|0)){break a}H[a>>2]=b-1}}function oa(a){a=a|0;var b=0,c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0;a:{if(!a){break a}d=a-8|0;b=H[a-4>>2];a=b&-8;f=d+a|0;b:{if(b&1){break b}if(!(b&3)){break a}b=H[d>>2];d=d-b|0;if(d>>>0>>0>2];b=b>>>3|0;c=H[d+12>>2];if((c|0)==(e|0)){i=17192,j=H[4298]&Vj(b),H[i>>2]=j;break b}H[e+12>>2]=c;H[c+8>>2]=e;break b}h=H[d+24>>2];b=H[d+12>>2];c:{if((d|0)!=(b|0)){c=H[d+8>>2];H[c+12>>2]=b;H[b+8>>2]=c;break c}d:{e=d+20|0;c=H[e>>2];if(c){break d}e=d+16|0;c=H[e>>2];if(c){break d}b=0;break c}while(1){g=e;b=c;e=b+20|0;c=H[e>>2];if(c){continue}e=b+16|0;c=H[b+16>>2];if(c){continue}break}H[g>>2]=0}if(!h){break b}e=H[d+28>>2];c=(e2]==(d|0)){H[c>>2]=b;if(b){break e}i=17196,j=H[4299]&Vj(e),H[i>>2]=j;break b}H[h+(H[h+16>>2]==(d|0)?16:20)>>2]=b;if(!b){break b}}H[b+24>>2]=h;c=H[d+16>>2];if(c){H[b+16>>2]=c;H[c+24>>2]=b}c=H[d+20>>2];if(!c){break b}H[b+20>>2]=c;H[c+24>>2]=b;break b}b=H[f+4>>2];if((b&3)!=3){break b}H[4300]=a;H[f+4>>2]=b&-2;H[d+4>>2]=a|1;H[a+d>>2]=a;return}if(d>>>0>=f>>>0){break a}b=H[f+4>>2];if(!(b&1)){break a}f:{if(!(b&2)){if(H[4304]==(f|0)){H[4304]=d;a=H[4301]+a|0;H[4301]=a;H[d+4>>2]=a|1;if(H[4303]!=(d|0)){break a}H[4300]=0;H[4303]=0;return}if(H[4303]==(f|0)){H[4303]=d;a=H[4300]+a|0;H[4300]=a;H[d+4>>2]=a|1;H[a+d>>2]=a;return}a=(b&-8)+a|0;g:{if(b>>>0>2];b=b>>>3|0;c=H[f+12>>2];if((c|0)==(e|0)){i=17192,j=H[4298]&Vj(b),H[i>>2]=j;break g}H[e+12>>2]=c;H[c+8>>2]=e;break g}h=H[f+24>>2];b=H[f+12>>2];h:{if((f|0)!=(b|0)){c=H[f+8>>2];H[c+12>>2]=b;H[b+8>>2]=c;break h}i:{e=f+20|0;c=H[e>>2];if(c){break i}e=f+16|0;c=H[e>>2];if(c){break i}b=0;break h}while(1){g=e;b=c;e=b+20|0;c=H[e>>2];if(c){continue}e=b+16|0;c=H[b+16>>2];if(c){continue}break}H[g>>2]=0}if(!h){break g}e=H[f+28>>2];c=(e2]==(f|0)){H[c>>2]=b;if(b){break j}i=17196,j=H[4299]&Vj(e),H[i>>2]=j;break g}H[h+(H[h+16>>2]==(f|0)?16:20)>>2]=b;if(!b){break g}}H[b+24>>2]=h;c=H[f+16>>2];if(c){H[b+16>>2]=c;H[c+24>>2]=b}c=H[f+20>>2];if(!c){break g}H[b+20>>2]=c;H[c+24>>2]=b}H[d+4>>2]=a|1;H[a+d>>2]=a;if(H[4303]!=(d|0)){break f}H[4300]=a;return}H[f+4>>2]=b&-2;H[d+4>>2]=a|1;H[a+d>>2]=a}if(a>>>03);k:{if(!(c&a)){H[4298]=a|c;a=b;break k}a=H[b+8>>2]}H[b+8>>2]=d;H[a+12>>2]=d;H[d+12>>2]=b;H[d+8>>2]=a;return}e=31;if(a>>>0>>8|0);e=((a>>>38-b&1)-(b2]=e;H[d+16>>2]=0;H[d+20>>2]=0;g=(e2]=g;break n}e=a>1|0)|0:0);b=H[g>>2];while(1){c=b;if((H[b+4>>2]&-8)==(a|0)){break m}b=e>>>29|0;e=e2];if(b){continue}break}H[g+16>>2]=d;H[d+24>>2]=c}H[d+12>>2]=d;H[d+8>>2]=d;break l}a=H[c+8>>2];H[a+12>>2]=d;H[c+8>>2]=d;H[d+24>>2]=0;H[d+12>>2]=c;H[d+8>>2]=a}a=H[4306]-1|0;H[4306]=a?a:-1}}function tj(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,w=0;H[a+8>>2]=e;n=a+32|0;h=H[n>>2];f=H[a+36>>2]-h>>2;a:{if(f>>>0>>0){ya(n,e-f|0);d=H[a+8>>2];break a}d=e;if(d>>>0>=f>>>0){break a}H[a+36>>2]=h+(e2];p=H[a+48>>2];f=0;h=e>>>0>1073741823?-1:e>2];c:{if((h|0)>(j|0)){H[d+g>>2]=j;break c}d=d+g|0;j=H[a+12>>2];if((j|0)>(h|0)){H[d>>2]=j;break c}H[d>>2]=h}d=H[a+8>>2];f=f+1|0;if((d|0)>(f|0)){continue}break}if((d|0)>2]|0;H[d>>2]=h;d:{if((h|0)>H[a+16>>2]){i=h-H[a+20>>2]|0}else{if((h|0)>=H[a+12>>2]){break d}i=h+H[a+20>>2]|0}H[d>>2]=i}d=H[a+8>>2];f=f+1|0;if((d|0)>(f|0)){continue}break}}f=H[a+56>>2];q=H[f>>2];f=H[f+4>>2]-q|0;if((f|0)>=5){o=f>>>2|0;t=o>>>0>2]+(f2];if((f|0)==-1){break f}j=H[s>>2];g=H[p>>2];k=H[j+(H[g+(f2]2];i=f+1|0;i=(i>>>0)%3|0?i:f-2|0;if((i|0)!=-1){i=H[g+(i2]}else{i=-1}g:{h:{if((f>>>0)%3|0){f=f-1|0;break h}f=f+2|0;l=-1;if((f|0)==-1){break g}}l=H[g+(f2]}if((h|0)=(h|0)){break f}g=H[j+(l2];if((g|0)>=(h|0)){break f}i:{if((e|0)2];f=0;while(1){d=f2];k=H[a+16>>2];j:{if((g|0)>(k|0)){H[d+j>>2]=k;break j}d=d+j|0;k=H[a+12>>2];if((k|0)>(g|0)){H[d>>2]=k;break j}H[d>>2]=g}d=H[a+8>>2];f=f+1|0;if((d|0)>(f|0)){continue}break}f=0;if((d|0)>2]=g;k:{if((g|0)>H[a+16>>2]){l=g-H[a+20>>2]|0}else{if((g|0)>=H[a+12>>2]){break k}l=g+H[a+20>>2]|0}H[d>>2]=l}d=H[a+8>>2];f=f+1|0;if((d|0)>(f|0)){continue}break}break e}Ca();v()}if((d|0)>2];l:{if((g|0)>(i|0)){H[d+j>>2]=i;break l}d=d+j|0;i=H[a+12>>2];if((i|0)>(g|0)){H[d>>2]=i;break l}H[d>>2]=g}d=H[a+8>>2];f=f+1|0;if((d|0)>(f|0)){continue}break}f=0;if((d|0)>2]=g;m:{if((g|0)>H[a+16>>2]){l=g-H[a+20>>2]|0}else{if((g|0)>=H[a+12>>2]){break m}l=g+H[a+20>>2]|0}H[d>>2]=l}d=H[a+8>>2];f=f+1|0;if((d|0)>(f|0)){continue}break}}h=h+1|0;if((t|0)!=(h|0)){continue}break}}oa(m);return 1}function we(a,b){var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0;if((b|0)==-1){return 1}g=(b>>>0)/3|0;if(!(H[H[a+24>>2]+(g>>>3&268435452)>>2]>>>g&1)){e=H[a+48>>2];H[a+52>>2]=e;a:{if((e|0)!=H[a+56>>2]){H[e>>2]=b;H[a+52>>2]=e+4;break a}d=pa(4);H[d>>2]=b;c=d+4|0;H[a+56>>2]=c;H[a+52>>2]=c;H[a+48>>2]=d;if(!e){break a}oa(e)}c=b+1|0;i=(c>>>0)%3|0?c:b-2|0;c=H[H[a+4>>2]+28>>2];k=H[(i2];if((k|0)==-1){return 0}e=(b-N(g,3)|0?-1:2)+b|0;j=H[c+(e2];if((j|0)==-1){return 0}b=H[a+36>>2];g=b+(k>>>3&536870908)|0;d=H[g>>2];c=12]=c|d;Ua(a+8|0,k,i);b=H[a+36>>2]}d=(j>>>3&536870908)+b|0;c=H[d>>2];b=12]=b|c;Ua(a+8|0,j,e)}f=H[a+52>>2];if((f|0)==H[a+48>>2]){return 1}k=a+8|0;while(1){b:{c:{f=f-4|0;b=H[f>>2];if((b|0)==-1){break c}c=(b>>>0)/3|0;g=H[a+24>>2]+(c>>>3&268435452)|0;d=H[g>>2];c=12]=c|d;h=H[a+4>>2];c=H[H[h+28>>2]+(b2];if((c|0)==-1){return 0}while(1){d=b;d:{e:{j=H[a+36>>2]+(c>>>3&536870908)|0;i=H[j>>2];e=12]+(c2];g:{if((g|0)==-1){break g}b=g+1|0;b=(b>>>0)%3|0?b:g-2|0;if((b|0)==-1|H[H[h>>2]+(b>>>3&536870908)>>2]>>>b&1){break g}g=H[H[H[h+64>>2]+12>>2]+(b2];if((g|0)!=-1){break f}}H[j>>2]=e|i;Ua(k,c,d);h=H[a+4>>2];break e}H[j>>2]=e|i;Ua(k,c,d);h=H[a+4>>2];b=g+1|0;if((((b>>>0)%3|0?b:g-2|0)|0)==-1){break e}b=-1;h:{if((d|0)==-1){break h}c=d+1|0;c=(c>>>0)%3|0?c:d-2|0;if((c|0)==-1|H[H[h>>2]+(c>>>3&536870908)>>2]>>>c&1){break h}b=H[H[H[h+64>>2]+12>>2]+(c2]}c=(b>>>0)/3|0;d=12];e=c>>>5|0;j=H[f+(e2];break d}i:{j:{if((d|0)==-1){break j}c=-1;b=d+1|0;b=(b>>>0)%3|0?b:d-2|0;if(!((b|0)==-1|H[H[h>>2]+(b>>>3&536870908)>>2]>>>b&1)){c=H[H[H[h+64>>2]+12>>2]+(b2]}k:{l:{if((d>>>0)%3|0){f=d-1|0;break l}f=d+2|0;b=-1;if((f|0)==-1){break k}}b=-1;if(H[H[h>>2]+(f>>>3&536870908)>>2]>>>f&1){break k}b=H[H[H[h+64>>2]+12>>2]+(f2]}g=(b|0)==-1;i=g?-1:(b>>>0)/3|0;if((c|0)!=-1){f=H[a+24>>2];d=(c>>>0)/3|0;e=d>>>5|0;j=H[f+(e2];d=1>5|0;j=H[f+(e2];if(!(d&j)){break d}}f=H[a+52>>2]-4|0;H[a+52>>2]=f;break b}if(g){b=c;break d}if(H[(i>>>3&536870908)+f>>2]>>>i&1){b=c;break d}h=H[a+52>>2];H[h-4>>2]=b;if(H[a+56>>2]!=(h|0)){H[h>>2]=c;f=h+4|0;break c}m:{i=H[a+48>>2];e=h-i|0;g=e>>2;d=g+1|0;if(d>>>0>>1|0;e=e>>>0>=2147483644?1073741823:b>>>0>d>>>0?b:d;if(e){if(e>>>0>=1073741824){break m}d=pa(e2]=H[h>>2];if((h|0)!=(i|0)){continue}break}}H[a+56>>2]=d+(e2]=f;H[a+48>>2]=b;if(!i){break b}oa(i);f=H[a+52>>2];break b}sa();v()}wa();v()}H[(e2]=d|j;c=H[H[h+28>>2]+(b2];if((c|0)!=-1){continue}break}return 0}H[a+52>>2]=f}if(H[a+48>>2]!=(f|0)){continue}break}}return 1}function Lj(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,w=0;H[a+8>>2]=e;m=a+32|0;h=H[m>>2];f=H[a+36>>2]-h>>2;a:{if(f>>>0>>0){ya(m,e-f|0);d=H[a+8>>2];break a}d=e;if(d>>>0>=f>>>0){break a}H[a+36>>2]=h+(e2];n=H[a+48>>2];f=0;h=e>>>0>1073741823?-1:e>2];c:{if((h|0)>(i|0)){H[d+g>>2]=i;break c}d=d+g|0;i=H[a+12>>2];if((i|0)>(h|0)){H[d>>2]=i;break c}H[d>>2]=h}d=H[a+8>>2];f=f+1|0;if((d|0)>(f|0)){continue}break}if((d|0)>2]|0;H[d>>2]=h;d:{if((h|0)>H[a+16>>2]){h=h-H[a+20>>2]|0}else{if((h|0)>=H[a+12>>2]){break d}h=h+H[a+20>>2]|0}H[d>>2]=h}d=H[a+8>>2];f=f+1|0;if((d|0)>(f|0)){continue}break}}f=H[a+56>>2];q=H[f>>2];f=H[f+4>>2]-q|0;if((f|0)>=5){o=f>>>2|0;t=o>>>0>2]+(f>>>3&536870908)>>2]>>>f&1){break f}f=H[H[H[n+64>>2]+12>>2]+(f2];if((f|0)==-1){break f}i=H[s>>2];g=H[n+28>>2];k=H[i+(H[g+(f2]2];if((k|0)>=(h|0)){break f}j=f+1|0;j=H[i+(H[g+(((j>>>0)%3|0?j:f-2|0)2]2];if((j|0)>=(h|0)){break f}f=H[i+(H[g+(f+((f>>>0)%3|0?-1:2)2]2];if((f|0)>=(h|0)){break f}g:{if((e|0)2];f=0;while(1){d=f2];k=H[a+16>>2];h:{if((g|0)>(k|0)){H[d+i>>2]=k;break h}d=d+i|0;k=H[a+12>>2];if((k|0)>(g|0)){H[d>>2]=k;break h}H[d>>2]=g}d=H[a+8>>2];f=f+1|0;if((d|0)>(f|0)){continue}break}f=0;if((d|0)>2]=g;i:{if((g|0)>H[a+16>>2]){g=g-H[a+20>>2]|0}else{if((g|0)>=H[a+12>>2]){break i}g=g+H[a+20>>2]|0}H[d>>2]=g}d=H[a+8>>2];f=f+1|0;if((d|0)>(f|0)){continue}break}break e}Ca();v()}if((d|0)>2];j:{if((g|0)>(j|0)){H[d+i>>2]=j;break j}d=d+i|0;j=H[a+12>>2];if((j|0)>(g|0)){H[d>>2]=j;break j}H[d>>2]=g}d=H[a+8>>2];f=f+1|0;if((d|0)>(f|0)){continue}break}f=0;if((d|0)>2]=g;k:{if((g|0)>H[a+16>>2]){g=g-H[a+20>>2]|0}else{if((g|0)>=H[a+12>>2]){break k}g=g+H[a+20>>2]|0}H[d>>2]=g}d=H[a+8>>2];f=f+1|0;if((d|0)>(f|0)){continue}break}}h=h+1|0;if((t|0)!=(h|0)){continue}break}}oa(l);return 1}function Gb(a,b,c,d){var e=0,f=0,g=0,h=0,i=0,j=O(0),k=0,l=0,m=O(0);i=H[c>>2];a:{b:{f=H[b+4>>2];if(!f){break b}g=Uj(f);c:{if(g>>>0>=2){e=i;if(f>>>0>>0){e=(i>>>0)%(f>>>0)|0}c=H[H[b>>2]+(e2];if(!c){break b}if(g>>>0>2];if(!c){break b}g=H[c+4>>2];if((g|0)!=(i|0)){if(f>>>0>>0){g=(g>>>0)%(f>>>0)|0}if((e|0)!=(g|0)){break b}}if(H[c+8>>2]!=(i|0)){continue}break}b=0;break a}e=f-1&i;c=H[H[b>>2]+(e2];if(!c){break b}}h=f-1|0;while(1){c=H[c>>2];if(!c){break b}g=H[c+4>>2];if((g|0)!=(i|0)&(g&h)!=(e|0)){break b}if(H[c+8>>2]!=(i|0)){continue}break}b=0;break a}c=pa(16);d=H[H[d>>2]>>2];H[c+12>>2]=0;H[c+8>>2]=d;H[c+4>>2]=i;H[c>>2]=0;m=O(H[b+12>>2]+1>>>0);j=L[b+16>>2];d:{if(m>O(j*O(f>>>0))?0:f){break d}e=2;d=(f-1&f)!=0|f>>>00;break e}g=0}d=d>>>0>g>>>0?d:g;f:{if((d|0)==1){break f}if(!(d&d-1)){e=d;break f}e=Kd(d);f=H[b+4>>2]}g:{if(e>>>0>>0){if(e>>>0>=f>>>0){break g}g=f>>>0>2])/L[b+16>>2])));h:{if(j=O(0)){d=~~j>>>0;break h}d=0}i:{j:{if(g){break j}if(Uj(f)>>>0>1){break j}d=d>>>00>>0?e:d;if(f>>>0>>0){break g}}f=0;g=0;h=e;k:{l:{m:{n:{if(e){if(h>>>0>=1073741824){break n}d=pa(h2];H[b>>2]=d;if(e){oa(e)}H[b+4>>2]=h;d=0;if(h>>>0>=4){e=h&-4;while(1){k=d2]>>2]=0;H[H[b>>2]+(k|4)>>2]=0;H[H[b>>2]+(k|8)>>2]=0;H[H[b>>2]+(k|12)>>2]=0;d=d+4|0;g=g+4|0;if((e|0)!=(g|0)){continue}break}}e=h&3;if(e){while(1){H[H[b>>2]+(d2]=0;d=d+1|0;f=f+1|0;if((e|0)!=(f|0)){continue}break}}e=H[b+8>>2];if(!e){break k}d=b+8|0;f=H[e+4>>2];g=Uj(h);if(g>>>0>>0>=h>>>0?(f>>>0)%(h>>>0)|0:f;H[H[b>>2]+(f2]=d;d=H[e>>2];if(!d){break k}if(g>>>0>2];if(h>>>0>>0){g=(g>>>0)%(h>>>0)|0}o:{if((f|0)==(g|0)){e=d;break o}l=g2]|0;if(!H[k>>2]){H[k>>2]=e;e=d;f=g;break o}H[e>>2]=H[d>>2];H[d>>2]=H[H[l+H[b>>2]>>2]>>2];H[H[l+H[b>>2]>>2]>>2]=d}d=H[e>>2];if(d){continue}break}break k}d=H[b>>2];H[b>>2]=0;if(d){oa(d)}H[b+4>>2]=0;break k}wa();v()}f=h-1&f;H[H[b>>2]+(f2]=d;d=H[e>>2];if(!d){break k}}k=h-1|0;while(1){g=k&H[d+4>>2];p:{if((g|0)==(f|0)){e=d;break p}l=g2]|0;if(H[h>>2]){H[e>>2]=H[d>>2];H[d>>2]=H[H[l+H[b>>2]>>2]>>2];H[H[l+H[b>>2]>>2]>>2]=d;break p}H[h>>2]=e;e=d;f=g}d=H[e>>2];if(d){continue}break}}}f=H[b+4>>2];d=f-1|0;if(!(d&f)){e=d&i;break d}if(f>>>0>i>>>0){e=i;break d}e=(i>>>0)%(f>>>0)|0}e=H[b>>2]+(e2];q:{r:{if(!d){d=b+8|0;H[c>>2]=H[d>>2];H[b+8>>2]=c;H[e>>2]=d;d=H[c>>2];if(!d){break q}d=H[d+4>>2];e=f-1|0;s:{if(!(e&f)){d=d&e;break s}if(d>>>0>>0){break s}d=(d>>>0)%(f>>>0)|0}d=H[b>>2]+(d2]=H[d>>2]}H[d>>2]=c}H[b+12>>2]=H[b+12>>2]+1;b=1}F[a+4|0]=b;H[a>>2]=c}function Oe(a,b,c,d){var e=0,f=0,g=0,h=0,i=0,j=0;f=ca-80|0;ca=f;e=H[c+36>>2];H[f+72>>2]=H[c+32>>2];H[f+76>>2]=e;g=H[c+28>>2];e=f- -64|0;H[e>>2]=H[c+24>>2];H[e+4>>2]=g;e=H[c+20>>2];H[f+56>>2]=H[c+16>>2];H[f+60>>2]=e;e=H[c+12>>2];H[f+48>>2]=H[c+8>>2];H[f+52>>2]=e;e=H[c+4>>2];H[f+40>>2]=H[c>>2];H[f+44>>2]=e;nc(a,f+40|0,f+24|0);a:{if(H[a>>2]){break a}if(F[a+15|0]>2])}if(I[f+31|0]!=1){b=pa(32);F[b+20|0]=0;c=I[1448]|I[1449]16;F[b+19|0]=c>>>24;c=I[1444]|I[1445]8;F[b+14|0]=c>>>16;F[b+15|0]=c>>>24;c=I[1436]|I[1437]8;F[b+6|0]=c>>>16;F[b+7|0]=c>>>24;H[a>>2]=-1;za(a+4|0,b,20);oa(b);break a}i=ca-16|0;ca=i;b:{c:{switch(I[f+32|0]){case 0:e=Ke(pa(48));H[e>>2]=13112;H[f+8>>2]=0;H[f+12>>2]=0;H[f>>2]=0;H[f+4>>2]=0;H[f+16>>2]=e;break b;case 1:e=Ke(pa(52));H[e+48>>2]=0;H[e>>2]=11276;H[f+8>>2]=0;H[f+12>>2]=0;H[f>>2]=0;H[f+4>>2]=0;H[f+16>>2]=e;break b;default:break c}}g=pa(32);F[g+28|0]=0;e=I[1550]|I[1551]16;F[g+27|0]=e>>>24;e=I[1546]|I[1547]8;F[g+22|0]=e>>>16;F[g+23|0]=e>>>24;e=I[1538]|I[1539]8;F[g+14|0]=e>>>16;F[g+15|0]=e>>>24;e=I[1530]|I[1531]8;F[g+6|0]=e>>>16;F[g+7|0]=e>>>24;H[i>>2]=-1;e=i|4;za(e,g,28);j=F[i+15|0];H[f>>2]=H[i>>2];h=f+4|0;d:{if((j|0)>=0){j=H[e+4>>2];H[h>>2]=H[e>>2];H[h+4>>2]=j;H[h+8>>2]=H[e+8>>2];H[f+16>>2]=0;break d}za(h,H[i+4>>2],H[i+8>>2]);e=F[i+15|0];H[f+16>>2]=0;if((e|0)>=0){break d}oa(H[i+4>>2])}oa(g)}ca=i+16|0;e=H[f>>2];e:{if(e){H[a>>2]=e;a=a+4|0;if(F[f+15|0]>=0){b=f|4;c=H[b+4>>2];H[a>>2]=H[b>>2];H[a+4>>2]=c;H[a+8>>2]=H[b+8>>2];break e}za(a,H[f+4>>2],H[f+8>>2]);break e}e=H[f+16>>2];H[f+16>>2]=0;H[e+44>>2]=d;te(a,e,b,c,d);if(!H[a>>2]){if(F[a+15|0]>2])}H[a>>2]=0;H[a+4>>2]=0;H[a+8>>2]=0;H[a+12>>2]=0}ea[H[H[e>>2]+4>>2]](e)}a=H[f+16>>2];H[f+16>>2]=0;if(a){ea[H[H[a>>2]+4>>2]](a)}if(F[f+15|0]>=0){break a}oa(H[f+4>>2])}ca=f+80|0}function Gc(a,b,c){var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0;j=N(b,12)+a|0;H[j+12>>2]=H[j+8>>2];m=(c|0)==-1?-1:(c>>>0)/3|0;d=1;k=c;a:{b:{c:{while(1){d:{l=d;if(!d){if((k|0)==-1){break d}if((de(a,((k>>>0)%3|0?-1:2)+k|0)|0)==-1){break a}c=k+1|0;d=(c>>>0)%3|0?c:k-2|0;if((d|0)==-1){break a}c=d+1|0;c=(c>>>0)%3|0?c:d-2|0;if((c|0)==-1){break a}d=H[H[H[a+4>>2]+12>>2]+(c2];if((d|0)==-1){break a}c=d+1|0;c=(c>>>0)%3|0?c:d-2|0;if((c|0)==-1){break a}m=(c>>>0)/3|0}e:{d=H[a+56>>2]+(m>>>3&536870908)|0;h=H[d>>2];e=12]=e|h;d=H[j+12>>2];f:{if((d|0)!=H[j+16>>2]){H[d>>2]=m;H[j+12>>2]=d+4;break f}n=H[j+8>>2];h=d-n|0;e=h>>2;i=e+1|0;if(i>>>0>=1073741824){break c}g=h>>>1|0;i=h>>>0>=2147483644?1073741823:i>>>0>>0?g:i;if(i){if(i>>>0>=1073741824){break b}g=pa(i2]=H[d>>2];if((d|0)!=(n|0)){continue}break}}H[j+8>>2]=h;H[j+12>>2]=e;H[j+16>>2]=g+(i>0)%3|0?d:c-2|0;break i}k=l?k:c;if((c|0)==-1){c=-1;break g}if((c>>>0)%3|0){d=c-1|0;break h}c=c+2|0}d=c;c=-1;if((d|0)==-1){break g}}c=H[H[H[a+4>>2]+12>>2]+(d2];h=-1;f=-1;e=d+1|0;e=(e>>>0)%3|0?e:d-2|0;if((e|0)>=0){f=(e>>>0)/3|0;f=H[(H[H[a>>2]+96>>2]+N(f,12)|0)+(e-N(f,3)2]}j:{if((c|0)==-1){break j}i=((c>>>0)%3|0?-1:2)+c|0;if((i|0)>>0)/3|0;h=H[(H[H[a>>2]+96>>2]+N(e,12)|0)+(i-N(e,3)2]}if((f|0)!=(h|0)){c=-1;break g}k:{l:{f=((d>>>0)%3|0?-1:2)+d|0;if((f|0)>=0){d=(f>>>0)/3|0;if((c|0)!=-1){break l}c=-1;break g}d=-1;if((c|0)!=-1){break k}c=-1;break g}d=H[(H[H[a>>2]+96>>2]+N(d,12)|0)+(f-N(d,3)2]}f=c+1|0;e=(f>>>0)%3|0?f:c-2|0;if((e|0)>=0){f=(e>>>0)/3|0;f=H[(H[H[a>>2]+96>>2]+N(f,12)|0)+(e-N(f,3)2]}else{f=-1}if((f|0)!=(d|0)){c=-1;break g}f=g;m=(c>>>0)/3|0;d=H[a+56>>2]+(m>>>3&268435452)|0;h=H[d>>2];e=12]-4|0;g=H[l>>2];d=H[a+56>>2]+(g>>>3&536870908)|0;c=H[d>>2];o=d,p=Vj(g)&c,H[o>>2]=p;H[j+12>>2]=l;break a}d=0;if(l){continue}break a}break}k=-1;de(a,-1);break a}sa();v()}wa();v()}H[((b2]=k;b=H[j+12>>2];i=H[j+8>>2];m:{if((b|0)==(i|0)){break m}c=b-i|0;b=c>>2;b=b>>>0>2];d=0;if(c>>>0>=8){f=b&-2;c=0;while(1){l=d2];b=e+(g>>>3&536870908)|0;a=H[b>>2];o=b,p=Vj(g)&a,H[o>>2]=p;g=H[i+(l|4)>>2];b=e+(g>>>3&536870908)|0;a=H[b>>2];o=b,p=Vj(g)&a,H[o>>2]=p;d=d+2|0;c=c+2|0;if((f|0)!=(c|0)){continue}break}}if(!k){break m}c=H[i+(d2];b=e+(c>>>3&536870908)|0;a=H[b>>2];o=b,p=Vj(c)&a,H[o>>2]=p}}function Gj(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0;h=ca-32|0;ca=h;a:{if(J[b+38>>1]>2];f=H[b+12>>2];d=H[b+16>>2];if((c|0)>=(f|0)&d>>>0>=K[b+8>>2]|(c|0)>(f|0)){break a}f=I[d+H[b>>2]|0];d=d+1|0;c=d?c:c+1|0;H[b+16>>2]=d;H[b+20>>2]=c;if(f){break a}}b:{if(!Xa(1,h+28|0,b)){break b}d=H[h+28>>2];c=H[H[a+48>>2]+64>>2];if(d>>>0>H[c+4>>2]-H[c>>2]>>2>>>0){break b}c:{if(d){Wa(a+60|0,d);c=h+8|0;H[c>>2]=0;H[c+4>>2]=0;F[c+5|0]=0;F[c+6|0]=0;F[c+7|0]=0;F[c+8|0]=0;F[c+9|0]=0;F[c+10|0]=0;F[c+11|0]=0;F[c+12|0]=0;if(!ta(c,b)){break c}while(1){f=12]+(e>>>3&536870908)|0;if(j){i=f|H[g>>2]}else{i=H[g>>2]&(f^-1)}H[g>>2]=i;e=e+1|0;if((d|0)!=(e|0)){continue}break}}if(!Xa(1,h+28|0,b)){break b}d=H[h+28>>2];c=H[H[a+48>>2]+64>>2];if(d>>>0>H[c+4>>2]-H[c>>2]>>2>>>0){break b}if(d){e=0;Wa(a+72|0,d);c=h+8|0;H[c>>2]=0;H[c+4>>2]=0;F[c+5|0]=0;F[c+6|0]=0;F[c+7|0]=0;F[c+8|0]=0;F[c+9|0]=0;F[c+10|0]=0;F[c+11|0]=0;F[c+12|0]=0;if(!ta(c,b)){break c}while(1){f=12]+(e>>>3&536870908)|0;if(j){i=f|H[g>>2]}else{i=H[g>>2]&(f^-1)}H[g>>2]=i;e=e+1|0;if((d|0)!=(e|0)){continue}break}}if(!Xa(1,h+28|0,b)){break b}d=H[h+28>>2];c=H[H[a+48>>2]+64>>2];if(d>>>0>H[c+4>>2]-H[c>>2]>>2>>>0){break b}if(d){e=0;Wa(a+84|0,d);c=h+8|0;H[c>>2]=0;H[c+4>>2]=0;F[c+5|0]=0;F[c+6|0]=0;F[c+7|0]=0;F[c+8|0]=0;F[c+9|0]=0;F[c+10|0]=0;F[c+11|0]=0;F[c+12|0]=0;if(!ta(c,b)){break c}while(1){f=12]+(e>>>3&536870908)|0;if(j){i=f|H[g>>2]}else{i=H[g>>2]&(f^-1)}H[g>>2]=i;e=e+1|0;if((d|0)!=(e|0)){continue}break}}if(!Xa(1,h+28|0,b)){break b}d=H[h+28>>2];c=H[H[a+48>>2]+64>>2];if(d>>>0>H[c+4>>2]-H[c>>2]>>2>>>0){break b}if(d){e=0;Wa(a+96|0,d);c=h+8|0;H[c>>2]=0;H[c+4>>2]=0;F[c+5|0]=0;F[c+6|0]=0;F[c+7|0]=0;F[c+8|0]=0;F[c+9|0]=0;F[c+10|0]=0;F[c+11|0]=0;F[c+12|0]=0;if(!ta(c,b)){break c}while(1){f=12]+(e>>>3&536870908)|0;if(j){i=f|H[g>>2]}else{i=H[g>>2]&(f^-1)}H[g>>2]=i;e=e+1|0;if((d|0)!=(e|0)){continue}break}}e=0;c=H[b+8>>2];f=H[b+12>>2];d=c;c=H[b+20>>2];i=c;g=H[b+16>>2];j=g+4|0;c=j>>>0>>0>>0&(c|0)>=(f|0)|(c|0)>(f|0)){break a}m=H[b>>2];k=m+g|0;l=I[k|0]|I[k+1|0]>0>>0>k>>>0&(c|0)>=(d|0)|(c|0)>(d|0)){break a}d=j+m|0;d=I[d|0]|I[d+1|0]>2]=l;c=(d>>31)-((l>>31)+(d>>>0>>0)|0)|0;b=d-l|0;if(!c&b>>>0>2147483646|c){break a}e=1;b=b+1|0;H[a+20>>2]=b;c=b>>>1|0;H[a+24>>2]=c;H[a+28>>2]=0-c;if(b&1){break a}H[a+24>>2]=c-1;break a}}e=0}ca=h+32|0;return e|0}function pj(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0;h=ca-32|0;ca=h;a:{if(J[b+38>>1]>2];f=H[b+12>>2];d=H[b+16>>2];if((c|0)>=(f|0)&d>>>0>=K[b+8>>2]|(c|0)>(f|0)){break a}f=I[d+H[b>>2]|0];d=d+1|0;c=d?c:c+1|0;H[b+16>>2]=d;H[b+20>>2]=c;if(f){break a}}b:{if(!Xa(1,h+28|0,b)){break b}d=H[h+28>>2];c=H[a+48>>2];if(d>>>0>H[c+4>>2]-H[c>>2]>>2>>>0){break b}c:{if(d){Wa(a+60|0,d);c=h+8|0;H[c>>2]=0;H[c+4>>2]=0;F[c+5|0]=0;F[c+6|0]=0;F[c+7|0]=0;F[c+8|0]=0;F[c+9|0]=0;F[c+10|0]=0;F[c+11|0]=0;F[c+12|0]=0;if(!ta(c,b)){break c}while(1){f=12]+(e>>>3&536870908)|0;if(j){i=f|H[g>>2]}else{i=H[g>>2]&(f^-1)}H[g>>2]=i;e=e+1|0;if((d|0)!=(e|0)){continue}break}}if(!Xa(1,h+28|0,b)){break b}d=H[h+28>>2];c=H[a+48>>2];if(d>>>0>H[c+4>>2]-H[c>>2]>>2>>>0){break b}if(d){e=0;Wa(a+72|0,d);c=h+8|0;H[c>>2]=0;H[c+4>>2]=0;F[c+5|0]=0;F[c+6|0]=0;F[c+7|0]=0;F[c+8|0]=0;F[c+9|0]=0;F[c+10|0]=0;F[c+11|0]=0;F[c+12|0]=0;if(!ta(c,b)){break c}while(1){f=12]+(e>>>3&536870908)|0;if(j){i=f|H[g>>2]}else{i=H[g>>2]&(f^-1)}H[g>>2]=i;e=e+1|0;if((d|0)!=(e|0)){continue}break}}if(!Xa(1,h+28|0,b)){break b}d=H[h+28>>2];c=H[a+48>>2];if(d>>>0>H[c+4>>2]-H[c>>2]>>2>>>0){break b}if(d){e=0;Wa(a+84|0,d);c=h+8|0;H[c>>2]=0;H[c+4>>2]=0;F[c+5|0]=0;F[c+6|0]=0;F[c+7|0]=0;F[c+8|0]=0;F[c+9|0]=0;F[c+10|0]=0;F[c+11|0]=0;F[c+12|0]=0;if(!ta(c,b)){break c}while(1){f=12]+(e>>>3&536870908)|0;if(j){i=f|H[g>>2]}else{i=H[g>>2]&(f^-1)}H[g>>2]=i;e=e+1|0;if((d|0)!=(e|0)){continue}break}}if(!Xa(1,h+28|0,b)){break b}d=H[h+28>>2];c=H[a+48>>2];if(d>>>0>H[c+4>>2]-H[c>>2]>>2>>>0){break b}if(d){e=0;Wa(a+96|0,d);c=h+8|0;H[c>>2]=0;H[c+4>>2]=0;F[c+5|0]=0;F[c+6|0]=0;F[c+7|0]=0;F[c+8|0]=0;F[c+9|0]=0;F[c+10|0]=0;F[c+11|0]=0;F[c+12|0]=0;if(!ta(c,b)){break c}while(1){f=12]+(e>>>3&536870908)|0;if(j){i=f|H[g>>2]}else{i=H[g>>2]&(f^-1)}H[g>>2]=i;e=e+1|0;if((d|0)!=(e|0)){continue}break}}e=0;c=H[b+8>>2];f=H[b+12>>2];d=c;c=H[b+20>>2];i=c;g=H[b+16>>2];j=g+4|0;c=j>>>0>>0>>0&(c|0)>=(f|0)|(c|0)>(f|0)){break a}m=H[b>>2];k=m+g|0;l=I[k|0]|I[k+1|0]>0>>0>k>>>0&(c|0)>=(d|0)|(c|0)>(d|0)){break a}d=j+m|0;d=I[d|0]|I[d+1|0]>2]=l;c=(d>>31)-((l>>31)+(d>>>0>>0)|0)|0;b=d-l|0;if(!c&b>>>0>2147483646|c){break a}e=1;b=b+1|0;H[a+20>>2]=b;c=b>>>1|0;H[a+24>>2]=c;H[a+28>>2]=0-c;if(b&1){break a}H[a+24>>2]=c-1;break a}}e=0}ca=h+32|0;return e|0}function xe(a,b){var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0;if((b|0)==-1){return 1}g=(b>>>0)/3|0;if(!(H[H[a+24>>2]+(g>>>3&268435452)>>2]>>>g&1)){f=H[a+48>>2];H[a+52>>2]=f;a:{if((f|0)!=H[a+56>>2]){H[f>>2]=b;H[a+52>>2]=f+4;break a}d=pa(4);H[d>>2]=b;c=d+4|0;H[a+56>>2]=c;H[a+52>>2]=c;H[a+48>>2]=d;if(!f){break a}oa(f)}e=-1;d=H[a+4>>2];c=b+1|0;i=(c>>>0)%3|0?c:b-2|0;if((i|0)!=-1){e=H[H[d>>2]+(i2]}b:{h=b-N(g,3)|0;if(h){c=b-1|0;break b}c=b+2|0;if((c|0)!=-1){break b}return 0}if((e|0)==-1){return 0}j=H[H[d>>2]+(c2];if((j|0)==-1){return 0}c=H[a+36>>2];f=c+(e>>>3&536870908)|0;g=H[f>>2];d=12]=d|g;Ua(a+8|0,e,i);c=H[a+36>>2]}g=(j>>>3&536870908)+c|0;d=H[g>>2];c=12]=c|d;Ua(a+8|0,j,(h?-1:2)+b|0)}c=H[a+52>>2];if((c|0)==H[a+48>>2]){return 1}j=a+8|0;while(1){c:{d:{c=c-4|0;b=H[c>>2];if((b|0)==-1){break d}d=(b>>>0)/3|0;f=H[a+24>>2]+(d>>>3&268435452)|0;g=H[f>>2];d=12]=d|g;while(1){i=H[a+4>>2];e=H[H[i>>2]+(b2];if((e|0)==-1){return 0}e:{f:{h=H[a+36>>2]+(e>>>3&536870908)|0;f=H[h>>2];g=12]+(e2];h:{if((d|0)==-1){break h}c=d+1|0;c=(c>>>0)%3|0?c:d-2|0;if((c|0)==-1){break h}d=H[H[i+12>>2]+(c2];if((d|0)!=-1){break g}}H[h>>2]=f|g;Ua(j,e,b);break f}H[h>>2]=f|g;Ua(j,e,b);c=d+1|0;if((((c>>>0)%3|0?c:d-2|0)|0)==-1){break f}c=b-2|0;d=b+1|0;b=-1;c=(d>>>0)%3|0?d:c;if((c|0)!=-1){b=H[H[H[a+4>>2]+12>>2]+(c2]}c=(b>>>0)/3|0;d=12];f=c>>>5|0;i=H[e+(f2];break e}c=-1;g=H[a+4>>2];d=b+1|0;d=(d>>>0)%3|0?d:b-2|0;if((d|0)!=-1){c=H[H[g+12>>2]+(d2]}i:{j:{if((b>>>0)%3|0){e=b-1|0;break j}e=b+2|0;b=-1;if((e|0)==-1){break i}}b=H[H[g+12>>2]+(e2]}g=(b|0)==-1;h=g?-1:(b>>>0)/3|0;k:{if((c|0)!=-1){e=H[a+24>>2];d=(c>>>0)/3|0;f=d>>>5|0;i=H[e+(f2];d=1>5|0;i=H[e+(f2];if(!(d&i)){break e}}c=H[a+52>>2]-4|0;H[a+52>>2]=c;break c}if(g){b=c;break e}if(H[(h>>>3&536870908)+e>>2]>>>h&1){b=c;break e}e=H[a+52>>2];H[e-4>>2]=b;if(H[a+56>>2]!=(e|0)){H[e>>2]=c;c=e+4|0;break d}l:{h=H[a+48>>2];f=e-h|0;g=f>>2;d=g+1|0;if(d>>>0>>1|0;f=f>>>0>=2147483644?1073741823:b>>>0>d>>>0?b:d;if(f){if(f>>>0>=1073741824){break l}d=pa(f2]=H[e>>2];if((e|0)!=(h|0)){continue}break}}H[a+56>>2]=d+(f2]=c;H[a+48>>2]=b;if(!h){break c}oa(h);c=H[a+52>>2];break c}sa();v()}wa();v()}H[(f2]=d|i;if((b|0)!=-1){continue}break}return 0}H[a+52>>2]=c}if(H[a+48>>2]!=(c|0)){continue}break}}return 1}function uj(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0;g=ca-32|0;ca=g;H[a+68>>2]=f;d=H[a+56>>2];e=H[d>>2];d=H[d+4>>2];H[g+24>>2]=0;H[g+16>>2]=0;H[g+20>>2]=0;a:{d=d-e|0;if((d|0)>0){m=a+60|0;d=d>>>2|0;n=d>>>0>2];d=H[e>>2];if(H[e+4>>2]-d>>2>>>0>>0){break a}Nb(m,H[d+(j2],g+16|0);i=H[g+20>>2];d=i>>31;h=H[g+16>>2];e=h>>31;f=(d^i)-d+((e^h)-e)|0;k=H[g+24>>2];d=k>>31;e=(d^k)-d|0;d=0;l=e;e=e+f|0;d=l>>>0>e>>>0?1:d;b:{if(!(d|e)){H[g+16>>2]=H[a+108>>2];break b}f=H[a+108>>2];l=f>>31;h=Sj(Rj(f,l,h,h>>31),da,e,d);H[g+16>>2]=h;d=Sj(Rj(f,l,i,i>>31),da,e,d);H[g+20>>2]=d;e=d;d=d>>31;e=(e^d)-d|0;d=h>>31;d=e+((d^h)-d|0)|0;if((k|0)>=0){H[g+24>>2]=f-d;break b}H[g+24>>2]=d-f}d=Ba(o);f=H[g+16>>2];c:{if(d){H[g+24>>2]=0-H[g+24>>2];e=0-H[g+20>>2]|0;H[g+20>>2]=e;f=0-f|0;H[g+16>>2]=f;break c}e=H[g+20>>2]}d:{if((f|0)>=0){f=H[a+108>>2];d=f+H[g+24>>2]|0;f=e+f|0;break d}e:{if((e|0)>2];f=d>>31;f=(d^f)-f|0;break e}d=H[g+24>>2];f=d>>31;f=H[a+100>>2]+(f-(d^f)|0)|0}if((d|0)>31;d=(d^e)-d|0;break d}d=e>>31;d=H[a+100>>2]+(d-(d^e)|0)|0}e=H[a+100>>2];f:{if(!(d|f)){d=e;f=d;break f}if(!((d|0)!=(e|0)|f)){f=d;break f}if(!((e|0)!=(f|0)|d)){d=f;break f}g:{if(f){break g}i=H[a+108>>2];if((i|0)>=(d|0)){break g}d=(i2];if((i|0)>2]=f;j:{if(H[a+8>>2]>2];f=0;while(1){d=f2];h=H[a+16>>2];k:{if((e|0)>(h|0)){H[d+i>>2]=h;break k}d=d+i|0;h=H[a+12>>2];if((h|0)>(e|0)){H[d>>2]=h;break k}H[d>>2]=e}f=f+1|0;e=H[a+8>>2];if((f|0)2]=f;l:{if((f|0)>H[a+16>>2]){f=f-H[a+20>>2]|0}else{if((f|0)>=H[a+12>>2]){break l}f=f+H[a+20>>2]|0}H[e>>2]=f}d=d+1|0;if((d|0)>2]){continue}break}}j=j+1|0;if((n|0)!=(j|0)){continue}break}}ca=g+32|0;return 1}Ca();v()}function dj(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0;g=ca-32|0;ca=g;H[a+68>>2]=f;d=H[a+56>>2];e=H[d>>2];d=H[d+4>>2];H[g+24>>2]=0;H[g+16>>2]=0;H[g+20>>2]=0;a:{d=d-e|0;if((d|0)>0){m=a+60|0;d=d>>>2|0;n=d>>>0>2];d=H[e>>2];if(H[e+4>>2]-d>>2>>>0>>0){break a}Lb(m,H[d+(j2],g+16|0);i=H[g+20>>2];d=i>>31;h=H[g+16>>2];e=h>>31;f=(d^i)-d+((e^h)-e)|0;k=H[g+24>>2];d=k>>31;e=(d^k)-d|0;d=0;l=e;e=e+f|0;d=l>>>0>e>>>0?1:d;b:{if(!(d|e)){H[g+16>>2]=H[a+108>>2];break b}f=H[a+108>>2];l=f>>31;h=Sj(Rj(f,l,h,h>>31),da,e,d);H[g+16>>2]=h;d=Sj(Rj(f,l,i,i>>31),da,e,d);H[g+20>>2]=d;e=d;d=d>>31;e=(e^d)-d|0;d=h>>31;d=e+((d^h)-d|0)|0;if((k|0)>=0){H[g+24>>2]=f-d;break b}H[g+24>>2]=d-f}d=Ba(o);f=H[g+16>>2];c:{if(d){H[g+24>>2]=0-H[g+24>>2];e=0-H[g+20>>2]|0;H[g+20>>2]=e;f=0-f|0;H[g+16>>2]=f;break c}e=H[g+20>>2]}d:{if((f|0)>=0){f=H[a+108>>2];d=f+H[g+24>>2]|0;f=e+f|0;break d}e:{if((e|0)>2];f=d>>31;f=(d^f)-f|0;break e}d=H[g+24>>2];f=d>>31;f=H[a+100>>2]+(f-(d^f)|0)|0}if((d|0)>31;d=(d^e)-d|0;break d}d=e>>31;d=H[a+100>>2]+(d-(d^e)|0)|0}e=H[a+100>>2];f:{if(!(d|f)){d=e;f=d;break f}if(!((d|0)!=(e|0)|f)){f=d;break f}if(!((e|0)!=(f|0)|d)){d=f;break f}g:{if(f){break g}i=H[a+108>>2];if((i|0)>=(d|0)){break g}d=(i2];if((i|0)>2]=f;j:{if(H[a+8>>2]>2];f=0;while(1){d=f2];h=H[a+16>>2];k:{if((e|0)>(h|0)){H[d+i>>2]=h;break k}d=d+i|0;h=H[a+12>>2];if((h|0)>(e|0)){H[d>>2]=h;break k}H[d>>2]=e}f=f+1|0;e=H[a+8>>2];if((f|0)2]=f;l:{if((f|0)>H[a+16>>2]){f=f-H[a+20>>2]|0}else{if((f|0)>=H[a+12>>2]){break l}f=f+H[a+20>>2]|0}H[e>>2]=f}d=d+1|0;if((d|0)>2]){continue}break}}j=j+1|0;if((n|0)!=(j|0)){continue}break}}ca=g+32|0;return 1}Ca();v()}function ke(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0;h=ca-80|0;ca=h;a:{b:{if(I[H[a+28>>2]+36|0]>2];f=H[b+16>>2];c=f+4|0;d=c>>>0>2];if(K[b+8>>2]>>0&(g|0)(g|0)){break a}f=f+H[b>>2]|0;j=I[f|0]|I[f+1|0]2]}if(!j){break a}d=H[b+8>>2];c=H[b+16>>2];d=Rj(d-c|0,H[b+12>>2]-(H[b+20>>2]+(c>>>0>d>>>0)|0)|0,5,0);c=da;if(d>>>0>>0&(c|0)2];d=H[a+8>>2]-c>>2;c:{if(d>>>0>>0){ya(a+4|0,j-d|0);break c}if(d>>>0>>0){break c}H[a+8>>2]=c+(j2];while(1){i=H[b+12>>2];c=i;d=H[b+20>>2];e=H[b+8>>2];f=H[b+16>>2];if((c|0)>>0>>0|(c|0)>2];q=I[n+f|0];c=d;g=f+1|0;c=g?c:c+1|0;H[b+16>>2]=g;H[b+20>>2]=c;if(e>>>0>>0&(c|0)>=(i|0)|(c|0)>(i|0)){e=0;break a}g=I[g+n|0];c=d;k=f+2|0;c=k>>>0>2]=k;H[b+20>>2]=c;if(e>>>0>>0&(c|0)>=(i|0)|(c|0)>(i|0)){e=0;break a}k=I[k+n|0];c=d;m=f+3|0;c=m>>>0>2]=m;H[b+20>>2]=c;if(e>>>0>>0&(c|0)>=(i|0)|(c|0)>(i|0)){e=0;break a}e=I[m+n|0];c=d;d=f+4|0;c=d>>>0>2]=d;H[b+20>>2]=c;if(q>>>0>4){e=0;break a}if((g-12&255)>>>0>>0>31);d:{d=J[H[a+28>>2]+36>>1];e:{if(((d>8)&65535)>>>0>2];f=H[b+16>>2];d=f+2|0;c=d>>>0>2];if(K[b+8>>2]>>0&(e|0)(e|0)){break d}f=f+H[b>>2]|0;e=I[f|0]|I[f+1|0]2]=d;H[b+20>>2]=c;break e}if(!Pc(1,h+4|0,b)){break d}e=H[h+4>>2]}H[h+68>>2]=e;d=jc(pa(96),m);ea[H[H[l>>2]+8>>2]](l,H[l+12>>2]-H[l+8>>2]>>2,d);d=(H[l+12>>2]-H[l+8>>2]>>2)-1|0;f=d2]>>2]+60>>2]=e;H[H[a+4>>2]+(o2]=d;e=H[a+16>>2];c=H[a+20>>2]-e>>2;f:{if((c|0)>(d|0)){break f}H[h>>2]=-1;d=d+1|0;if(d>>>0>c>>>0){Pa(p,d-c|0,h);e=H[p>>2];break f}if(c>>>0>>0){break f}H[a+20>>2]=(d2]=o;e=1;o=o+1|0;if((o|0)!=(j|0)){continue}break a}break}e=0}ca=h+80|0;return e|0}function nd(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0;n=ea[H[H[a>>2]+44>>2]](a)|0;a:{if((n|0)>2]-H[b>>2]>>2;e=ca+-64|0;ca=e;f=Eb(e);d=N(H[3400],n);lc(f,H[H[a+8>>2]+56>>2],n&255,5,0,d,d>>31);f=jc(pa(96),f);F[f+84|0]=1;H[f+72>>2]=H[f+68>>2];mb(f,i);H[f+60>>2]=H[H[a+8>>2]+60>>2];d=H[a+16>>2];H[a+16>>2]=f;if(d){Ga(d)}ca=e- -64|0;h=H[a+16>>2];if(!H[h+80>>2]){break a}j=H[H[h>>2]>>2];if(!j){break a}m=H[c+12>>2];e=m;d=H[c+20>>2];g=H[c+8>>2];k=H[c+16>>2];if((e|0)>>0>>0|(d|0)>(e|0)){break a}l=N(i,n);i=j+H[h+48>>2]|0;h=H[c>>2];j=I[h+k|0];e=k+1|0;f=e?d:d+1|0;H[c+16>>2]=e;H[c+20>>2]=f;b:{c:{if(j){if(kd(l,n,c,i)){break c}break a}if((f|0)>=(m|0)&e>>>0>=g>>>0|(f|0)>(m|0)){break a}g=I[e+h|0];f=k+2|0;d=f>>>0>2]=f;H[c+20>>2]=d;d=H[H[a+16>>2]+64>>2];d=H[d+4>>2]-H[d>>2]|0;if((g|0)==H[3400]){e=l>0>d>>>0){break a}g=H[c+8>>2];k=H[c+12>>2];j=H[c+20>>2];d=H[c+16>>2];f=e+d|0;j=f>>>0>>0?j+1|0:j;if(f>>>0>g>>>0&(j|0)>=(k|0)|(j|0)>(k|0)){break a}qa(i,d+H[c>>2]|0,e);f=H[c+20>>2];d=e+H[c+16>>2]|0;f=d>>>0>>0?f+1|0:f;H[c+16>>2]=d;H[c+20>>2]=f;break c}if(d>>>0>>0){break a}d=H[c+8>>2];f=H[c+16>>2];e=d-f|0;m=d>>>0>>0;d=H[c+20>>2];k=H[c+12>>2]-(m+d|0)|0;m=Rj(g,0,l,0)>>>0>e>>>0;e=da;if(m&(e|0)>=(k|0)|(e|0)>(k|0)){break a}e=1;if(!l){break b}h=0;while(1){k=H[c+8>>2];j=H[c+12>>2];e=f+g|0;d=e>>>0>>0?d+1|0:d;if(e>>>0>k>>>0&(d|0)>=(j|0)|(d|0)>(j|0)){return 0}qa(i+(h2]+f|0,g);d=H[c+20>>2];f=g+H[c+16>>2]|0;d=f>>>0>>0?d+1|0:d;H[c+16>>2]=f;H[c+20>>2]=d;h=h+1|0;if((l|0)!=(h|0)){continue}break}}e=1;if(!l){break b}d=H[a+20>>2];if(d){e=0;if(ea[H[H[d>>2]+32>>2]](d)|0){break b}}g=0;h=0;d:{if((l|0)>2]=0-(d&1)^d>>>1;d=e|4;e=H[d+i>>2];H[d+i>>2]=0-(e&1)^e>>>1;g=g+2|0;h=h+2|0;if((f|0)!=(h|0)){continue}break}}if(!(l&1)){break d}d=g2];H[d+i>>2]=0-(f&1)^f>>>1}e=0}d=e;f=H[a+20>>2];e:{if(!f){break e}if(!(ea[H[H[f>>2]+40>>2]](f,c)|0)){break a}if(d){break e}a=H[a+20>>2];if(!(ea[H[H[a>>2]+44>>2]](a,i,i,l,n,H[b>>2])|0)){break a}}o=1}return o|0}function pb(a,b){var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0;h=ca-32|0;ca=h;a:{b:{if(H[a+8>>2]>0>=b>>>0){break b}if((b|0)>>5|0)+1|0;c=pa(b2]=b;H[h+20>>2]=0;H[h+16>>2]=c;b=H[a>>2];H[h+12>>2]=0;H[h+8>>2]=b;c=H[a+4>>2];H[h+4>>2]=c&31;H[h>>2]=b+(c>>>3&536870908);e=ca-32|0;ca=e;i=H[h+4>>2];g=H[h+12>>2];j=H[h>>2];d=H[h+8>>2];b=(i-g|0)+(j-d2];c=b+f|0;H[h+20>>2]=c;if(!((c-1^f-1)>>>0>2]+((c>>>0>=33?c-1>>>5|0:0)2]=0}c=H[h+16>>2]+(f>>>3&536870908)|0;f=f&31;c:{if((f|0)==(g|0)){if((b|0)>2]=H[c>>2]&(i^-1)|i&H[d>>2];d=d+4|0;c=(g+f>>>3&536870908)+c|0;b=b-f|0}g=(b|0)/32|0;if(b+31>>>0>=63){va(c,d,g2]&(b^-1)|b&H[c+d>>2];break c}H[e+28>>2]=g;H[e+24>>2]=d;H[e+20>>2]=i;H[e+16>>2]=j;H[e+12>>2]=f;H[e+8>>2]=c;b=H[e+28>>2];c=H[e+24>>2];g=(H[e+20>>2]-b|0)+(H[e+16>>2]-c>2];break d}e:{if(!b){b=H[e+12>>2];break e}d=H[e+12>>2];j=32-d|0;k=32-b|0;f=(g|0)>>0>j>>>0?j:f;l=H[e+8>>2];m=H[l>>2]&(-1>j-i^-1);j=H[c>>2]&(-1>k-f);H[l>>2]=m|(b>>>0>>0?j>b-d|0);c=d+i|0;b=c&31;H[e+12>>2]=b;d=l+(c>>>3&536870908)|0;H[e+8>>2]=d;c=f-i|0;if((c|0)>0){H[d>>2]=H[d>>2]&(-1>>>32-c^-1)|j>>>i+H[e+28>>2];H[e+12>>2]=c;b=c}g=g-f|0;c=H[e+24>>2]+4|0;H[e+24>>2]=c}i=-1>2];c=H[c>>2];H[d>>2]=j&H[d>>2]|c2]=d+4;H[d+4>>2]=i&H[d+4>>2]|c>>>f;c=H[e+24>>2]+4|0;H[e+24>>2]=c;d=g>>>0>63;g=g-32|0;if(d){continue}break}}d=H[e+8>>2];if((g|0)(f|0)?f:g;j=H[d>>2]&(i&-1>>>j-f^-1);i=H[c>>2]&-1>>>32-g;H[d>>2]=j|i2]=c;d=(b>>>3&536870908)+d|0;H[e+8>>2]=d;b=g-f|0;if((b|0)>2]=H[d>>2]&(-1>>>32-b^-1)|i>>>f;H[e+12>>2]=b}H[e+4>>2]=b;H[e>>2]=d}ca=e+32|0;b=H[a>>2];H[a>>2]=H[h+16>>2];H[h+16>>2]=b;c=H[a+4>>2];H[a+4>>2]=H[h+20>>2];H[h+20>>2]=c;c=H[a+8>>2];H[a+8>>2]=H[h+24>>2];H[h+24>>2]=c;if(!b){break b}oa(b)}ca=h+32|0;return}sa();v()}function Ne(a,b){var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0;c=J[b+38>>1];a:{if(!c){break a}b:{if(c>>>0>2];e=H[b+12>>2];d=H[b+20>>2];c=H[b+16>>2];i=c+4|0;d=i>>>0>>0>>0&(d|0)>=(e|0)|(d|0)>(e|0)){break a}c=c+H[b>>2]|0;f=I[c|0]|I[c+1|0]2]+4|0;d=c>>>0>2]=c;H[b+20>>2]=d;break b}if(!hb(1,a+12|0,b)){break a}c=H[b+16>>2];d=H[b+20>>2];f=H[a+12>>2]}e=H[b+8>>2];i=e-c|0;c=H[b+12>>2]-(d+(c>>>0>e>>>0)|0)|0;if(i>>>0>>6>>>0&(c|0)2];c=H[a+4>>2]-d>>2;c:{if(c>>>0>>0){ya(a,f-c|0);f=H[a+12>>2];break c}if(c>>>0>>0){break c}H[a+4>>2]=d+(f2];d=H[b+20>>2];l=H[a>>2];i=H[b+8>>2];j=H[b+12>>2];g=0;while(1){if((d|0)>=(j|0)&c>>>0>=i>>>0|(d|0)>(j|0)){return 0}m=H[b>>2];k=I[m+c|0];c=c+1|0;d=c?d:d+1|0;H[b+16>>2]=c;H[b+20>>2]=d;e=k>>>2|0;h=0;d:{e:{f:{g:{n=k&3;switch(n|0){case 0:break e;case 3:break g;default:break f}}e=e+g|0;if(e>>>0>=f>>>0){return 0}ra(l+(g2]=c;H[b+20>>2]=d;e=f>0>g>>>0){continue}break}b=a+16|0;i=H[a>>2];d=H[a+16>>2];c=H[a+20>>2]-d|0;h:{if(c>>>0>>2|0)|0);break h}if((c|0)==16384){break h}H[a+20>>2]=d+16384}c=a+28|0;g=H[c>>2];d=H[a+32>>2]-g>>3;i:{if(d>>>0>>0){ob(c,f-d|0);g=H[c>>2];break i}if(d>>>0>f>>>0){H[a+32>>2]=(f2];b=0;a=0;while(1){c=i+(b2];e=a;j=(b2]=a;H[j>>2]=h;c=H[c>>2];a=c+a|0;if(a>>>0>4096){break a}j:{if(a>>>0>>0){break j}h=0;j=c&7;if(j){while(1){H[d+(e2]=b;e=e+1|0;h=h+1|0;if((j|0)!=(h|0)){continue}break}}if(c-1>>>0>2]=b;H[c+24>>2]=b;H[c+20>>2]=b;H[c+16>>2]=b;H[c+12>>2]=b;H[c+8>>2]=b;H[c+4>>2]=b;e=e+8|0;if((e|0)!=(a|0)){continue}break}}b=b+1|0;if((f|0)!=(b|0)){continue}break}o=(a|0)==4096}return o}function Ni(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0;g=ca-48|0;ca=g;d=H[a+8>>2];if(d-2>>>0>2]=d;e=-12]=d;H[a+80>>2]=e^-1;H[a+92>>2]=(d|0)/2;L[a+88>>2]=O(2)/O(d|0)}H[a+52>>2]=f;d=H[a+40>>2];e=H[d>>2];d=H[d+4>>2];H[g+16>>2]=0;H[g+8>>2]=0;H[g+12>>2]=0;a:{d=d-e|0;if((d|0)>0){m=a+8|0;n=a+44|0;d=d>>>2|0;o=d>>>0>2];d=H[e>>2];if(H[e+4>>2]-d>>2>>>0>>0){break a}Nb(n,H[d+(j2],g+8|0);h=H[g+12>>2];d=h>>31;i=H[g+8>>2];e=i>>31;f=(d^h)-d+((e^i)-e)|0;l=H[g+16>>2];d=l>>31;e=(d^l)-d|0;d=0;k=e;e=e+f|0;d=k>>>0>e>>>0?1:d;b:{if(!(d|e)){H[g+8>>2]=H[a+92>>2];break b}f=H[a+92>>2];k=f>>31;i=Sj(Rj(f,k,i,i>>31),da,e,d);H[g+8>>2]=i;d=Sj(Rj(f,k,h,h>>31),da,e,d);H[g+12>>2]=d;e=d>>31;e=(d^e)-e|0;d=i>>31;d=e+((d^i)-d|0)|0;if((l|0)>=0){H[g+16>>2]=f-d;break b}H[g+16>>2]=d-f}d=Ba(p);f=H[g+8>>2];c:{if(d){H[g+16>>2]=0-H[g+16>>2];e=0-H[g+12>>2]|0;H[g+12>>2]=e;f=0-f|0;H[g+8>>2]=f;break c}e=H[g+12>>2]}d:{if((f|0)>=0){f=H[a+92>>2];d=f+H[g+16>>2]|0;f=e+f|0;break d}e:{if((e|0)>2];f=d>>31;f=(d^f)-f|0;break e}d=H[g+16>>2];f=d>>31;f=H[a+84>>2]+(f-(d^f)|0)|0}if((d|0)>31;d=(d^e)-d|0;break d}d=e>>31;d=H[a+84>>2]+(d-(d^e)|0)|0}e=H[a+84>>2];f:{if(!(d|f)){d=e;f=d;break f}if(!((d|0)!=(e|0)|f)){f=d;break f}if(!((e|0)!=(f|0)|d)){d=f;break f}g:{if(f){break g}h=H[a+92>>2];if((h|0)>=(d|0)){break g}d=(h2];if((h|0)>2]=d;H[g+32>>2]=f;H[g+24>>2]=i;H[g+28>>2]=h;qc(g+40|0,m,g+32|0,g+24|0);d=c+e|0;H[d>>2]=H[g+40>>2];H[d+4>>2]=H[g+44>>2];j=j+1|0;if((o|0)!=(j|0)){continue}break}}ca=g+48|0;return 1}Ca();v()}function Ii(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0;g=ca-48|0;ca=g;d=H[a+8>>2];if(d-2>>>0>2]=d;e=-12]=d;H[a+80>>2]=e^-1;H[a+92>>2]=(d|0)/2;L[a+88>>2]=O(2)/O(d|0)}H[a+52>>2]=f;d=H[a+40>>2];e=H[d>>2];d=H[d+4>>2];H[g+16>>2]=0;H[g+8>>2]=0;H[g+12>>2]=0;a:{d=d-e|0;if((d|0)>0){m=a+8|0;n=a+44|0;d=d>>>2|0;o=d>>>0>2];d=H[e>>2];if(H[e+4>>2]-d>>2>>>0>>0){break a}Lb(n,H[d+(j2],g+8|0);h=H[g+12>>2];d=h>>31;i=H[g+8>>2];e=i>>31;f=(d^h)-d+((e^i)-e)|0;l=H[g+16>>2];d=l>>31;e=(d^l)-d|0;d=0;k=e;e=e+f|0;d=k>>>0>e>>>0?1:d;b:{if(!(d|e)){H[g+8>>2]=H[a+92>>2];break b}f=H[a+92>>2];k=f>>31;i=Sj(Rj(f,k,i,i>>31),da,e,d);H[g+8>>2]=i;d=Sj(Rj(f,k,h,h>>31),da,e,d);H[g+12>>2]=d;e=d>>31;e=(d^e)-e|0;d=i>>31;d=e+((d^i)-d|0)|0;if((l|0)>=0){H[g+16>>2]=f-d;break b}H[g+16>>2]=d-f}d=Ba(p);f=H[g+8>>2];c:{if(d){H[g+16>>2]=0-H[g+16>>2];e=0-H[g+12>>2]|0;H[g+12>>2]=e;f=0-f|0;H[g+8>>2]=f;break c}e=H[g+12>>2]}d:{if((f|0)>=0){f=H[a+92>>2];d=f+H[g+16>>2]|0;f=e+f|0;break d}e:{if((e|0)>2];f=d>>31;f=(d^f)-f|0;break e}d=H[g+16>>2];f=d>>31;f=H[a+84>>2]+(f-(d^f)|0)|0}if((d|0)>31;d=(d^e)-d|0;break d}d=e>>31;d=H[a+84>>2]+(d-(d^e)|0)|0}e=H[a+84>>2];f:{if(!(d|f)){d=e;f=d;break f}if(!((d|0)!=(e|0)|f)){f=d;break f}if(!((e|0)!=(f|0)|d)){d=f;break f}g:{if(f){break g}h=H[a+92>>2];if((h|0)>=(d|0)){break g}d=(h2];if((h|0)>2]=d;H[g+32>>2]=f;H[g+24>>2]=i;H[g+28>>2]=h;qc(g+40|0,m,g+32|0,g+24|0);d=c+e|0;H[d>>2]=H[g+40>>2];H[d+4>>2]=H[g+44>>2];j=j+1|0;if((o|0)!=(j|0)){continue}break}}ca=g+48|0;return 1}Ca();v()}function Wi(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0;g=ca-48|0;ca=g;d=H[a+8>>2];if(d-2>>>0>2]=d;e=-12]=d;H[a+80>>2]=e^-1;H[a+92>>2]=(d|0)/2;L[a+88>>2]=O(2)/O(d|0)}H[a+52>>2]=f;d=H[a+40>>2];e=H[d>>2];d=H[d+4>>2];H[g+16>>2]=0;H[g+8>>2]=0;H[g+12>>2]=0;a:{d=d-e|0;if((d|0)>0){m=a+8|0;n=a+44|0;d=d>>>2|0;o=d>>>0>2];d=H[e>>2];if(H[e+4>>2]-d>>2>>>0>>0){break a}Nb(n,H[d+(j2],g+8|0);h=H[g+12>>2];d=h>>31;i=H[g+8>>2];e=i>>31;f=(d^h)-d+((e^i)-e)|0;l=H[g+16>>2];d=l>>31;e=(d^l)-d|0;d=0;k=e;e=e+f|0;d=k>>>0>e>>>0?1:d;b:{if(!(d|e)){H[g+8>>2]=H[a+92>>2];break b}f=H[a+92>>2];k=f>>31;i=Sj(Rj(f,k,i,i>>31),da,e,d);H[g+8>>2]=i;d=Sj(Rj(f,k,h,h>>31),da,e,d);H[g+12>>2]=d;e=d>>31;e=(d^e)-e|0;d=i>>31;d=e+((d^i)-d|0)|0;if((l|0)>=0){H[g+16>>2]=f-d;break b}H[g+16>>2]=d-f}d=Ba(p);f=H[g+8>>2];c:{if(d){H[g+16>>2]=0-H[g+16>>2];e=0-H[g+12>>2]|0;H[g+12>>2]=e;f=0-f|0;H[g+8>>2]=f;break c}e=H[g+12>>2]}d:{if((f|0)>=0){f=H[a+92>>2];d=f+H[g+16>>2]|0;f=e+f|0;break d}e:{if((e|0)>2];f=d>>31;f=(d^f)-f|0;break e}d=H[g+16>>2];f=d>>31;f=H[a+84>>2]+(f-(d^f)|0)|0}if((d|0)>31;d=(d^e)-d|0;break d}d=e>>31;d=H[a+84>>2]+(d-(d^e)|0)|0}e=H[a+84>>2];f:{if(!(d|f)){d=e;f=d;break f}if(!((d|0)!=(e|0)|f)){f=d;break f}if(!((e|0)!=(f|0)|d)){d=f;break f}g:{if(f){break g}h=H[a+92>>2];if((h|0)>=(d|0)){break g}d=(h2];if((h|0)>2];H[g+44>>2]=i;H[g+28>>2]=d;H[g+24>>2]=f;rc(g+32|0,m,g+24|0,g+40|0);d=c+e|0;H[d>>2]=H[g+32>>2];H[d+4>>2]=H[g+36>>2];j=j+1|0;if((o|0)!=(j|0)){continue}break}}ca=g+48|0;return 1}Ca();v()}function Ri(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0;g=ca-48|0;ca=g;d=H[a+8>>2];if(d-2>>>0>2]=d;e=-12]=d;H[a+80>>2]=e^-1;H[a+92>>2]=(d|0)/2;L[a+88>>2]=O(2)/O(d|0)}H[a+52>>2]=f;d=H[a+40>>2];e=H[d>>2];d=H[d+4>>2];H[g+16>>2]=0;H[g+8>>2]=0;H[g+12>>2]=0;a:{d=d-e|0;if((d|0)>0){m=a+8|0;n=a+44|0;d=d>>>2|0;o=d>>>0>2];d=H[e>>2];if(H[e+4>>2]-d>>2>>>0>>0){break a}Lb(n,H[d+(j2],g+8|0);h=H[g+12>>2];d=h>>31;i=H[g+8>>2];e=i>>31;f=(d^h)-d+((e^i)-e)|0;l=H[g+16>>2];d=l>>31;e=(d^l)-d|0;d=0;k=e;e=e+f|0;d=k>>>0>e>>>0?1:d;b:{if(!(d|e)){H[g+8>>2]=H[a+92>>2];break b}f=H[a+92>>2];k=f>>31;i=Sj(Rj(f,k,i,i>>31),da,e,d);H[g+8>>2]=i;d=Sj(Rj(f,k,h,h>>31),da,e,d);H[g+12>>2]=d;e=d>>31;e=(d^e)-e|0;d=i>>31;d=e+((d^i)-d|0)|0;if((l|0)>=0){H[g+16>>2]=f-d;break b}H[g+16>>2]=d-f}d=Ba(p);f=H[g+8>>2];c:{if(d){H[g+16>>2]=0-H[g+16>>2];e=0-H[g+12>>2]|0;H[g+12>>2]=e;f=0-f|0;H[g+8>>2]=f;break c}e=H[g+12>>2]}d:{if((f|0)>=0){f=H[a+92>>2];d=f+H[g+16>>2]|0;f=e+f|0;break d}e:{if((e|0)>2];f=d>>31;f=(d^f)-f|0;break e}d=H[g+16>>2];f=d>>31;f=H[a+84>>2]+(f-(d^f)|0)|0}if((d|0)>31;d=(d^e)-d|0;break d}d=e>>31;d=H[a+84>>2]+(d-(d^e)|0)|0}e=H[a+84>>2];f:{if(!(d|f)){d=e;f=d;break f}if(!((d|0)!=(e|0)|f)){f=d;break f}if(!((e|0)!=(f|0)|d)){d=f;break f}g:{if(f){break g}h=H[a+92>>2];if((h|0)>=(d|0)){break g}d=(h2];if((h|0)>2];H[g+44>>2]=i;H[g+28>>2]=d;H[g+24>>2]=f;rc(g+32|0,m,g+24|0,g+40|0);d=c+e|0;H[d>>2]=H[g+32>>2];H[d+4>>2]=H[g+36>>2];j=j+1|0;if((o|0)!=(j|0)){continue}break}}ca=g+48|0;return 1}Ca();v()}function Ge(a,b){var c=0,d=0,e=0,f=0,g=0,h=0,i=0;f=ca-16|0;ca=f;c=H[a+4>>2];H[a+40>>2]=H[a>>2];H[a+44>>2]=c;c=H[a+36>>2];H[a+72>>2]=H[a+32>>2];H[a+76>>2]=c;d=H[a+28>>2];c=a- -64|0;H[c>>2]=H[a+24>>2];H[c+4>>2]=d;c=H[a+20>>2];H[a+56>>2]=H[a+16>>2];H[a+60>>2]=c;c=H[a+12>>2];H[a+48>>2]=H[a+8>>2];H[a+52>>2]=c;a:{b:{if(Db(a+40|0,1,f+8|0)){c=H[a+44>>2];H[a>>2]=H[a+40>>2];H[a+4>>2]=c;c=H[a+76>>2];H[a+32>>2]=H[a+72>>2];H[a+36>>2]=c;c=H[a+68>>2];H[a+24>>2]=H[a+64>>2];H[a+28>>2]=c;d=H[a+60>>2];h=d;c=H[a+56>>2];H[a+16>>2]=c;H[a+20>>2]=d;e=H[a+52>>2];d=H[a+48>>2];H[a+8>>2]=d;H[a+12>>2]=e;i=d-c|0;g=H[f+12>>2];e=e-((c>>>0>d>>>0)+h|0)|0;d=H[f+8>>2];if((g|0)==(e|0)&i>>>0>=d>>>0|e>>>0>g>>>0){break b}}c=0;break a}e=h+g|0;c=c+d|0;e=c>>>0>>0?e+1|0:e;H[a+16>>2]=c;H[a+20>>2]=e;c:{if(J[a+38>>1]>2];H[a+96>>2]=H[a>>2];H[a+100>>2]=c;c=H[a+36>>2];H[a+128>>2]=H[a+32>>2];H[a+132>>2]=c;c=H[a+28>>2];H[a+120>>2]=H[a+24>>2];H[a+124>>2]=c;c=H[a+20>>2];H[a+112>>2]=H[a+16>>2];H[a+116>>2]=c;c=H[a+12>>2];H[a+104>>2]=H[a+8>>2];H[a+108>>2]=c;d:{if(Db(a+96|0,1,f+8|0)){c=H[a+100>>2];H[a>>2]=H[a+96>>2];H[a+4>>2]=c;c=H[a+132>>2];H[a+32>>2]=H[a+128>>2];H[a+36>>2]=c;c=H[a+124>>2];H[a+24>>2]=H[a+120>>2];H[a+28>>2]=c;d=H[a+116>>2];h=d;c=H[a+112>>2];H[a+16>>2]=c;H[a+20>>2]=d;e=H[a+108>>2];d=H[a+104>>2];H[a+8>>2]=d;H[a+12>>2]=e;i=d-c|0;g=H[f+12>>2];e=e-((c>>>0>d>>>0)+h|0)|0;d=H[f+8>>2];if((g|0)==(e|0)&i>>>0>=d>>>0|e>>>0>g>>>0){break d}}c=0;break a}e=h+g|0;c=c+d|0;e=c>>>0>>0?e+1|0:e;H[a+16>>2]=c;H[a+20>>2]=e;break c}c=0;if(!ta(a+80|0,a)){break a}}c=0;if(!Fe(a)){break a}c=H[a+4>>2];H[b>>2]=H[a>>2];H[b+4>>2]=c;c=H[a+36>>2];H[b+32>>2]=H[a+32>>2];H[b+36>>2]=c;c=H[a+28>>2];H[b+24>>2]=H[a+24>>2];H[b+28>>2]=c;c=H[a+20>>2];H[b+16>>2]=H[a+16>>2];H[b+20>>2]=c;c=H[a+12>>2];H[b+8>>2]=H[a+8>>2];H[b+12>>2]=c;c=1}ca=f+16|0;return c}function oe(a,b){var c=0,d=0,e=0,f=0,g=0,h=0,i=0;if(!H[a+64>>2]){c=pa(32);H[c+16>>2]=0;H[c+20>>2]=0;H[c+8>>2]=0;H[c>>2]=0;H[c+4>>2]=0;H[c+24>>2]=0;H[c+28>>2]=0;d=H[a+64>>2];H[a+64>>2]=c;if(d){c=H[d>>2];if(c){H[d+4>>2]=c;oa(c)}oa(d);c=H[a+64>>2]}H[a>>2]=c;d=H[c+20>>2];H[a+8>>2]=H[c+16>>2];H[a+12>>2]=d;d=H[c+24>>2];c=H[c+28>>2];H[a+48>>2]=0;H[a+52>>2]=0;H[a+40>>2]=0;H[a+44>>2]=0;H[a+16>>2]=d;H[a+20>>2]=c}a:{F[a+24|0]=I[b+24|0];H[a+28>>2]=H[b+28>>2];F[a+32|0]=I[b+32|0];c=H[b+44>>2];H[a+40>>2]=H[b+40>>2];H[a+44>>2]=c;c=H[b+52>>2];H[a+48>>2]=H[b+48>>2];H[a+52>>2]=c;H[a+56>>2]=H[b+56>>2];c=H[b+12>>2];H[a+8>>2]=H[b+8>>2];H[a+12>>2]=c;c=H[b+20>>2];H[a+16>>2]=H[b+16>>2];H[a+20>>2]=c;H[a+60>>2]=H[b+60>>2];c=H[b>>2];b:{if(!c){H[a>>2]=0;d=1;break b}g=H[a>>2];d=0;if(!g){break b}d=H[c>>2];c=H[c+4>>2]-d|0;se(g,d,c,0);d=1}c:{if(!d){break c}F[a+84|0]=I[b+84|0];H[a+80>>2]=H[b+80>>2];if((a|0)!=(b|0)){Cb(a+68|0,H[b+68>>2],H[b+72>>2])}f=H[b+88>>2];d:{if(f){e=pa(40);b=H[f>>2];H[e+16>>2]=0;H[e+8>>2]=0;H[e+12>>2]=0;H[e>>2]=b;c=H[f+12>>2];b=H[f+8>>2];if((c|0)!=(b|0)){c=c-b|0;if((c|0)>2]=b;H[e+8>>2]=b;H[e+16>>2]=b+c;c=H[f+8>>2];h=H[f+12>>2];e:{if((c|0)==(h|0)){break e}g=(c^-1)+h|0;d=h-c&7;if(d){while(1){F[b|0]=I[c|0];b=b+1|0;c=c+1|0;i=i+1|0;if((d|0)!=(i|0)){continue}break}}if(g>>>0>2]=b}b=H[f+36>>2];H[e+32>>2]=H[f+32>>2];H[e+36>>2]=b;b=H[f+28>>2];H[e+24>>2]=H[f+24>>2];H[e+28>>2]=b;b=H[a+88>>2];H[a+88>>2]=e;if(b){break d}break c}b=H[a+88>>2];H[a+88>>2]=0;if(!b){break c}}a=H[b+8>>2];if(a){H[b+12>>2]=a;oa(a)}oa(b)}return}sa();v()}function og(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0;f=ca-32|0;ca=f;e=f+8|0;c=ca-80|0;ca=c;a=H[b+36>>2];H[c+72>>2]=H[b+32>>2];H[c+76>>2]=a;d=H[b+28>>2];a=c- -64|0;H[a>>2]=H[b+24>>2];H[a+4>>2]=d;a=H[b+20>>2];H[c+56>>2]=H[b+16>>2];H[c+60>>2]=a;a=H[b+12>>2];H[c+48>>2]=H[b+8>>2];H[c+52>>2]=a;a=H[b+4>>2];H[c+40>>2]=H[b>>2];H[c+44>>2]=a;nc(c+8|0,c+40|0,c+24|0);a=H[c+8>>2];a:{if(a){H[e>>2]=a;a=e+4|0;if(F[c+23|0]>=0){b=c+8|4;e=H[b+4>>2];H[a>>2]=H[b>>2];H[a+4>>2]=e;H[a+8>>2]=H[b+8>>2];break a}za(a,H[c+12>>2],H[c+16>>2]);if(F[c+23|0]>=0){break a}oa(H[c+12>>2]);break a}if(F[c+23|0]>2])}a=I[c+31|0];if(a>>>0>=2){b=pa(32);F[b+26|0]=0;a=I[1477]|I[1478]>8;a=I[1473]|I[1474]8;F[b+22|0]=a>>>16;F[b+23|0]=a>>>24;a=I[1465]|I[1466]8;F[b+14|0]=a>>>16;F[b+15|0]=a>>>24;a=I[1457]|I[1458]8;F[b+6|0]=a>>>16;F[b+7|0]=a>>>24;H[c+8>>2]=-1;a=c+8|4;za(a,b,26);d=F[c+23|0];H[e>>2]=H[c+8>>2];e=e+4|0;if((d|0)>=0){d=H[a+4>>2];H[e>>2]=H[a>>2];H[e+4>>2]=d;H[e+8>>2]=H[a+8>>2];oa(b);break a}za(e,H[c+12>>2],H[c+16>>2]);if(F[c+23|0]>2])}oa(b);break a}H[e>>2]=0;H[e+4>>2]=0;H[e+16>>2]=a;H[e+8>>2]=0;H[e+12>>2]=0}ca=c+80|0;a=H[f+24>>2];if(F[f+23|0]>2])}ca=f+32|0;return a|0}function Xd(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0;k=ca-16|0;ca=k;H[k+8>>2]=c;h=H[a+12>>2];d=H[a+8>>2];g=h-d>>2;a:{if((g|0)>(b|0)){break a}e=b+1|0;if(e>>>0>g>>>0){l=e-g|0;f=H[a+16>>2];d=H[a+12>>2];if(l>>>0>2>>>0){if(l){e=d;d=l2]=d;break a}b:{c:{d:{m=H[a+8>>2];g=d-m>>2;i=g+l|0;if(i>>>0>>1|0;e=e>>>0>=2147483644?1073741823:f>>>0>i>>>0?f:i;if(e){if(e>>>0>=1073741824){break d}j=pa(e2]=e;e=H[a+12>>2];H[a+12>>2]=g;d=H[a+8>>2];H[a+8>>2]=h;if((d|0)==(e|0)){break b}while(1){e=e-4|0;f=H[e>>2];H[e>>2]=0;if(f){Ga(f)}if((d|0)!=(e|0)){continue}break}break b}sa();v()}wa();v()}H[a+16>>2]=e;H[a+12>>2]=g;H[a+8>>2]=i}if(d){oa(d)}break a}if(e>>>0>=g>>>0){break a}d=d+(e2];H[h>>2]=0;if(c){Ga(c)}if((d|0)!=(h|0)){continue}break}c=H[k+8>>2]}H[a+12>>2]=d}e:{f:{d=H[c+56>>2];g:{if((d|0)>4){break g}j=N(d,12)+a|0;d=H[j+24>>2];if((d|0)!=H[j+28>>2]){H[d>>2]=b;H[j+24>>2]=d+4;break g}i=H[j+20>>2];g=d-i|0;f=g>>2;e=f+1|0;if(e>>>0>=1073741824){break f}d=g>>>1|0;e=g>>>0>=2147483644?1073741823:d>>>0>e>>>0?d:e;if(e){if(e>>>0>=1073741824){break e}d=pa(e2]=d;H[j+24>>2]=f+4;H[j+28>>2]=d+(e2]=b;a=H[a+8>>2];H[k+8>>2]=0;a=a+(b2];H[a>>2]=c;if(b){Ga(b)}a=H[k+8>>2];H[k+8>>2]=0;if(a){Ga(a)}ca=k+16|0;return}sa();v()}wa();v()}function Og(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0;i=c;d=a;a:{if(H[a+12>>2]==(b|0)){break a}a=b;b=H[d+4>>2];e=H[d>>2];if((b|0)!=(e|0)){while(1){c=b-12|0;if(F[b-1|0]>2])}b=c;if((e|0)!=(b|0)){continue}break}}H[d+12>>2]=a;H[d+4>>2]=e;c=H[a>>2];j=a+4|0;if((c|0)==(j|0)){break a}while(1){a=H[d+4>>2];b:{if((a|0)!=H[d+8>>2]){c:{if(F[c+27|0]>=0){b=H[c+20>>2];H[a>>2]=H[c+16>>2];H[a+4>>2]=b;H[a+8>>2]=H[c+24>>2];break c}za(a,H[c+16>>2],H[c+20>>2])}H[d+4>>2]=a+12;break b}g=0;d:{e:{f:{a=H[d+4>>2];e=H[d>>2];f=(a-e|0)/12|0;b=f+1|0;if(b>>>0>2]-e|0)/12|0;k=h>0>=178956970?357913941:b>>>0>>0?k:b;if(b){if(b>>>0>=357913942){break f}g=pa(N(b,12))}h=N(b,12);b=N(f,12)+g|0;g:{if(F[c+27|0]>=0){f=H[c+20>>2];H[b>>2]=H[c+16>>2];H[b+4>>2]=f;H[b+8>>2]=H[c+24>>2];break g}za(b,H[c+16>>2],H[c+20>>2]);e=H[d>>2];a=H[d+4>>2]}g=g+h|0;f=b+12|0;if((a|0)==(e|0)){break e}while(1){a=a-12|0;h=H[a+4>>2];b=b-12|0;H[b>>2]=H[a>>2];H[b+4>>2]=h;H[b+8>>2]=H[a+8>>2];H[a>>2]=0;H[a+4>>2]=0;H[a+8>>2]=0;if((a|0)!=(e|0)){continue}break}H[d+8>>2]=g;a=H[d+4>>2];H[d+4>>2]=f;e=H[d>>2];H[d>>2]=b;if((a|0)==(e|0)){break d}while(1){b=a-12|0;if(F[a-1|0]>2])}a=b;if((e|0)!=(b|0)){continue}break}break d}sa();v()}wa();v()}H[d+8>>2]=g;H[d+4>>2]=f;H[d>>2]=b}if(e){oa(e)}}b=H[c+4>>2];h:{if(b){while(1){a=b;b=H[b>>2];if(b){continue}break h}}while(1){a=H[c+8>>2];b=H[a>>2]!=(c|0);c=a;if(b){continue}break}}c=a;if((j|0)!=(a|0)){continue}break}}a=0;i:{if((i|0)>2];if((H[d+4>>2]-b|0)/12>>>0>>0){break i}a=b+N(i,12)|0;a=F[a+11|0]>2]:a}return a|0}function bd(a,b){var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0;i=ca-16|0;ca=i;H[i>>2]=b;f=-1;a:{if((b|0)==-1){H[i+4>>2]=-1;break a}f=b+1|0;H[i+4>>2]=(f>>>0)%3|0?f:b-2|0;if((b>>>0)%3|0){f=b-1|0;break a}f=b+2|0}H[i+8>>2]=f;n=(b>>>0)/3|0;b:{c:{d:{while(1){e:{f:{j=H[(l2];if((j|0)!=-1){f=H[H[H[a+8>>2]+12>>2]+(j2];if((f|0)!=-1){break f}}f=0;g=H[a+216>>2];if((g|0)==H[a+220>>2]){break e}while(1){g=N(f,144)+g|0;d=H[g+136>>2];c=H[g+140>>2];g:{if(d>>>0>>0){H[d>>2]=j;H[g+136>>2]=d+4;break g}e=d;d=H[g+132>>2];k=e-d|0;e=k>>2;h=e+1|0;if(h>>>0>=1073741824){break d}m=e>1|0;h=c>>>0>=2147483644?1073741823:h>>>0>>0?e:h;if(h){if(h>>>0>=1073741824){break c}c=pa(h2]=j;c=va(c,d,k);H[g+132>>2]=c;H[g+136>>2]=e+4;H[g+140>>2]=c+(h2];if(f>>>0>2]-g|0)/144>>>0){continue}break}break e}if((b|0)==-1|(f>>>0)/3>>>0>>0){break e}f=0;if(H[a+220>>2]==H[a+216>>2]){break e}while(1){h:{if(!Ba(H[a+368>>2]+(f2]+N(f,144)|0;d=H[g+136>>2];c=H[g+140>>2];if(d>>>0>>0){H[d>>2]=j;H[g+136>>2]=d+4;break h}e=d;d=H[g+132>>2];k=e-d|0;e=k>>2;h=e+1|0;if(h>>>0>=1073741824){break b}m=e>1|0;h=c>>>0>=2147483644?1073741823:h>>>0>>0?e:h;if(h){if(h>>>0>=1073741824){break c}c=pa(h2]=j;c=va(c,d,k);H[g+132>>2]=c;H[g+136>>2]=e+4;H[g+140>>2]=c+(h>0>2]-H[a+216>>2]|0)/144>>>0){continue}break}}l=l+1|0;if((l|0)!=3){continue}break}ca=i+16|0;return 1}sa();v()}wa();v()}sa();v()}function cd(a,b){var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0;h=ca-16|0;ca=h;H[h>>2]=b;c=-1;a:{if((b|0)==-1){H[h+4>>2]=-1;break a}c=b+1|0;H[h+4>>2]=(c>>>0)%3|0?c:b-2|0;if((b>>>0)%3|0){c=b-1|0;break a}c=b+2|0}H[h+8>>2]=c;b:{c:{while(1){i=H[(k2];d:{if(!((i|0)==-1|H[H[H[a+8>>2]+12>>2]+(i2]==-1)){b=0;if(H[a+220>>2]==H[a+216>>2]){break d}while(1){e:{f:{if(!Ba(H[a+368>>2]+(b2]+N(b,144)|0;e=H[c+136>>2];d=H[c+140>>2];if(e>>>0>>0){H[e>>2]=i;H[c+136>>2]=e+4;break f}f=e;e=H[c+132>>2];j=f-e|0;f=j>>2;g=f+1|0;if(g>>>0>=1073741824){break e}l=f>1|0;g=d>>>0>=2147483644?1073741823:g>>>0>>0?f:g;if(g){if(g>>>0>=1073741824){break b}d=pa(g2]=i;d=va(d,e,j);H[c+132>>2]=d;H[c+136>>2]=f+4;H[c+140>>2]=d+(g>0>2]-H[a+216>>2]|0)/144>>>0){continue}break d}break}sa();v()}b=0;c=H[a+216>>2];if((c|0)==H[a+220>>2]){break d}while(1){c=N(b,144)+c|0;e=H[c+136>>2];d=H[c+140>>2];g:{if(e>>>0>>0){H[e>>2]=i;H[c+136>>2]=e+4;break g}f=e;e=H[c+132>>2];j=f-e|0;f=j>>2;g=f+1|0;if(g>>>0>=1073741824){break c}l=f>1|0;g=d>>>0>=2147483644?1073741823:g>>>0>>0?f:g;if(g){if(g>>>0>=1073741824){break b}d=pa(g2]=i;d=va(d,e,j);H[c+132>>2]=d;H[c+136>>2]=f+4;H[c+140>>2]=d+(g2];if(b>>>0>2]-c|0)/144>>>0){continue}break}}k=k+1|0;if((k|0)!=3){continue}break}ca=h+16|0;return 1}sa();v()}wa();v()}function vg(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0;m=ca-16|0;ca=m;l=H[b+80>>2];e=I[c+24|0];a=N(l,e);a:{b:{c:{d:{b=H[c+28>>2];if(!(!I[c+84|0]|(b|0)!=1&(b|0)!=2)){b=H[c+48>>2];c=H[H[c>>2]>>2];H[m+8>>2]=0;H[m>>2]=0;H[m+4>>2]=0;if(a){if((a|0)>2];if(a){H[d+4>>2]=a;oa(a)}H[d+8>>2]=h;H[d+4>>2]=h;H[d>>2]=f;b=1;break a}if(e){f=pa(e);ra(f,0,e)}e:{i=H[d+4>>2];b=H[d>>2];g=i-b|0;f:{if(g>>>0>>0){k=a-g|0;j=H[d+8>>2];if(k>>>0>>0){n=d,o=ra(i,0,k)+k|0,H[n+4>>2]=o;break f}if((a|0)0>=1073741823?2147483647:a>>>0>>0?j:a;j=pa(i);ra(j+g|0,0,k);g=va(j,b,g);H[d+8>>2]=g+i;H[d+4>>2]=a+g;H[d>>2]=g;if(!b){break f}oa(b);break f}if(a>>>0>=g>>>0){break f}H[d+4>>2]=a+b}if(!l){b=1;break c}if(!e){b=0;a=0;while(1){if(!ic(c,I[c+84|0]?a:H[H[c+68>>2]+(a2],F[c+24|0],f)){break c}a=a+1|0;b=l>>>0>>0;if((a|0)!=(l|0)){continue}break}break c}i=e&252;g=e&3;b=0;j=e>>>0>2]+(e2],F[c+24|0],f)){break c}b=0;a=0;k=0;if(!j){while(1){F[H[d>>2]+h|0]=I[a+f|0];F[(H[d>>2]+h|0)+1|0]=I[(a|1)+f|0];F[(H[d>>2]+h|0)+2|0]=I[(a|2)+f|0];F[(H[d>>2]+h|0)+3|0]=I[(a|3)+f|0];a=a+4|0;h=h+4|0;k=k+4|0;if((i|0)!=(k|0)){continue}break}}if(g){while(1){F[H[d>>2]+h|0]=I[a+f|0];a=a+1|0;h=h+1|0;b=b+1|0;if((g|0)!=(b|0)){continue}break}}e=e+1|0;b=l>>>0>>0;if((e|0)!=(l|0)){continue}break}break b}sa();v()}sa();v()}if(!f){break a}}oa(f)}ca=m+16|0;return b&1}function ug(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0;m=ca-16|0;ca=m;l=H[b+80>>2];e=I[c+24|0];a=N(l,e);a:{b:{c:{d:{b=H[c+28>>2];if(!(!I[c+84|0]|(b|0)!=1&(b|0)!=2)){b=H[c+48>>2];c=H[H[c>>2]>>2];H[m+8>>2]=0;H[m>>2]=0;H[m+4>>2]=0;if(a){if((a|0)>2];if(a){H[d+4>>2]=a;oa(a)}H[d+8>>2]=h;H[d+4>>2]=h;H[d>>2]=f;b=1;break a}if(e){f=pa(e);ra(f,0,e)}e:{i=H[d+4>>2];b=H[d>>2];g=i-b|0;f:{if(g>>>0>>0){k=a-g|0;j=H[d+8>>2];if(k>>>0>>0){n=d,o=ra(i,0,k)+k|0,H[n+4>>2]=o;break f}if((a|0)0>=1073741823?2147483647:a>>>0>>0?j:a;j=pa(i);ra(j+g|0,0,k);g=va(j,b,g);H[d+8>>2]=g+i;H[d+4>>2]=a+g;H[d>>2]=g;if(!b){break f}oa(b);break f}if(a>>>0>=g>>>0){break f}H[d+4>>2]=a+b}if(!l){b=1;break c}if(!e){b=0;a=0;while(1){if(!hc(c,I[c+84|0]?a:H[H[c+68>>2]+(a2],F[c+24|0],f)){break c}a=a+1|0;b=l>>>0>>0;if((a|0)!=(l|0)){continue}break}break c}i=e&252;g=e&3;b=0;j=e>>>0>2]+(e2],F[c+24|0],f)){break c}b=0;a=0;k=0;if(!j){while(1){F[H[d>>2]+h|0]=I[a+f|0];F[(H[d>>2]+h|0)+1|0]=I[(a|1)+f|0];F[(H[d>>2]+h|0)+2|0]=I[(a|2)+f|0];F[(H[d>>2]+h|0)+3|0]=I[(a|3)+f|0];a=a+4|0;h=h+4|0;k=k+4|0;if((i|0)!=(k|0)){continue}break}}if(g){while(1){F[H[d>>2]+h|0]=I[a+f|0];a=a+1|0;h=h+1|0;b=b+1|0;if((g|0)!=(b|0)){continue}break}}e=e+1|0;b=l>>>0>>0;if((e|0)!=(l|0)){continue}break}break b}sa();v()}sa();v()}if(!f){break a}}oa(f)}ca=m+16|0;return b&1}function qc(a,b,c,d){var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0;k=H[b+16>>2];h=H[c+4>>2]-k|0;e=H[c>>2]-k|0;H[c>>2]=e;f=h;H[c+4>>2]=f;l=H[b+16>>2];f=f>>31;g=(h^f)-f|0;f=e>>31;m=l>>>0>=g+((f^e)-f|0)>>>0;a:{if(m){f=h;break a}b:{c:{if((e|0)>=0){g=1;j=1;if((h|0)>=0){break b}i=1;g=-1;j=-1;if(e){break c}break b}i=-1;g=-1;j=-1;if((h|0)0){break g}i=(f|0)>0?3:0;g=f;f=e;break d}g=0-f|0;f=0-e|0;i=2;break e}if((f|0)>2]=f;H[c+4>>2]=g;j=0}e=H[d>>2]+f|0;h=H[b+16>>2];k:{if((e|0)>(h|0)){e=e-H[b+4>>2]|0;break k}if((0-h|0)>2]+e|0}c=H[d+4>>2]+g|0;l:{if((h|0)>2]|0;break l}if((0-h|0)>2]+c|0}m:{if(j){b=c;break m}b=c;n:{o:{p:{d=4-i|0;switch((d>>>0=0){c=1;f=1;if((b|0)>=0){break r}d=1;c=-1;f=-1;if(e){break s}break r}d=-1;c=-1;f=-1;if((b|0)>2]=0;a:{b:{if(J[b+38>>1]>2];d=H[b+16>>2];e=d+4|0;c=e>>>0>2];if(K[b+8>>2]>>0&(h|0)(h|0)){break a}d=d+H[b>>2]|0;f=I[d|0]|I[d+1|0]2]}if(!f){break a}c=H[H[a+48>>2]+64>>2];if(H[c+4>>2]-H[c>>2]>>2>>>0>>0){break a}Wa(a+76|0,f);c=j+8|0;H[c>>2]=0;H[c+4>>2]=0;F[c+5|0]=0;F[c+6|0]=0;F[c+7|0]=0;F[c+8|0]=0;F[c+9|0]=0;F[c+10|0]=0;F[c+11|0]=0;F[c+12|0]=0;c:{if(!ta(c,b)){break c}h=1;while(1){d=12]+(i>>>3&536870908)|0;e=e^h;if(e&1){d=H[g>>2]&(d^-1)}else{d=d|H[g>>2]}h=e^1;H[g>>2]=d;i=i+1|0;if((f|0)!=(i|0)){continue}break}c=H[b+8>>2];e=H[b+12>>2];g=e;e=H[b+20>>2];h=e;f=H[b+16>>2];d=f+4|0;e=d>>>0>>0>c>>>0&(e|0)>=(g|0)|(e|0)>(g|0)){break c}l=H[b>>2];d=l+f|0;k=I[d|0]|I[d+1|0]>0>>0>>0&(c|0)>=(g|0)|(c|0)>(g|0)){break c}d=i+l|0;d=I[d|0]|I[d+1|0]>2]=k;c=(d>>31)-((k>>31)+(d>>>0>>0)|0)|0;b=d-k|0;if(!c&b>>>0>2147483646|c){break c}m=1;c=b+1|0;H[a+20>>2]=c;b=c>>>1|0;H[a+24>>2]=b;H[a+28>>2]=0-b;if(c&1){break c}H[a+24>>2]=b-1}}ca=j+32|0;return m|0}function lj(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0;j=ca-32|0;ca=j;H[j+28>>2]=0;a:{b:{if(J[b+38>>1]>2];d=H[b+16>>2];e=d+4|0;c=e>>>0>2];if(K[b+8>>2]>>0&(h|0)(h|0)){break a}d=d+H[b>>2]|0;f=I[d|0]|I[d+1|0]2]}if(!f){break a}c=H[a+48>>2];if(H[c+4>>2]-H[c>>2]>>2>>>0>>0){break a}Wa(a+76|0,f);c=j+8|0;H[c>>2]=0;H[c+4>>2]=0;F[c+5|0]=0;F[c+6|0]=0;F[c+7|0]=0;F[c+8|0]=0;F[c+9|0]=0;F[c+10|0]=0;F[c+11|0]=0;F[c+12|0]=0;c:{if(!ta(c,b)){break c}h=1;while(1){d=12]+(i>>>3&536870908)|0;e=e^h;if(e&1){d=H[g>>2]&(d^-1)}else{d=d|H[g>>2]}h=e^1;H[g>>2]=d;i=i+1|0;if((f|0)!=(i|0)){continue}break}c=H[b+8>>2];e=H[b+12>>2];g=e;e=H[b+20>>2];h=e;f=H[b+16>>2];d=f+4|0;e=d>>>0>>0>c>>>0&(e|0)>=(g|0)|(e|0)>(g|0)){break c}l=H[b>>2];d=l+f|0;k=I[d|0]|I[d+1|0]>0>>0>>0&(c|0)>=(g|0)|(c|0)>(g|0)){break c}d=i+l|0;d=I[d|0]|I[d+1|0]>2]=k;c=(d>>31)-((k>>31)+(d>>>0>>0)|0)|0;b=d-k|0;if(!c&b>>>0>2147483646|c){break c}m=1;c=b+1|0;H[a+20>>2]=c;b=c>>>1|0;H[a+24>>2]=b;H[a+28>>2]=0-b;if(c&1){break c}H[a+24>>2]=b-1}}ca=j+32|0;return m|0}function cj(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0;H[a+8>>2]=e;m=a+32|0;h=H[m>>2];g=H[a+36>>2]-h>>2;a:{if(g>>>0>>0){ya(m,e-g|0);f=H[a+8>>2];break a}f=e;if(f>>>0>=g>>>0){break a}H[a+36>>2]=h+(e>0>1073741823?-1:e>2];c:{if((g|0)>(j|0)){H[f+h>>2]=j;break c}f=f+h|0;j=H[a+12>>2];if((j|0)>(g|0)){H[f>>2]=j;break c}H[f>>2]=g}f=H[a+8>>2];i=i+1|0;if((f|0)>(i|0)){continue}break}if((f|0)>2]|0;H[f>>2]=g;d:{if((g|0)>H[a+16>>2]){g=g-H[a+20>>2]|0}else{if((g|0)>=H[a+12>>2]){break d}g=g+H[a+20>>2]|0}H[f>>2]=g}f=H[a+8>>2];i=i+1|0;if((f|0)>(i|0)){continue}break}}if(!((d|0)2]=k;break f}f=f+j|0;k=H[a+12>>2];if((k|0)>(h|0)){H[f>>2]=k;break f}H[f>>2]=h}f=H[a+8>>2];i=i+1|0;if((f|0)>(i|0)){continue}break}i=0;if((f|0)>2]|0;H[f>>2]=h;g:{if((h|0)>H[a+16>>2]){h=h-H[a+20>>2]|0}else{if((h|0)>=H[a+12>>2]){break g}h=h+H[a+20>>2]|0}H[f>>2]=h}f=H[a+8>>2];i=i+1|0;if((f|0)>(i|0)){continue}break}}g=e+g|0;if((g|0)>>0)%3|0?c:b-2|0;f=b-1|0;if((b>>>0)%3|0){break a}f=b+2|0}b:{c:{d:{e:{f:{g:{e=H[a+184>>2];switch(e|0){case 7:break d;case 3:break e;case 5:break f;case 0:case 1:break g;default:break b}}g=H[a+148>>2];c=-1;e=1;d=((d|0)!=-1?H[H[g>>2]+(d2]:c)2];d=d+c|0;H[d>>2]=H[d>>2]+1;c=(((f|0)==-1?-1:H[H[g>>2]+(f2])2];c=H[a+156>>2];e=c+(((b|0)==-1?-1:H[H[g>>2]+(b2])2]=H[e>>2]+1;d=(((d|0)==-1?-1:H[H[g>>2]+(d2])2]=H[d>>2]+1;e=2;c=(((f|0)==-1?-1:H[H[g>>2]+(f2])2];c=H[a+156>>2];e=c+(((b|0)==-1?-1:H[H[g>>2]+(b2])2]=H[e>>2]+1;d=(((d|0)==-1?-1:H[H[g>>2]+(d2])2]=H[d>>2]+2;e=1;c=(((f|0)==-1?-1:H[H[g>>2]+(f2])2];c=H[a+156>>2];e=c+(((b|0)==-1?-1:H[H[g>>2]+(b2])2]=H[e>>2]+2;d=(((d|0)==-1?-1:H[H[g>>2]+(d2])2]=H[d>>2]+2;e=2;c=(((f|0)==-1?-1:H[H[g>>2]+(f2])2]=H[c>>2]+e;e=H[a+184>>2]}h:{switch(e|0){case 0:case 5:f=H[a+156>>2];c=-1;i:{if((b|0)==-1){break i}d=b+1|0;b=(d>>>0)%3|0?d:b-2|0;c=-1;if((b|0)==-1){break i}c=H[H[H[a+148>>2]>>2]+(b2]}if(H[f+(c2]>2]=5;return}H[a+188>>2]=0;return;default:break h}}H[a+188>>2]=-1}function xg(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0;j=H[b+80>>2];b=I[c+24|0];g=N(j,b);a:{if(!b){break a}h=b2]=-1073741824;a=a+4|0;e=e+1|0;if((k|0)!=(e|0)){continue}break}}if((b-1&1073741823)>>>0>2]=-1073741824;H[a+28>>2]=-1073741824;H[a+16>>2]=-1073741824;H[a+20>>2]=-1073741824;H[a+8>>2]=-1073741824;H[a+12>>2]=-1073741824;H[a>>2]=-1073741824;H[a+4>>2]=-1073741824;a=a+32|0;if((e|0)!=(a|0)){continue}break}}e=H[d>>2];a=H[d+4>>2]-e>>2;b:{if(a>>>0>>0){ya(d,g-a|0);break b}if(a>>>0>>0){break b}H[d+4>>2]=e+(g2]+(a2],F[c+24|0],f)){break e}a=a+1|0;i=j>>>0>>0;if((a|0)!=(j|0)){continue}break}break e}n=b&252;k=b&3;o=b>>>0>2]+(b2],F[c+24|0],f)){break e}m=H[d>>2];i=0;a=0;l=0;if(!o){while(1){g=(e2];L[g+4>>2]=L[(h|4)+f>>2];L[g+8>>2]=L[(h|8)+f>>2];L[g+12>>2]=L[(h|12)+f>>2];a=a+4|0;e=e+4|0;l=l+4|0;if((n|0)!=(l|0)){continue}break}}if(k){while(1){L[(e2]=L[(a2];a=a+1|0;e=e+1|0;i=i+1|0;if((k|0)!=(i|0)){continue}break}}b=b+1|0;i=j>>>0>>0;if((b|0)!=(j|0)){continue}break}break d}if(!f){break c}}oa(f)}return i|0}function mf(a){a=a|0;var b=0,c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0;e=ca-16|0;ca=e;h=1;i=ea[H[H[a>>2]+24>>2]](a)|0;a:{if((i|0)>2]+28>>2]](a)|0)+40>>2]){break c}j=f2]>>2];b=H[g+8>>2];k=rb(g);if(!k){break c}g=H[(ea[H[H[a>>2]+28>>2]](a)|0)+40>>2];H[e+12>>2]=H[b+56>>2];b=pa(32);H[e>>2]=b;H[e+4>>2]=24;H[e+8>>2]=-2147483616;c=I[1206]|I[1207]8;F[b+22|0]=c>>>16;F[b+23|0]=c>>>24;c=I[1198]|I[1199]8;F[b+14|0]=c>>>16;F[b+15|0]=c>>>24;c=I[1190]|I[1191]8;F[b+6|0]=c>>>16;F[b+7|0]=c>>>24;F[b+24|0]=0;b=sd(g,e+12|0,e);if(F[e+11|0]>2])}if(!b){break c}oe(H[H[H[a+36>>2]+j>>2]+8>>2],k);break b}b=H[H[a+36>>2]+(f2];if(!(ea[H[H[b>>2]+24>>2]](b,l)|0)){break a}}f=f+1|0;h=(i|0)>2];d=H[b+16>>2];e=d+4|0;c=e>>>0>2];a:{if(K[b+8>>2]>>0&(g|0)(g|0)){break a}d=d+H[b>>2]|0;h=I[d|0]|I[d+1|0]>2]=0;F[c+5|0]=0;F[c+6|0]=0;F[c+7|0]=0;F[c+8|0]=0;F[c+9|0]=0;F[c+10|0]=0;F[c+11|0]=0;F[c+12|0]=0;b:{if(!ta(c,b)){break b}if(h){g=1;while(1){d=12]+(i>>>3&536870908)|0;e=e^g;if(e&1){d=H[f>>2]&(d^-1)}else{d=d|H[f>>2]}g=e^1;H[f>>2]=d;i=i+1|0;if((h|0)!=(i|0)){continue}break}}i=0;c=H[b+8>>2];e=H[b+12>>2];f=e;e=H[b+20>>2];g=e;l=H[b+16>>2];d=l+4|0;e=d>>>0>>0>c>>>0&(e|0)>=(f|0)|(e|0)>(f|0)){break b}m=H[b>>2];d=m+l|0;j=I[d|0]|I[d+1|0]>0>>0>>0&(c|0)>=(f|0)|(c|0)>(f|0)){break b}d=h+m|0;d=I[d|0]|I[d+1|0]>2]=j;c=(d>>31)-((j>>31)+(d>>>0>>0)|0)|0;b=d-j|0;if(!c&b>>>0>2147483646|c){break b}i=1;c=b+1|0;H[a+20>>2]=c;b=c>>>1|0;H[a+24>>2]=b;H[a+28>>2]=0-b;if(c&1){break b}H[a+24>>2]=b-1}}ca=k+16|0;return i|0}function rg(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0;a=0;k=ca-16|0;ca=k;j=H[b+80>>2];e=I[c+24|0];b=N(j,e);a:{b:{c:{d:{f=H[c+28>>2];if(!(!I[c+84|0]|(f|0)!=5&(f|0)!=6)){e=H[c+48>>2];c=H[H[c>>2]>>2];H[k+8>>2]=0;H[k>>2]=0;H[k+4>>2]=0;if(b){if((b|0)>2]=b;oa(b)}H[d+8>>2]=g;H[d+4>>2]=g;H[d>>2]=a;h=1;break a}if(e){f=e2];f=H[d+4>>2]-i>>2;e:{if(f>>>0>>0){ya(d,b-f|0);break e}if(b>>>0>=f>>>0){break e}H[d+4>>2]=i+(b2]+(b2],F[c+24|0],a)){break c}b=b+1|0;h=j>>>0>>0;if((b|0)!=(j|0)){continue}break}break c}o=e&252;m=e&3;p=e>>>0>2]+(e2],F[c+24|0],a)){break c}n=H[d>>2];l=0;b=0;h=0;if(!p){while(1){f=(g2];H[f+4>>2]=H[(i|4)+a>>2];H[f+8>>2]=H[(i|8)+a>>2];H[f+12>>2]=H[(i|12)+a>>2];b=b+4|0;g=g+4|0;h=h+4|0;if((o|0)!=(h|0)){continue}break}}if(m){while(1){H[(g2]=H[(b2];b=b+1|0;g=g+1|0;l=l+1|0;if((l|0)!=(m|0)){continue}break}}e=e+1|0;h=j>>>0>>0;if((e|0)!=(j|0)){continue}break}break b}sa();v()}if(!a){break a}}oa(a)}ca=k+16|0;return h|0}function ge(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0;a=0;k=ca-16|0;ca=k;j=H[b+80>>2];e=I[c+24|0];b=N(j,e);a:{b:{c:{d:{f=H[c+28>>2];if(!(!I[c+84|0]|(f|0)!=5&(f|0)!=6)){e=H[c+48>>2];c=H[H[c>>2]>>2];H[k+8>>2]=0;H[k>>2]=0;H[k+4>>2]=0;if(b){if((b|0)>2]=b;oa(b)}H[d+8>>2]=g;H[d+4>>2]=g;H[d>>2]=a;h=1;break a}if(e){f=e2];f=H[d+4>>2]-i>>2;e:{if(f>>>0>>0){ya(d,b-f|0);break e}if(b>>>0>=f>>>0){break e}H[d+4>>2]=i+(b2]+(b2],F[c+24|0],a)){break c}b=b+1|0;h=j>>>0>>0;if((b|0)!=(j|0)){continue}break}break c}o=e&252;m=e&3;p=e>>>0>2]+(e2],F[c+24|0],a)){break c}n=H[d>>2];l=0;b=0;h=0;if(!p){while(1){f=(g2];H[f+4>>2]=H[(i|4)+a>>2];H[f+8>>2]=H[(i|8)+a>>2];H[f+12>>2]=H[(i|12)+a>>2];b=b+4|0;g=g+4|0;h=h+4|0;if((o|0)!=(h|0)){continue}break}}if(m){while(1){H[(g2]=H[(b2];b=b+1|0;g=g+1|0;l=l+1|0;if((l|0)!=(m|0)){continue}break}}e=e+1|0;h=j>>>0>>0;if((e|0)!=(j|0)){continue}break}break b}sa();v()}if(!a){break a}}oa(a)}ca=k+16|0;return h|0}function tg(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0;a=0;k=ca-16|0;ca=k;j=H[b+80>>2];e=I[c+24|0];b=N(j,e);a:{b:{c:{d:{f=H[c+28>>2];if(!(!I[c+84|0]|(f|0)!=3&(f|0)!=4)){e=H[c+48>>2];c=H[H[c>>2]>>2];H[k+8>>2]=0;H[k>>2]=0;H[k+4>>2]=0;if(b){if((b|0)>2]=b;oa(b)}H[d+8>>2]=g;H[d+4>>2]=g;H[d>>2]=a;h=1;break a}if(e){f=e2];f=H[d+4>>2]-i>>1;e:{if(f>>>0>>0){qe(d,b-f|0);break e}if(b>>>0>=f>>>0){break e}H[d+4>>2]=i+(b2]+(b2],F[c+24|0],a)){break c}b=b+1|0;h=j>>>0>>0;if((b|0)!=(j|0)){continue}break}break c}o=e&252;m=e&3;p=e>>>0>2]+(e2],F[c+24|0],a)){break c}n=H[d>>2];l=0;b=0;h=0;if(!p){while(1){f=(g1];G[f+2>>1]=J[(i|2)+a>>1];G[f+4>>1]=J[(i|4)+a>>1];G[f+6>>1]=J[(i|6)+a>>1];b=b+4|0;g=g+4|0;h=h+4|0;if((o|0)!=(h|0)){continue}break}}if(m){while(1){G[(g1]=J[(b1];b=b+1|0;g=g+1|0;l=l+1|0;if((l|0)!=(m|0)){continue}break}}e=e+1|0;h=j>>>0>>0;if((e|0)!=(j|0)){continue}break}break b}sa();v()}if(!a){break a}}oa(a)}ca=k+16|0;return h|0}function sg(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0;a=0;k=ca-16|0;ca=k;j=H[b+80>>2];e=I[c+24|0];b=N(j,e);a:{b:{c:{d:{f=H[c+28>>2];if(!(!I[c+84|0]|(f|0)!=3&(f|0)!=4)){e=H[c+48>>2];c=H[H[c>>2]>>2];H[k+8>>2]=0;H[k>>2]=0;H[k+4>>2]=0;if(b){if((b|0)>2]=b;oa(b)}H[d+8>>2]=g;H[d+4>>2]=g;H[d>>2]=a;h=1;break a}if(e){f=e2];f=H[d+4>>2]-i>>1;e:{if(f>>>0>>0){qe(d,b-f|0);break e}if(b>>>0>=f>>>0){break e}H[d+4>>2]=i+(b2]+(b2],F[c+24|0],a)){break c}b=b+1|0;h=j>>>0>>0;if((b|0)!=(j|0)){continue}break}break c}o=e&252;m=e&3;p=e>>>0>2]+(e2],F[c+24|0],a)){break c}n=H[d>>2];l=0;b=0;h=0;if(!p){while(1){f=(g1];G[f+2>>1]=J[(i|2)+a>>1];G[f+4>>1]=J[(i|4)+a>>1];G[f+6>>1]=J[(i|6)+a>>1];b=b+4|0;g=g+4|0;h=h+4|0;if((o|0)!=(h|0)){continue}break}}if(m){while(1){G[(g1]=J[(b1];b=b+1|0;g=g+1|0;l=l+1|0;if((l|0)!=(m|0)){continue}break}}e=e+1|0;h=j>>>0>>0;if((e|0)!=(j|0)){continue}break}break b}sa();v()}if(!a){break a}}oa(a)}ca=k+16|0;return h|0}function Ce(a,b){var c=0,d=0,e=0,f=0,g=0;f=-1;d=-1;a:{if((b|0)==-1){break a}d=b+1|0;f=(d>>>0)%3|0?d:b-2|0;d=b-1|0;if((b>>>0)%3|0){break a}d=b+2|0}b:{c:{d:{switch(H[a+168>>2]){case 0:case 1:e=H[a+148>>2];c=1;b=H[a+156>>2];g=b+(((f|0)==-1?-1:H[H[e>>2]+(f2])2]=H[g>>2]+1;b=(((d|0)==-1?-1:H[H[e>>2]+(d2])2];c=-1;c=((b|0)!=-1?H[H[e>>2]+(b2]:c)2];c=c+b|0;H[c>>2]=H[c>>2]+1;c=(((f|0)==-1?-1:H[H[e>>2]+(f2])2]=H[c>>2]+1;c=2;b=(((d|0)==-1?-1:H[H[e>>2]+(d2])2];c=-1;c=((b|0)!=-1?H[H[e>>2]+(b2]:c)2];c=c+b|0;H[c>>2]=H[c>>2]+1;c=(((f|0)==-1?-1:H[H[e>>2]+(f2])2]=H[c>>2]+2;c=1;b=(((d|0)==-1?-1:H[H[e>>2]+(d2])2];c=-1;c=((b|0)!=-1?H[H[e>>2]+(b2]:c)2];c=c+b|0;H[c>>2]=H[c>>2]+2;c=(((f|0)==-1?-1:H[H[e>>2]+(f2])2]=H[c>>2]+2;c=2;b=(((d|0)==-1?-1:H[H[e>>2]+(d2])2]=H[b>>2]+c}c=a;b=H[H[a+156>>2]+(((f|0)==-1?-1:H[H[H[a+148>>2]>>2]+(f2])2];d=H[a+180>>2];a=H[a+176>>2];H[c+172>>2]=(a|0)2]=0;H[a+20>>2]=0;H[a+8>>2]=0;H[a>>2]=0;H[a+4>>2]=0;H[a+24>>2]=0;f=H[b+4>>2];g=H[b>>2];e=f-g|0;c=(e|0)/20|0;a:{if((f|0)==(g|0)){break a}b:{if(c>>>0>2]=f;H[a+16>>2]=f;H[a+24>>2]=f+N(c,20);c=H[b>>2];g=H[b+4>>2];if((c|0)==(g|0)){break a}b=f;while(1){e=H[c+4>>2];H[b>>2]=H[c>>2];H[b+4>>2]=e;H[b+16>>2]=H[c+16>>2];e=H[c+12>>2];H[b+8>>2]=H[c+8>>2];H[b+12>>2]=e;b=b+20|0;c=c+20|0;if((g|0)!=(c|0)){continue}break}g=0;H[a+28>>2]=0;H[a+20>>2]=b;if((b|0)!=(f|0)){b=(b-f|0)/20|0;e=b>>>0>>0>=3){i=e&-4;e=0;while(1){d=f+N(b,20)|0;d=N(H[d+16>>2],H[d+12>>2]);c=c>>>0>d>>>0?c:d;d=f+N(b|1,20)|0;d=N(H[d+16>>2],H[d+12>>2]);c=c>>>0>d>>>0?c:d;d=f+N(b|2,20)|0;d=N(H[d+16>>2],H[d+12>>2]);c=c>>>0>d>>>0?c:d;d=f+N(b|3,20)|0;d=N(H[d+16>>2],H[d+12>>2]);c=c>>>0>d>>>0?c:d;b=b+4|0;e=e+4|0;if((i|0)!=(e|0)){continue}break}}if(h){while(1){e=f+N(b,20)|0;e=N(H[e+16>>2],H[e+12>>2]);c=c>>>0>e>>>0?c:e;b=b+1|0;g=g+1|0;if((h|0)!=(g|0)){continue}break}}if(!c){H[a+12>>2]=0;return a}if((c|0)>2]=f;H[a+4>>2]=f;H[a>>2]=b}H[a+12>>2]=g;return a}sa();v()}sa();v()}H[a+28>>2]=0;H[a+12>>2]=0;return a}function Dh(a){a=a|0;var b=0,c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0;a:{b=H[a+32>>2];f=H[b+8>>2];h=H[b+12>>2];g=H[b+20>>2];c=H[b+16>>2];e=0;b:{if((h|0)>>0>=f>>>0|(g|0)>(h|0)){break b}f=I[H[b>>2]+c|0];e=b;b=g;c=c+1|0;b=c?b:b+1|0;H[e+16>>2]=c;H[e+20>>2]=b;c:{if(!f){break c}while(1){if(ea[H[H[a>>2]+16>>2]](a,d)|0){d=d+1|0;if((f|0)!=(d|0)){continue}break c}break}return 0}d=H[a+8>>2];b=H[a+12>>2];if((d|0)!=(b|0)){while(1){c=H[d>>2];if(!(ea[H[H[c>>2]+8>>2]](c,a,H[a+4>>2])|0)){break a}d=d+4|0;if((b|0)!=(d|0)){continue}break}}d:{if(!f){break d}d=0;while(1){b=H[H[a+8>>2]+(d2];if(!(ea[H[H[b>>2]+12>>2]](b,H[a+32>>2])|0)){break a}d=d+1|0;if((f|0)!=(d|0)){continue}break}if(!f){break d}i=a+20|0;b=0;while(1){d=0;j=b2]>>2];k=ea[H[H[c>>2]+24>>2]](c)|0;if((k|0)>0){while(1){c=H[H[a+8>>2]+j>>2];c=ea[H[H[c>>2]+20>>2]](c,d)|0;e=H[a+20>>2];g=H[a+24>>2]-e>>2;e:{if(c>>>0>>0){break e}h=c+1|0;if(h>>>0>g>>>0){ya(i,h-g|0);e=H[i>>2];break e}if(g>>>0>>0){break e}H[a+24>>2]=(h2]+28>>2]](a)|0)){break b}e=ea[H[H[a>>2]+32>>2]](a)|0}return e|0}return 0}function ta(a,b){var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0;i=ca-16|0;ca=i;f=H[b+20>>2];d=H[b+12>>2];c=H[b+16>>2];a:{if((f|0)>=(d|0)&c>>>0>=K[b+8>>2]|(d|0)>2]|0];c=H[b+20>>2];g=c;f=H[b+16>>2];e=f+1|0;c=e?c:c+1|0;H[b+16>>2]=e;H[b+20>>2]=c;b:{if(J[b+38>>1]>2];c=H[b+12>>2];h=c;c=g;f=f+5|0;c=f>>>0>>0>>0&(c|0)>=(h|0)|(c|0)>(h|0)){break a}e=e+H[b>>2]|0;e=I[e|0]|I[e+1|0]2];c=H[b+20>>2];d=H[b+8>>2];h=H[b+12>>2];e=H[i+12>>2]}g=d-f|0;d=h-(c+(d>>>0>>0)|0)|0;if((d|0)>>0>g>>>0|(d|0)2]+f|0;H[a>>2]=j;c:{d:{h=e-1|0;g=h+j|0;d=I[g|0];e:{if(d>>>0>2]=h;g=I[g|0]&63;break e}f:{switch((d>>>6|0)-1|0){case 1:break d;case 0:break f;default:break a}}if(e>>>0>2]=d;d=d+j|0;g=I[d+1|0]2]=g+4096;break c}if(e>>>0>2]=d;g=a;a=d+j|0;a=I[a+1|0]>0>1044479){break a}}a=e+f|0;c=a>>>0>>0?c+1|0:c;H[b+16>>2]=a;H[b+20>>2]=c;k=1}ca=i+16|0;return k}function Wf(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0;Xd(a,b,c);c=H[a+84>>2];d=H[a+88>>2]-c>>2;a:{if((d|0)>(b|0)){break a}b=b+1|0;if(b>>>0>d>>>0){b:{d=b-d|0;e=H[a+92>>2];c=H[a+88>>2];if(d>>>0>2>>>0){c:{if(!d){break c}b=c;e=d&7;if(e){while(1){H[b>>2]=1;b=b+4|0;f=f+1|0;if((e|0)!=(f|0)){continue}break}}c=(d>0>2]=1;H[b+28>>2]=1;H[b+16>>2]=1;H[b+20>>2]=1;H[b+8>>2]=1;H[b+12>>2]=1;H[b>>2]=1;H[b+4>>2]=1;b=b+32|0;if((c|0)!=(b|0)){continue}break}}H[a+88>>2]=c;break b}d:{b=c;c=H[a+84>>2];i=b-c|0;g=i>>2;b=g+d|0;if(b>>>0>>1|0;e=e>>>0>=2147483644?1073741823:b>>>0>>0?h:b;if(e){if(e>>>0>=1073741824){break d}j=pa(e=7){while(1){H[b+24>>2]=1;H[b+28>>2]=1;H[b+16>>2]=1;H[b+20>>2]=1;H[b+8>>2]=1;H[b+12>>2]=1;H[b>>2]=1;H[b+4>>2]=1;b=b+32|0;if((f|0)!=(b|0)){continue}break}}b=va(j,c,i);H[a+88>>2]=f;H[a+84>>2]=b;H[a+92>>2]=b+(e>0>=d>>>0){break a}H[a+88>>2]=c+(b2];e=H[a+4>>2];if(d-e>>2>>>0>=b>>>0){a:{if(!b){break a}d=e;g=b&7;if(g){while(1){H[d>>2]=H[c>>2];d=d+4|0;f=f+1|0;if((g|0)!=(f|0)){continue}break}}e=(b>0>2]=H[c>>2];H[d+4>>2]=H[c>>2];H[d+8>>2]=H[c>>2];H[d+12>>2]=H[c>>2];H[d+16>>2]=H[c>>2];H[d+20>>2]=H[c>>2];H[d+24>>2]=H[c>>2];H[d+28>>2]=H[c>>2];d=d+32|0;if((e|0)!=(d|0)){continue}break}}H[a+4>>2]=e;return}b:{i=H[a>>2];f=e-i>>2;h=f+b|0;if(h>>>0>>1|0;h=j>>>0>=2147483644?1073741823:d>>>0>h>>>0?d:h;if(h){if(h>>>0>=1073741824){break b}k=pa(h2];d=d+4|0;g=g+1|0;if((j|0)!=(g|0)){continue}break}}g=(b>0>=7){while(1){H[d>>2]=H[c>>2];H[d+4>>2]=H[c>>2];H[d+8>>2]=H[c>>2];H[d+12>>2]=H[c>>2];H[d+16>>2]=H[c>>2];H[d+20>>2]=H[c>>2];H[d+24>>2]=H[c>>2];H[d+28>>2]=H[c>>2];d=d+32|0;if((g|0)!=(d|0)){continue}break}}if((e|0)!=(i|0)){while(1){f=f-4|0;e=e-4|0;H[f>>2]=H[e>>2];if((e|0)!=(i|0)){continue}break}}H[a+8>>2]=(h2]=g;H[a>>2]=f;if(i){oa(i)}return}sa();v()}wa();v()}function Kc(a,b,c){var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0;d=H[a+8>>2];e=H[a>>2];if(d-e>>2>>>0>=b>>>0){f=H[a+4>>2];h=f-e>>2;i=b>>>0>h>>>0?h:b;a:{if(!i){break a}d=e;g=i;j=g&7;if(j){while(1){H[d>>2]=H[c>>2];g=g-1|0;d=d+4|0;k=k+1|0;if((k|0)!=(j|0)){continue}break}}if(i>>>0>2]=H[c>>2];H[d+4>>2]=H[c>>2];H[d+8>>2]=H[c>>2];H[d+12>>2]=H[c>>2];H[d+16>>2]=H[c>>2];H[d+20>>2]=H[c>>2];H[d+24>>2]=H[c>>2];H[d+28>>2]=H[c>>2];d=d+32|0;g=g-8|0;if(g){continue}break}}if(b>>>0>h>>>0){b=(b-h2]=H[c>>2];f=f+4|0;if((b|0)!=(f|0)){continue}break}H[a+4>>2]=b;return}H[a+4>>2]=e+(b2]=e;oa(e);H[a+8>>2]=0;H[a>>2]=0;H[a+4>>2]=0;d=0}b:{if(b>>>0>=1073741824){break b}e=d>>>1|0;d=d>>>0>=2147483644?1073741823:b>>>0>>0?e:b;if(d>>>0>=1073741824){break b}d=d2]=e;H[a+8>>2]=d+e;c=H[c>>2];d=e;g=b&7;if(g){while(1){H[d>>2]=c;d=d+4|0;f=f+1|0;if((g|0)!=(f|0)){continue}break}}e=e+(b>0>=7){while(1){H[d+28>>2]=c;H[d+24>>2]=c;H[d+20>>2]=c;H[d+16>>2]=c;H[d+12>>2]=c;H[d+8>>2]=c;H[d+4>>2]=c;H[d>>2]=c;d=d+32|0;if((e|0)!=(d|0)){continue}break}}H[a+4>>2]=e;return}sa();v()}function Me(a,b){var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0;h=ca-16|0;ca=h;a:{b:{if(J[b+38>>1]>2];c=H[b+12>>2];i=c;f=H[b+20>>2];d=H[b+16>>2];g=d+8|0;f=g>>>0>>0>>0&(c|0)2]|0;c=I[d|0]|I[d+1|0]2];c=H[h+8>>2];d=H[h+12>>2]}j=e-g|0;e=i-(f+(e>>>0>>0)|0)|0;if((e|0)==(d|0)&c>>>0>j>>>0|d>>>0>e>>>0){break a}e=d+f|0;f=c+g|0;e=f>>>0>>0?e+1|0:e;H[b+16>>2]=f;H[b+20>>2]=e;if((c|0)>2]+g|0;H[a+40>>2]=b;g=c-1|0;e=b+g|0;f=I[e|0];c:{if(f>>>0>2]=g;b=I[e|0]&63;break c}d:{switch((f>>>6|0)-1|0){case 0:if(c>>>0>2]=c;b=b+c|0;b=I[b+1|0]>0>2]=c;b=b+c|0;b=I[b+1|0]>2]+96>>2]+N(f,12)|0)+(c-N(f,3)2];a:{h=H[H[a+12>>2]+4>>2];e=H[h+4>>2];if((e|0)!=H[h+8>>2]){H[e>>2]=j;H[h+4>>2]=e+4;break a}b:{i=H[h>>2];f=e-i|0;g=f>>2;d=g+1|0;if(d>>>01|0;g=f>>>0>=2147483644?1073741823:d>>>0>>0?g:d;if(g){if(g>>>0>=1073741824){break b}f=pa(g2]=j;j=d+4|0;if((e|0)!=(i|0)){while(1){d=d-4|0;e=e-4|0;H[d>>2]=H[e>>2];if((e|0)!=(i|0)){continue}break}}H[h+8>>2]=f+(g2]=j;H[h>>2]=d;if(i){oa(i)}break a}sa();v()}wa();v()}c:{d:{h=H[a+4>>2];e=H[h+4>>2];e:{if((e|0)!=H[h+8>>2]){H[e>>2]=c;H[h+4>>2]=e+4;break e}i=H[h>>2];f=e-i|0;j=f>>2;d=j+1|0;if(d>>>0>=1073741824){break d}g=f>>>1|0;g=f>>>0>=2147483644?1073741823:d>>>0>>0?g:d;if(g){if(g>>>0>=1073741824){break c}f=pa(g2]=H[e>>2];if((e|0)!=(i|0)){continue}break}}H[h+8>>2]=f+(g2]=c;H[h>>2]=d;if(!i){break e}oa(i)}a=H[a+4>>2];H[H[a+12>>2]+(b2]=H[a+24>>2];H[a+24>>2]=H[a+24>>2]+1;return}sa();v()}wa();v()}function Wb(a,b,c,d){var e=0,f=0,g=0,h=0,i=0,j=0,k=0;h=d-c|0;if((h|0)>2];i=H[a+4>>2];if((e-i|0)>=(h|0)){j=i-b|0;if((j|0)>=(h|0)){f=i;g=d;break a}f=i;g=c+j|0;if((g|0)!=(d|0)){e=g;while(1){F[f|0]=I[e|0];f=f+1|0;e=e+1|0;if((e|0)!=(d|0)){continue}break}}H[a+4>>2]=f;if((j|0)>0){break a}return}k=H[a>>2];g=(i-k|0)+h|0;if((g|0)>=0){j=b-k|0;f=e-k|0;e=f>0>=1073741823?2147483647:e>>>0>g>>>0?e:g;if(f){e=pa(f)}else{e=0}g=j+e|0;if((c|0)!=(d|0)){g=qa(g,c,h)+h|0}d=va(e,k,j);c=i-b|0;b=va(g,b,c);H[a+8>>2]=e+f;H[a+4>>2]=b+c;H[a>>2]=d;if(k){oa(k)}return}sa();v()}e=f;d=e-h|0;if(i>>>0>d>>>0){while(1){F[e|0]=I[d|0];e=e+1|0;d=d+1|0;if(i>>>0>d>>>0){continue}break}}H[a+4>>2]=e;a=b+h|0;if((a|0)!=(f|0)){a=f-a|0;va(f-a|0,b,a)}if((c|0)==(g|0)){return}f=(c^-1)+g|0;a=g-c&7;b:{if(!a){e=b;break b}d=0;e=b;while(1){F[e|0]=I[c|0];e=e+1|0;c=c+1|0;d=d+1|0;if((a|0)!=(d|0)){continue}break}}if(f>>>0>>0>=512){ba(a|0,b|0,c|0);return a}e=a+c|0;a:{if(!((a^b)&3)){b:{if(!(a&3)){c=a;break b}if(!c){c=a;break b}c=a;while(1){F[c|0]=I[b|0];b=b+1|0;c=c+1|0;if(!(c&3)){break b}if(c>>>0>>0){continue}break}}d=e&-4;c:{if(d>>>0>>0>>0){break c}while(1){H[c>>2]=H[b>>2];H[c+4>>2]=H[b+4>>2];H[c+8>>2]=H[b+8>>2];H[c+12>>2]=H[b+12>>2];H[c+16>>2]=H[b+16>>2];H[c+20>>2]=H[b+20>>2];H[c+24>>2]=H[b+24>>2];H[c+28>>2]=H[b+28>>2];H[c+32>>2]=H[b+32>>2];H[c+36>>2]=H[b+36>>2];H[c+40>>2]=H[b+40>>2];H[c+44>>2]=H[b+44>>2];H[c+48>>2]=H[b+48>>2];H[c+52>>2]=H[b+52>>2];H[c+56>>2]=H[b+56>>2];H[c+60>>2]=H[b+60>>2];b=b- -64|0;c=c- -64|0;if(f>>>0>=c>>>0){continue}break}}if(c>>>0>=d>>>0){break a}while(1){H[c>>2]=H[b>>2];b=b+4|0;c=c+4|0;if(d>>>0>c>>>0){continue}break}break a}if(e>>>0>>0>>0){c=a;break a}c=a;while(1){F[c|0]=I[b|0];F[c+1|0]=I[b+1|0];F[c+2|0]=I[b+2|0];F[c+3|0]=I[b+3|0];b=b+4|0;c=c+4|0;if(d>>>0>=c>>>0){continue}break}}if(c>>>0>>0){while(1){F[c|0]=I[b|0];b=b+1|0;c=c+1|0;if((e|0)!=(c|0)){continue}break}}return a}function ub(a,b){var c=0,d=0,e=0,f=0,g=0;d=ca-16|0;ca=d;H[a+12>>2]=b;H[a+8>>2]=0;H[a>>2]=0;H[a+4>>2]=0;c=a+16|0;H[c>>2]=0;H[c+4>>2]=0;F[c+5|0]=0;F[c+6|0]=0;F[c+7|0]=0;F[c+8|0]=0;F[c+9|0]=0;F[c+10|0]=0;F[c+11|0]=0;F[c+12|0]=0;H[a+32>>2]=0;H[a+36>>2]=0;H[a+48>>2]=0;H[a+40>>2]=0;H[a+44>>2]=0;H[a+52>>2]=0;H[a+56>>2]=0;H[a+68>>2]=0;H[a+60>>2]=0;H[a+64>>2]=0;H[a+72>>2]=0;H[a+76>>2]=0;H[a+88>>2]=0;H[a+80>>2]=0;H[a+84>>2]=0;H[a+100>>2]=0;H[a+92>>2]=0;H[a+96>>2]=0;g=a+116|0;a:{b:{if(b){if(b>>>0>2]=0;H[a+108>>2]=0;H[a+112>>2]=0;H[d+8>>2]=0;H[d>>2]=0;H[d+4>>2]=0;c=1;break a}c=b2]=e;f=c+e|0;H[a+100>>2]=f;ra(e,0,c);H[a+112>>2]=0;H[a+104>>2]=0;H[a+108>>2]=0;H[a+96>>2]=f;e=pa(c);H[a+104>>2]=e;f=c+e|0;H[a+112>>2]=f;ra(e,0,c);H[a+108>>2]=f;e=pa(c);H[d>>2]=e;f=c+e|0;H[d+8>>2]=f;ra(e,0,c);H[d+4>>2]=f;c=b2];if(e){H[d+4>>2]=e;oa(e)}H[d+8>>2]=0;H[d>>2]=0;H[d+4>>2]=0;if(b){b=b2]=e;f=b+e|0;H[d+8>>2]=f;ra(e,0,b);H[d+4>>2]=f}tb(a+128|0,c,d);b=H[d>>2];if(b){H[d+4>>2]=b;oa(b)}ca=d+16|0;return a}function ze(a){a=a|0;var b=0,c=0,d=0,e=0,f=0;H[a>>2]=11484;d=a+232|0;b=H[d+196>>2];if(b){H[d+200>>2]=b;oa(b)}c=H[d+184>>2];if(c){b=c;e=H[d+188>>2];if((b|0)!=(e|0)){while(1){b=e-12|0;f=H[b>>2];if(f){H[e-8>>2]=f;oa(f)}e=b;if((b|0)!=(c|0)){continue}break}b=H[d+184>>2]}H[d+188>>2]=c;oa(b)}b=H[d+156>>2];if(b){H[d+160>>2]=b;oa(b)}c=H[d+136>>2];H[d+136>>2]=0;if(c){e=c-4|0;b=H[e>>2];if(b){b=c+(b2];if(b){H[a+200>>2]=b;oa(b)}b=H[a+184>>2];if(b){H[a+188>>2]=b;oa(b)}b=H[a+172>>2];if(b){H[a+176>>2]=b;oa(b)}b=H[a+160>>2];if(b){H[a+164>>2]=b;oa(b)}b=H[a+144>>2];if(b){while(1){c=H[b>>2];oa(b);b=c;if(b){continue}break}}b=H[a+136>>2];H[a+136>>2]=0;if(b){oa(b)}b=H[a+120>>2];if(b){oa(b)}b=H[a+108>>2];if(b){oa(b)}b=H[a+96>>2];if(b){oa(b)}b=H[a+72>>2];if(b){H[a+76>>2]=b;oa(b)}b=H[a+60>>2];if(b){oa(b)}b=H[a+48>>2];if(b){H[a+52>>2]=b;oa(b)}b=H[a+36>>2];if(b){H[a+40>>2]=b;oa(b)}b=H[a+24>>2];if(b){H[a+28>>2]=b;oa(b)}b=H[a+12>>2];if(b){H[a+16>>2]=b;oa(b)}b=H[a+8>>2];H[a+8>>2]=0;if(b){cb(b)}return a|0}function Pa(a,b,c){var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0;d=H[a+8>>2];e=H[a+4>>2];if(d-e>>2>>>0>=b>>>0){a:{if(!b){break a}d=e;f=b&7;if(f){while(1){H[d>>2]=H[c>>2];d=d+4|0;h=h+1|0;if((f|0)!=(h|0)){continue}break}}e=(b>0>2]=H[c>>2];H[d+4>>2]=H[c>>2];H[d+8>>2]=H[c>>2];H[d+12>>2]=H[c>>2];H[d+16>>2]=H[c>>2];H[d+20>>2]=H[c>>2];H[d+24>>2]=H[c>>2];H[d+28>>2]=H[c>>2];d=d+32|0;if((e|0)!=(d|0)){continue}break}}H[a+4>>2]=e;return}b:{i=H[a>>2];j=e-i|0;f=j>>2;g=f+b|0;if(g>>>0>>1|0;g=d>>>0>=2147483644?1073741823:e>>>0>g>>>0?e:g;if(g){if(g>>>0>=1073741824){break b}k=pa(g2];d=d+4|0;h=h+1|0;if((e|0)!=(h|0)){continue}break}}e=f+(b>0>=7){while(1){H[d>>2]=H[c>>2];H[d+4>>2]=H[c>>2];H[d+8>>2]=H[c>>2];H[d+12>>2]=H[c>>2];H[d+16>>2]=H[c>>2];H[d+20>>2]=H[c>>2];H[d+24>>2]=H[c>>2];H[d+28>>2]=H[c>>2];d=d+32|0;if((e|0)!=(d|0)){continue}break}}b=va(k,i,j);H[a+4>>2]=e;H[a>>2]=b;H[a+8>>2]=b+(g>7|0){d=H[a+4>>2]}else{d=I[a+11|0]&127}if(d>>>0>>0){h=ca-16|0;ca=h;b=b-d|0;if(b){g=I[a+11|0]>>>7|0?(H[a+8>>2]&2147483647)-1|0:10;if(I[a+11|0]>>>7|0){d=H[a+4>>2]}else{d=I[a+11|0]&127}i=d+b|0;if(g-d>>>0>>0){a:{e=ca-16|0;ca=e;c=i-g|0;if(c>>>0>>0){if(I[a+11|0]>>>7|0){f=H[a>>2]}else{f=a}if(g>>>0>2]=g2]=c+g;c=ca-16|0;ca=c;ca=c+16|0;c=e+12|0;c=H[(K[e>>2]>2]?c:e)>>2];if(c>>>0>=11){j=c+16&-16;c=j-1|0;c=(c|0)==11?j:c}else{c=10}c=c+1|0}else{c=2147483631}Zb(e,c);c=H[e>>2];if(d){yb(c,f,d)}if((g|0)!=10){oa(f)}H[a>>2]=c;H[a+8>>2]=H[a+8>>2]&-2147483648|H[e+4>>2]&2147483647;H[a+8>>2]=H[a+8>>2]|-2147483648;ca=e+16|0;break a}Na();v()}}f=d;if(I[a+11|0]>>>7|0){d=H[a>>2]}else{d=a}f=f+d|0;e=ca-16|0;ca=e;F[e+15|0]=0;while(1){if(b){F[f|0]=I[e+15|0];b=b-1|0;f=f+1|0;continue}break}ca=e+16|0;Id(a,i);F[h+15|0]=0;F[d+i|0]=I[h+15|0]}ca=h+16|0;return}if(I[a+11|0]>>>7|0){d=H[a>>2]}else{d=a}f=ca-16|0;ca=f;Id(a,b);F[f+15|0]=0;F[b+d|0]=I[f+15|0];ca=f+16|0}function Jc(a,b){var c=0,d=0,e=0,f=0,g=0,h=0;g=ca-16|0;ca=g;a:{b:{if(b){H[a+88>>2]=0;H[a+92>>2]=0;d=H[a+84>>2];H[a+84>>2]=0;if(d){oa(d)}H[a+76>>2]=0;H[a+80>>2]=0;d=H[a+72>>2];H[a+72>>2]=0;if(d){oa(d)}d=H[b>>2];c=H[b+4>>2];F[g+15|0]=0;Oa(a,c-d>>2,g+15|0);d=H[b+28>>2];c=H[b+24>>2];F[g+14|0]=0;Oa(a+12|0,d-c>>2,g+14|0);Kc(a+28|0,H[b+4>>2]-H[b>>2]>>2,13708);c=H[b+28>>2]-H[b+24>>2]|0;f=c>>2;e=H[a+52>>2];c:{if(f>>>0>2]-e>>2>>>0){break c}if((c|0)>2];c=pa(c);f=c+(f2]=H[d>>2];if((d|0)!=(e|0)){continue}break}}H[a+60>>2]=f;H[a+56>>2]=h;H[a+52>>2]=c;if(!e){break c}oa(e)}c=H[b+28>>2]-H[b+24>>2]|0;f=c>>2;e=H[a+40>>2];d:{if(f>>>0>2]-e>>2>>>0){break d}if((c|0)>2];c=pa(c);f=c+(f2]=H[d>>2];if((d|0)!=(e|0)){continue}break}}H[a+48>>2]=f;H[a+44>>2]=h;H[a+40>>2]=c;if(!e){break d}oa(e)}F[a+24|0]=1;H[a+64>>2]=b}ca=g+16|0;return}sa();v()}sa();v()}function wb(a,b){var c=0,d=0,e=0,f=0,g=0;c=ca-16|0;ca=c;H[a+12>>2]=b;H[a+8>>2]=0;H[a>>2]=0;H[a+4>>2]=0;H[a+16>>2]=0;H[a+20>>2]=0;H[a+32>>2]=0;H[a+24>>2]=0;H[a+28>>2]=0;H[a+36>>2]=0;H[a+40>>2]=0;H[a+52>>2]=0;H[a+44>>2]=0;H[a+48>>2]=0;H[a+56>>2]=0;H[a+60>>2]=0;H[a+72>>2]=0;H[a+64>>2]=0;H[a+68>>2]=0;H[a+76>>2]=0;H[a+80>>2]=0;H[a+92>>2]=0;H[a+84>>2]=0;H[a+88>>2]=0;H[a+104>>2]=0;H[a+96>>2]=0;H[a+100>>2]=0;g=a+120|0;a:{b:{if(b){if(b>>>0>2]=0;H[a+112>>2]=0;H[a+116>>2]=0;H[c+8>>2]=0;H[c>>2]=0;H[c+4>>2]=0;e=1;break a}e=b2]=d;f=d+e|0;H[a+104>>2]=f;ra(d,0,e);H[a+116>>2]=0;H[a+108>>2]=0;H[a+112>>2]=0;H[a+100>>2]=f;d=pa(e);H[a+108>>2]=d;f=d+e|0;H[a+116>>2]=f;ra(d,0,e);H[a+112>>2]=f;d=pa(e);H[c>>2]=d;f=d+e|0;H[c+8>>2]=f;ra(d,0,e);H[c+4>>2]=f;e=b2];if(d){H[c+4>>2]=d;oa(d)}H[c+8>>2]=0;H[c>>2]=0;H[c+4>>2]=0;if(b){b=b2]=d;f=b+d|0;H[c+8>>2]=f;ra(d,0,b);H[c+4>>2]=f}tb(a+132|0,e,c);b=H[c>>2];if(b){H[c+4>>2]=b;oa(b)}ca=c+16|0;return a}function Sb(a,b){var c=0,d=0,e=0;c=(a|0)==(b|0);F[b+12|0]=c;a:{if(c){break a}while(1){d=H[b+8>>2];if(I[d+12|0]){break a}b:{c=H[d+8>>2];e=H[c>>2];if((e|0)==(d|0)){e=H[c+4>>2];if(!(!e|I[e+12|0])){break b}c:{if(H[d>>2]==(b|0)){b=d;break c}b=H[d+4>>2];a=H[b>>2];H[d+4>>2]=a;if(a){H[a+8>>2]=d;c=H[d+8>>2]}H[b+8>>2]=c;a=H[d+8>>2];H[((H[a>>2]!=(d|0))2]=b;H[b>>2]=d;H[d+8>>2]=b;c=H[b+8>>2];d=H[c>>2]}F[b+12|0]=1;F[c+12|0]=0;a=H[d+4>>2];H[c>>2]=a;if(a){H[a+8>>2]=c}H[d+8>>2]=H[c+8>>2];a=H[c+8>>2];H[((H[a>>2]!=(c|0))2]=d;H[d+4>>2]=c;H[c+8>>2]=d;return}if(!(I[e+12|0]|!e)){break b}d:{if(H[d>>2]!=(b|0)){b=d;break d}a=H[b+4>>2];H[d>>2]=a;if(a){H[a+8>>2]=d;c=H[d+8>>2]}H[b+8>>2]=c;a=H[d+8>>2];H[((H[a>>2]!=(d|0))2]=b;H[b+4>>2]=d;H[d+8>>2]=b;c=H[b+8>>2]}F[b+12|0]=1;F[c+12|0]=0;a=H[c+4>>2];b=H[a>>2];H[c+4>>2]=b;if(b){H[b+8>>2]=c}H[a+8>>2]=H[c+8>>2];b=H[c+8>>2];H[((H[b>>2]!=(c|0))2]=a;H[a>>2]=c;H[c+8>>2]=a;break a}F[d+12|0]=1;F[c+12|0]=(a|0)==(c|0);F[e+12|0]=1;b=c;if((c|0)!=(a|0)){continue}break}}}function Tj(a,b,c,d){var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0;a:{b:{c:{d:{e:{f:{g:{h:{i:{j:{k:{if(b){if(!c){break k}if(!d){break j}e=Q(d)-Q(b)|0;if(e>>>0>>0>1){break c}da=0;a=(a>>>0)/(c>>>0)|0;break a}if(!a){break h}if(!d|d-1&d){break g}a=b>>>Qj(d)|0;da=0;break a}if(!(c-1&c)){break f}h=(Q(c)+33|0)-Q(b)|0;g=0-h|0;break d}h=e+1|0;g=63-e|0;break d}da=0;a=(b>>>0)/(d>>>0)|0;break a}e=Q(d)-Q(b)|0;if(e>>>0>>0>=32){a=b>>>c|0}else{e=b>>>c|0;a=((1>>0>=32){e=0;i=b>>>f|0}else{e=b>>>f|0;i=((1>>0>=32){b=a0>g>>>0)|0)>>31;k=c&f;i=e-k|0;e=j-((d&f)+(e>>>0>>0)|0)|0;b=b>31;a=l|a>2]-k|0;e=H[c>>2]-k|0;H[c>>2]=e;H[c+4>>2]=h;g=H[b+16>>2];f=h>>31;i=(f^h)-f|0;f=e>>31;l=g>>>0>=i+((f^e)-f|0)>>>0;a:{if(l){f=h;break a}b:{c:{if((e|0)>=0){f=1;i=1;if((h|0)>=0){break b}j=1;f=-1;i=-1;if(e){break c}break b}j=-1;f=-1;i=-1;if((h|0)>2]}c=H[d+4>>2]+f|0;e=H[d>>2]+e|0;d:{if((g|0)>2]|0;break d}if((0-g|0)>2]+e|0}e:{if((c|0)>(g|0)){c=c-H[b+4>>2]|0;break e}if((0-g|0)>2]+c|0}f:{if(l){g=c;break f}g:{h:{if((e|0)>=0){b=1;f=1;if((c|0)>=0){break g}d=1;b=-1;f=-1;if(e){break h}break g}d=-1;b=-1;f=-1;if((c|0)>2];d=H[e>>2];a:{b=H[a+12>>2];c=H[b+28>>2]-H[b+24>>2]|0;f=c>>2;b:{if(f>>>0>2]-d>>2>>>0){break b}if((c|0)>2];c=pa(c);f=c+(f2]=H[b>>2];if((b|0)!=(d|0)){continue}break}}H[e+8>>2]=f;H[e+4>>2]=h;H[e>>2]=c;if(!d){break b}oa(d)}b=H[a+12>>2];c=H[b+28>>2];b=H[b+24>>2];H[g+12>>2]=0;b=c-b>>2;d=a+96|0;e=H[d>>2];c=H[a+100>>2]-e>>2;c:{if(b>>>0>c>>>0){Pa(d,b-c|0,g+12|0);break c}if(b>>>0>=c>>>0){break c}H[a+100>>2]=e+(b2];d:{if(b){d=H[b>>2];if((d|0)==H[b+4>>2]){c=1;break d}b=0;while(1){c=ye(e,H[(b2]);if(!c){break d}f=H[a+116>>2];d=H[f>>2];b=b+1|0;if(b>>>0>2]-d>>2>>>0){continue}break}break d}c=1;a=H[a+12>>2];a=H[a+4>>2]-H[a>>2]|0;if(a>>>0>2>>>0)/3|0;b=0;while(1){c=ye(e,N(b,3));if(!c){break d}b=b+1|0;if((a|0)!=(b|0)){continue}break}}ca=g+16|0;return c|0}sa();v()}function gj(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0;c=H[b+88>>2];if(!(!c|H[c>>2]!=1)){e=H[c+8>>2];H[a+4>>2]=I[e|0]|I[e+1|0]2;a:{if(d>>>0>g>>>0){ya(f,d-g|0);d=I[b+24|0];e=H[c+8>>2];break a}if(d>>>0>=g>>>0){break a}H[a+12>>2]=h+(d2];c:{if(d-1>>>02]=c+d;H[a>>2]=d;if(!b){break c}oa(b);break c}if(c>>>0>=d>>>0){break c}H[a+4>>2]=b+c;break c}if((d|0)>2];f=H[a>>2];g=e-f|0;d:{if((d|0)>>0>>0|(d|0)>>0>g>>>0){d=c-g|0;h=H[a+8>>2];if(d>>>0>>0){i=a,j=ra(e,0,d)+d|0,H[i+4>>2]=j;break d}if((c|0)0>=1073741823?2147483647:c>>>0>>0?h:c;h=pa(e);ra(h+g|0,0,d);d=va(h,f,g);H[a+8>>2]=d+e;H[a+4>>2]=c+d;H[a>>2]=d;if(!f){break d}oa(f);break d}if(c>>>0>=g>>>0){break d}H[a+4>>2]=c+f}if(!c){break c}va(H[a>>2],b,c)}b=H[a+28>>2];c=H[a+24>>2]+1|0;b=c?b:b+1|0;H[a+24>>2]=c;H[a+28>>2]=b;g=1;break a}sa();v()}return g}function Jh(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0;k=H[a+12>>2];c=H[a+68>>2];d=H[c+80>>2];F[b+84|0]=0;n=b+68|0;i=H[b+68>>2];e=H[b+72>>2]-i>>2;a:{if(e>>>0>>0){qb(n,d-e|0,12372);c=H[a+68>>2];d=H[c+80>>2];break a}if(d>>>0>=e>>>0){break a}H[b+72>>2]=i+(d2];e=H[c+96>>2];i=(b-e|0)/12|0;m=1;b:{if((b|0)==(e|0)){break b}k=H[k+28>>2];f=H[k>>2];if((f|0)==-1){return 0}o=i>>>0>2];if(g>>>0>=d>>>0){break b}j=H[H[a+72>>2]+12>>2];h=H[j+(f2];if(h>>>0>=d>>>0){break b}f=H[n>>2];H[f+(g2]=h;g=k+(l2];if((h|0)==-1){break b}l=H[c+4>>2];if(l>>>0>=d>>>0){break b}h=H[(h2];if(h>>>0>=d>>>0){break b}H[f+(l2]=h;g=H[g+8>>2];if((g|0)==-1){break b}c=H[c+8>>2];if(c>>>0>=d>>>0){break b}j=H[(g2];if(j>>>0>=d>>>0){break b}H[f+(c2]=j;b=b+1|0;m=i>>>0>>0;if((b|0)==(o|0)){break b}c=e+N(b,12)|0;l=N(b,3);f=H[k+(l2];if((f|0)!=-1){continue}break}}return m|0}function Gh(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0;h=H[d+80>>2];e=ca-48|0;ca=e;a=H[a+4>>2];m=a-2|0;a:{if(m>>>0>28){break a}j=H[H[d>>2]>>2]+H[d+48>>2]|0;H[e+16>>2]=a;a=-12]=a^-1;a=-2-a|0;H[e+24>>2]=a;H[e+32>>2]=(a|0)/2;L[e+28>>2]=O(2)/O(a|0);f=H[c>>2];if((f|0)!=H[c+4>>2]){a=0;d=0;while(1){g=H[(d2];h=e+36|0;k=H[H[b>>2]>>2];l=H[b+48>>2];f=H[b+40>>2];i=H[b+44>>2];if(!I[b+84|0]){g=H[H[b+68>>2]+(g2]}g=Rj(f,i,g,0);i=g;g=g+l|0;qa(h,g+k|0,f);he(e+16|0,h,e+12|0,e+8|0);f=a2]=H[e+12>>2];H[(f|4)+j>>2]=H[e+8>>2];a=a+2|0;d=d+1|0;f=H[c>>2];if(d>>>0>2]-f>>2>>>0){continue}break}break a}if(!h){break a}d=0;a=0;while(1){k=e+36|0;l=H[H[b>>2]>>2];i=H[b+48>>2];c=H[b+40>>2];f=Rj(c,H[b+44>>2],I[b+84|0]?a:H[H[b+68>>2]+(a2],0);g=f;f=f+i|0;qa(k,f+l|0,c);he(e+16|0,k,e+12|0,e+8|0);c=d2]=H[e+12>>2];H[(c|4)+j>>2]=H[e+8>>2];d=d+2|0;a=a+1|0;if((h|0)!=(a|0)){continue}break}}ca=e+48|0;return m>>>0>2]==9){d=H[a+4>>2];h=I[c+24|0];e=h2]=1065353216;i=L[a+20>>2];d=-1>2]=i/O(d|0)}o=(d|0)>0;a:{if(!o){break a}j=H[c+80>>2];if(!j){break a}if(h){p=H[H[b>>2]>>2]+H[b+48>>2]|0;t=h&254;u=h&1;b=0;while(1){m=H[a+8>>2];i=L[l>>2];d=0;n=0;if((h|0)!=1){while(1){g=d2]))+L[g+m>>2];g=g|4;L[g+f>>2]=O(i*O(H[q+4>>2]))+L[g+m>>2];d=d+2|0;b=b+2|0;n=n+2|0;if((t|0)!=(n|0)){continue}break}}if(u){d=d2]=O(i*O(H[(b2]))+L[d+m>>2];b=b+1|0}qa(H[H[c+64>>2]>>2]+r|0,f,e);r=e+r|0;s=s+1|0;if((s|0)!=(j|0)){continue}break}break a}b=0;if((j|0)!=1){a=j&-2;d=0;while(1){qa(H[H[c+64>>2]>>2]+b|0,f,e);b=b+e|0;qa(b+H[H[c+64>>2]>>2]|0,f,e);b=b+e|0;d=d+2|0;if((a|0)!=(d|0)){continue}break}}if(!(j&1)){break a}qa(H[H[c+64>>2]>>2]+b|0,f,e)}oa(f)}ca=k+16|0;return o|0}function Xh(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0;c=H[a+12>>2];d=H[a+108>>2];e=H[d+80>>2];F[b+84|0]=0;m=b+68|0;h=H[b+68>>2];f=H[b+72>>2]-h>>2;a:{if(f>>>0>>0){qb(m,e-f|0,12372);d=H[a+108>>2];e=H[d+80>>2];break a}if(e>>>0>=f>>>0){break a}H[b+72>>2]=h+(e2];f=H[d+96>>2];h=(b-f|0)/12|0;k=1;b:{if((b|0)==(f|0)){break b}n=h>>>0>2];c=0;d=f;b=0;k=0;while(1){c=(c2];if((i|0)==-1){break b}g=H[d>>2];if(g>>>0>=e>>>0){break b}l=H[H[a+112>>2]+12>>2];j=H[l+(i2];if(j>>>0>=e>>>0){break b}i=H[m>>2];H[i+(g2]=j;g=H[c+4>>2];if((g|0)==-1){break b}j=H[d+4>>2];if(j>>>0>=e>>>0){break b}g=H[(g2];if(g>>>0>=e>>>0){break b}H[i+(j2]=g;c=H[c+8>>2];if((c|0)==-1){break b}d=H[d+8>>2];if(d>>>0>=e>>>0){break b}c=H[(c2];if(c>>>0>=e>>>0){break b}H[i+(d2]=c;b=b+1|0;k=h>>>0>>0;if((b|0)==(n|0)){break b}c=N(b,3);d=f+N(b,12)|0;if((b|0)!=1431655765){continue}break}}return k|0}function Ph(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0;c=H[a+12>>2];d=H[a+68>>2];e=H[d+80>>2];F[b+84|0]=0;m=b+68|0;h=H[b+68>>2];f=H[b+72>>2]-h>>2;a:{if(f>>>0>>0){qb(m,e-f|0,12372);d=H[a+68>>2];e=H[d+80>>2];break a}if(e>>>0>=f>>>0){break a}H[b+72>>2]=h+(e2];f=H[d+96>>2];h=(b-f|0)/12|0;k=1;b:{if((b|0)==(f|0)){break b}n=h>>>0>2];c=0;d=f;b=0;k=0;while(1){c=(c2];if((i|0)==-1){break b}g=H[d>>2];if(g>>>0>=e>>>0){break b}l=H[H[a+72>>2]+12>>2];j=H[l+(i2];if(j>>>0>=e>>>0){break b}i=H[m>>2];H[i+(g2]=j;g=H[c+4>>2];if((g|0)==-1){break b}j=H[d+4>>2];if(j>>>0>=e>>>0){break b}g=H[(g2];if(g>>>0>=e>>>0){break b}H[i+(j2]=g;c=H[c+8>>2];if((c|0)==-1){break b}d=H[d+8>>2];if(d>>>0>=e>>>0){break b}c=H[(c2];if(c>>>0>=e>>>0){break b}H[i+(d2]=c;b=b+1|0;k=h>>>0>>0;if((b|0)==(n|0)){break b}c=N(b,3);d=f+N(b,12)|0;if((b|0)!=1431655765){continue}break}}return k|0}function Wa(a,b){var c=0,d=0,e=0,f=0,g=0,h=0,i=0;d=ca-16|0;ca=d;a:{f=H[a+4>>2];b:{if(f>>>0>>0){e=b-f|0;c=H[a+8>>2];g=c>0>g>>>0|f>>>0>g-e>>>0)){H[a+4>>2]=b;h=f&31;b=H[a>>2]+(f>>>3&536870908)|0;break c}H[d+8>>2]=0;H[d>>2]=0;H[d+4>>2]=0;if((b|0)>>00>>0?c:b}else{b=2147483647}pb(d,b);f=H[a+4>>2];H[d+4>>2]=f+e;i=H[a>>2];b=H[d>>2];d:{if((f|0)>>5|0;if(f>>>0>=32){va(b,i,c>2]=H[b>>2]&(c^-1)|H[i+g>>2]&c}i=H[a>>2]}H[a>>2]=H[d>>2];H[d>>2]=i;c=H[a+4>>2];H[a+4>>2]=H[d+4>>2];H[d+4>>2]=c;c=H[a+8>>2];H[a+8>>2]=H[d+8>>2];H[d+8>>2]=c;if(!i){break c}oa(i)}if(!e){break b}if(h){c=32-h|0;a=c>>>0>>0?c:e;H[b>>2]=H[b>>2]&(-1>c-a^-1);e=e-a|0;b=b+4|0}a=e>>>5|0;if(e>>>0>=32){ra(b,0,a2]&(-1>>>32-(e&31)^-1);break b}H[a+4>>2]=b}ca=d+16|0;return}sa();v()}function Je(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0;e=H[a+12>>2];i=H[a+8>>2];d=e-i>>2;b=I[b+24|0];a:{if(d>>>0>>0){ya(a+8|0,b-d|0);i=H[a+8>>2];e=H[a+12>>2];break a}if(b>>>0>=d>>>0){break a}e=(b2]=e}b=0;f=H[c+8>>2];h=H[c+12>>2];j=H[c+20>>2];e=e-i|0;d=H[c+16>>2];g=e+d|0;j=e>>>0>g>>>0?j+1|0:j;b:{if(f>>>0>>0&(h|0)2]|0,e);d=H[c+20>>2];g=e;e=e+H[c+16>>2]|0;d=g>>>0>e>>>0?d+1|0:d;H[c+16>>2]=e;H[c+20>>2]=d;f=H[c+8>>2];h=H[c+12>>2];g=e+4|0;d=g>>>0>>0>>0&(d|0)>=(h|0)|(d|0)>(h|0)){break b}d=e+H[c>>2]|0;H[a+20>>2]=I[d|0]|I[d+1|0]>0>2]=d;H[c+20>>2]=f;h=H[c+12>>2];if((f|0)>=(h|0)&d>>>0>=K[c+8>>2]|(f|0)>(h|0)){break b}f=I[d+H[c>>2]|0];d=g;e=e+5|0;d=e>>>0>2]=e;H[c+20>>2]=d;if(f-1>>>0>29){break b}H[a+4>>2]=f;b=1}return b|0}function qd(a,b){var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0;a:{f=H[a+4>>2];b:{if((f|0)!=H[a>>2]){c=f;break b}g=H[a+8>>2];c=H[a+12>>2];if(g>>>0>>0){e=((c-g>>2)+1|0)/22]}H[a+4>>2]=c;H[a+8>>2]=e+f;break b}d=(c|0)==(f|0)?1:c-f>>1;if(d>>>0>=1073741824){break a}c=d>2|0)+1&7;if(g){h=0;while(1){H[e>>2]=H[d>>2];d=d+4|0;e=e+4|0;h=h+1|0;if((g|0)!=(h|0)){continue}break}}h=c+l|0;if(j>>>0>2]=H[d>>2];H[e+4>>2]=H[d+4>>2];H[e+8>>2]=H[d+8>>2];H[e+12>>2]=H[d+12>>2];H[e+16>>2]=H[d+16>>2];H[e+20>>2]=H[d+20>>2];H[e+24>>2]=H[d+24>>2];H[e+28>>2]=H[d+28>>2];d=d+32|0;e=e+32|0;if((h|0)!=(e|0)){continue}break}}H[a+12>>2]=k;H[a+8>>2]=h;H[a+4>>2]=c;H[a>>2]=i;if(!f){break b}oa(f);c=H[a+4>>2]}H[c-4>>2]=H[b>>2];H[a+4>>2]=H[a+4>>2]-4;return}wa();v()}function sb(a,b){var c=0;a:{if(!ta(a,b)){break a}if(!ta(a+16|0,b)){break a}if(!ta(a+32|0,b)){break a}if(!ta(a+48|0,b)){break a}if(!ta(a- -64|0,b)){break a}if(!ta(a+80|0,b)){break a}if(!ta(a+96|0,b)){break a}if(!ta(a+112|0,b)){break a}if(!ta(a+128|0,b)){break a}if(!ta(a+144|0,b)){break a}if(!ta(a+160|0,b)){break a}if(!ta(a+176|0,b)){break a}if(!ta(a+192|0,b)){break a}if(!ta(a+208|0,b)){break a}if(!ta(a+224|0,b)){break a}if(!ta(a+240|0,b)){break a}if(!ta(a+256|0,b)){break a}if(!ta(a+272|0,b)){break a}if(!ta(a+288|0,b)){break a}if(!ta(a+304|0,b)){break a}if(!ta(a+320|0,b)){break a}if(!ta(a+336|0,b)){break a}if(!ta(a+352|0,b)){break a}if(!ta(a+368|0,b)){break a}if(!ta(a+384|0,b)){break a}if(!ta(a+400|0,b)){break a}if(!ta(a+416|0,b)){break a}if(!ta(a+432|0,b)){break a}if(!ta(a+448|0,b)){break a}if(!ta(a+464|0,b)){break a}if(!ta(a+480|0,b)){break a}if(!ta(a+496|0,b)){break a}c=ta(a+512|0,b)}return c}function qf(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0;a:{if(!ke(a,b)){break a}h=a+36|0;g=ea[H[H[a>>2]+24>>2]](a)|0;e=H[a+40>>2];d=H[a+36>>2];c=e-d>>2;b:{if(g>>>0>c>>>0){Vb(h,g-c|0);break b}if(c>>>0>>0){break b}d=d+(g2];H[e>>2]=0;if(c){ea[H[H[c>>2]+4>>2]](c)}if((d|0)!=(e|0)){continue}break}}H[a+40>>2]=d}c=1;if((g|0)>2];f=H[b+12>>2];d=H[b+16>>2];if((c|0)>=(f|0)&d>>>0>=K[b+8>>2]|(c|0)>(f|0)){break c}f=I[H[b>>2]+d|0];d=d+1|0;c=d?c:c+1|0;H[b+16>>2]=d;H[b+20>>2]=c;d=ea[H[H[a>>2]+48>>2]](a,f)|0;f=e2]|0;c=H[i>>2];H[i>>2]=d;if(c){ea[H[H[c>>2]+4>>2]](c)}c=H[H[h>>2]+f>>2];if(!c){break c}if(!(k=c,l=ea[H[H[a>>2]+28>>2]](a)|0,m=ea[H[H[a>>2]+20>>2]](a,e)|0,j=H[H[c>>2]+8>>2],ea[j](k|0,l|0,m|0)|0)){break c}c=1;e=e+1|0;if((g|0)!=(e|0)){continue}break a}break}c=0}return c|0}function he(a,b,c,d){var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0;j=+L[b>>2];k=+L[b+4>>2];l=+L[b+8>>2];g=P(j)+P(k)+P(l);a:{if(!(g>1e-6)){j=1;k=0;e=0;break a}g=1/g;k=g*k;j=g*j;e=g*l>2];l=+(h|0);g=T(j*l+.5);b:{if(P(g)>31;i=(f^m)-f|0;g=T(k*l+.5);c:{if(P(g)>31;b=h-(i+((f^b)-b|0)|0)|0;i=(b|0)>0?b:0;e=e?0-i|0:i;f=f+(b>>31&((f|0)>0?b:0-b|0))|0;d:{if((m|0)>=0){b=e+h|0;a=H[a+8>>2];e=h+f|0;break d}b=f>>31;b=(b^f)-b|0;a=H[a+8>>2];b=(e|0)2];i=c;k=H[b+16>>2];d=k+4|0;c=d>>>0>>0>g>>>0&(c|0)>=(h|0)|(c|0)>(h|0)){break a}l=H[b>>2];f=k+l|0;e=I[f|0]|I[f+1|0]>0>>0>g>>>0&(c|0)>=(h|0)|(c|0)>(h|0)){break a}d=d+l|0;j=I[d|0]|I[d+1|0]>2]=j;H[a+12>>2]=e;d=j-e|0;e=(j>>31)-((e>>31)+(e>>>0>j>>>0)|0)|0;if(!e&d>>>0>2147483646|e){break a}d=d+1|0;H[a+20>>2]=d;e=d>>>1|0;H[a+24>>2]=e;H[a+28>>2]=0-e;if(!(d&1)){H[a+24>>2]=e-1}if(J[b+38>>1]=(h|0)&f>>>0>=g>>>0|(c|0)>(h|0)){break a}g=I[f+l|0];c=i;i=k+9|0;c=i>>>0>2]=i;H[b+20>>2]=c;if(g>>>0>1){break a}H[a+88>>2]=g}m=ta(a+112|0,b)}return m|0}function Hc(a,b){var c=0,d=0,e=0,f=0,g=0,h=0;g=H[a>>2];c=g+(b>>>3&536870908)|0;H[c>>2]=H[c>>2]|12];e=(b|0)==-1;d=-1;a:{if(e){break a}c=b+1|0;c=(c>>>0)%3|0?c:b-2|0;d=-1;if((c|0)==-1){break a}d=H[H[f>>2]+(c2]}c=H[a+12>>2];h=(d>>>3&536870908)+c|0;H[h>>2]=H[h>>2]|1>0)%3|0){e=b-1|0;break e}e=b+2|0;d=-1;if((e|0)==-1){break d}}d=H[H[f>>2]+(e2]}e=(d>>>3&536870908)+c|0;H[e>>2]=H[e>>2]|12]+(b2];if((b|0)==-1){break b}F[a+24|0]=0;a=(b>>>3&536870908)+g|0;H[a>>2]=H[a>>2]|1>0)%3|0?a:b-2|0;if((a|0)!=-1){d=H[H[f>>2]+(a2]}a=c+(d>>>3&536870908)|0;H[a>>2]=H[a>>2]|1>0)%3|0){b=b-1|0;break g}b=b+2|0;a=-1;if((b|0)==-1){break f}}a=H[H[f>>2]+(b2]}b=1>3&536870908)|0;c=H[a>>2];break c}a=c+536870908|0;b=H[c+536870908>>2];c=-2147483648}H[a>>2]=b|c}}function Fd(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=O(0),f=O(0),g=O(0),h=O(0),i=O(0),j=0,k=O(0),l=O(0),m=O(0),n=O(0),o=0;a:{if(H[c+28>>2]!=9|I[c+24|0]!=3){break a}a=H[a+4>>2];if(a-2>>>0>28){break a}o=1;j=H[c+80>>2];if(!j){break a}k=O(O(2)/O((12]>>2]+H[c+48>>2]|0;a=H[H[b>>2]>>2]+H[b+48>>2]|0;b=0;while(1){g=O(0);l=O(0);m=O(0);e=O(O(O(H[a>>2])*k)+O(-1));f=O(O(O(H[a+4>>2])*k)+O(-1));i=O(O(O(1)-O(P(e)))-O(P(f)));h=O(S(O(-i),O(0)));n=O(-h);f=O(f+(f8;F[c+10|0]=d>>>16;F[c+11|0]=d>>>24;d=(w(l),y(2));F[c+4|0]=d;F[c+5|0]=d>>>8;F[c+6|0]=d>>>16;F[c+7|0]=d>>>24;d=(w(g),y(2));F[c|0]=d;F[c+1|0]=d>>>8;F[c+2|0]=d>>>16;F[c+3|0]=d>>>24;c=c+12|0;b=b+1|0;if((j|0)!=(b|0)){continue}break}}return o|0}function Vd(a,b,c){var d=0,e=0,f=0,g=0,h=0,i=0,j=0;a:{if(b>>>0>2];if(a>>>0>2];c=0;b:{if(a-2>>>0K[d+(a2]?a:b;b=K[d+(b2]>K[d+(i2]?i:b;b=K[d+(b2]>K[d+(h2]?h:b;b=K[d+(b2]>K[d+(g2]?g:b;a=a+4|0;j=j+4|0;if((f|0)!=(j|0)){continue}break}}if(!e){break a}while(1){b=K[d+(b2]>K[d+(a2]?a:b;a=a+1|0;c=c+1|0;if((e|0)!=(c|0)){continue}break}break a}b=H[a+580>>2];d=32-b|0;if((d|0)>=4){c=H[a+576>>2];if((c|0)==H[a+568>>2]){return 0}d=H[c>>2];e=b+4|0;H[a+580>>2]=e;b=d>28|0;if((e|0)!=32){break a}H[a+580>>2]=0;H[a+576>>2]=c+4;return b}c=H[a+576>>2];e=c+4|0;if((e|0)==H[a+568>>2]){return 0}f=H[c>>2];H[a+576>>2]=e;H[a+580>>2]=b-28;a=60-b|0;b=H[c+4>>2]>>>a|f>a-d}return b}function Ae(a){a=a|0;var b=0,c=0,d=0,e=0;H[a>>2]=11436;b=H[a+388>>2];if(b){H[a+392>>2]=b;oa(b)}d=H[a+368>>2];H[a+368>>2]=0;if(d){e=d-4|0;b=H[e>>2];if(b){c=(b2];if(b){H[a+200>>2]=b;oa(b)}b=H[a+184>>2];if(b){H[a+188>>2]=b;oa(b)}b=H[a+172>>2];if(b){H[a+176>>2]=b;oa(b)}b=H[a+160>>2];if(b){H[a+164>>2]=b;oa(b)}c=H[a+144>>2];if(c){while(1){b=H[c>>2];oa(c);c=b;if(b){continue}break}}b=H[a+136>>2];H[a+136>>2]=0;if(b){oa(b)}b=H[a+120>>2];if(b){oa(b)}b=H[a+108>>2];if(b){oa(b)}b=H[a+96>>2];if(b){oa(b)}b=H[a+72>>2];if(b){H[a+76>>2]=b;oa(b)}b=H[a+60>>2];if(b){oa(b)}b=H[a+48>>2];if(b){H[a+52>>2]=b;oa(b)}b=H[a+36>>2];if(b){H[a+40>>2]=b;oa(b)}b=H[a+24>>2];if(b){H[a+28>>2]=b;oa(b)}b=H[a+12>>2];if(b){H[a+16>>2]=b;oa(b)}b=H[a+8>>2];H[a+8>>2]=0;if(b){cb(b)}return a|0}function Sg(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,g=0;a:{a=ca-32|0;ca=a;e=Ma(c);if(e>>>0>>0>=11){g=(e|15)+1|0;f=pa(g);H[a+24>>2]=g|-2147483648;H[a+16>>2]=f;H[a+20>>2]=e;g=e+f|0;break c}F[a+27|0]=e;f=a+16|0;g=e+f|0;if(!e){break b}}qa(f,c,e)}F[g|0]=0;H[a+8>>2]=0;H[a>>2]=0;H[a+4>>2]=0;d:{c=nb(b,a+16|0);if((c|0)==(b+4|0)){break d}b=H[c+28>>2];e=H[c+32>>2];if((b|0)==(e|0)){break d}b=e-b|0;if(b&3){break d}e=b>>>2|0;f=H[a+4>>2];b=H[a>>2];g=f-b>>2;e:{if(e>>>0>g>>>0){ya(a,e-g|0);b=H[a>>2];f=H[a+4>>2];break e}if(e>>>0>=g>>>0){break e}f=(e2]=f}if((b|0)!=(f|0)){e=b;b=H[c+28>>2];qa(e,b,H[c+32>>2]-b|0);break d}Ca();v()}b=H[d>>2];if(b){H[d+4>>2]=b;oa(b)}H[d>>2]=H[a>>2];H[d+4>>2]=H[a+4>>2];H[d+8>>2]=H[a+8>>2];if(F[a+27|0]>2])}ca=a+32|0;break a}Na();v()}}function Be(a){a=a|0;var b=0,c=0,d=0,e=0;H[a>>2]=11384;d=H[a+368>>2];H[a+368>>2]=0;if(d){e=d-4|0;b=H[e>>2];if(b){c=(b2];if(b){H[a+200>>2]=b;oa(b)}b=H[a+184>>2];if(b){H[a+188>>2]=b;oa(b)}b=H[a+172>>2];if(b){H[a+176>>2]=b;oa(b)}b=H[a+160>>2];if(b){H[a+164>>2]=b;oa(b)}c=H[a+144>>2];if(c){while(1){b=H[c>>2];oa(c);c=b;if(b){continue}break}}b=H[a+136>>2];H[a+136>>2]=0;if(b){oa(b)}b=H[a+120>>2];if(b){oa(b)}b=H[a+108>>2];if(b){oa(b)}b=H[a+96>>2];if(b){oa(b)}b=H[a+72>>2];if(b){H[a+76>>2]=b;oa(b)}b=H[a+60>>2];if(b){oa(b)}b=H[a+48>>2];if(b){H[a+52>>2]=b;oa(b)}b=H[a+36>>2];if(b){H[a+40>>2]=b;oa(b)}b=H[a+24>>2];if(b){H[a+28>>2]=b;oa(b)}b=H[a+12>>2];if(b){H[a+16>>2]=b;oa(b)}b=H[a+8>>2];H[a+8>>2]=0;if(b){cb(b)}return a|0}function Ug(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0;d=ca-16|0;ca=d;a:{e=Ma(c);if(e>>>0>>0>=11){f=(e|15)+1|0;a=pa(f);H[d+8>>2]=f|-2147483648;H[d>>2]=a;H[d+4>>2]=e;f=a+e|0;break c}F[d+11|0]=e;f=d+e|0;a=d;if(!e){break b}}qa(a,c,e)}F[f|0]=0;c=I[d+11|0];e=c24;b=H[b+4>>2];a=0;d:{if(!b){break d}a=c;c=(e|0)>2]:a;f=c?H[d>>2]:d;while(1){c=I[b+27|0];g=c24>2]:c;i=c>>>0>>0;e:{f:{g:{h:{i:{j:{h=i?c:a;if(h){g=g?H[b+16>>2]:b+16|0;j=Fa(f,g,h);if(j){break j}if(a>>>0>=c>>>0){break i}break e}if(a>>>0>=c>>>0){break h}break e}if((j|0)2];if(b){continue}break}a=0}if((e|0)>2])}ca=d+16|0;break a}Na();v()}return a|0}function fd(a,b){var c=0,d=0;c=H[b+8>>2];H[a+4>>2]=H[b+4>>2];H[a+8>>2]=c;H[a+20>>2]=H[b+20>>2];c=H[b+16>>2];H[a+12>>2]=H[b+12>>2];H[a+16>>2]=c;a:{b:{if((a|0)!=(b|0)){c=H[b+28>>2];if(c){d=H[a+24>>2];if(H[a+32>>2]>0>>0){if(d){oa(d);H[a+32>>2]=0;H[a+24>>2]=0;H[a+28>>2]=0;c=H[b+28>>2]}if((c|0)>>5|0)+1|0;d=pa(c2]=c;H[a+28>>2]=0;H[a+24>>2]=d;c=H[b+28>>2]}va(d,H[b+24>>2],(c-1>>>3&536870908)+4|0);c=H[b+28>>2]}else{c=0}H[a+28>>2]=c;c=H[b+40>>2];if(c){d=H[a+36>>2];if(H[a+44>>2]>0>>0){if(d){oa(d);H[a+44>>2]=0;H[a+36>>2]=0;H[a+40>>2]=0;c=H[b+40>>2]}if((c|0)>>5|0)+1|0;d=pa(c2]=c;H[a+40>>2]=0;H[a+36>>2]=d;c=H[b+40>>2]}va(d,H[b+36>>2],(c-1>>>3&536870908)+4|0);b=H[b+40>>2]}else{b=0}H[a+40>>2]=b}return}sa();v()}sa();v()}function uc(a){var b=0,c=0,d=0;b=H[a+8>>2];d=H[a>>2];a:{if(I[a+12|0]){b:{c:{d:{e:{if((b|0)==-1){break e}c=b+1|0;b=(c>>>0)%3|0?c:b-2|0;if((b|0)==-1){break e}b=H[H[d+12>>2]+(b2];if((b|0)!=-1){break d}}H[a+8>>2]=-1;break c}c=b+1|0;b=(c>>>0)%3|0?c:b-2|0;H[a+8>>2]=b;if((b|0)!=-1){break b}}c=H[a+4>>2];b=-1;f:{if((c|0)==-1){break f}g:{if((c>>>0)%3|0){c=c-1|0;break g}c=c+2|0;b=-1;if((c|0)==-1){break f}}c=H[H[d+12>>2]+(c2];b=-1;if((c|0)==-1){break f}b=c-1|0;if((c>>>0)%3|0){break f}b=c+2|0}F[a+12|0]=0;H[a+8>>2]=b;return}if((b|0)!=H[a+4>>2]){break a}H[a+8>>2]=-1;return}c=-1;h:{if((b|0)==-1){break h}i:{if((b>>>0)%3|0){b=b-1|0;break i}b=b+2|0;c=-1;if((b|0)==-1){break h}}b=H[H[d+12>>2]+(b2];c=-1;if((b|0)==-1){break h}c=b-1|0;if((b>>>0)%3|0){break h}c=b+2|0}H[a+8>>2]=c}}function Rf(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0;f=ca-32|0;ca=f;d=H[a+28>>2];H[f+16>>2]=d;g=H[a+20>>2];H[f+28>>2]=c;H[f+24>>2]=b;b=g-d|0;H[f+20>>2]=b;g=b+c|0;i=2;a:{b:{b=f+16|0;d=Z(H[a+60>>2],b|0,2,f+12|0)|0;if(d){H[3992]=d;d=-1}else{d=0}c:{d:{if(d){d=b;break d}while(1){e=H[f+12>>2];if((e|0)==(g|0)){break c}if((e|0)>2];j=h>>>0>>0;d=(j2]=h+H[d>>2];b=(j?12:4)+b|0;H[b>>2]=H[b>>2]-h;g=g-e|0;b=d;i=i-j|0;e=Z(H[a+60>>2],b|0,i|0,f+12|0)|0;if(e){H[3992]=e;e=-1}else{e=0}if(!e){continue}break}}if((g|0)!=-1){break b}}b=H[a+44>>2];H[a+28>>2]=b;H[a+20>>2]=b;H[a+16>>2]=b+H[a+48>>2];a=c;break a}H[a+28>>2]=0;H[a+16>>2]=0;H[a+20>>2]=0;H[a>>2]=H[a>>2]|32;a=0;if((i|0)==2){break a}a=c-H[d+4>>2]|0}ca=f+32|0;return a|0}function Ih(a){a=a|0;var b=0,c=0,d=0,e=0,f=0,g=0;e=H[a+4>>2];d=H[e>>2];a:{b=H[a+12>>2];c=H[b+56>>2]-H[b+52>>2]|0;f=c>>2;b:{if(f>>>0>2]-d>>2>>>0){break b}if((c|0)>2];c=pa(c);f=c+(f2]=H[b>>2];if((b|0)!=(d|0)){continue}break}}H[e+8>>2]=f;H[e+4>>2]=g;H[e>>2]=c;if(!d){break b}oa(d)}e=a+8|0;b=H[a+76>>2];c:{if(b){d=H[b>>2];if((d|0)==H[b+4>>2]){return 1}b=0;while(1){c=we(e,H[(b2]);if(!c){break c}f=H[a+76>>2];d=H[f>>2];b=b+1|0;if(b>>>0>2]-d>>2>>>0){continue}break}break c}c=1;a=H[H[a+12>>2]+64>>2];a=H[a+4>>2]-H[a>>2]|0;if(a>>>0>2>>>0)/3|0;b=0;while(1){c=we(e,N(b,3));if(!c){break c}b=b+1|0;if((a|0)!=(b|0)){continue}break}}return c|0}sa();v()}function Oh(a){a=a|0;var b=0,c=0,d=0,e=0,f=0,g=0;e=H[a+4>>2];d=H[e>>2];a:{b=H[a+12>>2];c=H[b+28>>2]-H[b+24>>2]|0;f=c>>2;b:{if(f>>>0>2]-d>>2>>>0){break b}if((c|0)>2];c=pa(c);f=c+(f2]=H[b>>2];if((b|0)!=(d|0)){continue}break}}H[e+8>>2]=f;H[e+4>>2]=g;H[e>>2]=c;if(!d){break b}oa(d)}e=a+8|0;b=H[a+76>>2];c:{if(b){d=H[b>>2];if((d|0)==H[b+4>>2]){return 1}b=0;while(1){c=xe(e,H[(b2]);if(!c){break c}f=H[a+76>>2];d=H[f>>2];b=b+1|0;if(b>>>0>2]-d>>2>>>0){continue}break}break c}c=1;a=H[a+12>>2];a=H[a+4>>2]-H[a>>2]|0;if(a>>>0>2>>>0)/3|0;b=0;while(1){c=xe(e,N(b,3));if(!c){break c}b=b+1|0;if((a|0)!=(b|0)){continue}break}}return c|0}sa();v()}function Te(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0;g=H[b+8>>2];h=H[b+12>>2];c=H[b+20>>2];i=c;e=H[b+16>>2];d=e+4|0;c=d>>>0>>0>g>>>0&(c|0)>=(h|0)|(c|0)>(h|0)){break a}j=H[b>>2];f=e+j|0;f=I[f|0]|I[f+1|0]1];if(k>>>0>>0>>0>g>>>0&(c|0)>=(h|0)|(c|0)>(h|0)){break a}H[b+16>>2]=d;H[b+20>>2]=c}if(!(f&1)){break a}e=Q(f)^31;if(e-1>>>0>28){break a}H[a+8>>2]=e+1;i=-22]=e;H[a+12>>2]=i^-1;H[a+24>>2]=e>>1;L[a+20>>2]=O(2)/O(e|0);if(k>>>0=(h|0)&d>>>0>=g>>>0|(c|0)>(h|0)){break a}g=I[d+j|0];d=d+1|0;c=d?c:c+1|0;H[b+16>>2]=d;H[b+20>>2]=c;if(g>>>0>1){break a}H[a+72>>2]=g}l=ta(a+96|0,b)}return l|0}function Se(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0;f=H[b+8>>2];g=H[b+12>>2];c=H[b+20>>2];h=c;i=H[b+16>>2];e=i+4|0;c=e>>>0>>0>f>>>0&(c|0)>=(g|0)|(c|0)>(g|0)){break a}j=H[b>>2];d=i+j|0;d=I[d|0]|I[d+1|0]>0>>0>f>>>0&(c|0)>=(g|0)|(c|0)>(g|0)){break a}H[b+16>>2]=e;H[b+20>>2]=c;if(!(d&1)){break a}d=Q(d)^31;if(d-1>>>0>28){break a}H[a+8>>2]=d+1;k=-22]=d;H[a+12>>2]=k^-1;H[a+24>>2]=d>>1;L[a+20>>2]=O(2)/O(d|0);if(J[b+38>>1]=(g|0)&e>>>0>=f>>>0|(c|0)>(g|0)){break a}c=I[e+j|0];f=i+9|0;h=f>>>0>2]=f;H[b+20>>2]=h;if(c>>>0>1){break a}H[a+72>>2]=c}l=ta(a+96|0,b)}return l|0} function va(a,b,c){var d=0,e=0;a:{if((a|0)==(b|0)){break a}e=a+c|0;if(b-e>>>00){return qa(a,b,c)}d=(a^b)&3;b:{c:{if(a>>>0>>0){if(d){d=a;break b}if(!(a&3)){d=a;break c}d=a;while(1){if(!c){break a}F[d|0]=I[b|0];b=b+1|0;c=c-1|0;d=d+1|0;if(d&3){continue}break}break c}d:{if(d){break d}if(e&3){while(1){if(!c){break a}c=c-1|0;d=c+a|0;F[d|0]=I[b+c|0];if(d&3){continue}break}}if(c>>>0>2]=H[b+c>>2];if(c>>>0>3){continue}break}}if(!c){break a}while(1){c=c-1|0;F[c+a|0]=I[b+c|0];if(c){continue}break}break a}if(c>>>0>2]=H[b>>2];b=b+4|0;d=d+4|0;c=c-4|0;if(c>>>0>3){continue}break}}if(!c){break a}while(1){F[d|0]=I[b|0];d=d+1|0;b=b+1|0;c=c-1|0;if(c){continue}break}}return a}function ff(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0;h=H[c+12>>2];f=h;e=H[c+20>>2];i=H[c+8>>2];g=H[c+16>>2];a:{if((f|0)>>0>>0|(e|0)>(f|0)){break a}j=H[c>>2];k=F[j+g|0];d=e;f=g+1|0;d=f?d:d+1|0;H[c+16>>2]=f;H[c+20>>2]=d;b:{if((k|0)==-2){break b}if((d|0)>=(h|0)&f>>>0>=i>>>0|(d|0)>(h|0)){break a}d=F[f+j|0];g=g+2|0;e=g>>>0>2]=g;H[c+20>>2]=e;if((d-4&255)>>>0>2]+40>>2]](a,k,d)|0;d=H[a+20>>2];H[a+20>>2]=e;if(!d){break b}ea[H[H[d>>2]+4>>2]](d)}d=H[a+20>>2];if(d){if(!(ea[H[H[a>>2]+28>>2]](a,d)|0)){break a}}if(!(ea[H[H[a>>2]+36>>2]](a,b,c)|0)){break a}c=H[a+4>>2];if(!(!c|I[c+36|0]>1)){if(!(ea[H[H[a>>2]+48>>2]](a,H[b+4>>2]-H[b>>2]>>2)|0)){break a}}l=1}return l|0}function Vb(a,b){var c=0,d=0,e=0,f=0,g=0,h=0,i=0;d=H[a+8>>2];c=H[a+4>>2];if(d-c>>2>>>0>=b>>>0){if(b){b=b2]=c;return}a:{b:{c:{g=H[a>>2];f=c-g>>2;e=f+b|0;if(e>>>0>>1|0;e=d>>>0>=2147483644?1073741823:e>>>0>>0?h:e;if(e){if(e>>>0>=1073741824){break c}i=pa(e2]=e;b=H[a+4>>2];H[a+4>>2]=f;c=H[a>>2];H[a>>2]=d;if((b|0)==(c|0)){break a}while(1){b=b-4|0;a=H[b>>2];H[b>>2]=0;if(a){ea[H[H[a>>2]+4>>2]](a)}if((b|0)!=(c|0)){continue}break}break a}sa();v()}wa();v()}H[a+8>>2]=e;H[a+4>>2]=f;H[a>>2]=b}if(c){oa(c)}}function Md(a,b,c){a:{switch(b-9|0){case 0:b=H[c>>2];H[c>>2]=b+4;H[a>>2]=H[b>>2];return;case 6:b=H[c>>2];H[c>>2]=b+4;b=G[b>>1];H[a>>2]=b;H[a+4>>2]=b>>31;return;case 7:b=H[c>>2];H[c>>2]=b+4;H[a>>2]=J[b>>1];H[a+4>>2]=0;return;case 8:b=H[c>>2];H[c>>2]=b+4;b=F[b|0];H[a>>2]=b;H[a+4>>2]=b>>31;return;case 9:b=H[c>>2];H[c>>2]=b+4;H[a>>2]=I[b|0];H[a+4>>2]=0;return;case 16:b=H[c>>2]+7&-8;H[c>>2]=b+8;M[a>>3]=M[b>>3];return;case 17:v();default:return;case 1:case 4:case 14:b=H[c>>2];H[c>>2]=b+4;b=H[b>>2];H[a>>2]=b;H[a+4>>2]=b>>31;return;case 2:case 5:case 11:case 15:b=H[c>>2];H[c>>2]=b+4;H[a>>2]=H[b>>2];H[a+4>>2]=0;return;case 3:case 10:case 12:case 13:break a}}b=H[c>>2]+7&-8;H[c>>2]=b+8;c=H[b+4>>2];H[a>>2]=H[b>>2];H[a+4>>2]=c}function Ed(a,b){var c=0,d=0,e=0;c=ca+-64|0;ca=c;d=H[a>>2];e=H[d-4>>2];d=H[d-8>>2];H[c+32>>2]=0;H[c+36>>2]=0;H[c+40>>2]=0;H[c+44>>2]=0;H[c+48>>2]=0;H[c+52>>2]=0;F[c+55|0]=0;F[c+56|0]=0;F[c+57|0]=0;F[c+58|0]=0;F[c+59|0]=0;F[c+60|0]=0;F[c+61|0]=0;F[c+62|0]=0;H[c+24>>2]=0;H[c+28>>2]=0;H[c+20>>2]=0;H[c+16>>2]=14924;H[c+12>>2]=a;H[c+8>>2]=b;a=a+d|0;d=0;a:{if(Ya(e,b,0)){H[c+56>>2]=1;ea[H[H[e>>2]+20>>2]](e,c+8|0,a,a,1,0);d=H[c+32>>2]==1?a:0;break a}ea[H[H[e>>2]+24>>2]](e,c+8|0,a,1,0);b:{switch(H[c+44>>2]){case 0:d=H[c+48>>2]==1?H[c+36>>2]==1?H[c+40>>2]==1?H[c+28>>2]:0:0:0;break a;case 1:break b;default:break a}}if(H[c+32>>2]!=1){if(H[c+48>>2]|H[c+36>>2]!=1|H[c+40>>2]!=1){break a}}d=H[c+24>>2]}ca=c- -64|0;return d}function ua(a,b){var c=0,d=0,e=0,f=0,g=0,h=0,i=0;H[a+16>>2]=0;e=H[a>>2];H[a+4>>2]=e;H[a+12>>2]=e;e=H[b+8>>2];c=H[b+12>>2];h=c;d=H[b+20>>2];f=H[b+16>>2];g=f+4|0;d=g>>>0>>0>>0&(d|0)>=(c|0)|(d|0)>(c|0)){break a}c=f+H[b>>2]|0;c=I[c|0]|I[c+1|0]>0>>0)|0)|0;if(e-g>>>0>>0&(f|0)>0>=4){ya(a,c>>>2|0);h=H[b+12>>2];g=H[b+16>>2];d=H[b+20>>2];e=H[b+8>>2]}f=c+g|0;d=f>>>0>>0?d+1|0:d;if(e>>>0>>0&(d|0)>=(h|0)|(d|0)>(h|0)){break a}qa(H[a>>2],H[b>>2]+g|0,c);d=H[b+20>>2];e=c+H[b+16>>2]|0;d=e>>>0>>0?d+1|0:d;H[b+16>>2]=e;H[b+20>>2]=d;H[a+16>>2]=0;H[a+12>>2]=H[a>>2];i=1}return i}function de(a,b){var c=0,d=0,e=0,f=0;d=-1;e=-1;f=-1;a:{b:{if((b|0)==-1){break b}e=H[H[H[a+4>>2]+12>>2]+(b2];c=b+1|0;c=(c>>>0)%3|0?c:b-2|0;if((c|0)>=0){f=(c>>>0)/3|0;f=H[(H[H[a>>2]+96>>2]+N(f,12)|0)+(c-N(f,3)2]}c:{if((e|0)==-1){break c}c=((e>>>0)%3|0?-1:2)+e|0;if((c|0)>>0)/3|0;d=H[(H[H[a>>2]+96>>2]+N(d,12)|0)+(c-N(d,3)2]}c=-1;if((d|0)!=(f|0)){break a}f=-1;d:{b=((b>>>0)%3|0?-1:2)+b|0;if((b|0)>=0){d=(b>>>0)/3|0;d=H[(H[H[a>>2]+96>>2]+N(d,12)|0)+(b-N(d,3)2];if((e|0)==-1){break b}break d}d=-1;if((e|0)!=-1){break d}break b}b=e+1|0;b=(b>>>0)%3|0?b:e-2|0;if((b|0)>2]+96>>2];a=(b>>>0)/3|0;f=H[(c+N(a,12)|0)+(b-N(a,3)2]}c=(d|0)!=(f|0)?-1:e}return c}function Ah(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0;c=pa(72);H[c+4>>2]=0;H[c+8>>2]=0;H[c>>2]=1984;H[c+12>>2]=0;H[c+16>>2]=0;H[c+20>>2]=0;H[c+24>>2]=0;H[c+28>>2]=0;H[c+32>>2]=0;H[c+36>>2]=0;H[c+40>>2]=0;H[c>>2]=2128;H[c+44>>2]=0;H[c+48>>2]=0;H[c+52>>2]=0;H[c+56>>2]=0;H[c+60>>2]=0;H[c+64>>2]=0;H[c+68>>2]=0;h=c;a:{if((b|0)>=0){g=a+8|0;c=H[a+12>>2];e=H[a+8>>2];f=c-e>>2;b:{if((f|0)>(b|0)){break b}d=b+1|0;if(b>>>0>=f>>>0){Vb(g,d-f|0);break b}if(d>>>0>=f>>>0){break b}e=(d2];H[c>>2]=0;if(d){ea[H[H[d>>2]+4>>2]](d)}if((c|0)!=(e|0)){continue}break}}H[a+12>>2]=e}a=H[g>>2]+(b2];H[a>>2]=h;if(!c){break a}}ea[H[H[c>>2]+4>>2]](c)}return(b^-1)>>>31|0}function ra(a,b,c){var d=0,e=0,f=0,g=0;a:{if(!c){break a}F[a|0]=b;d=a+c|0;F[d-1|0]=b;if(c>>>0>>0>>0>2]=b;d=c-d&-4;c=d+e|0;H[c-4>>2]=b;if(d>>>0>2]=b;H[e+4>>2]=b;H[c-8>>2]=b;H[c-12>>2]=b;if(d>>>0>2]=b;H[e+20>>2]=b;H[e+16>>2]=b;H[e+12>>2]=b;H[c-16>>2]=b;H[c-20>>2]=b;H[c-24>>2]=b;H[c-28>>2]=b;g=e&4|24;c=d-g|0;if(c>>>0>2]=d;H[b+28>>2]=f;H[b+16>>2]=d;H[b+20>>2]=f;H[b+8>>2]=d;H[b+12>>2]=f;H[b>>2]=d;H[b+4>>2]=f;b=b+32|0;c=c-32|0;if(c>>>0>31){continue}break}}return a}function Mj(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0;d=H[b+8>>2];e=H[b+12>>2];g=e;e=H[b+20>>2];k=e;h=H[b+16>>2];c=h+4|0;e=c>>>0>>0>d>>>0&(e|0)>=(g|0)|(e|0)>(g|0)){break a}j=H[b>>2];c=j+h|0;f=I[c|0]|I[c+1|0]>0>>0>>0&(d|0)>=(g|0)|(d|0)>(g|0)){break a}c=i+j|0;c=I[c|0]|I[c+1|0]>2]=f;d=(c>>31)-((f>>31)+(c>>>0>>0)|0)|0;b=c-f|0;if(!d&b>>>0>2147483646|d){break a}l=1;d=b+1|0;H[a+20>>2]=d;b=d>>>1|0;H[a+24>>2]=b;H[a+28>>2]=0-b;if(d&1){break a}H[a+24>>2]=b-1}return l|0}function sd(a,b,c){var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0;e=a+16|0;d=H[e>>2];a:{if(!d){break a}f=H[b>>2];b=e;while(1){g=(f|0)>H[d+16>>2];b=g?b:d;d=H[(g?d+4|0:d)>>2];if(d){continue}break}if((b|0)==(e|0)|(f|0)>2]){break a}d=H[b+24>>2];if(!d){break a}f=b+20|0;b=I[c+11|0];e=b24>2]:c;b=e?H[c+4>>2]:b;while(1){e=I[d+27|0];h=e24>2]:e;j=e>>>0>>0;b:{c:{d:{e:{f:{g:{i=j?e:b;if(i){h=h?H[d+16>>2]:d+16|0;k=Fa(g,h,i);if(k){break g}if(b>>>0>=e>>>0){break f}break b}if(b>>>0>=e>>>0){break e}break b}if((k|0)2];if(d){continue}break}}return Tc(a,c)}function be(a,b,c){var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0;d=ca-16|0;ca=d;f=H[a+24>>2];k=H[a+28>>2];a:{if((f|0)!=(k|0)){while(1){H[d+8>>2]=0;H[d>>2]=0;H[d+4>>2]=0;a=$d(H[f>>2],b,d);g=I[d+11|0];h=g24;i=3;b:{c:{d:{if(!a){break d}i=0;a=I[c+11|0];e=a24;j=(h|0)>2]:g;if((j|0)!=(((e|0)>2]:a)|0)){break d}a=(e|0)>2]:c;e=(h|0)>2]:d,a,j)){break c}}l=H[f>>2];i=1}if((h|0)>=0){break b}}oa(H[d>>2])}f:{switch(i|0){case 0:case 3:break f;default:break a}}f=f+4|0;if((k|0)!=(f|0)){continue}break}}l=0}ca=d+16|0;return l}function Cb(a,b,c){var d=0,e=0,f=0,g=0,h=0,i=0;f=c-b|0;h=f>>2;d=H[a+8>>2];e=H[a>>2];if(h>>>0>2>>>0){d=H[a+4>>2];g=d-e|0;f=g+b|0;i=g>>2;g=i>>>0>>0?f:c;if((g|0)!=(b|0)){while(1){H[e>>2]=H[b>>2];e=e+4|0;b=b+4|0;if((g|0)!=(b|0)){continue}break}}if(h>>>0>i>>>0){if((c|0)!=(g|0)){while(1){H[d>>2]=H[f>>2];d=d+4|0;f=f+4|0;if((f|0)!=(c|0)){continue}break}}H[a+4>>2]=d;return}H[a+4>>2]=e;return}if(e){H[a+4>>2]=e;oa(e);H[a+8>>2]=0;H[a>>2]=0;H[a+4>>2]=0;d=0}a:{if((f|0)>>1|0;d=d>>>0>=2147483644?1073741823:e>>>0>h>>>0?e:h;if(d>>>0>=1073741824){break a}e=d2]=d;H[a+8>>2]=d+e;if((b|0)!=(c|0)){c=b;b=(f-4&-4)+4|0;d=qa(d,c,b)+b|0}H[a+4>>2]=d;return}sa();v()}function Oa(a,b,c){var d=0,e=0,f=0;e=ca-16|0;ca=e;H[a+4>>2]=0;a:{b:{if(!b){break b}f=H[a+8>>2];d=f>0>=b>>>0){H[a+4>>2]=b;break c}H[e+8>>2]=0;H[e>>2]=0;H[e+4>>2]=0;if((b|0)>>00>>0?f:d}else{d=2147483647}pb(e,d);f=H[a>>2];H[a>>2]=H[e>>2];H[e>>2]=f;d=H[a+4>>2];H[a+4>>2]=b;H[e+4>>2]=d;d=H[a+8>>2];H[a+8>>2]=H[e+8>>2];H[e+8>>2]=d;if(!f){break c}oa(f)}d=b>>>5|0;a=H[a>>2];if(I[c|0]){if(b>>>0>=32){ra(a,255,d2]|-1>>>32-(b&31);break b}if(b>>>0>=32){ra(a,0,d2]&(-1>>>32-(b&31)^-1)}ca=e+16|0;return}sa();v()}function Hg(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,g=0;e=ca-32|0;ca=e;a:{b:{f=Ma(c);if(f>>>0>>0>=11){a=(f|15)+1|0;g=pa(a);H[e+24>>2]=a|-2147483648;H[e+16>>2]=g;H[e+20>>2]=f;a=f+g|0;break d}F[e+27|0]=f;g=e+16|0;a=f+g|0;if(!f){break c}}qa(g,c,f)}F[a|0]=0;c=Ma(d);if(c>>>0>=2147483632){break b}e:{f:{if(c>>>0>=11){f=(c|15)+1|0;a=pa(f);H[e+8>>2]=f|-2147483648;H[e>>2]=a;H[e+4>>2]=c;g=a+c|0;break f}F[e+11|0]=c;g=c+e|0;a=e;if(!c){break e}}qa(a,d,c)}F[g|0]=0;c=H[b+4>>2];a=-1;g:{if(!c){break g}c=be(c,e+16|0,e);a=-1;if(!c){break g}a=Yd(b,H[c+24>>2])}if(F[e+11|0]>2])}if(F[e+27|0]>2])}ca=e+32|0;break a}Na();v()}Na();v()}return a|0}function jb(a,b){var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0;b=H[b>>2];h=H[b+8>>2];i=H[b+4>>2];j=H[b>>2];d=H[a>>2];b=H[d+4>>2];a=H[d+8>>2];if(b>>>0>>0){H[b+8>>2]=h;H[b+4>>2]=i;H[b>>2]=j;H[d+4>>2]=b+12;return}a:{e=H[d>>2];g=(b-e|0)/12|0;c=g+1|0;if(c>>>00>=178956970?357913941:a>>>0>c>>>0?a:c;if(c){if(c>>>0>=357913942){break a}f=pa(N(c,12))}else{f=0}a=f+N(g,12)|0;H[a+8>>2]=h;H[a+4>>2]=i;H[a>>2]=j;g=a+12|0;if((b|0)!=(e|0)){while(1){a=a-12|0;b=b-12|0;H[a>>2]=H[b>>2];H[a+4>>2]=H[b+4>>2];H[a+8>>2]=H[b+8>>2];if((b|0)!=(e|0)){continue}break}}H[d+8>>2]=f+N(c,12);H[d+4>>2]=g;H[d>>2]=a;if(e){oa(e)}return}sa();v()}wa();v()}function lf(a,b){a=a|0;b=b|0;a=0;a:{switch(b|0){case 0:a=pa(20);H[a+12>>2]=-1;H[a+16>>2]=0;H[a+4>>2]=0;H[a+8>>2]=0;H[a>>2]=2232;return a|0;case 1:a=pa(24);H[a+12>>2]=-1;H[a+16>>2]=0;H[a+4>>2]=0;H[a+8>>2]=0;H[a>>2]=2232;H[a+20>>2]=0;H[a>>2]=2448;return a|0;case 2:a=pa(48);H[a+12>>2]=-1;H[a+16>>2]=0;H[a+4>>2]=0;H[a+8>>2]=0;H[a>>2]=2232;H[a+20>>2]=0;H[a>>2]=2448;H[a+24>>2]=1832;H[a>>2]=11048;H[a+32>>2]=0;H[a+36>>2]=0;H[a+28>>2]=-1;H[a+40>>2]=0;H[a+44>>2]=0;return a|0;case 3:a=pa(32);H[a+12>>2]=-1;H[a+16>>2]=0;H[a+4>>2]=0;H[a+8>>2]=0;H[a>>2]=2232;H[a+20>>2]=0;H[a>>2]=2448;H[a+24>>2]=1032;H[a>>2]=7028;H[a+28>>2]=-1;break;default:break a}}return a|0}function tf(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0;f=H[b>>2];b=H[b+4>>2];d=H[H[a+8>>2]+40>>2];j=d;m=pa((d|0)2];k=d;f=g+d|0;d=0+H[c+20>>2]|0;d=f>>>0>>0?d+1|0:d;h=H[c+12>>2];e=0;if(K[c+8>>2]>>0&(d|0)>=(h|0)|(d|0)>(h|0)){break a}e=i>>2;i=(e|0)>2]+g|0,j);H[c+16>>2]=f;H[c+20>>2]=d;qa(H[H[H[a+8>>2]+64>>2]>>2]+b|0,g,j);l=l+1|0;if((i|0)==(l|0)){break b}b=b+j|0;d=n+H[c+20>>2]|0;g=H[c+16>>2];f=k+g|0;d=f>>>0>>0?d+1|0:d;h=H[c+12>>2];if((d|0)>2]>=f>>>0|(d|0)2]=1;f=b+8|0;c=H[b+8>>2];d=H[b+12>>2]-c|0;if(d>>>0>2]}c=c+d|0;d=H[a+4>>2];F[c|0]=d;F[c+1|0]=d>>>8;F[c+2|0]=d>>>16;F[c+3|0]=d>>>24;c=H[a+8>>2];if((c|0)!=H[a+12>>2]){d=0;while(1){g=(d2];e=H[b+12>>2]-c|0;if(e>>>0>2]}c=c+e|0;e=H[g>>2];F[c|0]=e;F[c+1|0]=e>>>8;F[c+2|0]=e>>>16;F[c+3|0]=e>>>24;d=d+1|0;c=H[a+8>>2];if(d>>>0>2]-c>>2>>>0){continue}break}}c=H[b+12>>2];b=H[b+8>>2];c=c-b|0;if(c>>>0>2]}b=b+c|0;a=H[a+20>>2];F[b|0]=a;F[b+1|0]=a>>>8;F[b+2|0]=a>>>16;F[b+3|0]=a>>>24}function Aa(a,b,c){var d=0,e=0,f=0,g=0,h=0,i=0;f=c-b|0;g=f>>2;d=H[a+8>>2];e=H[a>>2];if(g>>>0>2>>>0){f=H[a+4>>2]-e|0;d=f+b|0;h=f>>2;f=h>>>0>>0?d:c;i=f-b|0;if((b|0)!=(f|0)){va(e,b,i)}if(g>>>0>h>>>0){b=H[a+4>>2];if((c|0)!=(f|0)){while(1){H[b>>2]=H[d>>2];b=b+4|0;d=d+4|0;if((d|0)!=(c|0)){continue}break}}H[a+4>>2]=b;return}H[a+4>>2]=e+i;return}if(e){H[a+4>>2]=e;oa(e);H[a+8>>2]=0;H[a>>2]=0;H[a+4>>2]=0;d=0}a:{if((f|0)>>1|0;d=d>>>0>=2147483644?1073741823:e>>>0>g>>>0?e:g;if(d>>>0>=1073741824){break a}e=d2]=d;H[a+8>>2]=d+e;if((b|0)!=(c|0)){c=b;b=(f-4&-4)+4|0;d=qa(d,c,b)+b|0}H[a+4>>2]=d;return}sa();v()}function Rb(a,b){var c=0,d=0,e=0,f=0,g=0,h=0;c=H[a+4>>2];if((c|0)!=H[a+8>>2]){e=H[b+4>>2];H[c>>2]=H[b>>2];H[c+4>>2]=e;H[c+8>>2]=H[b+8>>2];H[a+4>>2]=c+12;return}a:{g=H[a>>2];d=(c-g|0)/12|0;e=d+1|0;if(e>>>00>=178956970?357913941:e>>>0>>0?f:e;if(f){if(f>>>0>=357913942){break a}e=pa(N(f,12))}else{e=0}d=e+N(d,12)|0;h=H[b+4>>2];H[d>>2]=H[b>>2];H[d+4>>2]=h;H[d+8>>2]=H[b+8>>2];b=d+12|0;if((c|0)!=(g|0)){while(1){c=c-12|0;h=H[c+4>>2];d=d-12|0;H[d>>2]=H[c>>2];H[d+4>>2]=h;H[d+8>>2]=H[c+8>>2];if((c|0)!=(g|0)){continue}break}c=H[a>>2]}H[a+8>>2]=e+N(f,12);H[a+4>>2]=b;H[a>>2]=d;if(c){oa(c)}return}sa();v()}wa();v()}function Qi(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0;f=ca-32|0;ca=f;g=e>>>0>1073741823?-1:e2];g=H[g+4>>2];k=H[b+4>>2];H[f+24>>2]=H[b>>2];H[f+28>>2]=k;H[f+8>>2]=i;H[f+12>>2]=g;i=a+8|0;rc(f+16|0,i,f+8|0,f+24|0);H[c>>2]=H[f+16>>2];H[c+4>>2]=H[f+20>>2];if((d|0)>(e|0)){k=0-e2];h=b+h|0;n=H[h+4>>2];H[f+24>>2]=H[h>>2];H[f+28>>2]=n;H[f+8>>2]=m;H[f+12>>2]=j;rc(f+16|0,i,f+8|0,f+24|0);H[g>>2]=H[f+16>>2];H[g+4>>2]=H[f+20>>2];a=a+e|0;if((d|0)>(a|0)){continue}break}}oa(l);ca=f+32|0;return 1}function Hi(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0;f=ca-32|0;ca=f;h=e>>>0>1073741823?-1:e2];i=H[b+4>>2];k=H[h+4>>2];H[f+16>>2]=H[h>>2];H[f+20>>2]=k;H[f+8>>2]=g;H[f+12>>2]=i;i=a+8|0;qc(f+24|0,i,f+16|0,f+8|0);H[c>>2]=H[f+24>>2];H[c+4>>2]=H[f+28>>2];if((d|0)>(e|0)){k=0-e2];g=c+g|0;l=g+k|0;n=H[l+4>>2];H[f+16>>2]=H[l>>2];H[f+20>>2]=n;H[f+8>>2]=m;H[f+12>>2]=j;qc(f+24|0,i,f+16|0,f+8|0);H[g>>2]=H[f+24>>2];H[g+4>>2]=H[f+28>>2];a=a+e|0;if((d|0)>(a|0)){continue}break}}oa(h);ca=f+32|0;return 1}function Ag(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0;a:{if(K[b+80>>2]>65535){break a}a=H[b+100>>2];b=H[b+96>>2];e=(a-b|0)/12|0;f=N(e,6);g=(f|0)==(c|0);if((a|0)==(b|0)|(c|0)!=(f|0)){break a}g=1;c=e>>>0>>0>=2){j=c&-2;c=0;while(1){f=N(a,6);h=f+d|0;e=b+N(a,12)|0;G[h>>1]=H[e>>2];G[(f|2)+d>>1]=H[e+4>>2];G[h+4>>1]=H[e+8>>2];f=a|1;e=N(f,6)+d|0;f=b+N(f,12)|0;G[e>>1]=H[f>>2];G[e+2>>1]=H[f+4>>2];G[e+4>>1]=H[f+8>>2];a=a+2|0;c=c+2|0;if((j|0)!=(c|0)){continue}break}}if(!i){break a}c=N(a,6)+d|0;a=b+N(a,12)|0;G[c>>1]=H[a>>2];G[c+2>>1]=H[a+4>>2];G[c+4>>1]=H[a+8>>2]}return g|0}function Gd(a,b,c,d,e,f,g){var h=0,i=0,j=0;h=ca-16|0;ca=h;if((b^-1)+2147483631>>>0>=c>>>0){if(I[a+11|0]>>>7|0){i=H[a>>2]}else{i=a}if(b>>>0>2]=b2]=b+c;c=ca-16|0;ca=c;ca=c+16|0;c=h+12|0;c=H[(K[h>>2]>2]?c:h)>>2];if(c>>>0>=11){j=c+16&-16;c=j-1|0;c=(c|0)==11?j:c}else{c=10}c=c+1|0}else{c=2147483631}Zb(h,c);c=H[h>>2];if(f){yb(c,g,f)}g=d-e|0;if((d|0)!=(e|0)){yb(c+f|0,e+i|0,g)}if((b|0)!=10){oa(i)}H[a>>2]=c;H[a+8>>2]=H[a+8>>2]&-2147483648|H[h+4>>2]&2147483647;H[a+8>>2]=H[a+8>>2]|-2147483648;b=a;a=f+g|0;H[b+4>>2]=a;F[h+12|0]=0;F[a+c|0]=I[h+12|0];ca=h+16|0;return}Na();v()}function Rg(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0;a=ca-32|0;ca=a;H[a+24>>2]=0;H[a+28>>2]=0;a:{d=Ma(c);if(d>>>0>>0>=11){e=(d|15)+1|0;f=pa(e);H[a+16>>2]=e|-2147483648;H[a+8>>2]=f;H[a+12>>2]=d;e=d+f|0;break c}F[a+19|0]=d;f=a+8|0;e=f+d|0;if(!d){break b}}qa(f,c,d)}F[e|0]=0;c=b+4|0;b=nb(b,a+8|0);d:{if((c|0)==(b|0)){break d}c=H[b+32>>2];b=H[b+28>>2];if((c-b|0)!=8){break d}c=I[b+4|0]|I[b+5|0]2]+4>>2],ea[H[H[b>>2]+24>>2]](b,g)|0);if((c|0)==-1){break a}e=H[a+4>>2];b:{if(I[e+36|0]>2]+28>>2]](b,H[H[H[e+4>>2]+8>>2]+(c2])|0){break b}break a}d=0;c:{if((c|0)>2];if(H[h+12>>2]-H[h+8>>2]>>2>2]+(H[H[e+20>>2]+(c2]2];d=ea[H[H[d>>2]+32>>2]](d,c)|0}if(!d){break a}if(!(ea[H[H[b>>2]+28>>2]](b,d)|0)){break a}}f=1;g=g+1|0;if((ea[H[H[b>>2]+20>>2]](b)|0)>(g|0)){continue}break}}return f|0}function tb(a,b,c){var d=0,e=0,f=0,g=0,h=0,i=0;H[a+8>>2]=0;H[a>>2]=0;H[a+4>>2]=0;a:{b:{if(b){if(b>>>0>=357913942){break b}b=N(b,12);d=pa(b);H[a+4>>2]=d;H[a>>2]=d;e=b+d|0;H[a+8>>2]=e;f=H[c+4>>2];g=H[c>>2];c:{if((f|0)==(g|0)){b=b-12|0;ra(d,0,(b-((b>>>0)%12|0)|0)+12|0);break c}h=f-g|0;if((h|0)>2]=0;H[d>>2]=0;H[d+4>>2]=0;b=pa(h);H[d>>2]=b;H[d+8>>2]=b+i;c=g;while(1){H[b>>2]=H[c>>2];b=b+4|0;c=c+4|0;if((f|0)!=(c|0)){continue}break}H[d+4>>2]=b;d=d+12|0;if((e|0)!=(d|0)){continue}break}}H[a+4>>2]=e}return}sa();v()}H[d+8>>2]=0;H[d>>2]=0;H[d+4>>2]=0;sa();v()}function Vi(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0;c=H[b+8>>2];d=H[b+12>>2];g=d;d=H[b+20>>2];i=d;h=H[b+16>>2];f=h+4|0;d=f>>>0>>0>>0&(d|0)>=(g|0)|(d|0)>(g|0)){break a}e=h+H[b>>2]|0;e=I[e|0]|I[e+1|0]1]>>0>>0>f>>>0&(c|0)>=(g|0)|(c|0)>(g|0)){break a}H[b+16>>2]=d;H[b+20>>2]=c}if(!(e&1)){break a}b=Q(e)^31;if(b-1>>>0>28){break a}j=1;H[a+8>>2]=b+1;b=-22]=c;H[a+12>>2]=b^-1;H[a+24>>2]=c>>1;L[a+20>>2]=O(2)/O(c|0)}return j|0}function Lc(a,b,c){var d=0,e=0,f=0,g=0;a:{f=b>>>0=0;b:{if(!f){break b}b=N(b,3);Kc(a,b,13648);Kc(a+12|0,b,13652);d=H[a+24>>2];c:{if(H[a+32>>2]-d>>2>>>0>=c>>>0){break c}if(c>>>0>=1073741824){break a}b=H[a+28>>2];e=c2]=H[b>>2];if((b|0)!=(d|0)){continue}break}}H[a+32>>2]=e;H[a+28>>2]=g;H[a+24>>2]=c;if(!d){break c}oa(d)}H[a+80>>2]=0;H[a+84>>2]=0;b=H[a+76>>2];H[a+76>>2]=0;if(b){oa(b)}H[a+68>>2]=0;H[a+72>>2]=0;b=a- -64|0;a=H[b>>2];H[b>>2]=0;if(!a){break b}oa(a)}return f}sa();v()}function Fe(a){var b=0,c=0,d=0,e=0,f=0;f=1;c=H[a+140>>2];a:{if((c|0)0>268435455?-1:b|4);H[d>>2]=c;d=d+4|0;c=d+b|0;b=d;while(1){H[b>>2]=0;H[b+4>>2]=0;F[b+5|0]=0;F[b+6|0]=0;F[b+7|0]=0;F[b+8|0]=0;F[b+9|0]=0;F[b+10|0]=0;F[b+11|0]=0;F[b+12|0]=0;b=b+16|0;if((c|0)!=(b|0)){continue}break}e=H[a+136>>2];H[a+136>>2]=d;if(e){c=e-4|0;d=H[c>>2];if(d){b=(d2]>2]+(b>2]){break a}c=pa(32);H[c+16>>2]=0;H[c+20>>2]=0;H[c+8>>2]=0;H[c>>2]=0;H[c+4>>2]=0;H[c+24>>2]=0;H[c+28>>2]=0;d=H[a+64>>2];H[a+64>>2]=c;if(!d){break a}c=H[d>>2];if(c){H[d+4>>2]=c;oa(c)}oa(d)}d=H[a+64>>2];c=H[a+28>>2]-1|0;if(c>>>0>31;g=se(d,0,Rj(c,f,b,0),da);if(g){d=H[a+64>>2];H[a>>2]=d;e=H[d+20>>2];H[a+8>>2]=H[d+16>>2];H[a+12>>2]=e;e=H[d+24>>2];d=H[d+28>>2];H[a+48>>2]=0;H[a+52>>2]=0;H[a+40>>2]=c;H[a+44>>2]=f;H[a+16>>2]=e;H[a+20>>2]=d;H[a+80>>2]=b}return g}function jc(a,b){var c=0;c=H[b+4>>2];H[a>>2]=H[b>>2];H[a+4>>2]=c;c=H[b+60>>2];H[a+56>>2]=H[b+56>>2];H[a+60>>2]=c;c=H[b+52>>2];H[a+48>>2]=H[b+48>>2];H[a+52>>2]=c;c=H[b+44>>2];H[a+40>>2]=H[b+40>>2];H[a+44>>2]=c;c=H[b+36>>2];H[a+32>>2]=H[b+32>>2];H[a+36>>2]=c;c=H[b+28>>2];H[a+24>>2]=H[b+24>>2];H[a+28>>2]=c;c=H[b+20>>2];H[a+16>>2]=H[b+16>>2];H[a+20>>2]=c;c=H[b+12>>2];H[a+8>>2]=H[b+8>>2];H[a+12>>2]=c;H[a+88>>2]=0;H[a+64>>2]=0;H[a+68>>2]=0;H[a+72>>2]=0;H[a+76>>2]=0;F[a+77|0]=0;F[a+78|0]=0;F[a+79|0]=0;F[a+80|0]=0;F[a+81|0]=0;F[a+82|0]=0;F[a+83|0]=0;F[a+84|0]=0;return a}function zg(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0;a=H[b+100>>2];b=H[b+96>>2];h=a-b|0;a:{if((h|0)!=(c|0)|(a|0)==(b|0)){break a}g=(c|0)/12|0;e=g>>>0>>0>=2){k=e&-2;g=0;while(1){e=N(a,12);i=e+d|0;f=b+e|0;H[i>>2]=H[f>>2];H[(e|4)+d>>2]=H[f+4>>2];H[i+8>>2]=H[f+8>>2];f=N(a|1,12);e=f+d|0;f=b+f|0;H[e>>2]=H[f>>2];H[e+4>>2]=H[f+4>>2];H[e+8>>2]=H[f+8>>2];a=a+2|0;g=g+2|0;if((k|0)!=(g|0)){continue}break}}if(!j){break a}e=d;d=N(a,12);a=e+d|0;b=b+d|0;H[a>>2]=H[b>>2];H[a+4>>2]=H[b+4>>2];H[a+8>>2]=H[b+8>>2]}return(c|0)==(h|0)|0}function Mi(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0;c=H[b+8>>2];d=H[b+12>>2];g=d;d=H[b+20>>2];i=d;h=H[b+16>>2];f=h+4|0;d=f>>>0>>0>>0&(d|0)>=(g|0)|(d|0)>(g|0)){break a}e=h+H[b>>2]|0;e=I[e|0]|I[e+1|0]>0>>0>f>>>0&(c|0)>=(g|0)|(c|0)>(g|0)){break a}H[b+16>>2]=d;H[b+20>>2]=c;if(!(e&1)){break a}b=Q(e)^31;if(b-1>>>0>28){break a}j=1;H[a+8>>2]=b+1;b=-22]=c;H[a+12>>2]=b^-1;H[a+24>>2]=c>>1;L[a+20>>2]=O(2)/O(c|0)}return j|0}function nb(a,b){var c=0,d=0,e=0,f=0,g=0,h=0,i=0;f=a+4|0;a=H[a+4>>2];a:{b:{if(!a){break b}d=I[b+11|0];c=d24>2]:b;d=c?H[b+4>>2]:d;b=f;while(1){e=I[a+27|0];c=e24>2]:e;h=e>>>0>d>>>0;i=h?d:e;c:{if(i){c=Fa(c?H[a+16>>2]:a+16|0,g,i);if(c){break c}}c=d>>>0>e>>>0?-1:h}c=(c|0)>2];if(a){continue}break}if((b|0)==(f|0)){break b}c=I[b+27|0];a=c24>2]:c;e=c>>>0>>0?c:d;if(e){a=Fa(g,a?H[b+16>>2]:b+16|0,e);if(a){break d}}if(c>>>0>d>>>0){break b}break a}if((a|0)>=0){break a}}b=f}return b}function Jf(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;if(Ya(a,H[b+8>>2],e)){if(!(H[b+28>>2]==1|H[b+4>>2]!=(c|0))){H[b+28>>2]=d}return}a:{if(Ya(a,H[b>>2],e)){if(!(H[b+16>>2]!=(c|0)&H[b+20>>2]!=(c|0))){if((d|0)!=1){break a}H[b+32>>2]=1;return}H[b+32>>2]=d;b:{if(H[b+44>>2]==4){break b}G[b+52>>1]=0;a=H[a+8>>2];ea[H[H[a>>2]+20>>2]](a,b,c,c,1,e);if(I[b+53|0]){H[b+44>>2]=3;if(!I[b+52|0]){break b}break a}H[b+44>>2]=4}H[b+20>>2]=c;H[b+40>>2]=H[b+40>>2]+1;if(H[b+36>>2]!=1|H[b+24>>2]!=2){break a}F[b+54|0]=1;return}a=H[a+8>>2];ea[H[H[a>>2]+24>>2]](a,b,c,d,e)}}function Db(a,b,c){var d=0,e=0,f=0,g=0;a:{b:{if(!b){break b}if(J[a+38>>1]>2];d=H[a+20>>2];b=H[a+16>>2];g=b+8|0;d=g>>>0>2]>>0&(d|0)>=(f|0)|(d|0)>(f|0)){break a}b=b+H[a>>2]|0;d=I[b+4|0]|I[b+5|0]2]=c;H[a+20>>2]=b;break b}e=0;if(!re(1,c,a)){break a}}F[a+36|0]=1;H[a+32>>2]=0;b=H[a+16>>2];c=b+H[a>>2]|0;H[a+24>>2]=c;H[a+28>>2]=(H[a+8>>2]-b|0)+c;e=1}return e}function ve(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0;f=pa(64);c=pa(12);H[c+8>>2]=H[H[a+4>>2]+80>>2];H[c>>2]=13216;H[c+4>>2]=0;f=od(f,c);a:{b:{if((b|0)>2];e=H[a+8>>2];g=c-e>>2;c:{if((g|0)>(b|0)){break c}d=b+1|0;if(b>>>0>=g>>>0){Vb(h,d-g|0);break c}if(d>>>0>=g>>>0){break c}e=e+(d2];H[c>>2]=0;if(d){ea[H[H[d>>2]+4>>2]](d)}if((c|0)!=(e|0)){continue}break}}H[a+12>>2]=e}a=H[h>>2]+(b2];H[a>>2]=f;if(!c){break a}}ea[H[H[c>>2]+4>>2]](c)}return(b^-1)>>>31|0}function Qd(a,b){var c=0,d=0,e=0,f=0;d=ca-16|0;ca=d;H[d+12>>2]=b;c=ca-208|0;ca=c;H[c+204>>2]=b;b=c+160|0;ra(b,0,40);H[c+200>>2]=H[c+204>>2];a:{if((Od(0,a,c+200|0,c+80|0,b)|0)=0;b=H[3922];if(H[3940]>2];a:{if(!c){break a}H[c+4>>2]=a+48;if(!(ea[H[H[c>>2]+12>>2]](c)|0)){break a}b:{c=ea[H[H[a>>2]+24>>2]](a)|0;if((c|0)>2]+28>>2]](a)|0)+4>>2];g=ea[H[H[a>>2]+20>>2]](a,d)|0;e=H[a+60>>2];if(!(ea[H[H[e>>2]+8>>2]](e,H[H[f+8>>2]+(g2])|0)){break c}d=d+1|0;if((c|0)!=(d|0)){continue}break b}break}return 0}d=0;if(!(ea[H[H[a>>2]+36>>2]](a,b)|0)){break a}if(!(ea[H[H[a>>2]+40>>2]](a,b)|0)){break a}d=ea[H[H[a>>2]+44>>2]](a)|0}return d|0}function id(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0;c=H[a+216>>2];if((c|0)!=H[a+220>>2]){while(1){a:{c=H[N(e,144)+c>>2];if((c|0)>2];f=H[d+8>>2];if((c|0)>=H[d+12>>2]-f>>2){break a}d=0;c=H[(c2];if((ea[H[H[c>>2]+24>>2]](c)|0)>2]+20>>2]](c,d)|0)!=(b|0)){d=d+1|0;if((ea[H[H[c>>2]+24>>2]](c)|0)>(d|0)){continue}break a}break}a=H[a+216>>2]+N(e,144)|0;return(I[a+100|0]?a+4|0:0)|0}e=e+1|0;c=H[a+216>>2];if(e>>>0>2]-c|0)/144>>>0){continue}break}}return 0}function xb(a){var b=0,c=0,d=0,e=0;c=H[a+132>>2];if(c){d=c;b=H[a+136>>2];if((c|0)!=(b|0)){while(1){d=b-12|0;e=H[d>>2];if(e){H[b-8>>2]=e;oa(e)}b=d;if((c|0)!=(b|0)){continue}break}d=H[a+132>>2]}H[a+136>>2]=c;oa(d)}c=H[a+120>>2];if(c){d=c;b=H[a+124>>2];if((c|0)!=(b|0)){while(1){d=b-12|0;e=H[d>>2];if(e){H[b-8>>2]=e;oa(e)}b=d;if((c|0)!=(b|0)){continue}break}d=H[a+120>>2]}H[a+124>>2]=c;oa(d)}b=H[a+108>>2];if(b){H[a+112>>2]=b;oa(b)}b=H[a+96>>2];if(b){H[a+100>>2]=b;oa(b)}Za(a+76|0);Za(a+56|0);Za(a+36|0);Za(a+16|0)}function rd(a){a=a|0;var b=0,c=0,d=0;H[a>>2]=2128;d=H[a+60>>2];if(d){b=d;c=H[a- -64>>2];if((b|0)!=(c|0)){while(1){c=c-4|0;b=H[c>>2];H[c>>2]=0;if(b){Ga(b)}if((c|0)!=(d|0)){continue}break}b=H[a+60>>2]}H[a+64>>2]=d;oa(b)}b=H[a+48>>2];if(b){H[a+52>>2]=b;oa(b)}d=H[a+36>>2];if(d){b=d;c=H[a+40>>2];if((b|0)!=(c|0)){while(1){c=c-24|0;ea[H[H[c>>2]>>2]](c)|0;if((c|0)!=(d|0)){continue}break}b=H[a+36>>2]}H[a+40>>2]=d;oa(b)}H[a>>2]=1984;b=H[a+16>>2];if(b){H[a+20>>2]=b;oa(b)}b=H[a+4>>2];if(b){H[a+8>>2]=b;oa(b)}return a|0}function ue(a,b){var c=0,d=0,e=0,f=0,g=0,h=0,i=0;c=H[a+8>>2];d=H[a+4>>2];if(c-d>>2>>>0>=b>>>0){if(b){b=b2]=d;return}a:{f=H[a>>2];g=d-f>>2;e=g+b|0;if(e>>>0>>1|0;e=c>>>0>=2147483644?1073741823:e>>>0>>0?h:e;if(e){if(e>>>0>=1073741824){break a}i=pa(e2]=(e2]=b;H[a>>2]=c;if(f){oa(f)}return}sa();v()}wa();v()}function rb(a){var b=0,c=0,d=0,e=0,f=0;d=H[a+8>>2];a:{if(I[d+84|0]){break a}b=H[a+16>>2];if(!b|!I[b+84|0]){break a}c=H[d+72>>2];e=H[d+68>>2];F[b+84|0]=0;c=c-e>>2;f=H[b+68>>2];e=H[b+72>>2]-f>>2;b:{if(c>>>0>e>>>0){qb(b+68|0,c-e|0,2316);d=H[a+8>>2];break b}if(c>>>0>=e>>>0){break b}H[b+72>>2]=f+(c2];if((c|0)==H[d+72>>2]){break a}e=H[H[a+16>>2]+68>>2];b=0;while(1){f=b2]=H[c+f>>2];b=b+1|0;c=H[d+68>>2];if(b>>>0>2]-c>>2>>>0){continue}break}}return H[a+16>>2]}function Lg(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,g=0;e=ca+-64|0;ca=e;f=Ha(e+8|0);H[f+16>>2]=0;H[f+20>>2]=0;H[f>>2]=b;H[f+8>>2]=c;H[f+12>>2]=0;b=e+48|0;Pe(b,a,f,d);H[a+24>>2]=H[e+48>>2];f=a+24|0;a:{if((f|0)==(b|0)){break a}b=a+28|0;c=e+48|4;g=I[e+63|0];d=g24;if(F[a+39|0]>=0){if((d|0)>=0){a=H[c+4>>2];H[b>>2]=H[c>>2];H[b+4>>2]=a;H[b+8>>2]=H[c+8>>2];break a}Xb(b,H[e+52>>2],H[e+56>>2]);break a}a=(d|0)>2]:c,a?H[e+56>>2]:g)}if(F[e+63|0]>2])}ca=e- -64|0;return f|0}function Kg(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,g=0;e=ca+-64|0;ca=e;f=Ha(e+8|0);H[f+16>>2]=0;H[f+20>>2]=0;H[f>>2]=b;H[f+8>>2]=c;H[f+12>>2]=0;b=e+48|0;Oe(b,a,f,d);H[a+24>>2]=H[e+48>>2];f=a+24|0;a:{if((f|0)==(b|0)){break a}b=a+28|0;c=e+48|4;g=I[e+63|0];d=g24;if(F[a+39|0]>=0){if((d|0)>=0){a=H[c+4>>2];H[b>>2]=H[c>>2];H[b+4>>2]=a;H[b+8>>2]=H[c+8>>2];break a}Xb(b,H[e+52>>2],H[e+56>>2]);break a}a=(d|0)>2]:c,a?H[e+56>>2]:g)}if(F[e+63|0]>2])}ca=e- -64|0;return f|0}function Ig(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0;a=ca-32|0;ca=a;a:{d=Ma(c);if(d>>>0>>0>=11){e=(d|15)+1|0;f=pa(e);H[a+24>>2]=e|-2147483648;H[a+16>>2]=f;H[a+20>>2]=d;e=d+f|0;break c}F[a+27|0]=d;f=a+16|0;e=f+d|0;if(!d){break b}}qa(f,c,d)}F[e|0]=0;F[a+4|0]=0;H[a>>2]=1701667182;F[a+11|0]=4;d=H[b+4>>2];c=-1;d:{if(!d){break d}d=be(d,a,a+16|0);c=-1;if(!d){break d}c=Yd(b,H[d+24>>2])}b=c;if(F[a+11|0]>2])}if(F[a+27|0]>2])}ca=a+32|0;break a}Na();v()}return b|0}function hd(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0;c=H[a+216>>2];if((c|0)!=H[a+220>>2]){while(1){a:{c=H[N(e,144)+c>>2];if((c|0)>2];f=H[d+8>>2];if((c|0)>=H[d+12>>2]-f>>2){break a}d=0;c=H[(c2];if((ea[H[H[c>>2]+24>>2]](c)|0)>2]+20>>2]](c,d)|0)!=(b|0)){d=d+1|0;if((ea[H[H[c>>2]+24>>2]](c)|0)>(d|0)){continue}break a}break}return(H[a+216>>2]+N(e,144)|0)+104|0}e=e+1|0;c=H[a+216>>2];if(e>>>0>2]-c|0)/144>>>0){continue}break}}return a+184|0}function ab(a){var b=0,c=0,d=0,e=0;c=H[a+640>>2];if(c){d=c;b=H[a+644>>2];if((c|0)!=(b|0)){while(1){d=b-12|0;e=H[d>>2];if(e){H[b-8>>2]=e;oa(e)}b=d;if((c|0)!=(b|0)){continue}break}d=H[a+640>>2]}H[a+644>>2]=c;oa(d)}c=H[a+628>>2];if(c){d=c;b=H[a+632>>2];if((c|0)!=(b|0)){while(1){d=b-12|0;e=H[d>>2];if(e){H[b-8>>2]=e;oa(e)}b=d;if((c|0)!=(b|0)){continue}break}d=H[a+628>>2]}H[a+632>>2]=c;oa(d)}b=H[a+616>>2];if(b){H[a+620>>2]=b;oa(b)}b=H[a+604>>2];if(b){H[a+608>>2]=b;oa(b)}Za(a+584|0);Za(a+564|0);Za(a+544|0)}function Tg(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0;d=ca-16|0;ca=d;H[d+12>>2]=0;a:{e=Ma(c);if(e>>>0>>0>=11){f=(e|15)+1|0;a=pa(f);H[d+8>>2]=f|-2147483648;H[d>>2]=a;H[d+4>>2]=e;f=a+e|0;break c}F[d+11|0]=e;f=d+e|0;a=d;if(!e){break b}}qa(a,c,e)}F[f|0]=0;a=nb(b,d);d:{if((a|0)==(b+4|0)){break d}b=H[a+32>>2];a=H[a+28>>2];if((b-a|0)!=4){break d}H[d+12>>2]=I[a|0]|I[a+1|0]>2];if((c|0)!=(b|0)){while(1){d=b-12|0;e=H[d>>2];if(e){H[b-8>>2]=e;oa(e)}b=d;if((c|0)!=(b|0)){continue}break}d=H[a+128>>2]}H[a+132>>2]=c;oa(d)}c=H[a+116>>2];if(c){d=c;b=H[a+120>>2];if((c|0)!=(b|0)){while(1){d=b-12|0;e=H[d>>2];if(e){H[b-8>>2]=e;oa(e)}b=d;if((c|0)!=(b|0)){continue}break}d=H[a+116>>2]}H[a+120>>2]=c;oa(d)}b=H[a+104>>2];if(b){H[a+108>>2]=b;oa(b)}b=H[a+92>>2];if(b){H[a+96>>2]=b;oa(b)}Za(a+72|0);Za(a+52|0);Za(a+32|0)}function kc(a,b){var c=0,d=0,e=0,f=0,g=0,h=0,i=0;a:{c=H[a+4>>2];e=H[a>>2];d=c-e|0;b:{if(d>>>0>>0){g=b-d|0;f=H[a+8>>2];if(g>>>0>>0){h=a,i=ra(c,0,g)+g|0,H[h+4>>2]=i;break b}if((b|0)0>=1073741823?2147483647:b>>>0>>0?f:b;f=pa(c);ra(f+d|0,0,g);d=va(f,e,d);H[a+8>>2]=d+c;H[a+4>>2]=b+d;H[a>>2]=d;if(!e){break b}oa(e);break b}if(b>>>0>=d>>>0){break b}H[a+4>>2]=b+e}b=H[a+28>>2];c=b;d=b+1|0;b=H[a+24>>2]+1|0;e=b?c:d;H[a+24>>2]=b;H[a+28>>2]=e;return}sa();v()}function Ka(a,b){var c=0,d=0,e=0,f=0,g=0,h=0;e=H[a+4>>2];if((e|0)!=H[a+8>>2]){H[e>>2]=H[b>>2];H[a+4>>2]=e+4;return}a:{g=H[a>>2];f=e-g|0;c=f>>2;d=c+1|0;if(d>>>01|0;c=f>>>0>=2147483644?1073741823:c>>>0>d>>>0?c:d;if(c){if(c>>>0>=1073741824){break a}f=pa(c2]=H[b>>2];b=d+4|0;if((e|0)!=(g|0)){while(1){d=d-4|0;e=e-4|0;H[d>>2]=H[e>>2];if((e|0)!=(g|0)){continue}break}}H[a+8>>2]=f+(c2]=b;H[a>>2]=d;if(g){oa(g)}return}sa();v()}wa();v()}function Ia(a){H[a>>2]=-1;H[a+4>>2]=0;H[a+8>>2]=0;H[a+32>>2]=0;H[a+36>>2]=0;F[a+28|0]=1;H[a+20>>2]=0;H[a+24>>2]=0;H[a+12>>2]=0;H[a+16>>2]=0;H[a+40>>2]=0;H[a+44>>2]=0;H[a+48>>2]=0;H[a+52>>2]=0;H[a+56>>2]=0;H[a+60>>2]=0;H[a+64>>2]=0;H[a+68>>2]=0;H[a+76>>2]=0;H[a+80>>2]=0;H[a+84>>2]=0;H[a+88>>2]=0;H[a+92>>2]=0;H[a+96>>2]=0;H[a+72>>2]=a+4;H[a+104>>2]=0;H[a+108>>2]=0;F[a+100|0]=1;H[a+112>>2]=0;H[a+116>>2]=0;H[a+120>>2]=0;H[a+124>>2]=0;H[a+128>>2]=0;H[a+132>>2]=0;H[a+136>>2]=0;H[a+140>>2]=0}function Ld(a,b){if(!a){return 0}a:{b:{if(a){if(b>>>0>2]){if((b&-128)==57216){break b}break c}if(b>>>0>>6|192;a=2;break a}if(!((b&-8192)!=57344&b>>>0>=55296)){F[a+2|0]=b&63|128;F[a|0]=b>>>12|224;F[a+1|0]=b>>>6&63|128;a=3;break a}if(b-65536>>>0>>18|240;F[a+2|0]=b>>>6&63|128;F[a+1|0]=b>>>12&63|128;a=4;break a}}H[3992]=25;a=-1}else{a=1}break a}F[a|0]=b;a=1}return a}function Hb(a,b){var c=0,d=0,e=0,f=0;d=H[a+12>>2];c=H[a+16>>2]-d>>2;a:{if(c>>>0>>0){ya(a+12|0,b-c|0);break a}if(b>>>0>=c>>>0){break a}H[a+16>>2]=d+(b2];c:{if(H[a+8>>2]-c>>2>>>0>=b>>>0){break c}if(b>>>0>=1073741824){break b}d=H[a+4>>2];e=b2]=H[d>>2];if((c|0)!=(d|0)){continue}break}}H[a+8>>2]=e;H[a+4>>2]=f;H[a>>2]=b;if(!c){break c}oa(c)}return}sa();v()}function _b(a){a=a|0;var b=0,c=0,d=0;H[a>>2]=13724;b=H[a+68>>2];if(b){H[a+72>>2]=b;oa(b)}b=H[a+56>>2];if(b){H[a+60>>2]=b;oa(b)}b=H[a+44>>2];if(b){H[a+48>>2]=b;oa(b)}b=H[a+32>>2];if(b){H[a+36>>2]=b;oa(b)}b=H[a+20>>2];if(b){H[a+24>>2]=b;oa(b)}b=H[a+8>>2];if(b){d=b;c=H[a+12>>2];if((b|0)!=(c|0)){while(1){c=c-4|0;d=H[c>>2];H[c>>2]=0;if(d){Ga(d)}if((b|0)!=(c|0)){continue}break}d=H[a+8>>2]}H[a+12>>2]=b;oa(d)}b=H[a+4>>2];H[a+4>>2]=0;if(b){Uc(b)}return a|0}function yb(a,b,c){var d=0,e=0,f=0,g=0,h=0;f=ca-16|0;ca=f;d=ca-32|0;ca=d;e=ca-16|0;ca=e;H[e+12>>2]=b;H[e+8>>2]=b+c;H[d+24>>2]=H[e+12>>2];H[d+28>>2]=H[e+8>>2];ca=e+16|0;c=ca-16|0;ca=c;h=H[d+28>>2];e=H[d+24>>2];g=h-e|0;if((e|0)!=(h|0)){va(a,e,g)}H[c+12>>2]=e+g;H[c+8>>2]=a+g;H[d+16>>2]=H[c+12>>2];H[d+20>>2]=H[c+8>>2];ca=c+16|0;H[d+12>>2]=(H[d+16>>2]-b|0)+b;H[d+8>>2]=(H[d+20>>2]-a|0)+a;H[f+8>>2]=H[d+12>>2];H[f+12>>2]=H[d+8>>2];ca=d+32|0;ca=f+16|0}function ya(a,b){var c=0,d=0,e=0,f=0,g=0,h=0,i=0;e=H[a+8>>2];c=H[a+4>>2];if(e-c>>2>>>0>=b>>>0){if(b){b=b2]=c;return}a:{f=c;c=H[a>>2];g=f-c|0;h=g>>2;d=h+b|0;if(d>>>0>>1|0;d=e>>>0>=2147483644?1073741823:d>>>0>>0?f:d;if(d){if(d>>>0>=1073741824){break a}i=pa(d>>0>>0>>0>2];c=H[a+4>>2];e=H[a+8>>2];if(c>>>0>>0){H[c>>2]=H[b>>2];H[a+4>>2]=c+4;return}a:{d=c;c=H[a>>2];g=d-c|0;d=g>>2;f=d+1|0;if(f>>>01|0;f=e>>>0>=2147483644?1073741823:f>>>0>>0?d:f;if(f){if(f>>>0>=1073741824){break a}e=pa(f2]=H[b>>2];b=va(e,c,g);H[a+8>>2]=b+(f2]=d+4;H[a>>2]=b;if(c){oa(c)}return}sa();v()}wa();v()}function ob(a,b){var c=0,d=0,e=0,f=0,g=0,h=0,i=0;e=H[a+8>>2];c=H[a+4>>2];if(e-c>>3>>>0>=b>>>0){if(b){b=b2]=c;return}a:{f=c;c=H[a>>2];g=f-c|0;h=g>>3;d=h+b|0;if(d>>>0>>2|0;d=e>>>0>=2147483640?536870911:d>>>0>>0?f:d;if(d){if(d>>>0>=536870912){break a}i=pa(d2]=2328;b=H[a+60>>2];H[a+60>>2]=0;if(b){ea[H[H[b>>2]+4>>2]](b)}b=H[a+48>>2];if(b){H[a+52>>2]=b;oa(b)}d=H[a+36>>2];if(d){c=H[a+40>>2];b=d;if((c|0)!=(b|0)){while(1){c=c-4|0;b=H[c>>2];H[c>>2]=0;if(b){ea[H[H[b>>2]+4>>2]](b)}if((c|0)!=(d|0)){continue}break}b=H[a+36>>2]}H[a+40>>2]=d;oa(b)}H[a>>2]=1984;b=H[a+16>>2];if(b){H[a+20>>2]=b;oa(b)}b=H[a+4>>2];if(b){H[a+8>>2]=b;oa(b)}return a|0}function jf(a){a=a|0;var b=0,c=0,d=0;H[a>>2]=2328;b=H[a+60>>2];H[a+60>>2]=0;if(b){ea[H[H[b>>2]+4>>2]](b)}b=H[a+48>>2];if(b){H[a+52>>2]=b;oa(b)}d=H[a+36>>2];if(d){c=H[a+40>>2];b=d;if((c|0)!=(b|0)){while(1){c=c-4|0;b=H[c>>2];H[c>>2]=0;if(b){ea[H[H[b>>2]+4>>2]](b)}if((c|0)!=(d|0)){continue}break}b=H[a+36>>2]}H[a+40>>2]=d;oa(b)}H[a>>2]=1984;b=H[a+16>>2];if(b){H[a+20>>2]=b;oa(b)}b=H[a+4>>2];if(b){H[a+8>>2]=b;oa(b)}oa(a)}function xi(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0;d=ca-16|0;ca=d;e=H[a+4>>2];a:{if((e|0)==-1){break a}c=H[b+20>>2];if(!!H[b+16>>2]&(c|0)>=0|(c|0)>0){break a}Wb(b,H[b+4>>2],H[a+8>>2],H[a+12>>2]);c=H[b+20>>2];if(!!H[b+16>>2]&(c|0)>=0|(c|0)>0){break a}Wb(b,H[b+4>>2],a+20|0,a+24|0);c=H[b+20>>2];f=H[b+16>>2];F[d+15|0]=H[a+4>>2];if(!!f&(c|0)>=0|(c|0)>0){break a}Wb(b,H[b+4>>2],d+15|0,d+16|0)}ca=d+16|0;return(e|0)!=-1|0}function Eh(a){a=a|0;var b=0,c=0,d=0,e=0,f=0;a:{b=H[a+8>>2];b:{if((b|0)>2];e=H[c>>2];d=H[c+4>>2]-e>>2;c:{if(d>>>0>>0){ue(c,b-d|0);f=H[a+8>>2];break c}f=b;if(b>>>0>=d>>>0){break c}H[c+4>>2]=e+(b>2];e=H[a+4>>2]-c>>2;a=0;while(1){if((a|0)==(e|0)){break a}H[c+(a2]=a;a=a+1|0;if((d|0)!=(a|0)){continue}break}}return(b^-1)>>>31|0}Ca();v()}function qe(a,b){var c=0,d=0,e=0,f=0,g=0,h=0;e=H[a+8>>2];c=H[a+4>>2];if(e-c>>1>>>0>=b>>>0){if(b){b=b2]=c;return}a:{f=c;c=H[a>>2];g=f-c|0;f=g>>1;d=f+b|0;if((d|0)>=0){e=e-c|0;d=e>>>0>=2147483646?2147483647:d>>>0>>0?e:d;if(d){if((d|0)>2];e=a+24|0;a:{if((e|0)==(d|0)){break a}b=a+28|0;c=d|4;f=I[d+15|0];g=f24;if(F[a+39|0]>=0){if((g|0)>=0){a=H[c+4>>2];H[b>>2]=H[c>>2];H[b+4>>2]=a;H[b+8>>2]=H[c+8>>2];break a}Xb(b,H[d+4>>2],H[d+8>>2]);break a}a=(g|0)>2]:c,a?H[d+8>>2]:f)}if(F[d+15|0]>2])}ca=d+16|0;return e|0}function mg(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0;d=ca-16|0;ca=d;Oe(d,a,b,c);H[a+24>>2]=H[d>>2];e=a+24|0;a:{if((e|0)==(d|0)){break a}b=a+28|0;c=d|4;f=I[d+15|0];g=f24;if(F[a+39|0]>=0){if((g|0)>=0){a=H[c+4>>2];H[b>>2]=H[c>>2];H[b+4>>2]=a;H[b+8>>2]=H[c+8>>2];break a}Xb(b,H[d+4>>2],H[d+8>>2]);break a}a=(g|0)>2]:c,a?H[d+8>>2]:f)}if(F[d+15|0]>2])}ca=d+16|0;return e|0}function za(a,b,c){var d=0,e=0,f=0,g=0;e=ca-16|0;ca=e;a:{b:{if(c>>>0>>0>2147483631){break a}g=e+8|0;if(c>>>0>=11){f=c+16&-16;d=f-1|0;d=(d|0)==11?f:d}else{d=10}Zb(g,d+1|0);d=H[e+8>>2];H[a>>2]=d;H[a+8>>2]=H[a+8>>2]&-2147483648|H[e+12>>2]&2147483647;H[a+8>>2]=H[a+8>>2]|-2147483648;H[a+4>>2]=c}yb(d,b,c+1|0);ca=e+16|0;return}Na();v()}function Qg(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0;d=ca-16|0;ca=d;a:{e=Ma(c);if(e>>>0>>0>=11){g=(e|15)+1|0;f=pa(g);H[d+8>>2]=g|-2147483648;H[d>>2]=f;H[d+4>>2]=e;g=e+f|0;break c}F[d+11|0]=e;g=d+e|0;f=d;if(!e){break b}}qa(f,c,e)}F[g|0]=0;f=a+16|0;c=$d(b,d,f);b=H[a+16>>2];a=F[a+27|0];if(F[d+11|0]>2])}ca=d+16|0;a=c?(a|0)>2];d=c+b|0;H[a+4>>2]=d;if(!((d-1^c-1)>>>0>2]+((d>>>0>=33?d-1>>>5|0:0)2]=0}a:{if(!b){break a}a=H[a>>2]+(c>>>3&536870908)|0;c=c&31;if(c){d=32-c|0;e=b>>>0>d>>>0?d:b;H[a>>2]=H[a>>2]&(-1>d-e^-1);b=b-e|0;a=a+4|0}c=b>>>5|0;if(b>>>0>=32){ra(a,0,c2]&(-1>>>32-(b&31)^-1)}}function Fc(a,b,c){var d=0,e=0,f=0;d=H[c+16>>2];a:{if(!d){if(Sd(c)){break a}d=H[c+16>>2]}f=H[c+20>>2];if(d-f>>>0>>0){return ea[H[c+36>>2]](c,a,b)|0}b:{if(H[c+80>>2]>2]](c,a,d)|0;if(e>>>0>>0){break a}a=a+d|0;b=b-d|0;f=H[c+20>>2]}qa(f,a,b);H[c+20>>2]=H[c+20>>2]+b;e=b+d|0}return e}function ad(a){var b=0,c=0,d=0,e=0;if(I[a+76|0]){F[a+76|0]=0;e=H[a+60>>2];c=H[a+72>>2]+7|0;b=c>>>03;c=d+H[a+56>>2]|0;b=(b>>>3|0)+e|0;H[a+56>>2]=c;H[a+60>>2]=c>>>0>>0?b+1|0:b}if(J[a+38>>1]>2];b=0;c=H[a+128>>2]+7|0;b=c>>>03;c=d+H[a+112>>2]|0;b=(b>>>3|0)+e|0;H[a+112>>2]=c;H[a+116>>2]=c>>>0>>0?b+1|0:b}}function re(a,b,c){var d=0,e=0,f=0,g=0;a:{if(a>>>0>10){break a}d=H[c+20>>2];f=H[c+12>>2];e=H[c+16>>2];if((d|0)>=(f|0)&e>>>0>=K[c+8>>2]|(d|0)>(f|0)){break a}f=F[e+H[c>>2]|0];e=e+1|0;d=e?d:d+1|0;H[c+16>>2]=e;H[c+20>>2]=d;d=f;b:{if((d|0)>2];d=d&127|a2]>25;break b}d=d&255;a=0}H[b>>2]=d;H[b+4>>2]=a;g=1}return g}function gb(a,b,c){var d=0,e=0,f=0,g=0;a:{if(a>>>0>10){break a}d=H[c+20>>2];f=H[c+12>>2];e=H[c+16>>2];if((d|0)>=(f|0)&e>>>0>=K[c+8>>2]|(d|0)>(f|0)){break a}f=F[e+H[c>>2]|0];e=e+1|0;d=e?d:d+1|0;H[c+16>>2]=e;H[c+20>>2]=d;d=f;b:{if((d|0)>2];d=d&127|a2]>25;break b}d=d&255;a=0}H[b>>2]=d;H[b+4>>2]=a;g=1}return g}function Nh(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0,i=0;e=ca+-64|0;ca=e;d=ea[H[H[a>>2]+44>>2]](a,b)|0;a=ea[H[H[a>>2]+40>>2]](a,b)|0;f=Eb(e);g=H[b+56>>2];h=d&255;i=a;a=a-1|0;if(a>>>0>31);a=jc(pa(96),f);mb(a,c);F[a+84|0]=1;H[a+72>>2]=H[a+68>>2];H[a+60>>2]=H[b+60>>2];ca=e- -64|0;return a|0}function If(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;if(Ya(a,H[b+8>>2],e)){if(!(H[b+28>>2]==1|H[b+4>>2]!=(c|0))){H[b+28>>2]=d}return}a:{if(!Ya(a,H[b>>2],e)){break a}if(!(H[b+16>>2]!=(c|0)&H[b+20>>2]!=(c|0))){if((d|0)!=1){break a}H[b+32>>2]=1;return}H[b+20>>2]=c;H[b+32>>2]=d;H[b+40>>2]=H[b+40>>2]+1;if(!(H[b+36>>2]!=1|H[b+24>>2]!=2)){F[b+54|0]=1}H[b+44>>2]=4}}function Bh(a){a=a|0;var b=0,c=0,d=0,e=0,f=0,g=0,h=0;e=H[a+32>>2];b=e;h=H[b+8>>2];g=H[b+12>>2];c=H[b+16>>2];b=H[b+20>>2];f=c+4|0;b=f>>>0>>0>h>>>0&(b|0)>=(g|0)|(b|0)>(g|0)){break a}c=H[e>>2]+c|0;c=I[c|0]|I[c+1|0]>2]=c;d=1}return d|0}function qi(a){a=a|0;var b=0,c=0,d=0;H[a>>2]=11276;b=H[a+48>>2];H[a+48>>2]=0;if(b){ea[H[H[b>>2]+4>>2]](b)}H[a>>2]=13280;b=H[a+20>>2];if(b){H[a+24>>2]=b;oa(b)}d=H[a+8>>2];if(d){c=H[a+12>>2];b=d;if((c|0)!=(b|0)){while(1){c=c-4|0;b=H[c>>2];H[c>>2]=0;if(b){ea[H[H[b>>2]+4>>2]](b)}if((c|0)!=(d|0)){continue}break}b=H[a+8>>2]}H[a+12>>2]=d;oa(b)}return a|0}function Ee(a,b){var c=0,d=0,e=0,f=0;H[a+144>>2]=b;c=H[(ea[H[H[b>>2]+32>>2]](b)|0)+32>>2];c=H[c>>2]+H[c+16>>2]|0;d=H[(ea[H[H[b>>2]+32>>2]](b)|0)+32>>2];d=H[d+8>>2]-H[d+16>>2]|0;e=a,f=J[H[(ea[H[H[b>>2]+32>>2]](b)|0)+32>>2]+38>>1],G[e+38>>1]=f;H[a>>2]=c;H[a+16>>2]=0;H[a+20>>2]=0;H[a+8>>2]=d;H[a+12>>2]=0;e=a,f=ea[H[H[b>>2]+36>>2]](b)|0,H[e+148>>2]=f}function Cd(a,b,c,d){F[a+53|0]=1;a:{if(H[a+4>>2]!=(c|0)){break a}F[a+52|0]=1;c=H[a+16>>2];b:{if(!c){H[a+36>>2]=1;H[a+24>>2]=d;H[a+16>>2]=b;if((d|0)!=1){break a}if(H[a+48>>2]==1){break b}break a}if((b|0)==(c|0)){c=H[a+24>>2];if((c|0)==2){H[a+24>>2]=d;c=d}if(H[a+48>>2]!=1){break a}if((c|0)==1){break b}break a}H[a+36>>2]=H[a+36>>2]+1}F[a+54|0]=1}}function pi(a){a=a|0;var b=0,c=0,d=0;H[a>>2]=11276;b=H[a+48>>2];H[a+48>>2]=0;if(b){ea[H[H[b>>2]+4>>2]](b)}H[a>>2]=13280;b=H[a+20>>2];if(b){H[a+24>>2]=b;oa(b)}d=H[a+8>>2];if(d){c=H[a+12>>2];b=d;if((c|0)!=(b|0)){while(1){c=c-4|0;b=H[c>>2];H[c>>2]=0;if(b){ea[H[H[b>>2]+4>>2]](b)}if((c|0)!=(d|0)){continue}break}b=H[a+8>>2]}H[a+12>>2]=d;oa(b)}oa(a)}function zh(a){a=a|0;var b=0,c=0,d=0,e=0,f=0,g=0;e=H[a+32>>2];b=e;g=H[b+8>>2];d=H[b+12>>2];c=H[b+16>>2];b=H[b+20>>2];f=d;d=c+4|0;b=d>>>0=(b|0)&d>>>0>>0|(b|0)>2]+c|0;c=I[c|0]|I[c+1|0]2]+80>>2]=c}return(b|0)>>0>>0|(b|0)>2]=1;H[e+20>>2]=-1;H[e+16>>2]=a;H[e+8>>2]=b;ea[H[H[b>>2]+28>>2]](b,d,H[c>>2],1);a=H[e+32>>2];if((a|0)==1){H[c>>2]=H[e+24>>2]}d=(a|0)==1}ca=e- -64|0;return d|0}function Ie(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0;d=ca-16|0;ca=d;H[a+4>>2]=b;b=H[b+64>>2];e=H[b>>2];b=H[b+4>>2];F[d+15|0]=0;Oa(a+24|0,(b-e>>2>>>0)/3|0,d+15|0);b=H[a+4>>2];e=H[b+56>>2];b=H[b+52>>2];F[d+14|0]=0;Oa(a+36|0,e-b>>2,d+14|0);b=H[c+12>>2];H[a+16>>2]=H[c+8>>2];H[a+20>>2]=b;b=H[c+4>>2];H[a+8>>2]=H[c>>2];H[a+12>>2]=b;ca=d+16|0}function pc(a,b,c){var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0;if(!b){H[c>>2]=0;return}h=0-I[a+12|0]&255;e=H[a+4>>2];d=H[a+8>>2];i=H[a>>2];while(1){j=f0>4095)){e=e-1|0;H[a+4>>2]=e;d=I[e+i|0]|d>0>>0;k=g;g=N(d>>>8|0,h);d=f?k+g|0:d-(h+g|0)|0;H[a+8>>2]=d;f=f|j;b=b-1|0;if(b){continue}break}H[c>>2]=f}function yg(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,g=0;a=ca-16|0;ca=a;f=F[b+24|0];e=H[3411];H[a+8>>2]=H[3410];H[a+12>>2]=e;e=H[3409];H[a>>2]=H[3408];H[a+4>>2]=e;e=Va(b,c,f,a);if(e){b=0;if(f){c=(f&255)2];if(c){H[d+4>>2]=c;oa(c)}H[d+8>>2]=g;H[d+4>>2]=g;H[d>>2]=b}ca=a+16|0;return e|0}function of(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0;f=ea[H[H[a>>2]+24>>2]](a)|0;c=1;a:{if((f|0)>2]>>2];g=a+48|0;c=0;if(!(ea[H[H[d>>2]+16>>2]](d,g,b)|0)){break a}while(1){e=e+1|0;if((f|0)!=(e|0)){d=H[H[a+36>>2]+(e2];if(ea[H[H[d>>2]+16>>2]](d,g,b)|0){continue}}break}c=(e|0)>=(f|0)}return c|0}function nf(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0;f=ea[H[H[a>>2]+24>>2]](a)|0;c=1;a:{if((f|0)>2]>>2];g=a+48|0;c=0;if(!(ea[H[H[d>>2]+20>>2]](d,g,b)|0)){break a}while(1){e=e+1|0;if((f|0)!=(e|0)){d=H[H[a+36>>2]+(e2];if(ea[H[H[d>>2]+20>>2]](d,g,b)|0){continue}}break}c=(e|0)>=(f|0)}return c|0}function _c(a,b){var c=0,d=0;a:{c=H[a+4>>2];d=H[a+8>>2];if((c|0)==d00>>0?d:c}else{c=2147483647}pb(a,c);c=H[a+4>>2]}H[a+4>>2]=c+1;d=12]+(c>>>3&536870908)|0;if(I[b|0]){H[a>>2]=d|H[a>>2];return}H[a>>2]=H[a>>2]&(d^-1);return}sa();v()}function $h(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0;d=ca-16|0;ca=d;H[a+4>>2]=b;e=H[b>>2];b=H[b+4>>2];F[d+15|0]=0;Oa(a+24|0,(b-e>>2>>>0)/3|0,d+15|0);b=H[a+4>>2];e=H[b+28>>2];b=H[b+24>>2];F[d+14|0]=0;Oa(a+36|0,e-b>>2,d+14|0);b=H[c+12>>2];H[a+16>>2]=H[c+8>>2];H[a+20>>2]=b;b=H[c+4>>2];H[a+8>>2]=H[c>>2];H[a+12>>2]=b;ca=d+16|0}function $b(a){var b=0;H[a>>2]=0;H[a+4>>2]=0;H[a+56>>2]=0;H[a+48>>2]=0;H[a+52>>2]=0;H[a+40>>2]=0;H[a+44>>2]=0;H[a+32>>2]=0;H[a+36>>2]=0;H[a+24>>2]=0;H[a+28>>2]=0;H[a+16>>2]=0;H[a+20>>2]=0;H[a+8>>2]=0;H[a+12>>2]=0;b=a- -64|0;H[b>>2]=0;H[b+4>>2]=0;H[a+72>>2]=0;H[a+76>>2]=0;H[a+80>>2]=0;H[a+84>>2]=0;H[a+60>>2]=a;return a}function td(a,b,c){var d=0,e=0,f=0,g=0;a:{if(a>>>0>5){break a}d=H[c+20>>2];e=H[c+12>>2];f=H[c+16>>2];if((d|0)>=(e|0)&f>>>0>=K[c+8>>2]|(d|0)>(e|0)){break a}e=I[H[c>>2]+f|0];f=f+1|0;d=f?d:d+1|0;H[c+16>>2]=f;H[c+20>>2]=d;d=e24;if((d|0)>2]2]=e;g=1}return g} function hb(a,b,c){var d=0,e=0,f=0,g=0;a:{if(a>>>0>5){break a}d=H[c+20>>2];e=H[c+12>>2];f=H[c+16>>2];if((d|0)>=(e|0)&f>>>0>=K[c+8>>2]|(d|0)>(e|0)){break a}e=I[H[c>>2]+f|0];f=f+1|0;d=f?d:d+1|0;H[c+16>>2]=f;H[c+20>>2]=d;d=e24;if((d|0)>2]2]=e;g=1}return g}function Xa(a,b,c){var d=0,e=0,f=0,g=0;a:{if(a>>>0>5){break a}d=H[c+20>>2];e=H[c+12>>2];f=H[c+16>>2];if((d|0)>=(e|0)&f>>>0>=K[c+8>>2]|(d|0)>(e|0)){break a}e=I[H[c>>2]+f|0];f=f+1|0;d=f?d:d+1|0;H[c+16>>2]=f;H[c+20>>2]=d;d=e24;if((d|0)>2]2]=e;g=1}return g}function Qe(a,b,c){var d=0,e=0,f=0,g=0;a:{if(a>>>0>5){break a}d=H[c+20>>2];e=H[c+12>>2];f=H[c+16>>2];if((d|0)>=(e|0)&f>>>0>=K[c+8>>2]|(d|0)>(e|0)){break a}e=I[H[c>>2]+f|0];f=f+1|0;d=f?d:d+1|0;H[c+16>>2]=f;H[c+20>>2]=d;d=e24;if((d|0)>2]2]=e;g=1}return g}function Pc(a,b,c){var d=0,e=0,f=0,g=0;a:{if(a>>>0>5){break a}d=H[c+20>>2];e=H[c+12>>2];f=H[c+16>>2];if((d|0)>=(e|0)&f>>>0>=K[c+8>>2]|(d|0)>(e|0)){break a}e=I[H[c>>2]+f|0];f=f+1|0;d=f?d:d+1|0;H[c+16>>2]=f;H[c+20>>2]=d;d=e24;if((d|0)>2]2]=e;g=1}return g}function Fb(a,b,c){var d=0,e=0,f=0,g=0;a:{if(a>>>0>5){break a}d=H[c+20>>2];e=H[c+12>>2];f=H[c+16>>2];if((d|0)>=(e|0)&f>>>0>=K[c+8>>2]|(d|0)>(e|0)){break a}e=I[H[c>>2]+f|0];f=f+1|0;d=f?d:d+1|0;H[c+16>>2]=f;H[c+20>>2]=d;d=e24;if((d|0)>2]2]=e;g=1}return g}function Ea(a,b,c){var d=0,e=0,f=0,g=0;a:{if(a>>>0>5){break a}d=H[c+20>>2];e=H[c+12>>2];f=H[c+16>>2];if((d|0)>=(e|0)&f>>>0>=K[c+8>>2]|(d|0)>(e|0)){break a}e=I[H[c>>2]+f|0];f=f+1|0;d=f?d:d+1|0;H[c+16>>2]=f;H[c+20>>2]=d;d=e24;if((d|0)>2]2]=e;g=1}return g}function Bb(a,b,c){var d=0,e=0,f=0,g=0;a:{if(a>>>0>5){break a}d=H[c+20>>2];e=H[c+12>>2];f=H[c+16>>2];if((d|0)>=(e|0)&f>>>0>=K[c+8>>2]|(d|0)>(e|0)){break a}e=I[H[c>>2]+f|0];f=f+1|0;d=f?d:d+1|0;H[c+16>>2]=f;H[c+20>>2]=d;d=e24;if((d|0)>2]2]=e;g=1}return g}function Fa(a,b,c){var d=0,e=0;a:{b:{if(c>>>0>=4){if((a|b)&3){break b}while(1){if(H[a>>2]!=H[b>>2]){break b}b=b+4|0;a=a+4|0;c=c-4|0;if(c>>>0>3){continue}break}}if(!c){break a}}while(1){d=I[a|0];e=I[b|0];if((d|0)==(e|0)){b=b+1|0;a=a+1|0;c=c-1|0;if(c){continue}break a}break}return d-e|0}return 0}function Yc(a){var b=0,c=0,d=0,e=0;d=H[a>>2];if(d){e=d;c=H[a+4>>2];if((d|0)!=(c|0)){while(1){e=c-144|0;b=H[e+132>>2];if(b){H[c-8>>2]=b;oa(b)}b=H[c-28>>2];if(b){H[c-24>>2]=b;oa(b)}b=H[c-40>>2];if(b){H[c-36>>2]=b;oa(b)}oc(c-140|0);c=e;if((d|0)!=(c|0)){continue}break}e=H[a>>2]}H[a+4>>2]=d;oa(e)}}function Dg(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0;d=H[b+4>>2];a:{if(!d){break a}b=H[H[H[b+8>>2]+(c2]+60>>2];if((b|0)>2];c=H[d+28>>2];if((a|0)==(c|0)){break a}b:{while(1){e=H[a>>2];if((b|0)==H[e+24>>2]){break b}a=a+4|0;if((c|0)!=(a|0)){continue}break}e=0}}return e|0}function Zh(a){a=a|0;var b=0;H[a+8>>2]=12384;H[a>>2]=12172;b=H[a+96>>2];if(b){H[a+100>>2]=b;oa(b)}b=H[a+80>>2];if(b){H[a+84>>2]=b;oa(b)}b=H[a+68>>2];if(b){H[a+72>>2]=b;oa(b)}b=H[a+56>>2];if(b){H[a+60>>2]=b;oa(b)}H[a+8>>2]=12620;b=H[a+44>>2];if(b){oa(b)}b=H[a+32>>2];if(b){oa(b)}return a|0}function Uc(a){var b=0,c=0,d=0;if(a){d=H[a+24>>2];if(d){b=d;c=H[a+28>>2];if((b|0)!=(c|0)){while(1){c=c-4|0;b=H[c>>2];H[c>>2]=0;if(b){Ra(b+12|0,H[b+16>>2]);Qa(b,H[b+4>>2]);oa(b)}if((c|0)!=(d|0)){continue}break}b=H[a+24>>2]}H[a+28>>2]=d;oa(b)}Ra(a+12|0,H[a+16>>2]);Qa(a,H[a+4>>2]);oa(a)}}function Yh(a){a=a|0;var b=0;H[a+8>>2]=12384;H[a>>2]=12172;b=H[a+96>>2];if(b){H[a+100>>2]=b;oa(b)}b=H[a+80>>2];if(b){H[a+84>>2]=b;oa(b)}b=H[a+68>>2];if(b){H[a+72>>2]=b;oa(b)}b=H[a+56>>2];if(b){H[a+60>>2]=b;oa(b)}H[a+8>>2]=12620;b=H[a+44>>2];if(b){oa(b)}b=H[a+32>>2];if(b){oa(b)}oa(a)}function vi(a){a=a|0;var b=0,c=0,d=0;H[a>>2]=13280;b=H[a+20>>2];if(b){H[a+24>>2]=b;oa(b)}d=H[a+8>>2];if(d){c=H[a+12>>2];b=d;if((c|0)!=(b|0)){while(1){c=c-4|0;b=H[c>>2];H[c>>2]=0;if(b){ea[H[H[b>>2]+4>>2]](b)}if((c|0)!=(d|0)){continue}break}b=H[a+8>>2]}H[a+12>>2]=d;oa(b)}return a|0}function xc(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0,i=0;h=H[c+8>>2];e=H[c+16>>2];g=H[c+12>>2];f=g;d=H[c+20>>2];if(h>>>0>e>>>0&(f|0)>=(d|0)|(d|0)>2]+e|0];i=e+1|0;f=i?d:d+1|0;H[c+16>>2]=i;H[c+20>>2]=f;H[a+4>>2]=b}return e>>>0>>0&(d|0)2]=13280;b=H[a+20>>2];if(b){H[a+24>>2]=b;oa(b)}d=H[a+8>>2];if(d){c=H[a+12>>2];b=d;if((c|0)!=(b|0)){while(1){c=c-4|0;b=H[c>>2];H[c>>2]=0;if(b){ea[H[H[b>>2]+4>>2]](b)}if((c|0)!=(d|0)){continue}break}b=H[a+8>>2]}H[a+12>>2]=d;oa(b)}oa(a)}function Ya(a,b,c){var d=0;if(!c){return H[a+4>>2]==H[b+4>>2]}if((a|0)==(b|0)){return 1}d=H[a+4>>2];a=I[d|0];c=H[b+4>>2];b=I[c|0];a:{if(!a|(b|0)!=(a|0)){break a}while(1){b=I[c+1|0];a=I[d+1|0];if(!a){break a}c=c+1|0;d=d+1|0;if((a|0)==(b|0)){continue}break}}return(a|0)==(b|0)}function _h(a){a=a|0;var b=0;H[a>>2]=12384;b=H[a+88>>2];if(b){H[a+92>>2]=b;oa(b)}b=H[a+72>>2];if(b){H[a+76>>2]=b;oa(b)}b=H[a+60>>2];if(b){H[a- -64>>2]=b;oa(b)}b=H[a+48>>2];if(b){H[a+52>>2]=b;oa(b)}H[a>>2]=12620;b=H[a+36>>2];if(b){oa(b)}b=H[a+24>>2];if(b){oa(b)}return a|0}function Fg(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0;d=H[b+12>>2];b=H[b+8>>2];a=0;a:{if((d|0)==(b|0)){break a}a=d-b>>2;d=a>>>0>2]==(c|0)){break b}a=a+1|0;if((d|0)!=(a|0)){continue}break}a=0;break a}a=(a|0)!=-1?e:0}return a|0}function ae(a,b){var c=0,d=0,e=0;H[a+8>>2]=0;H[a>>2]=0;H[a+4>>2]=0;a:{c=H[b+4>>2];d=H[b>>2];b:{if((c|0)==(d|0)){a=c;break b}c=c-d|0;if((c|0)>2]=d;H[a+4>>2]=d;H[a>>2]=c;c=H[b>>2];a=H[b+4>>2]}qa(e,c,a-c|0);return}sa();v()}function ed(a){var b=0,c=0,d=0,e=0;c=H[a+4>>2];d=H[a>>2];if((c|0)!=(d|0)){while(1){e=c-144|0;b=H[e+132>>2];if(b){H[c-8>>2]=b;oa(b)}b=H[c-28>>2];if(b){H[c-24>>2]=b;oa(b)}b=H[c-40>>2];if(b){H[c-36>>2]=b;oa(b)}oc(c-140|0);c=e;if((d|0)!=(c|0)){continue}break}}H[a+4>>2]=d}function Vh(a){a=a|0;var b=0;H[a>>2]=12384;b=H[a+88>>2];if(b){H[a+92>>2]=b;oa(b)}b=H[a+72>>2];if(b){H[a+76>>2]=b;oa(b)}b=H[a+60>>2];if(b){H[a- -64>>2]=b;oa(b)}b=H[a+48>>2];if(b){H[a+52>>2]=b;oa(b)}H[a>>2]=12620;b=H[a+36>>2];if(b){oa(b)}b=H[a+24>>2];if(b){oa(b)}oa(a)}function cb(a){var b=0;if(a){b=H[a+76>>2];if(b){H[a+80>>2]=b;oa(b)}b=H[a- -64>>2];if(b){H[a+68>>2]=b;oa(b)}b=H[a+48>>2];if(b){H[a+52>>2]=b;oa(b)}b=H[a+24>>2];if(b){H[a+28>>2]=b;oa(b)}b=H[a+12>>2];if(b){H[a+16>>2]=b;oa(b)}b=H[a>>2];if(b){H[a+4>>2]=b;oa(b)}oa(a)}}function Jd(a,b,c){var d=0,e=0,f=0,g=0;f=ca-16|0;ca=f;d=ca-16|0;ca=d;b=b-a>>2;while(1){if(b){H[d+12>>2]=a;e=b>>>1|0;H[d+12>>2]=H[d+12>>2]+(e2]>>2]>2];b=e?g:b;a=e?H[d+12>>2]+4|0:a;continue}break}ca=d+16|0;ca=f+16|0;return a}function oc(a){var b=0;b=H[a+84>>2];if(b){H[a+88>>2]=b;oa(b)}b=H[a+72>>2];if(b){H[a+76>>2]=b;oa(b)}b=H[a+52>>2];if(b){H[a+56>>2]=b;oa(b)}b=H[a+40>>2];if(b){H[a+44>>2]=b;oa(b)}b=H[a+28>>2];if(b){H[a+32>>2]=b;oa(b)}b=H[a+12>>2];if(b){oa(b)}a=H[a>>2];if(a){oa(a)}}function Xc(a,b){var c=0,d=0;d=pa(40);H[d>>2]=-1;c=d+8|0;H[c+16>>2]=0;H[c+20>>2]=0;H[c+8>>2]=0;H[c>>2]=0;H[c+4>>2]=0;H[c+24>>2]=0;H[c+28>>2]=0;ea[H[H[a>>2]+16>>2]](a,d);a=H[b+88>>2];H[b+88>>2]=d;if(a){b=H[a+8>>2];if(b){H[a+12>>2]=b;oa(b)}oa(a)}return 1}function Ma(a){var b=0,c=0,d=0;b=a;a:{if(b&3){while(1){if(!I[b|0]){break a}b=b+1|0;if(b&3){continue}break}}while(1){c=b;b=b+4|0;d=H[c>>2];if(!((d^-1)&d-16843009&-2139062144)){continue}break}while(1){b=c;c=b+1|0;if(I[b|0]){continue}break}}return b-a|0}function Ba(a){var b=0,c=0,d=0,e=0,f=0;d=I[a+12|0];c=H[a+8>>2];a:{if(c>>>0>4095){break a}b=H[a+4>>2];if((b|0)>2]=b;c=I[b+H[a>>2]|0]|c>8|0);e=c&255;f=e>>>0>>0;H[a+8>>2]=f?b+e|0:c-(b+d|0)|0;return f}function od(a,b){H[a+4>>2]=0;H[a+8>>2]=0;H[a>>2]=1984;H[a+12>>2]=0;H[a+16>>2]=0;H[a+20>>2]=0;H[a+24>>2]=0;H[a+28>>2]=0;H[a+32>>2]=0;H[a+36>>2]=0;H[a+40>>2]=0;H[a>>2]=2328;H[a+60>>2]=b;H[a+44>>2]=0;H[a+48>>2]=0;H[a+52>>2]=0;H[a+56>>2]=0;return a}function mc(a,b){var c=0,d=0,e=0;c=Ma(b);if(c>>>0>>0>=11){d=(c|15)+1|0;e=pa(d);H[a+8>>2]=d|-2147483648;H[a>>2]=e;H[a+4>>2]=c;d=c+e|0;break b}F[a+11|0]=c;d=a+c|0;e=a;if(!c){break a}}va(e,b,c)}F[d|0]=0;return a}Na();v()}function Ng(a){a=a|0;var b=0,c=0,d=0;if(a){if(F[a+27|0]>2])}b=H[a>>2];if(b){c=b;d=H[a+4>>2];if((b|0)!=(d|0)){while(1){c=d-12|0;if(F[d-1|0]>2])}d=c;if((d|0)!=(b|0)){continue}break}c=H[a>>2]}H[a+4>>2]=b;oa(c)}oa(a)}}function Jb(a,b){var c=0,d=0,e=0;a:{c=H[a>>2];b:{if(H[a+8>>2]-c>>2>>>0>=b>>>0){break b}if(b>>>0>=1073741824){break a}d=H[a+4>>2]-c|0;e=b2]=b+e;H[a+4>>2]=b+d;H[a>>2]=b;if(!c){break b}oa(c)}return}sa();v()}function Ga(a){a=a|0;var b=0,c=0;if(a){b=H[a+88>>2];H[a+88>>2]=0;if(b){c=H[b+8>>2];if(c){H[b+12>>2]=c;oa(c)}oa(b)}b=H[a+68>>2];if(b){H[a+72>>2]=b;oa(b)}b=H[a+64>>2];H[a+64>>2]=0;if(b){c=H[b>>2];if(c){H[b+4>>2]=c;oa(c)}oa(b)}oa(a)}}function Nd(a){var b=0,c=0,d=0;if(F[H[a>>2]]-48>>>0>=10){return 0}while(1){d=H[a>>2];c=-1;if(b>>>0(b^2147483647)?-1:c+b|0}H[a>>2]=d+1;b=c;if(F[d+1|0]-48>>>0>2];a=pa(12);b=b+N(c,12)|0;c=H[b+4>>2];H[a>>2]=H[b>>2];H[a+4>>2]=c;H[a+8>>2]=H[b+8>>2];b=H[d>>2];if(b){H[d+4>>2]=b;oa(b)}H[d>>2]=a;a=a+12|0;H[d+8>>2]=a;H[d+4>>2]=a;return 1}function Ai(a){a=a|0;var b=0;H[a+24>>2]=1832;H[a>>2]=11048;b=H[a+32>>2];if(b){H[a+36>>2]=b;oa(b)}H[a>>2]=2448;b=H[a+20>>2];H[a+20>>2]=0;if(b){ea[H[H[b>>2]+4>>2]](b)}H[a>>2]=2232;b=H[a+16>>2];H[a+16>>2]=0;if(b){Ga(b)}return a|0}function Sj(a,b,c,d){var e=0,f=0,g=0,h=0;f=b^d;g=f>>31;e=b>>31;a=a^e;h=a-e|0;e=(b^e)-((a>>>0>>0)+e|0)|0;a=d>>31;b=c^a;f=f>>31;a=Tj(h,e,b-a|0,(a^d)-((a>>>0>b>>>0)+a|0)|0)^f;b=a-f|0;da=(g^da)-((a>>>0>>0)+g|0)|0;return b}function yi(a){a=a|0;var b=0;H[a+24>>2]=1832;H[a>>2]=11048;b=H[a+32>>2];if(b){H[a+36>>2]=b;oa(b)}H[a>>2]=2448;b=H[a+20>>2];H[a+20>>2]=0;if(b){ea[H[H[b>>2]+4>>2]](b)}H[a>>2]=2232;b=H[a+16>>2];H[a+16>>2]=0;if(b){Ga(b)}oa(a)}function Yb(a,b,c){var d=0,e=0,f=0;e=ca-16|0;ca=e;d=H[a+8>>2]&2147483647;a:{if(d>>>0>c>>>0){d=H[a>>2];H[a+4>>2]=c;yb(d,b,c);F[e+15|0]=0;F[c+d|0]=I[e+15|0];break a}f=a;a=H[a+4>>2];Gd(f,d-1|0,(c-d|0)+1|0,a,a,c,b)}ca=e+16|0}function Bf(a,b){a=a|0;b=b|0;var c=0,d=0;c=ca-16|0;ca=c;a=H[a+4>>2];a:{if((a|0)==-1){break a}F[c+15|0]=a;d=H[b+20>>2];if(!!H[b+16>>2]&(d|0)>=0|(d|0)>0){break a}Wb(b,H[b+4>>2],c+15|0,c+16|0)}ca=c+16|0;return(a|0)!=-1|0}function Xb(a,b,c){var d=0,e=0;d=ca-16|0;ca=d;a:{if(c>>>0>>16|0;f=a>>>16|0;j=N(e,f);g=c&65535;h=a&65535;i=N(g,h);f=(i>>>16|0)+N(f,g)|0;e=(f&65535)+N(e,h)|0;da=(N(b,c)+j|0)+N(a,d)+(f>>>16)+(e>>>16)|0;return i&65535|e2];if(!d){H[a+36>>2]=1;H[a+24>>2]=c;H[a+16>>2]=b;return}a:{if((b|0)==(d|0)){if(H[a+24>>2]!=2){break a}H[a+24>>2]=c;return}F[a+54|0]=1;H[a+24>>2]=2;H[a+36>>2]=H[a+36>>2]+1}}function th(){var a=0;a=Eb(pa(96));H[a+64>>2]=0;H[a+68>>2]=0;H[a+88>>2]=0;H[a+72>>2]=0;H[a+76>>2]=0;F[a+77|0]=0;F[a+78|0]=0;F[a+79|0]=0;F[a+80|0]=0;F[a+81|0]=0;F[a+82|0]=0;F[a+83|0]=0;F[a+84|0]=0;return a|0}function zi(a,b){a=a|0;b=b|0;var c=0,d=0;H[b>>2]=2;c=H[b+8>>2];d=H[b+12>>2]-c|0;if(d>>>0>2]}b=c+d|0;a=H[a+4>>2];F[b|0]=a;F[b+1|0]=a>>>8;F[b+2|0]=a>>>16;F[b+3|0]=a>>>24}function rj(a){a=a|0;var b=0;H[a>>2]=5580;b=H[a+96>>2];if(b){oa(b)}b=H[a+84>>2];if(b){oa(b)}b=H[a+72>>2];if(b){oa(b)}b=H[a+60>>2];if(b){oa(b)}H[a>>2]=3272;b=H[a+32>>2];if(b){H[a+36>>2]=b;oa(b)}return a|0}function ib(a,b,c,d,e){var f=0;f=ca-256|0;ca=f;if(!(e&73728|(c|0)>>0>>0>255){continue}break}}Ab(a,f,d)}ca=f+256|0}function Ij(a){a=a|0;var b=0;H[a>>2]=3564;b=H[a+96>>2];if(b){oa(b)}b=H[a+84>>2];if(b){oa(b)}b=H[a+72>>2];if(b){oa(b)}b=H[a+60>>2];if(b){oa(b)}H[a>>2]=3272;b=H[a+32>>2];if(b){H[a+36>>2]=b;oa(b)}return a|0}function Ch(a){a=a|0;var b=0,c=0,d=0;b=H[a+8>>2];d=H[a+12>>2];if((b|0)==(d|0)){return 1}while(1){c=H[b>>2];c=ea[H[H[c>>2]+16>>2]](c,H[a+32>>2])|0;if(c){b=b+4|0;if((d|0)!=(b|0)){continue}}break}return c|0}function Yd(a,b){var c=0,d=0;c=H[a+8>>2];a=H[a+12>>2];if((c|0)!=(a|0)){a=a-c>>2;d=a>>>0>2]==(b|0)){return a}a=a+1|0;if((d|0)!=(a|0)){continue}break}}return-1}function qj(a){a=a|0;var b=0;H[a>>2]=5580;b=H[a+96>>2];if(b){oa(b)}b=H[a+84>>2];if(b){oa(b)}b=H[a+72>>2];if(b){oa(b)}b=H[a+60>>2];if(b){oa(b)}H[a>>2]=3272;b=H[a+32>>2];if(b){H[a+36>>2]=b;oa(b)}oa(a)}function Hj(a){a=a|0;var b=0;H[a>>2]=3564;b=H[a+96>>2];if(b){oa(b)}b=H[a+84>>2];if(b){oa(b)}b=H[a+72>>2];if(b){oa(b)}b=H[a+60>>2];if(b){oa(b)}H[a>>2]=3272;b=H[a+32>>2];if(b){H[a+36>>2]=b;oa(b)}oa(a)}function $d(a,b,c){var d=0,e=0;d=a+4|0;a=nb(a,b);a:{if((d|0)==(a|0)){break a}b=H[a+32>>2];d=H[a+28>>2];if((b|0)==(d|0)){break a}Cc(c,b-d|0);c=Dc(c);b=H[a+28>>2];qa(c,b,H[a+32>>2]-b|0);e=1}return e}function Qf(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0;e=ca-16|0;ca=e;a=_(H[a+60>>2],b|0,c|0,d&255,e+8|0)|0;if(a){H[3992]=a;a=-1}else{a=0}ca=e+16|0;da=a?-1:H[e+12>>2];return(a?-1:H[e+8>>2])|0}function Sd(a){var b=0;b=H[a+72>>2];H[a+72>>2]=b-1|b;b=H[a>>2];if(b&8){H[a>>2]=b|32;return-1}H[a+4>>2]=0;H[a+8>>2]=0;b=H[a+44>>2];H[a+28>>2]=b;H[a+20>>2]=b;H[a+16>>2]=b+H[a+48>>2];return 0}function Eb(a){H[a+8>>2]=0;H[a+12>>2]=0;H[a>>2]=0;H[a+40>>2]=0;H[a+44>>2]=0;H[a+28>>2]=9;F[a+24|0]=1;H[a+56>>2]=-1;H[a+60>>2]=0;H[a+16>>2]=0;H[a+20>>2]=0;H[a+48>>2]=0;H[a+52>>2]=0;return a}function hf(a,b){a=a|0;b=b|0;var c=0,d=0;d=H[a+16>>2];c=0;a:{if(H[a+20>>2]-d>>22]+(b2])}return c|0}function Mg(){var a=0,b=0;a=pa(40);H[a+4>>2]=0;H[a+8>>2]=0;H[a+24>>2]=0;H[a+28>>2]=0;b=a+16|0;H[b>>2]=0;H[b+4>>2]=0;H[a>>2]=a+4;H[a+12>>2]=b;H[a+32>>2]=0;H[a+36>>2]=0;return a|0}function Vf(a,b){a=a|0;b=b|0;var c=0,d=0;Wd(a,b);a:{if((b|0)>2];c=H[a+84>>2];if(d-c>>2>2]=12804;H[a>>2]=12640;b=H[a+56>>2];if(b){H[a+60>>2]=b;oa(b)}H[a+8>>2]=12620;b=H[a+44>>2];if(b){oa(b)}b=H[a+32>>2];if(b){oa(b)}return a|0}function Lh(a){a=a|0;var b=0;H[a+8>>2]=11872;H[a>>2]=12932;b=H[a+56>>2];if(b){H[a+60>>2]=b;oa(b)}H[a+8>>2]=12124;b=H[a+44>>2];if(b){oa(b)}b=H[a+32>>2];if(b){oa(b)}return a|0}function zb(a){var b=0,c=0;b=H[3958];c=a+7&-8;a=b+c|0;a:{if(a>>>0>>0?c:0){break a}if(a>>>0>fa()>0){if(!($(a|0)|0)){break a}}H[3958]=a;return b}H[3992]=48;return-1}function bj(a,b,c){a=a|0;b=b|0;c=c|0;var d=0;H[a+4>>2]=b;b=H[H[H[b+4>>2]+8>>2]+(c2];H[a+12>>2]=c;H[a+8>>2]=b;a=H[a+8>>2];if(I[a+24|0]==3){d=H[a+28>>2]==9}return d|0}function wf(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0;d=H[a+8>>2];a:{if(!I[d+24|0]){break a}if(!mb(d,H[b+4>>2]-H[b>>2]>>2)){break a}e=ea[H[H[a>>2]+32>>2]](a,b,c)|0}return e|0}function Qh(a){a=a|0;var b=0;H[a+8>>2]=12804;H[a>>2]=12640;b=H[a+56>>2];if(b){H[a+60>>2]=b;oa(b)}H[a+8>>2]=12620;b=H[a+44>>2];if(b){oa(b)}b=H[a+32>>2];if(b){oa(b)}oa(a)}function Kh(a){a=a|0;var b=0;H[a+8>>2]=11872;H[a>>2]=12932;b=H[a+56>>2];if(b){H[a+60>>2]=b;oa(b)}H[a+8>>2]=12124;b=H[a+44>>2];if(b){oa(b)}b=H[a+32>>2];if(b){oa(b)}oa(a)}function nj(a){a=a|0;var b=0;H[a>>2]=5816;b=H[a+76>>2];if(b){oa(b)}b=H[a+68>>2];H[a+68>>2]=0;if(b){oa(b)}H[a>>2]=3272;b=H[a+32>>2];if(b){H[a+36>>2]=b;oa(b)}return a|0}function Ra(a,b){if(b){Ra(a,H[b>>2]);Ra(a,H[b+4>>2]);a=H[b+28>>2];H[b+28>>2]=0;if(a){Ra(a+12|0,H[a+16>>2]);Qa(a,H[a+4>>2]);oa(a)}if(F[b+27|0]>2])}oa(b)}}function Gi(a,b,c){a=a|0;b=b|0;c=c|0;var d=0;H[a+4>>2]=b;d=H[H[H[b+4>>2]+8>>2]+(c2];H[a+12>>2]=c;H[a+8>>2]=d;return H[H[H[H[b+4>>2]+8>>2]+(c2]+28>>2]==9|0}function Ej(a){a=a|0;var b=0;H[a>>2]=3812;b=H[a+76>>2];if(b){oa(b)}b=H[a+68>>2];H[a+68>>2]=0;if(b){oa(b)}H[a>>2]=3272;b=H[a+32>>2];if(b){H[a+36>>2]=b;oa(b)}return a|0}function Vc(a){H[a+40>>2]=0;H[a+4>>2]=0;H[a+8>>2]=0;H[a>>2]=13280;H[a+12>>2]=0;H[a+16>>2]=0;H[a+20>>2]=0;H[a+24>>2]=0;H[a+28>>2]=0;H[a+32>>2]=0;G[a+36>>1]=0;return a}function Hd(a,b){var c=0,d=0,e=0,f=0;H[a>>2]=15260;H[a>>2]=15372;c=Ma(b);d=pa(c+13|0);H[d+8>>2]=0;H[d+4>>2]=c;H[d>>2]=c;e=a,f=qa(d+12|0,b,c+1|0),H[e+4>>2]=f;return a}function jg(a,b){a=a|0;b=b|0;var c=0;a:{if(!(ea[H[H[a>>2]+36>>2]](a,b)|0)){break a}if(!(ea[H[H[a>>2]+40>>2]](a,b)|0)){break a}c=ea[H[H[a>>2]+44>>2]](a)|0}return c|0}function mj(a){a=a|0;var b=0;H[a>>2]=5816;b=H[a+76>>2];if(b){oa(b)}b=H[a+68>>2];H[a+68>>2]=0;if(b){oa(b)}H[a>>2]=3272;b=H[a+32>>2];if(b){H[a+36>>2]=b;oa(b)}oa(a)}function Dj(a){a=a|0;var b=0;H[a>>2]=3812;b=H[a+76>>2];if(b){oa(b)}b=H[a+68>>2];H[a+68>>2]=0;if(b){oa(b)}H[a>>2]=3272;b=H[a+32>>2];if(b){H[a+36>>2]=b;oa(b)}oa(a)}function Xe(a){a=a|0;var b=0;a:{if(!H[a- -64>>2]|!H[a+68>>2]|(!H[a+44>>2]|!H[a+48>>2])){break a}if(!H[a+52>>2]|!H[a+56>>2]){break a}b=H[a+92>>2]!=-1}return b|0}function cf(a){a=a|0;var b=0;H[a>>2]=2448;b=H[a+20>>2];H[a+20>>2]=0;if(b){ea[H[H[b>>2]+4>>2]](b)}H[a>>2]=2232;b=H[a+16>>2];H[a+16>>2]=0;if(b){Ga(b)}return a|0}function Pj(a,b){a=a|0;b=b|0;var c=0;b=H[b+88>>2];if(!(!b|H[b>>2]!=2)){c=a;a=H[b+8>>2];H[c+4>>2]=I[a|0]|I[a+1|0]2]|!H[a+32>>2])){break a}if(!H[a+36>>2]|!H[a+40>>2]){break a}b=H[a+76>>2]!=-1}return b|0}function Sh(a){a=a|0;var b=0;H[a>>2]=12804;b=H[a+48>>2];if(b){H[a+52>>2]=b;oa(b)}H[a>>2]=12620;b=H[a+36>>2];if(b){oa(b)}b=H[a+24>>2];if(b){oa(b)}return a|0}function He(a){a=a|0;var b=0;H[a>>2]=11872;b=H[a+48>>2];if(b){H[a+52>>2]=b;oa(b)}H[a>>2]=12124;b=H[a+36>>2];if(b){oa(b)}b=H[a+24>>2];if(b){oa(b)}return a|0}function bf(a){a=a|0;var b=0;H[a>>2]=2448;b=H[a+20>>2];H[a+20>>2]=0;if(b){ea[H[H[b>>2]+4>>2]](b)}H[a>>2]=2232;b=H[a+16>>2];H[a+16>>2]=0;if(b){Ga(b)}oa(a)}function wh(){var a=0,b=0;b=pa(40);H[b>>2]=-1;a=b+8|0;H[a+16>>2]=0;H[a+20>>2]=0;H[a+8>>2]=0;H[a>>2]=0;H[a+4>>2]=0;H[a+24>>2]=0;H[a+28>>2]=0;return b|0}function gf(a,b){a=a|0;b=b|0;var c=0,d=0;d=H[a+4>>2];a:{if(d){c=1;if(I[d+36|0]>2]+48>>2]](a,H[b+4>>2]-H[b>>2]>>2)|0}return c|0}function ci(a){a=a|0;var b=0;H[a>>2]=11872;b=H[a+48>>2];if(b){H[a+52>>2]=b;oa(b)}H[a>>2]=12124;b=H[a+36>>2];if(b){oa(b)}b=H[a+24>>2];if(b){oa(b)}oa(a)}function Mh(a){a=a|0;var b=0;H[a>>2]=12804;b=H[a+48>>2];if(b){H[a+52>>2]=b;oa(b)}H[a>>2]=12620;b=H[a+36>>2];if(b){oa(b)}b=H[a+24>>2];if(b){oa(b)}oa(a)}function Ha(a){H[a+8>>2]=0;H[a+12>>2]=0;H[a>>2]=0;H[a+16>>2]=0;H[a+20>>2]=0;H[a+32>>2]=0;H[a+24>>2]=0;H[a+28>>2]=0;G[a+38>>1]=0;F[a+36|0]=0;return a}function Hf(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;if(Ya(a,H[b+8>>2],f)){Cd(b,c,d,e);return}a=H[a+8>>2];ea[H[H[a>>2]+20>>2]](a,b,c,d,e,f)}function Ei(a,b,c){a=a|0;b=b|0;c=c|0;a:{if(I[H[a+4>>2]+36|0]>=2){b=0;if(!(ea[H[H[a>>2]+52>>2]](a)|0)){break a}}b=Xc(a+24|0,H[a+16>>2])}return b|0}function Fi(a,b,c){a=a|0;b=b|0;c=c|0;var d=0;a:{if(I[H[a+4>>2]+36|0]>2]+52>>2]](a)|0)){break a}}d=nd(a,b,c)}return d|0}function gh(){var a=0;a=_d(pa(108));H[a+84>>2]=0;H[a+88>>2]=0;H[a>>2]=13664;H[a+92>>2]=0;H[a+96>>2]=0;H[a+100>>2]=0;H[a+104>>2]=0;return a|0}function Zd(a,b){var c=0;c=-1;a:{if((b|0)==-1|(b|0)>4){break a}b=N(b,12)+a|0;a=H[b+20>>2];if((H[b+24>>2]-a|0)>2]}return c}function lc(a,b,c,d,e,f,g){H[a>>2]=0;H[a+56>>2]=b;H[a+48>>2]=0;H[a+52>>2]=0;H[a+40>>2]=f;H[a+44>>2]=g;F[a+32|0]=e;H[a+28>>2]=d;F[a+24|0]=c}function aj(a,b,c){a=a|0;b=b|0;c=c|0;var d=0;a:{if(I[H[a+4>>2]+36|0]>2],c)){break a}}d=nd(a,b,c)}return d|0}function $i(a,b,c){a=a|0;b=b|0;c=c|0;a:{if(I[H[a+4>>2]+36|0]>=2){b=0;if(!xc(a+24|0,rb(a),c)){break a}}b=Xc(a+24|0,H[a+16>>2])}return b|0}function Yf(a){a=a|0;var b=0;H[a>>2]=13664;b=H[a+96>>2];if(b){H[a+100>>2]=b;oa(b)}b=H[a+84>>2];if(b){H[a+88>>2]=b;oa(b)}return _b(a)|0}function Dc(a){var b=0;if(I[a+11|0]>>>7|0){b=H[a+4>>2]}else{b=I[a+11|0]&127}if(!b){af(1232);v()}if(I[a+11|0]>>>7|0){a=H[a>>2]}return a}function Xf(a){a=a|0;var b=0;H[a>>2]=13664;b=H[a+96>>2];if(b){H[a+100>>2]=b;oa(b)}b=H[a+84>>2];if(b){H[a+88>>2]=b;oa(b)}oa(_b(a))}function zj(a){a=a|0;var b=0;H[a>>2]=4040;b=H[a+76>>2];if(b){oa(b)}H[a>>2]=3272;b=H[a+32>>2];if(b){H[a+36>>2]=b;oa(b)}return a|0}function jj(a){a=a|0;var b=0;H[a>>2]=6032;b=H[a+76>>2];if(b){oa(b)}H[a>>2]=3272;b=H[a+32>>2];if(b){H[a+36>>2]=b;oa(b)}return a|0}function Qa(a,b){if(b){Qa(a,H[b>>2]);Qa(a,H[b+4>>2]);a=H[b+28>>2];if(a){H[b+32>>2]=a;oa(a)}if(F[b+27|0]>2])}oa(b)}}function Vg(){var a=0;a=pa(28);H[a>>2]=0;H[a+4>>2]=0;H[a+24>>2]=0;H[a+16>>2]=0;H[a+20>>2]=0;H[a+8>>2]=0;H[a+12>>2]=0;return a|0}function wg(a){a=a|0;var b=0;H[a>>2]=1984;b=H[a+16>>2];if(b){H[a+20>>2]=b;oa(b)}b=H[a+4>>2];if(b){H[a+8>>2]=b;oa(b)}return a|0}function eh(){var a=0,b=0;a=pa(24);H[a+4>>2]=0;H[a+8>>2]=0;b=a+16|0;H[b>>2]=0;H[b+4>>2]=0;H[a>>2]=a+4;H[a+12>>2]=b;return a|0}function Kf(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;if(Ya(a,H[b+8>>2],0)){Dd(b,c,d);return}a=H[a+8>>2];ea[H[H[a>>2]+28>>2]](a,b,c,d)}function yj(a){a=a|0;var b=0;H[a>>2]=4040;b=H[a+76>>2];if(b){oa(b)}H[a>>2]=3272;b=H[a+32>>2];if(b){H[a+36>>2]=b;oa(b)}oa(a)}function ij(a){a=a|0;var b=0;H[a>>2]=6032;b=H[a+76>>2];if(b){oa(b)}H[a>>2]=3272;b=H[a+32>>2];if(b){H[a+36>>2]=b;oa(b)}oa(a)}function pa(a){var b=0;a=a?a:1;a:{while(1){b=Ec(a);if(b){break a}b=H[4422];if(b){ea[b|0]();continue}break}X();v()}return b}function Kb(a,b){if(b){Kb(a,H[b>>2]);Kb(a,H[b+4>>2]);if(F[b+39|0]>2])}if(F[b+27|0]>2])}oa(b)}}function Ad(a){a=a|0;var b=0,c=0;H[a>>2]=15372;b=H[a+4>>2]-12|0;c=H[b+8>>2]-1|0;H[b+8>>2]=c;if((c|0)>2]=0;H[a+12>>2]=0;H[a+4>>2]=-1;H[a>>2]=1832;H[a+16>>2]=0;H[a+20>>2]=0;return a|0}function pd(a,b,c){a=a|0;b=b|0;c=c|0;H[a+4>>2]=b;b=H[H[H[b+4>>2]+8>>2]+(c2];H[a+12>>2]=c;H[a+8>>2]=b;return 1}function wc(a){a=a|0;var b=0;if(!(!H[a+60>>2]|!H[a+44>>2]|(!H[a+48>>2]|!H[a+52>>2]))){b=H[a+56>>2]!=0}return b|0}function Id(a,b){if(I[a+11|0]>>>7|0){H[a+4>>2]=b;return}F[a+11|0]=I[a+11|0]&128|b;F[a+11|0]=I[a+11|0]&127}function wj(a){a=a|0;var b=0;H[a>>2]=4276;H[a>>2]=3272;b=H[a+32>>2];if(b){H[a+36>>2]=b;oa(b)}return a|0}function fj(a){a=a|0;var b=0;H[a>>2]=6256;H[a>>2]=3272;b=H[a+32>>2];if(b){H[a+36>>2]=b;oa(b)}return a|0}function bi(a){a=a|0;var b=0;H[a>>2]=12124;b=H[a+36>>2];if(b){oa(b)}b=H[a+24>>2];if(b){oa(b)}return a|0}function Uh(a){a=a|0;var b=0;H[a>>2]=12620;b=H[a+36>>2];if(b){oa(b)}b=H[a+24>>2];if(b){oa(b)}return a|0}function lg(a){a=a|0;if(a){if(F[a+39|0]>2])}Oc(a+12|0,H[a+16>>2]);Kb(a,H[a+4>>2]);oa(a)}}function Pb(a){a=a|0;var b=0;if(!(!H[a+52>>2]|(!H[a+44>>2]|!H[a+48>>2]))){b=H[a+56>>2]!=0}return b|0}function vj(a){a=a|0;var b=0;H[a>>2]=4276;H[a>>2]=3272;b=H[a+32>>2];if(b){H[a+36>>2]=b;oa(b)}oa(a)}function vc(a,b){a=a|0;b=b|0;var c=0;if(!(H[b+56>>2]|!b|I[b+24|0]!=3)){H[a+60>>2]=b;c=1}return c|0}function ej(a){a=a|0;var b=0;H[a>>2]=6256;H[a>>2]=3272;b=H[a+32>>2];if(b){H[a+36>>2]=b;oa(b)}oa(a)}function ai(a){a=a|0;var b=0;H[a>>2]=12124;b=H[a+36>>2];if(b){oa(b)}b=H[a+24>>2];if(b){oa(b)}oa(a)}function Th(a){a=a|0;var b=0;H[a>>2]=12620;b=H[a+36>>2];if(b){oa(b)}b=H[a+24>>2];if(b){oa(b)}oa(a)}function xh(a,b,c){a=a|0;b=b|0;c=c|0;H[a+16>>2]=0;H[a+20>>2]=0;H[a>>2]=b;H[a+8>>2]=c;H[a+12>>2]=0}function We(a,b){a=a|0;b=b|0;var c=0;if(!(H[b+56>>2]|I[b+24|0]!=3)){H[a- -64>>2]=b;c=1}return c|0}function yc(a){var b=0;b=H[a+16>>2];if(b){H[a+20>>2]=b;oa(b)}b=H[a>>2];if(b){H[a+4>>2]=b;oa(b)}}function sc(a,b){a=a|0;b=b|0;var c=0;if(!(H[b+56>>2]|I[b+24|0]!=3)){H[a+48>>2]=b;c=1}return c|0}function Gf(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;if(Ya(a,H[b+8>>2],f)){Cd(b,c,d,e)}}function wa(){var a=0;a=Bc(4);H[a>>2]=15260;H[a>>2]=15220;H[a>>2]=15240;Y(a|0,15352,14);v()}function sf(a){a=a|0;var b=0;H[a>>2]=2232;b=H[a+16>>2];H[a+16>>2]=0;if(b){Ga(b)}return a|0}function Kj(a){a=a|0;var b=0;H[a>>2]=3272;b=H[a+32>>2];if(b){H[a+36>>2]=b;oa(b)}return a|0}function mi(a){a=a|0;var b=0;H[a>>2]=1832;b=H[a+8>>2];if(b){H[a+12>>2]=b;oa(b)}return a|0}function Ci(a){a=a|0;var b=0;b=rb(a);return Je(a+24|0,b?b:H[a+8>>2],H[H[a+4>>2]+32>>2])|0}function rf(a){a=a|0;var b=0;H[a>>2]=2232;b=H[a+16>>2];H[a+16>>2]=0;if(b){Ga(b)}oa(a)}function ji(a){a=a|0;var b=0;H[a>>2]=1832;b=H[a+8>>2];if(b){H[a+12>>2]=b;oa(b)}oa(a)} function Ub(a){a=a|0;var b=0;H[a>>2]=3272;b=H[a+32>>2];if(b){H[a+36>>2]=b;oa(b)}oa(a)}function Za(a){var b=0;H[a+16>>2]=0;b=H[a>>2];H[a+4>>2]=b;H[a+12>>2]=b;if(b){oa(b)}}function Oc(a,b){if(b){Oc(a,H[b>>2]);Oc(a,H[b+4>>2]);Kb(b+20|0,H[b+24>>2]);oa(b)}}function wi(a){a=a|0;if(!H[a+44>>2]){return 0}return ea[H[H[a>>2]+48>>2]](a)|0}function vh(a){a=a|0;var b=0;if(a){b=H[a+8>>2];if(b){H[a+12>>2]=b;oa(b)}oa(a)}}function Uj(a){var b=0;while(1){if(a){a=a-1&a;b=b+1|0;continue}break}return b}function Lf(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;if(Ya(a,H[b+8>>2],0)){Dd(b,c,d)}}function ui(a,b){a=a|0;b=b|0;a=H[a+48>>2];return ea[H[H[a>>2]+20>>2]](a,b)|0}function ni(a,b){a=a|0;b=b|0;a=H[a+48>>2];return ea[H[H[a>>2]+12>>2]](a,b)|0}function li(a,b){a=a|0;b=b|0;a=H[a+48>>2];return ea[H[H[a>>2]+16>>2]](a,b)|0}function lb(){var a=0;a=pa(12);H[a>>2]=0;H[a+4>>2]=0;H[a+8>>2]=0;return a|0}function kb(a){a=a|0;var b=0;if(a){b=H[a>>2];if(b){H[a+4>>2]=b;oa(b)}oa(a)}}function Vj(a){var b=0;b=a&31;a=0-a&31;return(-1>>>b&-2)>2]=c;H[a+28>>2]=b;return 1}function ch(a){a=a|0;if(a){Ra(a+12|0,H[a+16>>2]);Qa(a,H[a+4>>2]);oa(a)}}function Rd(a,b,c){a:{if(H[c+76>>2]>>0>2]=b}return b>>>0>2]=H[b+68>>2];return 1}function si(a){a=a|0;a=H[a+48>>2];return ea[H[H[a>>2]+24>>2]](a)|0}function ri(a){a=a|0;a=H[a+48>>2];return ea[H[H[a>>2]+28>>2]](a)|0}function oi(a){a=a|0;a=H[a+48>>2];return ea[H[H[a>>2]+36>>2]](a)|0}function ih(){var a=0;a=pa(8);H[a+4>>2]=-1;H[a>>2]=1032;return a|0}function Gg(a,b,c){a=a|0;b=b|0;c=c|0;return H[H[b+8>>2]+(c2]}function _i(a,b){a=a|0;b=b|0;return Fd(a+24|0,rb(a),H[a+8>>2])|0}function Bi(a,b){a=a|0;b=b|0;return Re(a+24|0,rb(a),H[a+8>>2])|0}function xf(a,b){a=a|0;b=b|0;H[a+12>>2]=-1;H[a+8>>2]=b;return 1}function ne(a,b){a=a|0;b=b|0;return ea[H[H[a>>2]+12>>2]](a,b)|0}function Ff(a){a=a|0;if(!a){return 0}return(Ed(a,15068)|0)!=0|0}function Di(a,b){a=a|0;b=b|0;return ea[H[H[a>>2]+56>>2]](a,b)|0}function $g(a){a=a|0;if(a){if(F[a+15|0]>2])}oa(a)}}function kh(a,b){a=a|0;b=b|0;return O(L[H[a+8>>2]+(b2])}function af(a){a=Hd(Bc(8),a);H[a>>2]=15472;Y(a|0,15504,1);v()}function Ue(a){a=Hd(Bc(8),a);H[a>>2]=15420;Y(a|0,15452,1);v()}function _g(a,b){a=a|0;b=b|0;return O(L[H[a>>2]+(b2])}function fh(a){a=a|0;return(H[a+100>>2]-H[a+96>>2]|0)/12|0}function ah(a){a=a|0;return(F[a+15|0]>2]:a+4|0)|0}function _f(a,b){a=a|0;b=b|0;return H[H[a+4>>2]+(b2]}function Pf(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;da=0;return 0}function Ke(a){a=Vc(a);H[a+44>>2]=0;H[a>>2]=11180;return a}function ie(a,b){a=a|0;b=b|0;return H[H[a>>2]+(b2]}function Xg(a,b){a=a|0;b=b|0;return G[H[a>>2]+(b1]}function Wg(a,b){a=a|0;b=b|0;return J[H[a>>2]+(b1]}function Zb(a,b){var c=0;c=pa(b);H[a+4>>2]=b;H[a>>2]=c}function Jg(a,b,c){a=a|0;b=b|0;c=c|0;return Zd(b,c)|0}function _d(a){H[a>>2]=13724;ra(a+4|0,0,80);return a}function me(a){a=a|0;return H[a+12>>2]-H[a+8>>2]>>2}function Qj(a){if(a){return 31-Q(a-1^a)|0}return 32}function cc(a){a=a|0;if(a){ea[H[H[a>>2]+4>>2]](a)}}function Zg(a,b){a=a|0;b=b|0;return F[H[a>>2]+b|0]}function Yg(a,b){a=a|0;b=b|0;return I[H[a>>2]+b|0]}function Uf(a){a=a|0;return H[a+8>>2]-H[a+4>>2]>>2}function jd(a,b){a=a|0;b=b|0;H[a+4>>2]=b;return 1}function je(a){a=a|0;return H[a+4>>2]-H[a>>2]>>1}function Qc(a){a=a|0;return H[a+4>>2]-H[a>>2]>>2}function le(a){a=a|0;return H[a+4>>2]-H[a>>2]|0}function Ab(a,b,c){if(!(I[a|0]&32)){Fc(b,c,a)}}function vf(a,b,c){a=a|0;b=b|0;c=c|0;return 1}function hi(a,b){a=a|0;b=b|0;return I[b+24|0]}function Pg(a,b){a=a|0;b=b|0;return H[b+8>>2]}function Nj(a){a=a|0;return I[H[a+8>>2]+24|0]}function Li(a){a=a|0;H[a>>2]=10032;return a|0}function Eg(a,b){a=a|0;b=b|0;return H[b+4>>2]}function Yi(a){a=a|0;H[a>>2]=7144;return a|0}function Ui(a){a=a|0;H[a>>2]=8080;return a|0}function Sf(a){a=a|0;return aa(H[a+60>>2])|0}function Pi(a){a=a|0;H[a>>2]=9028;return a|0}function jh(a){a=a|0;return O(L[a+20>>2])}function Ji(a){a=a|0;H[a>>2]=10032;oa(a)}function Xi(a){a=a|0;H[a>>2]=7144;oa(a)}function Si(a){a=a|0;H[a>>2]=8080;oa(a)}function Oi(a){a=a|0;H[a>>2]=9028;oa(a)}function sh(a){a=a|0;return H[a+88>>2]}function rh(a){a=a|0;return H[a+56>>2]}function oh(a){a=a|0;return H[a+40>>2]}function nh(a){a=a|0;return H[a+48>>2]}function mh(a){a=a|0;return H[a+60>>2]}function eb(a){a=a|0;return H[a+28>>2]}function df(){H[4292]=17048;H[4274]=42}function Rc(a){a=a|0;return H[a+80>>2]}function qh(a){a=a|0;return F[a+24|0]}function ph(a){a=a|0;return I[a+32|0]}function md(a,b){a=a|0;b=b|0;return-1}function db(a){a=a|0;return H[a+4>>2]}function bh(a){a=a|0;return!H[a>>2]|0}function _e(a,b){a=a|0;b=b|0;return 6}function Zc(a){a=a|0;return H[a+8>>2]}function Pd(a,b){a=a|0;b=b|0;return 1}function Ja(a,b){a=a|0;b=b|0;return 0}function Bj(a,b){a=a|0;b=b|0;return 2}function Bc(a){return Ec(a+80|0)+80|0}function pe(a){a=a|0;return H[a>>2]}function yh(){return Ha(pa(40))|0}function uh(){return Eb(pa(64))|0}function hh(){return _d(pa(84))|0}function Sc(a){a=a|0;if(a){oa(a)}}function zc(a){a=a|0;Ad(a);oa(a)}function Ef(a){a=a|0;return 1171}function Df(a){a=a|0;return 1245}function Cf(a){a=a|0;return 1211}function Ta(a){a=a|0;return a|0}function yf(a){a=a|0;oa(rd(a))}function fi(a){a=a|0;oa(Be(a))}function ei(a){a=a|0;oa(Ae(a))}function di(a){a=a|0;oa(ze(a))}function Tf(a){a=a|0;oa(_b(a))}function ld(a){a=a|0;return 3}function _a(a){a=a|0;return 0}function Ze(a){a=a|0;return 5}function Tb(a){a=a|0;return 2}function Ob(a){a=a|0;return 6}function Da(a){a=a|0;return 1}function $e(a){a=a|0;return 4}function sa(){Ue(1164);v()}function Na(){Ue(1232);v()}function La(a){a=a|0;oa(a)}function Ca(){af(1164);v()}function fb(a){a=a|0;v()}function eg(){return 10}function dg(){return 11}function cg(){return 12}function kg(){return 5}function ig(){return 6}function hg(){return 7}function gg(){return 8}function fg(){return 9}function fe(){return 3}function ee(){return 4}function bg(){return-2}function bc(){return-1}function ag(){return-3}function ac(){return 1}function Zf(){return-5}function Qb(){return 0}function Nc(){return 2}function $f(){return-4}function Nf(){X();v()}function Td(a){a=a|0} // EMSCRIPTEN_END_FUNCS e=I;p(q);var ea=c([null,Ad,Ta,La,Tb,Pj,zi,Gh,Fd,Bf,xc,Nh,_e,Bj,Ta,mi,ji,Da,gj,Ti,Ki,Re,xi,Je,_e,hi,wg,fb,dh,ke,jg,_f,Uf,eb,Ja,Nf,Pd,Da,rd,yf,Of,Af,zf,sf,rf,pd,xf,wf,vf,Pd,uf,tf,kf,jf,qf,pf,hf,of,nf,mf,lf,cf,bf,pd,gf,ff,nd,ef,Nj,Oj,Kj,Ub,Da,db,Pb,_a,md,Ja,_a,Da,Mj,Lj,fb,fb,Ub,Tb,Pb,Jj,Ij,Hj,$e,Pb,Gj,Fj,Ej,Dj,ld,wc,Da,Ja,vc,Cj,Aj,zj,yj,Ze,wc,Da,Ja,vc,Ye,xj,wj,vj,Ob,Xe,Da,Ja,We,Ve,uj,Ta,La,Mb,eb,Nb,fb,Ub,Da,Pb,tj,fb,Ub,Tb,Pb,sj,rj,qj,$e,Pb,pj,oj,nj,mj,ld,wc,Da,Ja,vc,lj,kj,jj,ij,Ze,wc,Da,Ja,vc,Ye,hj,fj,ej,Ob,Xe,Da,Ja,We,Ve,dj,Ta,La,Mb,eb,Lb,fb,Ub,_a,Da,cj,cf,bf,bj,$i,aj,Zi,Tb,_i,Yi,Xi,Ob,db,tc,Da,Ja,sc,Da,Tb,Te,Wi,Ta,La,Mb,eb,Nb,Ui,Si,Ob,tc,Da,Ja,sc,Te,Ri,Ta,La,Mb,eb,Lb,Ta,La,_a,Da,_a,md,Ja,Vi,Qi,Pi,Oi,Ob,db,tc,Da,Ja,sc,Da,ld,Se,Ni,Ta,La,Mb,eb,Nb,Li,Ji,Ob,tc,Da,Ja,sc,Se,Ii,Ta,La,Mb,eb,Lb,La,_a,Da,_a,md,Ja,Mi,Hi,Ai,yi,Gi,Ei,Fi,Di,Ci,Bi,vi,fb,Da,Da,wi,Dh,Ch,Da,_a,Ja,Ja,qi,pi,ti,ui,ri,oi,ni,li,si,Be,fi,jd,id,hd,gd,ki,Da,db,Zc,Ae,ei,jd,id,hd,gd,ii,Da,db,Zc,ze,di,jd,id,hd,gd,gi,Da,db,Zc,He,ci,Ie,bi,ai,Zh,Yh,Xh,Wh,_h,Vh,$h,Uh,Th,Rh,Qh,Ph,Oh,Sh,Mh,Lh,Kh,Jh,Ih,Wc,ve,Hh,Ta,La,Fh,Eh,fb,_a,Da,Wc,Ah,Bh,Wc,ve,zh,Yf,Xf,Wf,Vf,_b,Tf,Xd,Wd,Sf,Rf,Qf,_a,Pf,Ta,La,Td,Td,Mf,Gf,If,Lf,La,Hf,Jf,Kf,La,Df,La,Cf,La,Ef,zc,db,zc,zc]);function fa(){return E.byteLength/65536|0}function ka(la){la=la|0;var ga=fa()|0;var ha=ga+la|0;if(ga16&&heapOrArray.buffer&&UTF8Decoder){return UTF8Decoder.decode(heapOrArray.subarray(idx,endPtr))}var str=\"\";while(idx2]=type};this.get_type=function(){return HEAPU32[this.ptr+4>>2]};this.set_destructor=function(destructor){HEAPU32[this.ptr+8>>2]=destructor};this.get_destructor=function(){return HEAPU32[this.ptr+8>>2]};this.set_refcount=function(refcount){HEAP32[this.ptr>>2]=refcount};this.set_caught=function(caught){caught=caught?1:0;HEAP8[this.ptr+12>>0]=caught};this.get_caught=function(){return HEAP8[this.ptr+12>>0]!=0};this.set_rethrown=function(rethrown){rethrown=rethrown?1:0;HEAP8[this.ptr+13>>0]=rethrown};this.get_rethrown=function(){return HEAP8[this.ptr+13>>0]!=0};this.init=function(type,destructor){this.set_adjusted_ptr(0);this.set_type(type);this.set_destructor(destructor);this.set_refcount(0);this.set_caught(false);this.set_rethrown(false)};this.add_ref=function(){var value=HEAP32[this.ptr>>2];HEAP32[this.ptr>>2]=value+1};this.release_ref=function(){var prev=HEAP32[this.ptr>>2];HEAP32[this.ptr>>2]=prev-1;return prev===1};this.set_adjusted_ptr=function(adjustedPtr){HEAPU32[this.ptr+16>>2]=adjustedPtr};this.get_adjusted_ptr=function(){return HEAPU32[this.ptr+16>>2]};this.get_exception_ptr=function(){var isPointer=___cxa_is_pointer_type(this.get_type());if(isPointer){return HEAPU32[this.excPtr>>2]}var adjusted=this.get_adjusted_ptr();if(adjusted!==0)return adjusted;return this.excPtr}}var exceptionLast=0;var uncaughtExceptionCount=0;function ___cxa_throw(ptr,type,destructor){var info=new ExceptionInfo(ptr);info.init(type,destructor);exceptionLast=ptr;uncaughtExceptionCount++;throw ptr}function _abort(){abort(\"\")}function _emscripten_memcpy_big(dest,src,num){HEAPU8.copyWithin(dest,src,src+num)}function getHeapMax(){return 2147483648}function emscripten_realloc_buffer(size){var b=wasmMemory.buffer;try{wasmMemory.grow(size-b.byteLength+65535>>>16);updateMemoryViews();return 1}catch(e){}}function _emscripten_resize_heap(requestedSize){var oldSize=HEAPU8.length;requestedSize=requestedSize>>>0;var maxHeapSize=getHeapMax();if(requestedSize>maxHeapSize){return false}let alignUp=(x,multiple)=>x+(multiple-x%multiple)%multiple;for(var cutDown=1;cutDown>2];return ret},getStr:function(ptr){var ret=UTF8ToString(ptr);return ret}};function _fd_close(fd){return 52}function _fd_seek(fd,offset_low,offset_high,whence,newOffset){return 70}var printCharBuffers=[null,[],[]];function printChar(stream,curr){var buffer=printCharBuffers[stream];if(curr===0||curr===10){(stream===1?out:err)(UTF8ArrayToString(buffer,0));buffer.length=0}else{buffer.push(curr)}}function _fd_write(fd,iov,iovcnt,pnum){var num=0;for(var i=0;i>2];var len=HEAPU32[iov+4>>2];iov+=8;for(var j=0;j>2]=num;return 0}function intArrayFromString(stringy,dontAddNull,length){var len=length>0?length:lengthBytesUTF8(stringy)+1;var u8array=new Array(len);var numBytesWritten=stringToUTF8Array(stringy,u8array,0,u8array.length);if(dontAddNull)u8array.length=numBytesWritten;return u8array}var decodeBase64=typeof atob==\"function\"?atob:function(input){var keyStr=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";var output=\"\";var chr1,chr2,chr3;var enc1,enc2,enc3,enc4;var i=0;input=input.replace(/[^A-Za-z0-9\\+\\/\\=]/g,\"\");do{enc1=keyStr.indexOf(input.charAt(i++));enc2=keyStr.indexOf(input.charAt(i++));enc3=keyStr.indexOf(input.charAt(i++));enc4=keyStr.indexOf(input.charAt(i++));chr1=enc14;chr2=(enc2&15)2;chr3=(enc3&3)0);ensureCache.needed+=len;ret=Module[\"_malloc\"](len);ensureCache.temps.push(ret)}else{ret=ensureCache.buffer+ensureCache.pos;ensureCache.pos+=len}return ret},copy:function(array,view,offset){offset>>>=0;var bytes=view.BYTES_PER_ELEMENT;switch(bytes){case 2:offset>>>=1;break;case 4:offset>>>=2;break;case 8:offset>>>=3;break}for(var i=0;i"},{"title":"","date":"2023-10-12T14:08:39.200Z","updated":"2023-10-12T14:08:39.200Z","comments":true,"path":"js/three/build/three.js","permalink":"http://19999997.xyz/js/three/build/three.js","excerpt":"","text":"console.warn( 'Scripts \"build/three.js\" and \"build/three.min.js\" are deprecated with r150+, and will be removed with r160. Please use ES Modules or alternatives: https://threejs.org/docs/index.html#manual/en/introduction/Installation' ); /** * @license * Copyright 2010-2023 Three.js Authors * SPDX-License-Identifier: MIT */ (function (global, factory) { typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.THREE = {})); })(this, (function (exports) { 'use strict'; const REVISION = '157'; const MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 }; const TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }; const CullFaceNone = 0; const CullFaceBack = 1; const CullFaceFront = 2; const CullFaceFrontBack = 3; const BasicShadowMap = 0; const PCFShadowMap = 1; const PCFSoftShadowMap = 2; const VSMShadowMap = 3; const FrontSide = 0; const BackSide = 1; const DoubleSide = 2; const TwoPassDoubleSide = 2; // r149 const NoBlending = 0; const NormalBlending = 1; const AdditiveBlending = 2; const SubtractiveBlending = 3; const MultiplyBlending = 4; const CustomBlending = 5; const AddEquation = 100; const SubtractEquation = 101; const ReverseSubtractEquation = 102; const MinEquation = 103; const MaxEquation = 104; const ZeroFactor = 200; const OneFactor = 201; const SrcColorFactor = 202; const OneMinusSrcColorFactor = 203; const SrcAlphaFactor = 204; const OneMinusSrcAlphaFactor = 205; const DstAlphaFactor = 206; const OneMinusDstAlphaFactor = 207; const DstColorFactor = 208; const OneMinusDstColorFactor = 209; const SrcAlphaSaturateFactor = 210; const NeverDepth = 0; const AlwaysDepth = 1; const LessDepth = 2; const LessEqualDepth = 3; const EqualDepth = 4; const GreaterEqualDepth = 5; const GreaterDepth = 6; const NotEqualDepth = 7; const MultiplyOperation = 0; const MixOperation = 1; const AddOperation = 2; const NoToneMapping = 0; const LinearToneMapping = 1; const ReinhardToneMapping = 2; const CineonToneMapping = 3; const ACESFilmicToneMapping = 4; const CustomToneMapping = 5; const UVMapping = 300; const CubeReflectionMapping = 301; const CubeRefractionMapping = 302; const EquirectangularReflectionMapping = 303; const EquirectangularRefractionMapping = 304; const CubeUVReflectionMapping = 306; const RepeatWrapping = 1000; const ClampToEdgeWrapping = 1001; const MirroredRepeatWrapping = 1002; const NearestFilter = 1003; const NearestMipmapNearestFilter = 1004; const NearestMipMapNearestFilter = 1004; const NearestMipmapLinearFilter = 1005; const NearestMipMapLinearFilter = 1005; const LinearFilter = 1006; const LinearMipmapNearestFilter = 1007; const LinearMipMapNearestFilter = 1007; const LinearMipmapLinearFilter = 1008; const LinearMipMapLinearFilter = 1008; const UnsignedByteType = 1009; const ByteType = 1010; const ShortType = 1011; const UnsignedShortType = 1012; const IntType = 1013; const UnsignedIntType = 1014; const FloatType = 1015; const HalfFloatType = 1016; const UnsignedShort4444Type = 1017; const UnsignedShort5551Type = 1018; const UnsignedInt248Type = 1020; const AlphaFormat = 1021; const RGBAFormat = 1023; const LuminanceFormat = 1024; const LuminanceAlphaFormat = 1025; const DepthFormat = 1026; const DepthStencilFormat = 1027; const RedFormat = 1028; const RedIntegerFormat = 1029; const RGFormat = 1030; const RGIntegerFormat = 1031; const RGBAIntegerFormat = 1033; const RGB_S3TC_DXT1_Format = 33776; const RGBA_S3TC_DXT1_Format = 33777; const RGBA_S3TC_DXT3_Format = 33778; const RGBA_S3TC_DXT5_Format = 33779; const RGB_PVRTC_4BPPV1_Format = 35840; const RGB_PVRTC_2BPPV1_Format = 35841; const RGBA_PVRTC_4BPPV1_Format = 35842; const RGBA_PVRTC_2BPPV1_Format = 35843; const RGB_ETC1_Format = 36196; const RGB_ETC2_Format = 37492; const RGBA_ETC2_EAC_Format = 37496; const RGBA_ASTC_4x4_Format = 37808; const RGBA_ASTC_5x4_Format = 37809; const RGBA_ASTC_5x5_Format = 37810; const RGBA_ASTC_6x5_Format = 37811; const RGBA_ASTC_6x6_Format = 37812; const RGBA_ASTC_8x5_Format = 37813; const RGBA_ASTC_8x6_Format = 37814; const RGBA_ASTC_8x8_Format = 37815; const RGBA_ASTC_10x5_Format = 37816; const RGBA_ASTC_10x6_Format = 37817; const RGBA_ASTC_10x8_Format = 37818; const RGBA_ASTC_10x10_Format = 37819; const RGBA_ASTC_12x10_Format = 37820; const RGBA_ASTC_12x12_Format = 37821; const RGBA_BPTC_Format = 36492; const RGB_BPTC_SIGNED_Format = 36494; const RGB_BPTC_UNSIGNED_Format = 36495; const RED_RGTC1_Format = 36283; const SIGNED_RED_RGTC1_Format = 36284; const RED_GREEN_RGTC2_Format = 36285; const SIGNED_RED_GREEN_RGTC2_Format = 36286; const LoopOnce = 2200; const LoopRepeat = 2201; const LoopPingPong = 2202; const InterpolateDiscrete = 2300; const InterpolateLinear = 2301; const InterpolateSmooth = 2302; const ZeroCurvatureEnding = 2400; const ZeroSlopeEnding = 2401; const WrapAroundEnding = 2402; const NormalAnimationBlendMode = 2500; const AdditiveAnimationBlendMode = 2501; const TrianglesDrawMode = 0; const TriangleStripDrawMode = 1; const TriangleFanDrawMode = 2; /** @deprecated Use LinearSRGBColorSpace or NoColorSpace in three.js r152+. */ const LinearEncoding = 3000; /** @deprecated Use SRGBColorSpace in three.js r152+. */ const sRGBEncoding = 3001; const BasicDepthPacking = 3200; const RGBADepthPacking = 3201; const TangentSpaceNormalMap = 0; const ObjectSpaceNormalMap = 1; // Color space string identifiers, matching CSS Color Module Level 4 and WebGPU names where available. const NoColorSpace = ''; const SRGBColorSpace = 'srgb'; const LinearSRGBColorSpace = 'srgb-linear'; const DisplayP3ColorSpace = 'display-p3'; const LinearDisplayP3ColorSpace = 'display-p3-linear'; const LinearTransfer = 'linear'; const SRGBTransfer = 'srgb'; const Rec709Primaries = 'rec709'; const P3Primaries = 'p3'; const ZeroStencilOp = 0; const KeepStencilOp = 7680; const ReplaceStencilOp = 7681; const IncrementStencilOp = 7682; const DecrementStencilOp = 7683; const IncrementWrapStencilOp = 34055; const DecrementWrapStencilOp = 34056; const InvertStencilOp = 5386; const NeverStencilFunc = 512; const LessStencilFunc = 513; const EqualStencilFunc = 514; const LessEqualStencilFunc = 515; const GreaterStencilFunc = 516; const NotEqualStencilFunc = 517; const GreaterEqualStencilFunc = 518; const AlwaysStencilFunc = 519; const NeverCompare = 512; const LessCompare = 513; const EqualCompare = 514; const LessEqualCompare = 515; const GreaterCompare = 516; const NotEqualCompare = 517; const GreaterEqualCompare = 518; const AlwaysCompare = 519; const StaticDrawUsage = 35044; const DynamicDrawUsage = 35048; const StreamDrawUsage = 35040; const StaticReadUsage = 35045; const DynamicReadUsage = 35049; const StreamReadUsage = 35041; const StaticCopyUsage = 35046; const DynamicCopyUsage = 35050; const StreamCopyUsage = 35042; const GLSL1 = '100'; const GLSL3 = '300 es'; const _SRGBAFormat = 1035; // fallback for WebGL 1 const WebGLCoordinateSystem = 2000; const WebGPUCoordinateSystem = 2001; /** * https://github.com/mrdoob/eventdispatcher.js/ */ class EventDispatcher { addEventListener( type, listener ) { if ( this._listeners === undefined ) this._listeners = {}; const listeners = this._listeners; if ( listeners[ type ] === undefined ) { listeners[ type ] = []; } if ( listeners[ type ].indexOf( listener ) === - 1 ) { listeners[ type ].push( listener ); } } hasEventListener( type, listener ) { if ( this._listeners === undefined ) return false; const listeners = this._listeners; return listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1; } removeEventListener( type, listener ) { if ( this._listeners === undefined ) return; const listeners = this._listeners; const listenerArray = listeners[ type ]; if ( listenerArray !== undefined ) { const index = listenerArray.indexOf( listener ); if ( index !== - 1 ) { listenerArray.splice( index, 1 ); } } } dispatchEvent( event ) { if ( this._listeners === undefined ) return; const listeners = this._listeners; const listenerArray = listeners[ event.type ]; if ( listenerArray !== undefined ) { event.target = this; // Make a copy, in case listeners are removed while iterating. const array = listenerArray.slice( 0 ); for ( let i = 0, l = array.length; i < l; i ++ ) { array[ i ].call( this, event ); } event.target = null; } } } const _lut = [ '00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '0a', '0b', '0c', '0d', '0e', '0f', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '1a', '1b', '1c', '1d', '1e', '1f', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '2a', '2b', '2c', '2d', '2e', '2f', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '3a', '3b', '3c', '3d', '3e', '3f', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '4a', '4b', '4c', '4d', '4e', '4f', '50', '51', '52', '53', '54', '55', '56', '57', '58', '59', '5a', '5b', '5c', '5d', '5e', '5f', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '6a', '6b', '6c', '6d', '6e', '6f', '70', '71', '72', '73', '74', '75', '76', '77', '78', '79', '7a', '7b', '7c', '7d', '7e', '7f', '80', '81', '82', '83', '84', '85', '86', '87', '88', '89', '8a', '8b', '8c', '8d', '8e', '8f', '90', '91', '92', '93', '94', '95', '96', '97', '98', '99', '9a', '9b', '9c', '9d', '9e', '9f', 'a0', 'a1', 'a2', 'a3', 'a4', 'a5', 'a6', 'a7', 'a8', 'a9', 'aa', 'ab', 'ac', 'ad', 'ae', 'af', 'b0', 'b1', 'b2', 'b3', 'b4', 'b5', 'b6', 'b7', 'b8', 'b9', 'ba', 'bb', 'bc', 'bd', 'be', 'bf', 'c0', 'c1', 'c2', 'c3', 'c4', 'c5', 'c6', 'c7', 'c8', 'c9', 'ca', 'cb', 'cc', 'cd', 'ce', 'cf', 'd0', 'd1', 'd2', 'd3', 'd4', 'd5', 'd6', 'd7', 'd8', 'd9', 'da', 'db', 'dc', 'dd', 'de', 'df', 'e0', 'e1', 'e2', 'e3', 'e4', 'e5', 'e6', 'e7', 'e8', 'e9', 'ea', 'eb', 'ec', 'ed', 'ee', 'ef', 'f0', 'f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'fa', 'fb', 'fc', 'fd', 'fe', 'ff' ]; let _seed = 1234567; const DEG2RAD = Math.PI / 180; const RAD2DEG = 180 / Math.PI; // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136 function generateUUID() { const d0 = Math.random() * 0xffffffff | 0; const d1 = Math.random() * 0xffffffff | 0; const d2 = Math.random() * 0xffffffff | 0; const d3 = Math.random() * 0xffffffff | 0; const uuid = _lut[ d0 & 0xff ] + _lut[ d0 >> 8 & 0xff ] + _lut[ d0 >> 16 & 0xff ] + _lut[ d0 >> 24 & 0xff ] + '-' + _lut[ d1 & 0xff ] + _lut[ d1 >> 8 & 0xff ] + '-' + _lut[ d1 >> 16 & 0x0f | 0x40 ] + _lut[ d1 >> 24 & 0xff ] + '-' + _lut[ d2 & 0x3f | 0x80 ] + _lut[ d2 >> 8 & 0xff ] + '-' + _lut[ d2 >> 16 & 0xff ] + _lut[ d2 >> 24 & 0xff ] + _lut[ d3 & 0xff ] + _lut[ d3 >> 8 & 0xff ] + _lut[ d3 >> 16 & 0xff ] + _lut[ d3 >> 24 & 0xff ]; // .toLowerCase() here flattens concatenated strings to save heap memory space. return uuid.toLowerCase(); } function clamp( value, min, max ) { return Math.max( min, Math.min( max, value ) ); } // compute euclidean modulo of m % n // https://en.wikipedia.org/wiki/Modulo_operation function euclideanModulo( n, m ) { return ( ( n % m ) + m ) % m; } // Linear mapping from range to range function mapLinear( x, a1, a2, b1, b2 ) { return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 ); } // https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/ function inverseLerp( x, y, value ) { if ( x !== y ) { return ( value - x ) / ( y - x ); } else { return 0; } } // https://en.wikipedia.org/wiki/Linear_interpolation function lerp( x, y, t ) { return ( 1 - t ) * x + t * y; } // http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/ function damp( x, y, lambda, dt ) { return lerp( x, y, 1 - Math.exp( - lambda * dt ) ); } // https://www.desmos.com/calculator/vcsjnyz7x4 function pingpong( x, length = 1 ) { return length - Math.abs( euclideanModulo( x, length * 2 ) - length ); } // http://en.wikipedia.org/wiki/Smoothstep function smoothstep( x, min, max ) { if ( x = max ) return 1; x = ( x - min ) / ( max - min ); return x * x * ( 3 - 2 * x ); } function smootherstep( x, min, max ) { if ( x = max ) return 1; x = ( x - min ) / ( max - min ); return x * x * x * ( x * ( x * 6 - 15 ) + 10 ); } // Random integer from interval function randInt( low, high ) { return low + Math.floor( Math.random() * ( high - low + 1 ) ); } // Random float from interval function randFloat( low, high ) { return low + Math.random() * ( high - low ); } // Random float from interval function randFloatSpread( range ) { return range * ( 0.5 - Math.random() ); } // Deterministic pseudo-random float in the interval [ 0, 1 ] function seededRandom( s ) { if ( s !== undefined ) _seed = s; // Mulberry32 generator let t = _seed += 0x6D2B79F5; t = Math.imul( t ^ t >>> 15, t | 1 ); t ^= t + Math.imul( t ^ t >>> 7, t | 61 ); return ( ( t ^ t >>> 14 ) >>> 0 ) / 4294967296; } function degToRad( degrees ) { return degrees * DEG2RAD; } function radToDeg( radians ) { return radians * RAD2DEG; } function isPowerOfTwo( value ) { return ( value & ( value - 1 ) ) === 0 && value !== 0; } function ceilPowerOfTwo( value ) { return Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) ); } function floorPowerOfTwo( value ) { return Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) ); } function setQuaternionFromProperEuler( q, a, b, c, order ) { // Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles // rotations are applied to the axes in the order specified by 'order' // rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c' // angles are in radians const cos = Math.cos; const sin = Math.sin; const c2 = cos( b / 2 ); const s2 = sin( b / 2 ); const c13 = cos( ( a + c ) / 2 ); const s13 = sin( ( a + c ) / 2 ); const c1_3 = cos( ( a - c ) / 2 ); const s1_3 = sin( ( a - c ) / 2 ); const c3_1 = cos( ( c - a ) / 2 ); const s3_1 = sin( ( c - a ) / 2 ); switch ( order ) { case 'XYX': q.set( c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13 ); break; case 'YZY': q.set( s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13 ); break; case 'ZXZ': q.set( s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13 ); break; case 'XZX': q.set( c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13 ); break; case 'YXY': q.set( s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13 ); break; case 'ZYZ': q.set( s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13 ); break; default: console.warn( 'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order ); } } function denormalize( value, array ) { switch ( array.constructor ) { case Float32Array: return value; case Uint32Array: return value / 4294967295.0; case Uint16Array: return value / 65535.0; case Uint8Array: return value / 255.0; case Int32Array: return Math.max( value / 2147483647.0, - 1.0 ); case Int16Array: return Math.max( value / 32767.0, - 1.0 ); case Int8Array: return Math.max( value / 127.0, - 1.0 ); default: throw new Error( 'Invalid component type.' ); } } function normalize( value, array ) { switch ( array.constructor ) { case Float32Array: return value; case Uint32Array: return Math.round( value * 4294967295.0 ); case Uint16Array: return Math.round( value * 65535.0 ); case Uint8Array: return Math.round( value * 255.0 ); case Int32Array: return Math.round( value * 2147483647.0 ); case Int16Array: return Math.round( value * 32767.0 ); case Int8Array: return Math.round( value * 127.0 ); default: throw new Error( 'Invalid component type.' ); } } const MathUtils = { DEG2RAD: DEG2RAD, RAD2DEG: RAD2DEG, generateUUID: generateUUID, clamp: clamp, euclideanModulo: euclideanModulo, mapLinear: mapLinear, inverseLerp: inverseLerp, lerp: lerp, damp: damp, pingpong: pingpong, smoothstep: smoothstep, smootherstep: smootherstep, randInt: randInt, randFloat: randFloat, randFloatSpread: randFloatSpread, seededRandom: seededRandom, degToRad: degToRad, radToDeg: radToDeg, isPowerOfTwo: isPowerOfTwo, ceilPowerOfTwo: ceilPowerOfTwo, floorPowerOfTwo: floorPowerOfTwo, setQuaternionFromProperEuler: setQuaternionFromProperEuler, normalize: normalize, denormalize: denormalize }; class Vector2 { constructor( x = 0, y = 0 ) { Vector2.prototype.isVector2 = true; this.x = x; this.y = y; } get width() { return this.x; } set width( value ) { this.x = value; } get height() { return this.y; } set height( value ) { this.y = value; } set( x, y ) { this.x = x; this.y = y; return this; } setScalar( scalar ) { this.x = scalar; this.y = scalar; return this; } setX( x ) { this.x = x; return this; } setY( y ) { this.y = y; return this; } setComponent( index, value ) { switch ( index ) { case 0: this.x = value; break; case 1: this.y = value; break; default: throw new Error( 'index is out of range: ' + index ); } return this; } getComponent( index ) { switch ( index ) { case 0: return this.x; case 1: return this.y; default: throw new Error( 'index is out of range: ' + index ); } } clone() { return new this.constructor( this.x, this.y ); } copy( v ) { this.x = v.x; this.y = v.y; return this; } add( v ) { this.x += v.x; this.y += v.y; return this; } addScalar( s ) { this.x += s; this.y += s; return this; } addVectors( a, b ) { this.x = a.x + b.x; this.y = a.y + b.y; return this; } addScaledVector( v, s ) { this.x += v.x * s; this.y += v.y * s; return this; } sub( v ) { this.x -= v.x; this.y -= v.y; return this; } subScalar( s ) { this.x -= s; this.y -= s; return this; } subVectors( a, b ) { this.x = a.x - b.x; this.y = a.y - b.y; return this; } multiply( v ) { this.x *= v.x; this.y *= v.y; return this; } multiplyScalar( scalar ) { this.x *= scalar; this.y *= scalar; return this; } divide( v ) { this.x /= v.x; this.y /= v.y; return this; } divideScalar( scalar ) { return this.multiplyScalar( 1 / scalar ); } applyMatrix3( m ) { const x = this.x, y = this.y; const e = m.elements; this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ]; this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ]; return this; } min( v ) { this.x = Math.min( this.x, v.x ); this.y = Math.min( this.y, v.y ); return this; } max( v ) { this.x = Math.max( this.x, v.x ); this.y = Math.max( this.y, v.y ); return this; } clamp( min, max ) { // assumes min < max, componentwise this.x = Math.max( min.x, Math.min( max.x, this.x ) ); this.y = Math.max( min.y, Math.min( max.y, this.y ) ); return this; } clampScalar( minVal, maxVal ) { this.x = Math.max( minVal, Math.min( maxVal, this.x ) ); this.y = Math.max( minVal, Math.min( maxVal, this.y ) ); return this; } clampLength( min, max ) { const length = this.length(); return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) ); } floor() { this.x = Math.floor( this.x ); this.y = Math.floor( this.y ); return this; } ceil() { this.x = Math.ceil( this.x ); this.y = Math.ceil( this.y ); return this; } round() { this.x = Math.round( this.x ); this.y = Math.round( this.y ); return this; } roundToZero() { this.x = Math.trunc( this.x ); this.y = Math.trunc( this.y ); return this; } negate() { this.x = - this.x; this.y = - this.y; return this; } dot( v ) { return this.x * v.x + this.y * v.y; } cross( v ) { return this.x * v.y - this.y * v.x; } lengthSq() { return this.x * this.x + this.y * this.y; } length() { return Math.sqrt( this.x * this.x + this.y * this.y ); } manhattanLength() { return Math.abs( this.x ) + Math.abs( this.y ); } normalize() { return this.divideScalar( this.length() || 1 ); } angle() { // computes the angle in radians with respect to the positive x-axis const angle = Math.atan2( - this.y, - this.x ) + Math.PI; return angle; } angleTo( v ) { const denominator = Math.sqrt( this.lengthSq() * v.lengthSq() ); if ( denominator === 0 ) return Math.PI / 2; const theta = this.dot( v ) / denominator; // clamp, to handle numerical problems return Math.acos( clamp( theta, - 1, 1 ) ); } distanceTo( v ) { return Math.sqrt( this.distanceToSquared( v ) ); } distanceToSquared( v ) { const dx = this.x - v.x, dy = this.y - v.y; return dx * dx + dy * dy; } manhattanDistanceTo( v ) { return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ); } setLength( length ) { return this.normalize().multiplyScalar( length ); } lerp( v, alpha ) { this.x += ( v.x - this.x ) * alpha; this.y += ( v.y - this.y ) * alpha; return this; } lerpVectors( v1, v2, alpha ) { this.x = v1.x + ( v2.x - v1.x ) * alpha; this.y = v1.y + ( v2.y - v1.y ) * alpha; return this; } equals( v ) { return ( ( v.x === this.x ) && ( v.y === this.y ) ); } fromArray( array, offset = 0 ) { this.x = array[ offset ]; this.y = array[ offset + 1 ]; return this; } toArray( array = [], offset = 0 ) { array[ offset ] = this.x; array[ offset + 1 ] = this.y; return array; } fromBufferAttribute( attribute, index ) { this.x = attribute.getX( index ); this.y = attribute.getY( index ); return this; } rotateAround( center, angle ) { const c = Math.cos( angle ), s = Math.sin( angle ); const x = this.x - center.x; const y = this.y - center.y; this.x = x * c - y * s + center.x; this.y = x * s + y * c + center.y; return this; } random() { this.x = Math.random(); this.y = Math.random(); return this; } *[ Symbol.iterator ]() { yield this.x; yield this.y; } } class Matrix3 { constructor( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) { Matrix3.prototype.isMatrix3 = true; this.elements = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ]; if ( n11 !== undefined ) { this.set( n11, n12, n13, n21, n22, n23, n31, n32, n33 ); } } set( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) { const te = this.elements; te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31; te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32; te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33; return this; } identity() { this.set( 1, 0, 0, 0, 1, 0, 0, 0, 1 ); return this; } copy( m ) { const te = this.elements; const me = m.elements; te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ]; return this; } extractBasis( xAxis, yAxis, zAxis ) { xAxis.setFromMatrix3Column( this, 0 ); yAxis.setFromMatrix3Column( this, 1 ); zAxis.setFromMatrix3Column( this, 2 ); return this; } setFromMatrix4( m ) { const me = m.elements; this.set( me[ 0 ], me[ 4 ], me[ 8 ], me[ 1 ], me[ 5 ], me[ 9 ], me[ 2 ], me[ 6 ], me[ 10 ] ); return this; } multiply( m ) { return this.multiplyMatrices( this, m ); } premultiply( m ) { return this.multiplyMatrices( m, this ); } multiplyMatrices( a, b ) { const ae = a.elements; const be = b.elements; const te = this.elements; const a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ]; const a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ]; const a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ]; const b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ]; const b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ]; const b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ]; te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31; te[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32; te[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33; te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31; te[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32; te[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33; te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31; te[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32; te[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33; return this; } multiplyScalar( s ) { const te = this.elements; te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s; te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s; te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s; return this; } determinant() { const te = this.elements; const a = te[ 0 ], b = te[ 1 ], c = te[ 2 ], d = te[ 3 ], e = te[ 4 ], f = te[ 5 ], g = te[ 6 ], h = te[ 7 ], i = te[ 8 ]; return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g; } invert() { const te = this.elements, n11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ], n12 = te[ 3 ], n22 = te[ 4 ], n32 = te[ 5 ], n13 = te[ 6 ], n23 = te[ 7 ], n33 = te[ 8 ], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13; if ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0 ); const detInv = 1 / det; te[ 0 ] = t11 * detInv; te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv; te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv; te[ 3 ] = t12 * detInv; te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv; te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv; te[ 6 ] = t13 * detInv; te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv; te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv; return this; } transpose() { let tmp; const m = this.elements; tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp; tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp; tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp; return this; } getNormalMatrix( matrix4 ) { return this.setFromMatrix4( matrix4 ).invert().transpose(); } transposeIntoArray( r ) { const m = this.elements; r[ 0 ] = m[ 0 ]; r[ 1 ] = m[ 3 ]; r[ 2 ] = m[ 6 ]; r[ 3 ] = m[ 1 ]; r[ 4 ] = m[ 4 ]; r[ 5 ] = m[ 7 ]; r[ 6 ] = m[ 2 ]; r[ 7 ] = m[ 5 ]; r[ 8 ] = m[ 8 ]; return this; } setUvTransform( tx, ty, sx, sy, rotation, cx, cy ) { const c = Math.cos( rotation ); const s = Math.sin( rotation ); this.set( sx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx, - sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty, 0, 0, 1 ); return this; } // scale( sx, sy ) { this.premultiply( _m3.makeScale( sx, sy ) ); return this; } rotate( theta ) { this.premultiply( _m3.makeRotation( - theta ) ); return this; } translate( tx, ty ) { this.premultiply( _m3.makeTranslation( tx, ty ) ); return this; } // for 2D Transforms makeTranslation( x, y ) { if ( x.isVector2 ) { this.set( 1, 0, x.x, 0, 1, x.y, 0, 0, 1 ); } else { this.set( 1, 0, x, 0, 1, y, 0, 0, 1 ); } return this; } makeRotation( theta ) { // counterclockwise const c = Math.cos( theta ); const s = Math.sin( theta ); this.set( c, - s, 0, s, c, 0, 0, 0, 1 ); return this; } makeScale( x, y ) { this.set( x, 0, 0, 0, y, 0, 0, 0, 1 ); return this; } // equals( matrix ) { const te = this.elements; const me = matrix.elements; for ( let i = 0; i < 9; i ++ ) { if ( te[ i ] !== me[ i ] ) return false; } return true; } fromArray( array, offset = 0 ) { for ( let i = 0; i < 9; i ++ ) { this.elements[ i ] = array[ i + offset ]; } return this; } toArray( array = [], offset = 0 ) { const te = this.elements; array[ offset ] = te[ 0 ]; array[ offset + 1 ] = te[ 1 ]; array[ offset + 2 ] = te[ 2 ]; array[ offset + 3 ] = te[ 3 ]; array[ offset + 4 ] = te[ 4 ]; array[ offset + 5 ] = te[ 5 ]; array[ offset + 6 ] = te[ 6 ]; array[ offset + 7 ] = te[ 7 ]; array[ offset + 8 ] = te[ 8 ]; return array; } clone() { return new this.constructor().fromArray( this.elements ); } } const _m3 = /*@__PURE__*/ new Matrix3(); function arrayNeedsUint32( array ) { // assumes larger values usually on last for ( let i = array.length - 1; i >= 0; -- i ) { if ( array[ i ] >= 65535 ) return true; // account for PRIMITIVE_RESTART_FIXED_INDEX, #24565 } return false; } const TYPED_ARRAYS = { Int8Array: Int8Array, Uint8Array: Uint8Array, Uint8ClampedArray: Uint8ClampedArray, Int16Array: Int16Array, Uint16Array: Uint16Array, Int32Array: Int32Array, Uint32Array: Uint32Array, Float32Array: Float32Array, Float64Array: Float64Array }; function getTypedArray( type, buffer ) { return new TYPED_ARRAYS[ type ]( buffer ); } function createElementNS( name ) { return document.createElementNS( 'http://www.w3.org/1999/xhtml', name ); } function createCanvasElement() { const canvas = createElementNS( 'canvas' ); canvas.style.display = 'block'; return canvas; } const _cache = {}; function warnOnce( message ) { if ( message in _cache ) return; _cache[ message ] = true; console.warn( message ); } /** * Matrices converting P3 Rec. 709 primaries, without gamut mapping * or clipping. Based on W3C specifications for sRGB and Display P3, * and ICC specifications for the D50 connection space. Values in/out * are _linear_ sRGB and _linear_ Display P3. * * Note that both sRGB and Display P3 use the sRGB transfer functions. * * Reference: * - http://www.russellcottrell.com/photo/matrixCalculator.htm */ const LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = /*@__PURE__*/ new Matrix3().set( 0.8224621, 0.177538, 0.0, 0.0331941, 0.9668058, 0.0, 0.0170827, 0.0723974, 0.9105199, ); const LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = /*@__PURE__*/ new Matrix3().set( 1.2249401, - 0.2249404, 0.0, - 0.0420569, 1.0420571, 0.0, - 0.0196376, - 0.0786361, 1.0982735 ); /** * Defines supported color spaces by transfer function and primaries, * and provides conversions to/from the Linear-sRGB reference space. */ const COLOR_SPACES = { [ LinearSRGBColorSpace ]: { transfer: LinearTransfer, primaries: Rec709Primaries, toReference: ( color ) => color, fromReference: ( color ) => color, }, [ SRGBColorSpace ]: { transfer: SRGBTransfer, primaries: Rec709Primaries, toReference: ( color ) => color.convertSRGBToLinear(), fromReference: ( color ) => color.convertLinearToSRGB(), }, [ LinearDisplayP3ColorSpace ]: { transfer: LinearTransfer, primaries: P3Primaries, toReference: ( color ) => color.applyMatrix3( LINEAR_DISPLAY_P3_TO_LINEAR_SRGB ), fromReference: ( color ) => color.applyMatrix3( LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 ), }, [ DisplayP3ColorSpace ]: { transfer: SRGBTransfer, primaries: P3Primaries, toReference: ( color ) => color.convertSRGBToLinear().applyMatrix3( LINEAR_DISPLAY_P3_TO_LINEAR_SRGB ), fromReference: ( color ) => color.applyMatrix3( LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 ).convertLinearToSRGB(), }, }; const SUPPORTED_WORKING_COLOR_SPACES = new Set( [ LinearSRGBColorSpace, LinearDisplayP3ColorSpace ] ); const ColorManagement = { enabled: true, _workingColorSpace: LinearSRGBColorSpace, get legacyMode() { console.warn( 'THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150.' ); return ! this.enabled; }, set legacyMode( legacyMode ) { console.warn( 'THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150.' ); this.enabled = ! legacyMode; }, get workingColorSpace() { return this._workingColorSpace; }, set workingColorSpace( colorSpace ) { if ( ! SUPPORTED_WORKING_COLOR_SPACES.has( colorSpace ) ) { throw new Error( `Unsupported working color space, \"${ colorSpace }\".` ); } this._workingColorSpace = colorSpace; }, convert: function ( color, sourceColorSpace, targetColorSpace ) { if ( this.enabled === false || sourceColorSpace === targetColorSpace || ! sourceColorSpace || ! targetColorSpace ) { return color; } const sourceToReference = COLOR_SPACES[ sourceColorSpace ].toReference; const targetFromReference = COLOR_SPACES[ targetColorSpace ].fromReference; return targetFromReference( sourceToReference( color ) ); }, fromWorkingColorSpace: function ( color, targetColorSpace ) { return this.convert( color, this._workingColorSpace, targetColorSpace ); }, toWorkingColorSpace: function ( color, sourceColorSpace ) { return this.convert( color, sourceColorSpace, this._workingColorSpace ); }, getPrimaries: function ( colorSpace ) { return COLOR_SPACES[ colorSpace ].primaries; }, getTransfer: function ( colorSpace ) { if ( colorSpace === NoColorSpace ) return LinearTransfer; return COLOR_SPACES[ colorSpace ].transfer; }, }; function SRGBToLinear( c ) { return ( c < 0.04045 ) ? c * 0.0773993808 : Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 ); } function LinearToSRGB( c ) { return ( c < 0.0031308 ) ? c * 12.92 : 1.055 * ( Math.pow( c, 0.41666 ) ) - 0.055; } let _canvas; class ImageUtils { static getDataURL( image ) { if ( /^data:/i.test( image.src ) ) { return image.src; } if ( typeof HTMLCanvasElement === 'undefined' ) { return image.src; } let canvas; if ( image instanceof HTMLCanvasElement ) { canvas = image; } else { if ( _canvas === undefined ) _canvas = createElementNS( 'canvas' ); _canvas.width = image.width; _canvas.height = image.height; const context = _canvas.getContext( '2d' ); if ( image instanceof ImageData ) { context.putImageData( image, 0, 0 ); } else { context.drawImage( image, 0, 0, image.width, image.height ); } canvas = _canvas; } if ( canvas.width > 2048 || canvas.height > 2048 ) { console.warn( 'THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons', image ); return canvas.toDataURL( 'image/jpeg', 0.6 ); } else { return canvas.toDataURL( 'image/png' ); } } static sRGBToLinear( image ) { if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) || ( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) || ( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) { const canvas = createElementNS( 'canvas' ); canvas.width = image.width; canvas.height = image.height; const context = canvas.getContext( '2d' ); context.drawImage( image, 0, 0, image.width, image.height ); const imageData = context.getImageData( 0, 0, image.width, image.height ); const data = imageData.data; for ( let i = 0; i < data.length; i ++ ) { data[ i ] = SRGBToLinear( data[ i ] / 255 ) * 255; } context.putImageData( imageData, 0, 0 ); return canvas; } else if ( image.data ) { const data = image.data.slice( 0 ); for ( let i = 0; i < data.length; i ++ ) { if ( data instanceof Uint8Array || data instanceof Uint8ClampedArray ) { data[ i ] = Math.floor( SRGBToLinear( data[ i ] / 255 ) * 255 ); } else { // assuming float data[ i ] = SRGBToLinear( data[ i ] ); } } return { data: data, width: image.width, height: image.height }; } else { console.warn( 'THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.' ); return image; } } } let _sourceId = 0; class Source { constructor( data = null ) { this.isSource = true; Object.defineProperty( this, 'id', { value: _sourceId ++ } ); this.uuid = generateUUID(); this.data = data; this.version = 0; } set needsUpdate( value ) { if ( value === true ) this.version ++; } toJSON( meta ) { const isRootObject = ( meta === undefined || typeof meta === 'string' ); if ( ! isRootObject && meta.images[ this.uuid ] !== undefined ) { return meta.images[ this.uuid ]; } const output = { uuid: this.uuid, url: '' }; const data = this.data; if ( data !== null ) { let url; if ( Array.isArray( data ) ) { // cube texture url = []; for ( let i = 0, l = data.length; i < l; i ++ ) { if ( data[ i ].isDataTexture ) { url.push( serializeImage( data[ i ].image ) ); } else { url.push( serializeImage( data[ i ] ) ); } } } else { // texture url = serializeImage( data ); } output.url = url; } if ( ! isRootObject ) { meta.images[ this.uuid ] = output; } return output; } } function serializeImage( image ) { if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) || ( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) || ( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) { // default images return ImageUtils.getDataURL( image ); } else { if ( image.data ) { // images of DataTexture return { data: Array.from( image.data ), width: image.width, height: image.height, type: image.data.constructor.name }; } else { console.warn( 'THREE.Texture: Unable to serialize Texture.' ); return {}; } } } let _textureId = 0; class Texture extends EventDispatcher { constructor( image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = Texture.DEFAULT_ANISOTROPY, colorSpace = NoColorSpace ) { super(); this.isTexture = true; Object.defineProperty( this, 'id', { value: _textureId ++ } ); this.uuid = generateUUID(); this.name = ''; this.source = new Source( image ); this.mipmaps = []; this.mapping = mapping; this.channel = 0; this.wrapS = wrapS; this.wrapT = wrapT; this.magFilter = magFilter; this.minFilter = minFilter; this.anisotropy = anisotropy; this.format = format; this.internalFormat = null; this.type = type; this.offset = new Vector2( 0, 0 ); this.repeat = new Vector2( 1, 1 ); this.center = new Vector2( 0, 0 ); this.rotation = 0; this.matrixAutoUpdate = true; this.matrix = new Matrix3(); this.generateMipmaps = true; this.premultiplyAlpha = false; this.flipY = true; this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml) if ( typeof colorSpace === 'string' ) { this.colorSpace = colorSpace; } else { // @deprecated, r152 warnOnce( 'THREE.Texture: Property .encoding has been replaced by .colorSpace.' ); this.colorSpace = colorSpace === sRGBEncoding ? SRGBColorSpace : NoColorSpace; } this.userData = {}; this.version = 0; this.onUpdate = null; this.isRenderTargetTexture = false; // indicates whether a texture belongs to a render target or not this.needsPMREMUpdate = false; // indicates whether this texture should be processed by PMREMGenerator or not (only relevant for render target textures) } get image() { return this.source.data; } set image( value = null ) { this.source.data = value; } updateMatrix() { this.matrix.setUvTransform( this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y ); } clone() { return new this.constructor().copy( this ); } copy( source ) { this.name = source.name; this.source = source.source; this.mipmaps = source.mipmaps.slice( 0 ); this.mapping = source.mapping; this.channel = source.channel; this.wrapS = source.wrapS; this.wrapT = source.wrapT; this.magFilter = source.magFilter; this.minFilter = source.minFilter; this.anisotropy = source.anisotropy; this.format = source.format; this.internalFormat = source.internalFormat; this.type = source.type; this.offset.copy( source.offset ); this.repeat.copy( source.repeat ); this.center.copy( source.center ); this.rotation = source.rotation; this.matrixAutoUpdate = source.matrixAutoUpdate; this.matrix.copy( source.matrix ); this.generateMipmaps = source.generateMipmaps; this.premultiplyAlpha = source.premultiplyAlpha; this.flipY = source.flipY; this.unpackAlignment = source.unpackAlignment; this.colorSpace = source.colorSpace; this.userData = JSON.parse( JSON.stringify( source.userData ) ); this.needsUpdate = true; return this; } toJSON( meta ) { const isRootObject = ( meta === undefined || typeof meta === 'string' ); if ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) { return meta.textures[ this.uuid ]; } const output = { metadata: { version: 4.6, type: 'Texture', generator: 'Texture.toJSON' }, uuid: this.uuid, name: this.name, image: this.source.toJSON( meta ).uuid, mapping: this.mapping, channel: this.channel, repeat: [ this.repeat.x, this.repeat.y ], offset: [ this.offset.x, this.offset.y ], center: [ this.center.x, this.center.y ], rotation: this.rotation, wrap: [ this.wrapS, this.wrapT ], format: this.format, internalFormat: this.internalFormat, type: this.type, colorSpace: this.colorSpace, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY, generateMipmaps: this.generateMipmaps, premultiplyAlpha: this.premultiplyAlpha, unpackAlignment: this.unpackAlignment }; if ( Object.keys( this.userData ).length > 0 ) output.userData = this.userData; if ( ! isRootObject ) { meta.textures[ this.uuid ] = output; } return output; } dispose() { this.dispatchEvent( { type: 'dispose' } ); } transformUv( uv ) { if ( this.mapping !== UVMapping ) return uv; uv.applyMatrix3( this.matrix ); if ( uv.x < 0 || uv.x > 1 ) { switch ( this.wrapS ) { case RepeatWrapping: uv.x = uv.x - Math.floor( uv.x ); break; case ClampToEdgeWrapping: uv.x = uv.x < 0 ? 0 : 1; break; case MirroredRepeatWrapping: if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) { uv.x = Math.ceil( uv.x ) - uv.x; } else { uv.x = uv.x - Math.floor( uv.x ); } break; } } if ( uv.y < 0 || uv.y > 1 ) { switch ( this.wrapT ) { case RepeatWrapping: uv.y = uv.y - Math.floor( uv.y ); break; case ClampToEdgeWrapping: uv.y = uv.y < 0 ? 0 : 1; break; case MirroredRepeatWrapping: if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) { uv.y = Math.ceil( uv.y ) - uv.y; } else { uv.y = uv.y - Math.floor( uv.y ); } break; } } if ( this.flipY ) { uv.y = 1 - uv.y; } return uv; } set needsUpdate( value ) { if ( value === true ) { this.version ++; this.source.needsUpdate = true; } } get encoding() { // @deprecated, r152 warnOnce( 'THREE.Texture: Property .encoding has been replaced by .colorSpace.' ); return this.colorSpace === SRGBColorSpace ? sRGBEncoding : LinearEncoding; } set encoding( encoding ) { // @deprecated, r152 warnOnce( 'THREE.Texture: Property .encoding has been replaced by .colorSpace.' ); this.colorSpace = encoding === sRGBEncoding ? SRGBColorSpace : NoColorSpace; } } Texture.DEFAULT_IMAGE = null; Texture.DEFAULT_MAPPING = UVMapping; Texture.DEFAULT_ANISOTROPY = 1; class Vector4 { constructor( x = 0, y = 0, z = 0, w = 1 ) { Vector4.prototype.isVector4 = true; this.x = x; this.y = y; this.z = z; this.w = w; } get width() { return this.z; } set width( value ) { this.z = value; } get height() { return this.w; } set height( value ) { this.w = value; } set( x, y, z, w ) { this.x = x; this.y = y; this.z = z; this.w = w; return this; } setScalar( scalar ) { this.x = scalar; this.y = scalar; this.z = scalar; this.w = scalar; return this; } setX( x ) { this.x = x; return this; } setY( y ) { this.y = y; return this; } setZ( z ) { this.z = z; return this; } setW( w ) { this.w = w; return this; } setComponent( index, value ) { switch ( index ) { case 0: this.x = value; break; case 1: this.y = value; break; case 2: this.z = value; break; case 3: this.w = value; break; default: throw new Error( 'index is out of range: ' + index ); } return this; } getComponent( index ) { switch ( index ) { case 0: return this.x; case 1: return this.y; case 2: return this.z; case 3: return this.w; default: throw new Error( 'index is out of range: ' + index ); } } clone() { return new this.constructor( this.x, this.y, this.z, this.w ); } copy( v ) { this.x = v.x; this.y = v.y; this.z = v.z; this.w = ( v.w !== undefined ) ? v.w : 1; return this; } add( v ) { this.x += v.x; this.y += v.y; this.z += v.z; this.w += v.w; return this; } addScalar( s ) { this.x += s; this.y += s; this.z += s; this.w += s; return this; } addVectors( a, b ) { this.x = a.x + b.x; this.y = a.y + b.y; this.z = a.z + b.z; this.w = a.w + b.w; return this; } addScaledVector( v, s ) { this.x += v.x * s; this.y += v.y * s; this.z += v.z * s; this.w += v.w * s; return this; } sub( v ) { this.x -= v.x; this.y -= v.y; this.z -= v.z; this.w -= v.w; return this; } subScalar( s ) { this.x -= s; this.y -= s; this.z -= s; this.w -= s; return this; } subVectors( a, b ) { this.x = a.x - b.x; this.y = a.y - b.y; this.z = a.z - b.z; this.w = a.w - b.w; return this; } multiply( v ) { this.x *= v.x; this.y *= v.y; this.z *= v.z; this.w *= v.w; return this; } multiplyScalar( scalar ) { this.x *= scalar; this.y *= scalar; this.z *= scalar; this.w *= scalar; return this; } applyMatrix4( m ) { const x = this.x, y = this.y, z = this.z, w = this.w; const e = m.elements; this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w; this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w; this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w; this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w; return this; } divideScalar( scalar ) { return this.multiplyScalar( 1 / scalar ); } setAxisAngleFromQuaternion( q ) { // http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm // q is assumed to be normalized this.w = 2 * Math.acos( q.w ); const s = Math.sqrt( 1 - q.w * q.w ); if ( s < 0.0001 ) { this.x = 1; this.y = 0; this.z = 0; } else { this.x = q.x / s; this.y = q.y / s; this.z = q.z / s; } return this; } setAxisAngleFromRotationMatrix( m ) { // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled) let angle, x, y, z; // variables for result const epsilon = 0.01, // margin to allow for rounding errors epsilon2 = 0.1, // margin to distinguish between 0 and 180 degrees te = m.elements, m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ], m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ], m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ]; if ( ( Math.abs( m12 - m21 ) < epsilon ) && ( Math.abs( m13 - m31 ) < epsilon ) && ( Math.abs( m23 - m32 ) < epsilon ) ) { // singularity found // first check for identity matrix which must have +1 for all terms // in leading diagonal and zero in other terms if ( ( Math.abs( m12 + m21 ) < epsilon2 ) && ( Math.abs( m13 + m31 ) < epsilon2 ) && ( Math.abs( m23 + m32 ) < epsilon2 ) && ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) { // this singularity is identity matrix so angle = 0 this.set( 1, 0, 0, 0 ); return this; // zero angle, arbitrary axis } // otherwise this singularity is angle = 180 angle = Math.PI; const xx = ( m11 + 1 ) / 2; const yy = ( m22 + 1 ) / 2; const zz = ( m33 + 1 ) / 2; const xy = ( m12 + m21 ) / 4; const xz = ( m13 + m31 ) / 4; const yz = ( m23 + m32 ) / 4; if ( ( xx > yy ) && ( xx > zz ) ) { // m11 is the largest diagonal term if ( xx < epsilon ) { x = 0; y = 0.707106781; z = 0.707106781; } else { x = Math.sqrt( xx ); y = xy / x; z = xz / x; } } else if ( yy > zz ) { // m22 is the largest diagonal term if ( yy < epsilon ) { x = 0.707106781; y = 0; z = 0.707106781; } else { y = Math.sqrt( yy ); x = xy / y; z = yz / y; } } else { // m33 is the largest diagonal term so base result on this if ( zz < epsilon ) { x = 0.707106781; y = 0.707106781; z = 0; } else { z = Math.sqrt( zz ); x = xz / z; y = yz / z; } } this.set( x, y, z, angle ); return this; // return 180 deg rotation } // as we have reached here there are no singularities so we can handle normally let s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) + ( m13 - m31 ) * ( m13 - m31 ) + ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize if ( Math.abs( s ) < 0.001 ) s = 1; // prevent divide by zero, should not happen if matrix is orthogonal and should be // caught by singularity test above, but I've left it in just in case this.x = ( m32 - m23 ) / s; this.y = ( m13 - m31 ) / s; this.z = ( m21 - m12 ) / s; this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 ); return this; } min( v ) { this.x = Math.min( this.x, v.x ); this.y = Math.min( this.y, v.y ); this.z = Math.min( this.z, v.z ); this.w = Math.min( this.w, v.w ); return this; } max( v ) { this.x = Math.max( this.x, v.x ); this.y = Math.max( this.y, v.y ); this.z = Math.max( this.z, v.z ); this.w = Math.max( this.w, v.w ); return this; } clamp( min, max ) { // assumes min < max, componentwise this.x = Math.max( min.x, Math.min( max.x, this.x ) ); this.y = Math.max( min.y, Math.min( max.y, this.y ) ); this.z = Math.max( min.z, Math.min( max.z, this.z ) ); this.w = Math.max( min.w, Math.min( max.w, this.w ) ); return this; } clampScalar( minVal, maxVal ) { this.x = Math.max( minVal, Math.min( maxVal, this.x ) ); this.y = Math.max( minVal, Math.min( maxVal, this.y ) ); this.z = Math.max( minVal, Math.min( maxVal, this.z ) ); this.w = Math.max( minVal, Math.min( maxVal, this.w ) ); return this; } clampLength( min, max ) { const length = this.length(); return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) ); } floor() { this.x = Math.floor( this.x ); this.y = Math.floor( this.y ); this.z = Math.floor( this.z ); this.w = Math.floor( this.w ); return this; } ceil() { this.x = Math.ceil( this.x ); this.y = Math.ceil( this.y ); this.z = Math.ceil( this.z ); this.w = Math.ceil( this.w ); return this; } round() { this.x = Math.round( this.x ); this.y = Math.round( this.y ); this.z = Math.round( this.z ); this.w = Math.round( this.w ); return this; } roundToZero() { this.x = Math.trunc( this.x ); this.y = Math.trunc( this.y ); this.z = Math.trunc( this.z ); this.w = Math.trunc( this.w ); return this; } negate() { this.x = - this.x; this.y = - this.y; this.z = - this.z; this.w = - this.w; return this; } dot( v ) { return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w; } lengthSq() { return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w; } length() { return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w ); } manhattanLength() { return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w ); } normalize() { return this.divideScalar( this.length() || 1 ); } setLength( length ) { return this.normalize().multiplyScalar( length ); } lerp( v, alpha ) { this.x += ( v.x - this.x ) * alpha; this.y += ( v.y - this.y ) * alpha; this.z += ( v.z - this.z ) * alpha; this.w += ( v.w - this.w ) * alpha; return this; } lerpVectors( v1, v2, alpha ) { this.x = v1.x + ( v2.x - v1.x ) * alpha; this.y = v1.y + ( v2.y - v1.y ) * alpha; this.z = v1.z + ( v2.z - v1.z ) * alpha; this.w = v1.w + ( v2.w - v1.w ) * alpha; return this; } equals( v ) { return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) ); } fromArray( array, offset = 0 ) { this.x = array[ offset ]; this.y = array[ offset + 1 ]; this.z = array[ offset + 2 ]; this.w = array[ offset + 3 ]; return this; } toArray( array = [], offset = 0 ) { array[ offset ] = this.x; array[ offset + 1 ] = this.y; array[ offset + 2 ] = this.z; array[ offset + 3 ] = this.w; return array; } fromBufferAttribute( attribute, index ) { this.x = attribute.getX( index ); this.y = attribute.getY( index ); this.z = attribute.getZ( index ); this.w = attribute.getW( index ); return this; } random() { this.x = Math.random(); this.y = Math.random(); this.z = Math.random(); this.w = Math.random(); return this; } *[ Symbol.iterator ]() { yield this.x; yield this.y; yield this.z; yield this.w; } } /* In options, we can specify: * Texture parameters for an auto-generated target texture * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers */ class RenderTarget extends EventDispatcher { constructor( width = 1, height = 1, options = {} ) { super(); this.isRenderTarget = true; this.width = width; this.height = height; this.depth = 1; this.scissor = new Vector4( 0, 0, width, height ); this.scissorTest = false; this.viewport = new Vector4( 0, 0, width, height ); const image = { width: width, height: height, depth: 1 }; if ( options.encoding !== undefined ) { // @deprecated, r152 warnOnce( 'THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace.' ); options.colorSpace = options.encoding === sRGBEncoding ? SRGBColorSpace : NoColorSpace; } options = Object.assign( { generateMipmaps: false, internalFormat: null, minFilter: LinearFilter, depthBuffer: true, stencilBuffer: false, depthTexture: null, samples: 0 }, options ); this.texture = new Texture( image, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.colorSpace ); this.texture.isRenderTargetTexture = true; this.texture.flipY = false; this.texture.generateMipmaps = options.generateMipmaps; this.texture.internalFormat = options.internalFormat; this.depthBuffer = options.depthBuffer; this.stencilBuffer = options.stencilBuffer; this.depthTexture = options.depthTexture; this.samples = options.samples; } setSize( width, height, depth = 1 ) { if ( this.width !== width || this.height !== height || this.depth !== depth ) { this.width = width; this.height = height; this.depth = depth; this.texture.image.width = width; this.texture.image.height = height; this.texture.image.depth = depth; this.dispose(); } this.viewport.set( 0, 0, width, height ); this.scissor.set( 0, 0, width, height ); } clone() { return new this.constructor().copy( this ); } copy( source ) { this.width = source.width; this.height = source.height; this.depth = source.depth; this.scissor.copy( source.scissor ); this.scissorTest = source.scissorTest; this.viewport.copy( source.viewport ); this.texture = source.texture.clone(); this.texture.isRenderTargetTexture = true; // ensure image object is not shared, see #20328 const image = Object.assign( {}, source.texture.image ); this.texture.source = new Source( image ); this.depthBuffer = source.depthBuffer; this.stencilBuffer = source.stencilBuffer; if ( source.depthTexture !== null ) this.depthTexture = source.depthTexture.clone(); this.samples = source.samples; return this; } dispose() { this.dispatchEvent( { type: 'dispose' } ); } } class WebGLRenderTarget extends RenderTarget { constructor( width = 1, height = 1, options = {} ) { super( width, height, options ); this.isWebGLRenderTarget = true; } } class DataArrayTexture extends Texture { constructor( data = null, width = 1, height = 1, depth = 1 ) { super( null ); this.isDataArrayTexture = true; this.image = { data, width, height, depth }; this.magFilter = NearestFilter; this.minFilter = NearestFilter; this.wrapR = ClampToEdgeWrapping; this.generateMipmaps = false; this.flipY = false; this.unpackAlignment = 1; } } class WebGLArrayRenderTarget extends WebGLRenderTarget { constructor( width = 1, height = 1, depth = 1 ) { super( width, height ); this.isWebGLArrayRenderTarget = true; this.depth = depth; this.texture = new DataArrayTexture( null, width, height, depth ); this.texture.isRenderTargetTexture = true; } } class Data3DTexture extends Texture { constructor( data = null, width = 1, height = 1, depth = 1 ) { // We're going to add .setXXX() methods for setting properties later. // Users can still set in DataTexture3D directly. // // const texture = new THREE.DataTexture3D( data, width, height, depth ); // texture.anisotropy = 16; // // See #14839 super( null ); this.isData3DTexture = true; this.image = { data, width, height, depth }; this.magFilter = NearestFilter; this.minFilter = NearestFilter; this.wrapR = ClampToEdgeWrapping; this.generateMipmaps = false; this.flipY = false; this.unpackAlignment = 1; } } class WebGL3DRenderTarget extends WebGLRenderTarget { constructor( width = 1, height = 1, depth = 1 ) { super( width, height ); this.isWebGL3DRenderTarget = true; this.depth = depth; this.texture = new Data3DTexture( null, width, height, depth ); this.texture.isRenderTargetTexture = true; } } class WebGLMultipleRenderTargets extends WebGLRenderTarget { constructor( width = 1, height = 1, count = 1, options = {} ) { super( width, height, options ); this.isWebGLMultipleRenderTargets = true; const texture = this.texture; this.texture = []; for ( let i = 0; i < count; i ++ ) { this.texture[ i ] = texture.clone(); this.texture[ i ].isRenderTargetTexture = true; } } setSize( width, height, depth = 1 ) { if ( this.width !== width || this.height !== height || this.depth !== depth ) { this.width = width; this.height = height; this.depth = depth; for ( let i = 0, il = this.texture.length; i < il; i ++ ) { this.texture[ i ].image.width = width; this.texture[ i ].image.height = height; this.texture[ i ].image.depth = depth; } this.dispose(); } this.viewport.set( 0, 0, width, height ); this.scissor.set( 0, 0, width, height ); } copy( source ) { this.dispose(); this.width = source.width; this.height = source.height; this.depth = source.depth; this.scissor.copy( source.scissor ); this.scissorTest = source.scissorTest; this.viewport.copy( source.viewport ); this.depthBuffer = source.depthBuffer; this.stencilBuffer = source.stencilBuffer; if ( source.depthTexture !== null ) this.depthTexture = source.depthTexture.clone(); this.texture.length = 0; for ( let i = 0, il = source.texture.length; i < il; i ++ ) { this.texture[ i ] = source.texture[ i ].clone(); this.texture[ i ].isRenderTargetTexture = true; } return this; } } class Quaternion { constructor( x = 0, y = 0, z = 0, w = 1 ) { this.isQuaternion = true; this._x = x; this._y = y; this._z = z; this._w = w; } static slerpFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) { // fuzz-free, array-based Quaternion SLERP operation let x0 = src0[ srcOffset0 + 0 ], y0 = src0[ srcOffset0 + 1 ], z0 = src0[ srcOffset0 + 2 ], w0 = src0[ srcOffset0 + 3 ]; const x1 = src1[ srcOffset1 + 0 ], y1 = src1[ srcOffset1 + 1 ], z1 = src1[ srcOffset1 + 2 ], w1 = src1[ srcOffset1 + 3 ]; if ( t === 0 ) { dst[ dstOffset + 0 ] = x0; dst[ dstOffset + 1 ] = y0; dst[ dstOffset + 2 ] = z0; dst[ dstOffset + 3 ] = w0; return; } if ( t === 1 ) { dst[ dstOffset + 0 ] = x1; dst[ dstOffset + 1 ] = y1; dst[ dstOffset + 2 ] = z1; dst[ dstOffset + 3 ] = w1; return; } if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) { let s = 1 - t; const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = ( cos >= 0 ? 1 : - 1 ), sqrSin = 1 - cos * cos; // Skip the Slerp for tiny steps to avoid numeric problems: if ( sqrSin > Number.EPSILON ) { const sin = Math.sqrt( sqrSin ), len = Math.atan2( sin, cos * dir ); s = Math.sin( s * len ) / sin; t = Math.sin( t * len ) / sin; } const tDir = t * dir; x0 = x0 * s + x1 * tDir; y0 = y0 * s + y1 * tDir; z0 = z0 * s + z1 * tDir; w0 = w0 * s + w1 * tDir; // Normalize in case we just did a lerp: if ( s === 1 - t ) { const f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 ); x0 *= f; y0 *= f; z0 *= f; w0 *= f; } } dst[ dstOffset ] = x0; dst[ dstOffset + 1 ] = y0; dst[ dstOffset + 2 ] = z0; dst[ dstOffset + 3 ] = w0; } static multiplyQuaternionsFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1 ) { const x0 = src0[ srcOffset0 ]; const y0 = src0[ srcOffset0 + 1 ]; const z0 = src0[ srcOffset0 + 2 ]; const w0 = src0[ srcOffset0 + 3 ]; const x1 = src1[ srcOffset1 ]; const y1 = src1[ srcOffset1 + 1 ]; const z1 = src1[ srcOffset1 + 2 ]; const w1 = src1[ srcOffset1 + 3 ]; dst[ dstOffset ] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1; dst[ dstOffset + 1 ] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1; dst[ dstOffset + 2 ] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1; dst[ dstOffset + 3 ] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1; return dst; } get x() { return this._x; } set x( value ) { this._x = value; this._onChangeCallback(); } get y() { return this._y; } set y( value ) { this._y = value; this._onChangeCallback(); } get z() { return this._z; } set z( value ) { this._z = value; this._onChangeCallback(); } get w() { return this._w; } set w( value ) { this._w = value; this._onChangeCallback(); } set( x, y, z, w ) { this._x = x; this._y = y; this._z = z; this._w = w; this._onChangeCallback(); return this; } clone() { return new this.constructor( this._x, this._y, this._z, this._w ); } copy( quaternion ) { this._x = quaternion.x; this._y = quaternion.y; this._z = quaternion.z; this._w = quaternion.w; this._onChangeCallback(); return this; } setFromEuler( euler, update ) { const x = euler._x, y = euler._y, z = euler._z, order = euler._order; // http://www.mathworks.com/matlabcentral/fileexchange/ // 20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/ // content/SpinCalc.m const cos = Math.cos; const sin = Math.sin; const c1 = cos( x / 2 ); const c2 = cos( y / 2 ); const c3 = cos( z / 2 ); const s1 = sin( x / 2 ); const s2 = sin( y / 2 ); const s3 = sin( z / 2 ); switch ( order ) { case 'XYZ': this._x = s1 * c2 * c3 + c1 * s2 * s3; this._y = c1 * s2 * c3 - s1 * c2 * s3; this._z = c1 * c2 * s3 + s1 * s2 * c3; this._w = c1 * c2 * c3 - s1 * s2 * s3; break; case 'YXZ': this._x = s1 * c2 * c3 + c1 * s2 * s3; this._y = c1 * s2 * c3 - s1 * c2 * s3; this._z = c1 * c2 * s3 - s1 * s2 * c3; this._w = c1 * c2 * c3 + s1 * s2 * s3; break; case 'ZXY': this._x = s1 * c2 * c3 - c1 * s2 * s3; this._y = c1 * s2 * c3 + s1 * c2 * s3; this._z = c1 * c2 * s3 + s1 * s2 * c3; this._w = c1 * c2 * c3 - s1 * s2 * s3; break; case 'ZYX': this._x = s1 * c2 * c3 - c1 * s2 * s3; this._y = c1 * s2 * c3 + s1 * c2 * s3; this._z = c1 * c2 * s3 - s1 * s2 * c3; this._w = c1 * c2 * c3 + s1 * s2 * s3; break; case 'YZX': this._x = s1 * c2 * c3 + c1 * s2 * s3; this._y = c1 * s2 * c3 + s1 * c2 * s3; this._z = c1 * c2 * s3 - s1 * s2 * c3; this._w = c1 * c2 * c3 - s1 * s2 * s3; break; case 'XZY': this._x = s1 * c2 * c3 - c1 * s2 * s3; this._y = c1 * s2 * c3 - s1 * c2 * s3; this._z = c1 * c2 * s3 + s1 * s2 * c3; this._w = c1 * c2 * c3 + s1 * s2 * s3; break; default: console.warn( 'THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order ); } if ( update !== false ) this._onChangeCallback(); return this; } setFromAxisAngle( axis, angle ) { // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm // assumes axis is normalized const halfAngle = angle / 2, s = Math.sin( halfAngle ); this._x = axis.x * s; this._y = axis.y * s; this._z = axis.z * s; this._w = Math.cos( halfAngle ); this._onChangeCallback(); return this; } setFromRotationMatrix( m ) { // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled) const te = m.elements, m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ], m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ], m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ], trace = m11 + m22 + m33; if ( trace > 0 ) { const s = 0.5 / Math.sqrt( trace + 1.0 ); this._w = 0.25 / s; this._x = ( m32 - m23 ) * s; this._y = ( m13 - m31 ) * s; this._z = ( m21 - m12 ) * s; } else if ( m11 > m22 && m11 > m33 ) { const s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 ); this._w = ( m32 - m23 ) / s; this._x = 0.25 * s; this._y = ( m12 + m21 ) / s; this._z = ( m13 + m31 ) / s; } else if ( m22 > m33 ) { const s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 ); this._w = ( m13 - m31 ) / s; this._x = ( m12 + m21 ) / s; this._y = 0.25 * s; this._z = ( m23 + m32 ) / s; } else { const s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 ); this._w = ( m21 - m12 ) / s; this._x = ( m13 + m31 ) / s; this._y = ( m23 + m32 ) / s; this._z = 0.25 * s; } this._onChangeCallback(); return this; } setFromUnitVectors( vFrom, vTo ) { // assumes direction vectors vFrom and vTo are normalized let r = vFrom.dot( vTo ) + 1; if ( r < Number.EPSILON ) { // vFrom and vTo point in opposite directions r = 0; if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) { this._x = - vFrom.y; this._y = vFrom.x; this._z = 0; this._w = r; } else { this._x = 0; this._y = - vFrom.z; this._z = vFrom.y; this._w = r; } } else { // crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3 this._x = vFrom.y * vTo.z - vFrom.z * vTo.y; this._y = vFrom.z * vTo.x - vFrom.x * vTo.z; this._z = vFrom.x * vTo.y - vFrom.y * vTo.x; this._w = r; } return this.normalize(); } angleTo( q ) { return 2 * Math.acos( Math.abs( clamp( this.dot( q ), - 1, 1 ) ) ); } rotateTowards( q, step ) { const angle = this.angleTo( q ); if ( angle === 0 ) return this; const t = Math.min( 1, step / angle ); this.slerp( q, t ); return this; } identity() { return this.set( 0, 0, 0, 1 ); } invert() { // quaternion is assumed to have unit length return this.conjugate(); } conjugate() { this._x *= - 1; this._y *= - 1; this._z *= - 1; this._onChangeCallback(); return this; } dot( v ) { return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w; } lengthSq() { return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w; } length() { return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w ); } normalize() { let l = this.length(); if ( l === 0 ) { this._x = 0; this._y = 0; this._z = 0; this._w = 1; } else { l = 1 / l; this._x = this._x * l; this._y = this._y * l; this._z = this._z * l; this._w = this._w * l; } this._onChangeCallback(); return this; } multiply( q ) { return this.multiplyQuaternions( this, q ); } premultiply( q ) { return this.multiplyQuaternions( q, this ); } multiplyQuaternions( a, b ) { // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w; const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w; this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby; this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz; this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx; this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz; this._onChangeCallback(); return this; } slerp( qb, t ) { if ( t === 0 ) return this; if ( t === 1 ) return this.copy( qb ); const x = this._x, y = this._y, z = this._z, w = this._w; // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/ let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z; if ( cosHalfTheta < 0 ) { this._w = - qb._w; this._x = - qb._x; this._y = - qb._y; this._z = - qb._z; cosHalfTheta = - cosHalfTheta; } else { this.copy( qb ); } if ( cosHalfTheta >= 1.0 ) { this._w = w; this._x = x; this._y = y; this._z = z; return this; } const sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta; if ( sqrSinHalfTheta"},{"title":"","date":"2023-10-12T14:08:39.212Z","updated":"2023-10-12T14:08:39.212Z","comments":true,"path":"js/three/build/three.module.js","permalink":"http://19999997.xyz/js/three/build/three.module.js","excerpt":"","text":"/** * @license * Copyright 2010-2023 Three.js Authors * SPDX-License-Identifier: MIT */ const REVISION = '157'; const MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 }; const TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }; const CullFaceNone = 0; const CullFaceBack = 1; const CullFaceFront = 2; const CullFaceFrontBack = 3; const BasicShadowMap = 0; const PCFShadowMap = 1; const PCFSoftShadowMap = 2; const VSMShadowMap = 3; const FrontSide = 0; const BackSide = 1; const DoubleSide = 2; const TwoPassDoubleSide = 2; // r149 const NoBlending = 0; const NormalBlending = 1; const AdditiveBlending = 2; const SubtractiveBlending = 3; const MultiplyBlending = 4; const CustomBlending = 5; const AddEquation = 100; const SubtractEquation = 101; const ReverseSubtractEquation = 102; const MinEquation = 103; const MaxEquation = 104; const ZeroFactor = 200; const OneFactor = 201; const SrcColorFactor = 202; const OneMinusSrcColorFactor = 203; const SrcAlphaFactor = 204; const OneMinusSrcAlphaFactor = 205; const DstAlphaFactor = 206; const OneMinusDstAlphaFactor = 207; const DstColorFactor = 208; const OneMinusDstColorFactor = 209; const SrcAlphaSaturateFactor = 210; const NeverDepth = 0; const AlwaysDepth = 1; const LessDepth = 2; const LessEqualDepth = 3; const EqualDepth = 4; const GreaterEqualDepth = 5; const GreaterDepth = 6; const NotEqualDepth = 7; const MultiplyOperation = 0; const MixOperation = 1; const AddOperation = 2; const NoToneMapping = 0; const LinearToneMapping = 1; const ReinhardToneMapping = 2; const CineonToneMapping = 3; const ACESFilmicToneMapping = 4; const CustomToneMapping = 5; const UVMapping = 300; const CubeReflectionMapping = 301; const CubeRefractionMapping = 302; const EquirectangularReflectionMapping = 303; const EquirectangularRefractionMapping = 304; const CubeUVReflectionMapping = 306; const RepeatWrapping = 1000; const ClampToEdgeWrapping = 1001; const MirroredRepeatWrapping = 1002; const NearestFilter = 1003; const NearestMipmapNearestFilter = 1004; const NearestMipMapNearestFilter = 1004; const NearestMipmapLinearFilter = 1005; const NearestMipMapLinearFilter = 1005; const LinearFilter = 1006; const LinearMipmapNearestFilter = 1007; const LinearMipMapNearestFilter = 1007; const LinearMipmapLinearFilter = 1008; const LinearMipMapLinearFilter = 1008; const UnsignedByteType = 1009; const ByteType = 1010; const ShortType = 1011; const UnsignedShortType = 1012; const IntType = 1013; const UnsignedIntType = 1014; const FloatType = 1015; const HalfFloatType = 1016; const UnsignedShort4444Type = 1017; const UnsignedShort5551Type = 1018; const UnsignedInt248Type = 1020; const AlphaFormat = 1021; const RGBAFormat = 1023; const LuminanceFormat = 1024; const LuminanceAlphaFormat = 1025; const DepthFormat = 1026; const DepthStencilFormat = 1027; const RedFormat = 1028; const RedIntegerFormat = 1029; const RGFormat = 1030; const RGIntegerFormat = 1031; const RGBAIntegerFormat = 1033; const RGB_S3TC_DXT1_Format = 33776; const RGBA_S3TC_DXT1_Format = 33777; const RGBA_S3TC_DXT3_Format = 33778; const RGBA_S3TC_DXT5_Format = 33779; const RGB_PVRTC_4BPPV1_Format = 35840; const RGB_PVRTC_2BPPV1_Format = 35841; const RGBA_PVRTC_4BPPV1_Format = 35842; const RGBA_PVRTC_2BPPV1_Format = 35843; const RGB_ETC1_Format = 36196; const RGB_ETC2_Format = 37492; const RGBA_ETC2_EAC_Format = 37496; const RGBA_ASTC_4x4_Format = 37808; const RGBA_ASTC_5x4_Format = 37809; const RGBA_ASTC_5x5_Format = 37810; const RGBA_ASTC_6x5_Format = 37811; const RGBA_ASTC_6x6_Format = 37812; const RGBA_ASTC_8x5_Format = 37813; const RGBA_ASTC_8x6_Format = 37814; const RGBA_ASTC_8x8_Format = 37815; const RGBA_ASTC_10x5_Format = 37816; const RGBA_ASTC_10x6_Format = 37817; const RGBA_ASTC_10x8_Format = 37818; const RGBA_ASTC_10x10_Format = 37819; const RGBA_ASTC_12x10_Format = 37820; const RGBA_ASTC_12x12_Format = 37821; const RGBA_BPTC_Format = 36492; const RGB_BPTC_SIGNED_Format = 36494; const RGB_BPTC_UNSIGNED_Format = 36495; const RED_RGTC1_Format = 36283; const SIGNED_RED_RGTC1_Format = 36284; const RED_GREEN_RGTC2_Format = 36285; const SIGNED_RED_GREEN_RGTC2_Format = 36286; const LoopOnce = 2200; const LoopRepeat = 2201; const LoopPingPong = 2202; const InterpolateDiscrete = 2300; const InterpolateLinear = 2301; const InterpolateSmooth = 2302; const ZeroCurvatureEnding = 2400; const ZeroSlopeEnding = 2401; const WrapAroundEnding = 2402; const NormalAnimationBlendMode = 2500; const AdditiveAnimationBlendMode = 2501; const TrianglesDrawMode = 0; const TriangleStripDrawMode = 1; const TriangleFanDrawMode = 2; /** @deprecated Use LinearSRGBColorSpace or NoColorSpace in three.js r152+. */ const LinearEncoding = 3000; /** @deprecated Use SRGBColorSpace in three.js r152+. */ const sRGBEncoding = 3001; const BasicDepthPacking = 3200; const RGBADepthPacking = 3201; const TangentSpaceNormalMap = 0; const ObjectSpaceNormalMap = 1; // Color space string identifiers, matching CSS Color Module Level 4 and WebGPU names where available. const NoColorSpace = ''; const SRGBColorSpace = 'srgb'; const LinearSRGBColorSpace = 'srgb-linear'; const DisplayP3ColorSpace = 'display-p3'; const LinearDisplayP3ColorSpace = 'display-p3-linear'; const LinearTransfer = 'linear'; const SRGBTransfer = 'srgb'; const Rec709Primaries = 'rec709'; const P3Primaries = 'p3'; const ZeroStencilOp = 0; const KeepStencilOp = 7680; const ReplaceStencilOp = 7681; const IncrementStencilOp = 7682; const DecrementStencilOp = 7683; const IncrementWrapStencilOp = 34055; const DecrementWrapStencilOp = 34056; const InvertStencilOp = 5386; const NeverStencilFunc = 512; const LessStencilFunc = 513; const EqualStencilFunc = 514; const LessEqualStencilFunc = 515; const GreaterStencilFunc = 516; const NotEqualStencilFunc = 517; const GreaterEqualStencilFunc = 518; const AlwaysStencilFunc = 519; const NeverCompare = 512; const LessCompare = 513; const EqualCompare = 514; const LessEqualCompare = 515; const GreaterCompare = 516; const NotEqualCompare = 517; const GreaterEqualCompare = 518; const AlwaysCompare = 519; const StaticDrawUsage = 35044; const DynamicDrawUsage = 35048; const StreamDrawUsage = 35040; const StaticReadUsage = 35045; const DynamicReadUsage = 35049; const StreamReadUsage = 35041; const StaticCopyUsage = 35046; const DynamicCopyUsage = 35050; const StreamCopyUsage = 35042; const GLSL1 = '100'; const GLSL3 = '300 es'; const _SRGBAFormat = 1035; // fallback for WebGL 1 const WebGLCoordinateSystem = 2000; const WebGPUCoordinateSystem = 2001; /** * https://github.com/mrdoob/eventdispatcher.js/ */ class EventDispatcher { addEventListener( type, listener ) { if ( this._listeners === undefined ) this._listeners = {}; const listeners = this._listeners; if ( listeners[ type ] === undefined ) { listeners[ type ] = []; } if ( listeners[ type ].indexOf( listener ) === - 1 ) { listeners[ type ].push( listener ); } } hasEventListener( type, listener ) { if ( this._listeners === undefined ) return false; const listeners = this._listeners; return listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1; } removeEventListener( type, listener ) { if ( this._listeners === undefined ) return; const listeners = this._listeners; const listenerArray = listeners[ type ]; if ( listenerArray !== undefined ) { const index = listenerArray.indexOf( listener ); if ( index !== - 1 ) { listenerArray.splice( index, 1 ); } } } dispatchEvent( event ) { if ( this._listeners === undefined ) return; const listeners = this._listeners; const listenerArray = listeners[ event.type ]; if ( listenerArray !== undefined ) { event.target = this; // Make a copy, in case listeners are removed while iterating. const array = listenerArray.slice( 0 ); for ( let i = 0, l = array.length; i < l; i ++ ) { array[ i ].call( this, event ); } event.target = null; } } } const _lut = [ '00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '0a', '0b', '0c', '0d', '0e', '0f', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '1a', '1b', '1c', '1d', '1e', '1f', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '2a', '2b', '2c', '2d', '2e', '2f', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '3a', '3b', '3c', '3d', '3e', '3f', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '4a', '4b', '4c', '4d', '4e', '4f', '50', '51', '52', '53', '54', '55', '56', '57', '58', '59', '5a', '5b', '5c', '5d', '5e', '5f', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '6a', '6b', '6c', '6d', '6e', '6f', '70', '71', '72', '73', '74', '75', '76', '77', '78', '79', '7a', '7b', '7c', '7d', '7e', '7f', '80', '81', '82', '83', '84', '85', '86', '87', '88', '89', '8a', '8b', '8c', '8d', '8e', '8f', '90', '91', '92', '93', '94', '95', '96', '97', '98', '99', '9a', '9b', '9c', '9d', '9e', '9f', 'a0', 'a1', 'a2', 'a3', 'a4', 'a5', 'a6', 'a7', 'a8', 'a9', 'aa', 'ab', 'ac', 'ad', 'ae', 'af', 'b0', 'b1', 'b2', 'b3', 'b4', 'b5', 'b6', 'b7', 'b8', 'b9', 'ba', 'bb', 'bc', 'bd', 'be', 'bf', 'c0', 'c1', 'c2', 'c3', 'c4', 'c5', 'c6', 'c7', 'c8', 'c9', 'ca', 'cb', 'cc', 'cd', 'ce', 'cf', 'd0', 'd1', 'd2', 'd3', 'd4', 'd5', 'd6', 'd7', 'd8', 'd9', 'da', 'db', 'dc', 'dd', 'de', 'df', 'e0', 'e1', 'e2', 'e3', 'e4', 'e5', 'e6', 'e7', 'e8', 'e9', 'ea', 'eb', 'ec', 'ed', 'ee', 'ef', 'f0', 'f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'fa', 'fb', 'fc', 'fd', 'fe', 'ff' ]; let _seed = 1234567; const DEG2RAD = Math.PI / 180; const RAD2DEG = 180 / Math.PI; // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136 function generateUUID() { const d0 = Math.random() * 0xffffffff | 0; const d1 = Math.random() * 0xffffffff | 0; const d2 = Math.random() * 0xffffffff | 0; const d3 = Math.random() * 0xffffffff | 0; const uuid = _lut[ d0 & 0xff ] + _lut[ d0 >> 8 & 0xff ] + _lut[ d0 >> 16 & 0xff ] + _lut[ d0 >> 24 & 0xff ] + '-' + _lut[ d1 & 0xff ] + _lut[ d1 >> 8 & 0xff ] + '-' + _lut[ d1 >> 16 & 0x0f | 0x40 ] + _lut[ d1 >> 24 & 0xff ] + '-' + _lut[ d2 & 0x3f | 0x80 ] + _lut[ d2 >> 8 & 0xff ] + '-' + _lut[ d2 >> 16 & 0xff ] + _lut[ d2 >> 24 & 0xff ] + _lut[ d3 & 0xff ] + _lut[ d3 >> 8 & 0xff ] + _lut[ d3 >> 16 & 0xff ] + _lut[ d3 >> 24 & 0xff ]; // .toLowerCase() here flattens concatenated strings to save heap memory space. return uuid.toLowerCase(); } function clamp( value, min, max ) { return Math.max( min, Math.min( max, value ) ); } // compute euclidean modulo of m % n // https://en.wikipedia.org/wiki/Modulo_operation function euclideanModulo( n, m ) { return ( ( n % m ) + m ) % m; } // Linear mapping from range to range function mapLinear( x, a1, a2, b1, b2 ) { return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 ); } // https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/ function inverseLerp( x, y, value ) { if ( x !== y ) { return ( value - x ) / ( y - x ); } else { return 0; } } // https://en.wikipedia.org/wiki/Linear_interpolation function lerp( x, y, t ) { return ( 1 - t ) * x + t * y; } // http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/ function damp( x, y, lambda, dt ) { return lerp( x, y, 1 - Math.exp( - lambda * dt ) ); } // https://www.desmos.com/calculator/vcsjnyz7x4 function pingpong( x, length = 1 ) { return length - Math.abs( euclideanModulo( x, length * 2 ) - length ); } // http://en.wikipedia.org/wiki/Smoothstep function smoothstep( x, min, max ) { if ( x = max ) return 1; x = ( x - min ) / ( max - min ); return x * x * ( 3 - 2 * x ); } function smootherstep( x, min, max ) { if ( x = max ) return 1; x = ( x - min ) / ( max - min ); return x * x * x * ( x * ( x * 6 - 15 ) + 10 ); } // Random integer from interval function randInt( low, high ) { return low + Math.floor( Math.random() * ( high - low + 1 ) ); } // Random float from interval function randFloat( low, high ) { return low + Math.random() * ( high - low ); } // Random float from interval function randFloatSpread( range ) { return range * ( 0.5 - Math.random() ); } // Deterministic pseudo-random float in the interval [ 0, 1 ] function seededRandom( s ) { if ( s !== undefined ) _seed = s; // Mulberry32 generator let t = _seed += 0x6D2B79F5; t = Math.imul( t ^ t >>> 15, t | 1 ); t ^= t + Math.imul( t ^ t >>> 7, t | 61 ); return ( ( t ^ t >>> 14 ) >>> 0 ) / 4294967296; } function degToRad( degrees ) { return degrees * DEG2RAD; } function radToDeg( radians ) { return radians * RAD2DEG; } function isPowerOfTwo( value ) { return ( value & ( value - 1 ) ) === 0 && value !== 0; } function ceilPowerOfTwo( value ) { return Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) ); } function floorPowerOfTwo( value ) { return Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) ); } function setQuaternionFromProperEuler( q, a, b, c, order ) { // Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles // rotations are applied to the axes in the order specified by 'order' // rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c' // angles are in radians const cos = Math.cos; const sin = Math.sin; const c2 = cos( b / 2 ); const s2 = sin( b / 2 ); const c13 = cos( ( a + c ) / 2 ); const s13 = sin( ( a + c ) / 2 ); const c1_3 = cos( ( a - c ) / 2 ); const s1_3 = sin( ( a - c ) / 2 ); const c3_1 = cos( ( c - a ) / 2 ); const s3_1 = sin( ( c - a ) / 2 ); switch ( order ) { case 'XYX': q.set( c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13 ); break; case 'YZY': q.set( s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13 ); break; case 'ZXZ': q.set( s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13 ); break; case 'XZX': q.set( c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13 ); break; case 'YXY': q.set( s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13 ); break; case 'ZYZ': q.set( s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13 ); break; default: console.warn( 'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order ); } } function denormalize( value, array ) { switch ( array.constructor ) { case Float32Array: return value; case Uint32Array: return value / 4294967295.0; case Uint16Array: return value / 65535.0; case Uint8Array: return value / 255.0; case Int32Array: return Math.max( value / 2147483647.0, - 1.0 ); case Int16Array: return Math.max( value / 32767.0, - 1.0 ); case Int8Array: return Math.max( value / 127.0, - 1.0 ); default: throw new Error( 'Invalid component type.' ); } } function normalize( value, array ) { switch ( array.constructor ) { case Float32Array: return value; case Uint32Array: return Math.round( value * 4294967295.0 ); case Uint16Array: return Math.round( value * 65535.0 ); case Uint8Array: return Math.round( value * 255.0 ); case Int32Array: return Math.round( value * 2147483647.0 ); case Int16Array: return Math.round( value * 32767.0 ); case Int8Array: return Math.round( value * 127.0 ); default: throw new Error( 'Invalid component type.' ); } } const MathUtils = { DEG2RAD: DEG2RAD, RAD2DEG: RAD2DEG, generateUUID: generateUUID, clamp: clamp, euclideanModulo: euclideanModulo, mapLinear: mapLinear, inverseLerp: inverseLerp, lerp: lerp, damp: damp, pingpong: pingpong, smoothstep: smoothstep, smootherstep: smootherstep, randInt: randInt, randFloat: randFloat, randFloatSpread: randFloatSpread, seededRandom: seededRandom, degToRad: degToRad, radToDeg: radToDeg, isPowerOfTwo: isPowerOfTwo, ceilPowerOfTwo: ceilPowerOfTwo, floorPowerOfTwo: floorPowerOfTwo, setQuaternionFromProperEuler: setQuaternionFromProperEuler, normalize: normalize, denormalize: denormalize }; class Vector2 { constructor( x = 0, y = 0 ) { Vector2.prototype.isVector2 = true; this.x = x; this.y = y; } get width() { return this.x; } set width( value ) { this.x = value; } get height() { return this.y; } set height( value ) { this.y = value; } set( x, y ) { this.x = x; this.y = y; return this; } setScalar( scalar ) { this.x = scalar; this.y = scalar; return this; } setX( x ) { this.x = x; return this; } setY( y ) { this.y = y; return this; } setComponent( index, value ) { switch ( index ) { case 0: this.x = value; break; case 1: this.y = value; break; default: throw new Error( 'index is out of range: ' + index ); } return this; } getComponent( index ) { switch ( index ) { case 0: return this.x; case 1: return this.y; default: throw new Error( 'index is out of range: ' + index ); } } clone() { return new this.constructor( this.x, this.y ); } copy( v ) { this.x = v.x; this.y = v.y; return this; } add( v ) { this.x += v.x; this.y += v.y; return this; } addScalar( s ) { this.x += s; this.y += s; return this; } addVectors( a, b ) { this.x = a.x + b.x; this.y = a.y + b.y; return this; } addScaledVector( v, s ) { this.x += v.x * s; this.y += v.y * s; return this; } sub( v ) { this.x -= v.x; this.y -= v.y; return this; } subScalar( s ) { this.x -= s; this.y -= s; return this; } subVectors( a, b ) { this.x = a.x - b.x; this.y = a.y - b.y; return this; } multiply( v ) { this.x *= v.x; this.y *= v.y; return this; } multiplyScalar( scalar ) { this.x *= scalar; this.y *= scalar; return this; } divide( v ) { this.x /= v.x; this.y /= v.y; return this; } divideScalar( scalar ) { return this.multiplyScalar( 1 / scalar ); } applyMatrix3( m ) { const x = this.x, y = this.y; const e = m.elements; this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ]; this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ]; return this; } min( v ) { this.x = Math.min( this.x, v.x ); this.y = Math.min( this.y, v.y ); return this; } max( v ) { this.x = Math.max( this.x, v.x ); this.y = Math.max( this.y, v.y ); return this; } clamp( min, max ) { // assumes min < max, componentwise this.x = Math.max( min.x, Math.min( max.x, this.x ) ); this.y = Math.max( min.y, Math.min( max.y, this.y ) ); return this; } clampScalar( minVal, maxVal ) { this.x = Math.max( minVal, Math.min( maxVal, this.x ) ); this.y = Math.max( minVal, Math.min( maxVal, this.y ) ); return this; } clampLength( min, max ) { const length = this.length(); return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) ); } floor() { this.x = Math.floor( this.x ); this.y = Math.floor( this.y ); return this; } ceil() { this.x = Math.ceil( this.x ); this.y = Math.ceil( this.y ); return this; } round() { this.x = Math.round( this.x ); this.y = Math.round( this.y ); return this; } roundToZero() { this.x = Math.trunc( this.x ); this.y = Math.trunc( this.y ); return this; } negate() { this.x = - this.x; this.y = - this.y; return this; } dot( v ) { return this.x * v.x + this.y * v.y; } cross( v ) { return this.x * v.y - this.y * v.x; } lengthSq() { return this.x * this.x + this.y * this.y; } length() { return Math.sqrt( this.x * this.x + this.y * this.y ); } manhattanLength() { return Math.abs( this.x ) + Math.abs( this.y ); } normalize() { return this.divideScalar( this.length() || 1 ); } angle() { // computes the angle in radians with respect to the positive x-axis const angle = Math.atan2( - this.y, - this.x ) + Math.PI; return angle; } angleTo( v ) { const denominator = Math.sqrt( this.lengthSq() * v.lengthSq() ); if ( denominator === 0 ) return Math.PI / 2; const theta = this.dot( v ) / denominator; // clamp, to handle numerical problems return Math.acos( clamp( theta, - 1, 1 ) ); } distanceTo( v ) { return Math.sqrt( this.distanceToSquared( v ) ); } distanceToSquared( v ) { const dx = this.x - v.x, dy = this.y - v.y; return dx * dx + dy * dy; } manhattanDistanceTo( v ) { return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ); } setLength( length ) { return this.normalize().multiplyScalar( length ); } lerp( v, alpha ) { this.x += ( v.x - this.x ) * alpha; this.y += ( v.y - this.y ) * alpha; return this; } lerpVectors( v1, v2, alpha ) { this.x = v1.x + ( v2.x - v1.x ) * alpha; this.y = v1.y + ( v2.y - v1.y ) * alpha; return this; } equals( v ) { return ( ( v.x === this.x ) && ( v.y === this.y ) ); } fromArray( array, offset = 0 ) { this.x = array[ offset ]; this.y = array[ offset + 1 ]; return this; } toArray( array = [], offset = 0 ) { array[ offset ] = this.x; array[ offset + 1 ] = this.y; return array; } fromBufferAttribute( attribute, index ) { this.x = attribute.getX( index ); this.y = attribute.getY( index ); return this; } rotateAround( center, angle ) { const c = Math.cos( angle ), s = Math.sin( angle ); const x = this.x - center.x; const y = this.y - center.y; this.x = x * c - y * s + center.x; this.y = x * s + y * c + center.y; return this; } random() { this.x = Math.random(); this.y = Math.random(); return this; } *[ Symbol.iterator ]() { yield this.x; yield this.y; } } class Matrix3 { constructor( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) { Matrix3.prototype.isMatrix3 = true; this.elements = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ]; if ( n11 !== undefined ) { this.set( n11, n12, n13, n21, n22, n23, n31, n32, n33 ); } } set( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) { const te = this.elements; te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31; te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32; te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33; return this; } identity() { this.set( 1, 0, 0, 0, 1, 0, 0, 0, 1 ); return this; } copy( m ) { const te = this.elements; const me = m.elements; te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ]; return this; } extractBasis( xAxis, yAxis, zAxis ) { xAxis.setFromMatrix3Column( this, 0 ); yAxis.setFromMatrix3Column( this, 1 ); zAxis.setFromMatrix3Column( this, 2 ); return this; } setFromMatrix4( m ) { const me = m.elements; this.set( me[ 0 ], me[ 4 ], me[ 8 ], me[ 1 ], me[ 5 ], me[ 9 ], me[ 2 ], me[ 6 ], me[ 10 ] ); return this; } multiply( m ) { return this.multiplyMatrices( this, m ); } premultiply( m ) { return this.multiplyMatrices( m, this ); } multiplyMatrices( a, b ) { const ae = a.elements; const be = b.elements; const te = this.elements; const a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ]; const a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ]; const a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ]; const b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ]; const b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ]; const b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ]; te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31; te[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32; te[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33; te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31; te[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32; te[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33; te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31; te[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32; te[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33; return this; } multiplyScalar( s ) { const te = this.elements; te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s; te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s; te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s; return this; } determinant() { const te = this.elements; const a = te[ 0 ], b = te[ 1 ], c = te[ 2 ], d = te[ 3 ], e = te[ 4 ], f = te[ 5 ], g = te[ 6 ], h = te[ 7 ], i = te[ 8 ]; return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g; } invert() { const te = this.elements, n11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ], n12 = te[ 3 ], n22 = te[ 4 ], n32 = te[ 5 ], n13 = te[ 6 ], n23 = te[ 7 ], n33 = te[ 8 ], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13; if ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0 ); const detInv = 1 / det; te[ 0 ] = t11 * detInv; te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv; te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv; te[ 3 ] = t12 * detInv; te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv; te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv; te[ 6 ] = t13 * detInv; te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv; te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv; return this; } transpose() { let tmp; const m = this.elements; tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp; tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp; tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp; return this; } getNormalMatrix( matrix4 ) { return this.setFromMatrix4( matrix4 ).invert().transpose(); } transposeIntoArray( r ) { const m = this.elements; r[ 0 ] = m[ 0 ]; r[ 1 ] = m[ 3 ]; r[ 2 ] = m[ 6 ]; r[ 3 ] = m[ 1 ]; r[ 4 ] = m[ 4 ]; r[ 5 ] = m[ 7 ]; r[ 6 ] = m[ 2 ]; r[ 7 ] = m[ 5 ]; r[ 8 ] = m[ 8 ]; return this; } setUvTransform( tx, ty, sx, sy, rotation, cx, cy ) { const c = Math.cos( rotation ); const s = Math.sin( rotation ); this.set( sx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx, - sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty, 0, 0, 1 ); return this; } // scale( sx, sy ) { this.premultiply( _m3.makeScale( sx, sy ) ); return this; } rotate( theta ) { this.premultiply( _m3.makeRotation( - theta ) ); return this; } translate( tx, ty ) { this.premultiply( _m3.makeTranslation( tx, ty ) ); return this; } // for 2D Transforms makeTranslation( x, y ) { if ( x.isVector2 ) { this.set( 1, 0, x.x, 0, 1, x.y, 0, 0, 1 ); } else { this.set( 1, 0, x, 0, 1, y, 0, 0, 1 ); } return this; } makeRotation( theta ) { // counterclockwise const c = Math.cos( theta ); const s = Math.sin( theta ); this.set( c, - s, 0, s, c, 0, 0, 0, 1 ); return this; } makeScale( x, y ) { this.set( x, 0, 0, 0, y, 0, 0, 0, 1 ); return this; } // equals( matrix ) { const te = this.elements; const me = matrix.elements; for ( let i = 0; i < 9; i ++ ) { if ( te[ i ] !== me[ i ] ) return false; } return true; } fromArray( array, offset = 0 ) { for ( let i = 0; i < 9; i ++ ) { this.elements[ i ] = array[ i + offset ]; } return this; } toArray( array = [], offset = 0 ) { const te = this.elements; array[ offset ] = te[ 0 ]; array[ offset + 1 ] = te[ 1 ]; array[ offset + 2 ] = te[ 2 ]; array[ offset + 3 ] = te[ 3 ]; array[ offset + 4 ] = te[ 4 ]; array[ offset + 5 ] = te[ 5 ]; array[ offset + 6 ] = te[ 6 ]; array[ offset + 7 ] = te[ 7 ]; array[ offset + 8 ] = te[ 8 ]; return array; } clone() { return new this.constructor().fromArray( this.elements ); } } const _m3 = /*@__PURE__*/ new Matrix3(); function arrayNeedsUint32( array ) { // assumes larger values usually on last for ( let i = array.length - 1; i >= 0; -- i ) { if ( array[ i ] >= 65535 ) return true; // account for PRIMITIVE_RESTART_FIXED_INDEX, #24565 } return false; } const TYPED_ARRAYS = { Int8Array: Int8Array, Uint8Array: Uint8Array, Uint8ClampedArray: Uint8ClampedArray, Int16Array: Int16Array, Uint16Array: Uint16Array, Int32Array: Int32Array, Uint32Array: Uint32Array, Float32Array: Float32Array, Float64Array: Float64Array }; function getTypedArray( type, buffer ) { return new TYPED_ARRAYS[ type ]( buffer ); } function createElementNS( name ) { return document.createElementNS( 'http://www.w3.org/1999/xhtml', name ); } function createCanvasElement() { const canvas = createElementNS( 'canvas' ); canvas.style.display = 'block'; return canvas; } const _cache = {}; function warnOnce( message ) { if ( message in _cache ) return; _cache[ message ] = true; console.warn( message ); } /** * Matrices converting P3 Rec. 709 primaries, without gamut mapping * or clipping. Based on W3C specifications for sRGB and Display P3, * and ICC specifications for the D50 connection space. Values in/out * are _linear_ sRGB and _linear_ Display P3. * * Note that both sRGB and Display P3 use the sRGB transfer functions. * * Reference: * - http://www.russellcottrell.com/photo/matrixCalculator.htm */ const LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = /*@__PURE__*/ new Matrix3().set( 0.8224621, 0.177538, 0.0, 0.0331941, 0.9668058, 0.0, 0.0170827, 0.0723974, 0.9105199, ); const LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = /*@__PURE__*/ new Matrix3().set( 1.2249401, - 0.2249404, 0.0, - 0.0420569, 1.0420571, 0.0, - 0.0196376, - 0.0786361, 1.0982735 ); /** * Defines supported color spaces by transfer function and primaries, * and provides conversions to/from the Linear-sRGB reference space. */ const COLOR_SPACES = { [ LinearSRGBColorSpace ]: { transfer: LinearTransfer, primaries: Rec709Primaries, toReference: ( color ) => color, fromReference: ( color ) => color, }, [ SRGBColorSpace ]: { transfer: SRGBTransfer, primaries: Rec709Primaries, toReference: ( color ) => color.convertSRGBToLinear(), fromReference: ( color ) => color.convertLinearToSRGB(), }, [ LinearDisplayP3ColorSpace ]: { transfer: LinearTransfer, primaries: P3Primaries, toReference: ( color ) => color.applyMatrix3( LINEAR_DISPLAY_P3_TO_LINEAR_SRGB ), fromReference: ( color ) => color.applyMatrix3( LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 ), }, [ DisplayP3ColorSpace ]: { transfer: SRGBTransfer, primaries: P3Primaries, toReference: ( color ) => color.convertSRGBToLinear().applyMatrix3( LINEAR_DISPLAY_P3_TO_LINEAR_SRGB ), fromReference: ( color ) => color.applyMatrix3( LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 ).convertLinearToSRGB(), }, }; const SUPPORTED_WORKING_COLOR_SPACES = new Set( [ LinearSRGBColorSpace, LinearDisplayP3ColorSpace ] ); const ColorManagement = { enabled: true, _workingColorSpace: LinearSRGBColorSpace, get legacyMode() { console.warn( 'THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150.' ); return ! this.enabled; }, set legacyMode( legacyMode ) { console.warn( 'THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150.' ); this.enabled = ! legacyMode; }, get workingColorSpace() { return this._workingColorSpace; }, set workingColorSpace( colorSpace ) { if ( ! SUPPORTED_WORKING_COLOR_SPACES.has( colorSpace ) ) { throw new Error( `Unsupported working color space, \"${ colorSpace }\".` ); } this._workingColorSpace = colorSpace; }, convert: function ( color, sourceColorSpace, targetColorSpace ) { if ( this.enabled === false || sourceColorSpace === targetColorSpace || ! sourceColorSpace || ! targetColorSpace ) { return color; } const sourceToReference = COLOR_SPACES[ sourceColorSpace ].toReference; const targetFromReference = COLOR_SPACES[ targetColorSpace ].fromReference; return targetFromReference( sourceToReference( color ) ); }, fromWorkingColorSpace: function ( color, targetColorSpace ) { return this.convert( color, this._workingColorSpace, targetColorSpace ); }, toWorkingColorSpace: function ( color, sourceColorSpace ) { return this.convert( color, sourceColorSpace, this._workingColorSpace ); }, getPrimaries: function ( colorSpace ) { return COLOR_SPACES[ colorSpace ].primaries; }, getTransfer: function ( colorSpace ) { if ( colorSpace === NoColorSpace ) return LinearTransfer; return COLOR_SPACES[ colorSpace ].transfer; }, }; function SRGBToLinear( c ) { return ( c < 0.04045 ) ? c * 0.0773993808 : Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 ); } function LinearToSRGB( c ) { return ( c < 0.0031308 ) ? c * 12.92 : 1.055 * ( Math.pow( c, 0.41666 ) ) - 0.055; } let _canvas; class ImageUtils { static getDataURL( image ) { if ( /^data:/i.test( image.src ) ) { return image.src; } if ( typeof HTMLCanvasElement === 'undefined' ) { return image.src; } let canvas; if ( image instanceof HTMLCanvasElement ) { canvas = image; } else { if ( _canvas === undefined ) _canvas = createElementNS( 'canvas' ); _canvas.width = image.width; _canvas.height = image.height; const context = _canvas.getContext( '2d' ); if ( image instanceof ImageData ) { context.putImageData( image, 0, 0 ); } else { context.drawImage( image, 0, 0, image.width, image.height ); } canvas = _canvas; } if ( canvas.width > 2048 || canvas.height > 2048 ) { console.warn( 'THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons', image ); return canvas.toDataURL( 'image/jpeg', 0.6 ); } else { return canvas.toDataURL( 'image/png' ); } } static sRGBToLinear( image ) { if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) || ( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) || ( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) { const canvas = createElementNS( 'canvas' ); canvas.width = image.width; canvas.height = image.height; const context = canvas.getContext( '2d' ); context.drawImage( image, 0, 0, image.width, image.height ); const imageData = context.getImageData( 0, 0, image.width, image.height ); const data = imageData.data; for ( let i = 0; i < data.length; i ++ ) { data[ i ] = SRGBToLinear( data[ i ] / 255 ) * 255; } context.putImageData( imageData, 0, 0 ); return canvas; } else if ( image.data ) { const data = image.data.slice( 0 ); for ( let i = 0; i < data.length; i ++ ) { if ( data instanceof Uint8Array || data instanceof Uint8ClampedArray ) { data[ i ] = Math.floor( SRGBToLinear( data[ i ] / 255 ) * 255 ); } else { // assuming float data[ i ] = SRGBToLinear( data[ i ] ); } } return { data: data, width: image.width, height: image.height }; } else { console.warn( 'THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.' ); return image; } } } let _sourceId = 0; class Source { constructor( data = null ) { this.isSource = true; Object.defineProperty( this, 'id', { value: _sourceId ++ } ); this.uuid = generateUUID(); this.data = data; this.version = 0; } set needsUpdate( value ) { if ( value === true ) this.version ++; } toJSON( meta ) { const isRootObject = ( meta === undefined || typeof meta === 'string' ); if ( ! isRootObject && meta.images[ this.uuid ] !== undefined ) { return meta.images[ this.uuid ]; } const output = { uuid: this.uuid, url: '' }; const data = this.data; if ( data !== null ) { let url; if ( Array.isArray( data ) ) { // cube texture url = []; for ( let i = 0, l = data.length; i < l; i ++ ) { if ( data[ i ].isDataTexture ) { url.push( serializeImage( data[ i ].image ) ); } else { url.push( serializeImage( data[ i ] ) ); } } } else { // texture url = serializeImage( data ); } output.url = url; } if ( ! isRootObject ) { meta.images[ this.uuid ] = output; } return output; } } function serializeImage( image ) { if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) || ( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) || ( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) { // default images return ImageUtils.getDataURL( image ); } else { if ( image.data ) { // images of DataTexture return { data: Array.from( image.data ), width: image.width, height: image.height, type: image.data.constructor.name }; } else { console.warn( 'THREE.Texture: Unable to serialize Texture.' ); return {}; } } } let _textureId = 0; class Texture extends EventDispatcher { constructor( image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = Texture.DEFAULT_ANISOTROPY, colorSpace = NoColorSpace ) { super(); this.isTexture = true; Object.defineProperty( this, 'id', { value: _textureId ++ } ); this.uuid = generateUUID(); this.name = ''; this.source = new Source( image ); this.mipmaps = []; this.mapping = mapping; this.channel = 0; this.wrapS = wrapS; this.wrapT = wrapT; this.magFilter = magFilter; this.minFilter = minFilter; this.anisotropy = anisotropy; this.format = format; this.internalFormat = null; this.type = type; this.offset = new Vector2( 0, 0 ); this.repeat = new Vector2( 1, 1 ); this.center = new Vector2( 0, 0 ); this.rotation = 0; this.matrixAutoUpdate = true; this.matrix = new Matrix3(); this.generateMipmaps = true; this.premultiplyAlpha = false; this.flipY = true; this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml) if ( typeof colorSpace === 'string' ) { this.colorSpace = colorSpace; } else { // @deprecated, r152 warnOnce( 'THREE.Texture: Property .encoding has been replaced by .colorSpace.' ); this.colorSpace = colorSpace === sRGBEncoding ? SRGBColorSpace : NoColorSpace; } this.userData = {}; this.version = 0; this.onUpdate = null; this.isRenderTargetTexture = false; // indicates whether a texture belongs to a render target or not this.needsPMREMUpdate = false; // indicates whether this texture should be processed by PMREMGenerator or not (only relevant for render target textures) } get image() { return this.source.data; } set image( value = null ) { this.source.data = value; } updateMatrix() { this.matrix.setUvTransform( this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y ); } clone() { return new this.constructor().copy( this ); } copy( source ) { this.name = source.name; this.source = source.source; this.mipmaps = source.mipmaps.slice( 0 ); this.mapping = source.mapping; this.channel = source.channel; this.wrapS = source.wrapS; this.wrapT = source.wrapT; this.magFilter = source.magFilter; this.minFilter = source.minFilter; this.anisotropy = source.anisotropy; this.format = source.format; this.internalFormat = source.internalFormat; this.type = source.type; this.offset.copy( source.offset ); this.repeat.copy( source.repeat ); this.center.copy( source.center ); this.rotation = source.rotation; this.matrixAutoUpdate = source.matrixAutoUpdate; this.matrix.copy( source.matrix ); this.generateMipmaps = source.generateMipmaps; this.premultiplyAlpha = source.premultiplyAlpha; this.flipY = source.flipY; this.unpackAlignment = source.unpackAlignment; this.colorSpace = source.colorSpace; this.userData = JSON.parse( JSON.stringify( source.userData ) ); this.needsUpdate = true; return this; } toJSON( meta ) { const isRootObject = ( meta === undefined || typeof meta === 'string' ); if ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) { return meta.textures[ this.uuid ]; } const output = { metadata: { version: 4.6, type: 'Texture', generator: 'Texture.toJSON' }, uuid: this.uuid, name: this.name, image: this.source.toJSON( meta ).uuid, mapping: this.mapping, channel: this.channel, repeat: [ this.repeat.x, this.repeat.y ], offset: [ this.offset.x, this.offset.y ], center: [ this.center.x, this.center.y ], rotation: this.rotation, wrap: [ this.wrapS, this.wrapT ], format: this.format, internalFormat: this.internalFormat, type: this.type, colorSpace: this.colorSpace, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY, generateMipmaps: this.generateMipmaps, premultiplyAlpha: this.premultiplyAlpha, unpackAlignment: this.unpackAlignment }; if ( Object.keys( this.userData ).length > 0 ) output.userData = this.userData; if ( ! isRootObject ) { meta.textures[ this.uuid ] = output; } return output; } dispose() { this.dispatchEvent( { type: 'dispose' } ); } transformUv( uv ) { if ( this.mapping !== UVMapping ) return uv; uv.applyMatrix3( this.matrix ); if ( uv.x < 0 || uv.x > 1 ) { switch ( this.wrapS ) { case RepeatWrapping: uv.x = uv.x - Math.floor( uv.x ); break; case ClampToEdgeWrapping: uv.x = uv.x < 0 ? 0 : 1; break; case MirroredRepeatWrapping: if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) { uv.x = Math.ceil( uv.x ) - uv.x; } else { uv.x = uv.x - Math.floor( uv.x ); } break; } } if ( uv.y < 0 || uv.y > 1 ) { switch ( this.wrapT ) { case RepeatWrapping: uv.y = uv.y - Math.floor( uv.y ); break; case ClampToEdgeWrapping: uv.y = uv.y < 0 ? 0 : 1; break; case MirroredRepeatWrapping: if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) { uv.y = Math.ceil( uv.y ) - uv.y; } else { uv.y = uv.y - Math.floor( uv.y ); } break; } } if ( this.flipY ) { uv.y = 1 - uv.y; } return uv; } set needsUpdate( value ) { if ( value === true ) { this.version ++; this.source.needsUpdate = true; } } get encoding() { // @deprecated, r152 warnOnce( 'THREE.Texture: Property .encoding has been replaced by .colorSpace.' ); return this.colorSpace === SRGBColorSpace ? sRGBEncoding : LinearEncoding; } set encoding( encoding ) { // @deprecated, r152 warnOnce( 'THREE.Texture: Property .encoding has been replaced by .colorSpace.' ); this.colorSpace = encoding === sRGBEncoding ? SRGBColorSpace : NoColorSpace; } } Texture.DEFAULT_IMAGE = null; Texture.DEFAULT_MAPPING = UVMapping; Texture.DEFAULT_ANISOTROPY = 1; class Vector4 { constructor( x = 0, y = 0, z = 0, w = 1 ) { Vector4.prototype.isVector4 = true; this.x = x; this.y = y; this.z = z; this.w = w; } get width() { return this.z; } set width( value ) { this.z = value; } get height() { return this.w; } set height( value ) { this.w = value; } set( x, y, z, w ) { this.x = x; this.y = y; this.z = z; this.w = w; return this; } setScalar( scalar ) { this.x = scalar; this.y = scalar; this.z = scalar; this.w = scalar; return this; } setX( x ) { this.x = x; return this; } setY( y ) { this.y = y; return this; } setZ( z ) { this.z = z; return this; } setW( w ) { this.w = w; return this; } setComponent( index, value ) { switch ( index ) { case 0: this.x = value; break; case 1: this.y = value; break; case 2: this.z = value; break; case 3: this.w = value; break; default: throw new Error( 'index is out of range: ' + index ); } return this; } getComponent( index ) { switch ( index ) { case 0: return this.x; case 1: return this.y; case 2: return this.z; case 3: return this.w; default: throw new Error( 'index is out of range: ' + index ); } } clone() { return new this.constructor( this.x, this.y, this.z, this.w ); } copy( v ) { this.x = v.x; this.y = v.y; this.z = v.z; this.w = ( v.w !== undefined ) ? v.w : 1; return this; } add( v ) { this.x += v.x; this.y += v.y; this.z += v.z; this.w += v.w; return this; } addScalar( s ) { this.x += s; this.y += s; this.z += s; this.w += s; return this; } addVectors( a, b ) { this.x = a.x + b.x; this.y = a.y + b.y; this.z = a.z + b.z; this.w = a.w + b.w; return this; } addScaledVector( v, s ) { this.x += v.x * s; this.y += v.y * s; this.z += v.z * s; this.w += v.w * s; return this; } sub( v ) { this.x -= v.x; this.y -= v.y; this.z -= v.z; this.w -= v.w; return this; } subScalar( s ) { this.x -= s; this.y -= s; this.z -= s; this.w -= s; return this; } subVectors( a, b ) { this.x = a.x - b.x; this.y = a.y - b.y; this.z = a.z - b.z; this.w = a.w - b.w; return this; } multiply( v ) { this.x *= v.x; this.y *= v.y; this.z *= v.z; this.w *= v.w; return this; } multiplyScalar( scalar ) { this.x *= scalar; this.y *= scalar; this.z *= scalar; this.w *= scalar; return this; } applyMatrix4( m ) { const x = this.x, y = this.y, z = this.z, w = this.w; const e = m.elements; this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w; this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w; this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w; this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w; return this; } divideScalar( scalar ) { return this.multiplyScalar( 1 / scalar ); } setAxisAngleFromQuaternion( q ) { // http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm // q is assumed to be normalized this.w = 2 * Math.acos( q.w ); const s = Math.sqrt( 1 - q.w * q.w ); if ( s < 0.0001 ) { this.x = 1; this.y = 0; this.z = 0; } else { this.x = q.x / s; this.y = q.y / s; this.z = q.z / s; } return this; } setAxisAngleFromRotationMatrix( m ) { // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled) let angle, x, y, z; // variables for result const epsilon = 0.01, // margin to allow for rounding errors epsilon2 = 0.1, // margin to distinguish between 0 and 180 degrees te = m.elements, m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ], m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ], m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ]; if ( ( Math.abs( m12 - m21 ) < epsilon ) && ( Math.abs( m13 - m31 ) < epsilon ) && ( Math.abs( m23 - m32 ) < epsilon ) ) { // singularity found // first check for identity matrix which must have +1 for all terms // in leading diagonal and zero in other terms if ( ( Math.abs( m12 + m21 ) < epsilon2 ) && ( Math.abs( m13 + m31 ) < epsilon2 ) && ( Math.abs( m23 + m32 ) < epsilon2 ) && ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) { // this singularity is identity matrix so angle = 0 this.set( 1, 0, 0, 0 ); return this; // zero angle, arbitrary axis } // otherwise this singularity is angle = 180 angle = Math.PI; const xx = ( m11 + 1 ) / 2; const yy = ( m22 + 1 ) / 2; const zz = ( m33 + 1 ) / 2; const xy = ( m12 + m21 ) / 4; const xz = ( m13 + m31 ) / 4; const yz = ( m23 + m32 ) / 4; if ( ( xx > yy ) && ( xx > zz ) ) { // m11 is the largest diagonal term if ( xx < epsilon ) { x = 0; y = 0.707106781; z = 0.707106781; } else { x = Math.sqrt( xx ); y = xy / x; z = xz / x; } } else if ( yy > zz ) { // m22 is the largest diagonal term if ( yy < epsilon ) { x = 0.707106781; y = 0; z = 0.707106781; } else { y = Math.sqrt( yy ); x = xy / y; z = yz / y; } } else { // m33 is the largest diagonal term so base result on this if ( zz < epsilon ) { x = 0.707106781; y = 0.707106781; z = 0; } else { z = Math.sqrt( zz ); x = xz / z; y = yz / z; } } this.set( x, y, z, angle ); return this; // return 180 deg rotation } // as we have reached here there are no singularities so we can handle normally let s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) + ( m13 - m31 ) * ( m13 - m31 ) + ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize if ( Math.abs( s ) < 0.001 ) s = 1; // prevent divide by zero, should not happen if matrix is orthogonal and should be // caught by singularity test above, but I've left it in just in case this.x = ( m32 - m23 ) / s; this.y = ( m13 - m31 ) / s; this.z = ( m21 - m12 ) / s; this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 ); return this; } min( v ) { this.x = Math.min( this.x, v.x ); this.y = Math.min( this.y, v.y ); this.z = Math.min( this.z, v.z ); this.w = Math.min( this.w, v.w ); return this; } max( v ) { this.x = Math.max( this.x, v.x ); this.y = Math.max( this.y, v.y ); this.z = Math.max( this.z, v.z ); this.w = Math.max( this.w, v.w ); return this; } clamp( min, max ) { // assumes min < max, componentwise this.x = Math.max( min.x, Math.min( max.x, this.x ) ); this.y = Math.max( min.y, Math.min( max.y, this.y ) ); this.z = Math.max( min.z, Math.min( max.z, this.z ) ); this.w = Math.max( min.w, Math.min( max.w, this.w ) ); return this; } clampScalar( minVal, maxVal ) { this.x = Math.max( minVal, Math.min( maxVal, this.x ) ); this.y = Math.max( minVal, Math.min( maxVal, this.y ) ); this.z = Math.max( minVal, Math.min( maxVal, this.z ) ); this.w = Math.max( minVal, Math.min( maxVal, this.w ) ); return this; } clampLength( min, max ) { const length = this.length(); return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) ); } floor() { this.x = Math.floor( this.x ); this.y = Math.floor( this.y ); this.z = Math.floor( this.z ); this.w = Math.floor( this.w ); return this; } ceil() { this.x = Math.ceil( this.x ); this.y = Math.ceil( this.y ); this.z = Math.ceil( this.z ); this.w = Math.ceil( this.w ); return this; } round() { this.x = Math.round( this.x ); this.y = Math.round( this.y ); this.z = Math.round( this.z ); this.w = Math.round( this.w ); return this; } roundToZero() { this.x = Math.trunc( this.x ); this.y = Math.trunc( this.y ); this.z = Math.trunc( this.z ); this.w = Math.trunc( this.w ); return this; } negate() { this.x = - this.x; this.y = - this.y; this.z = - this.z; this.w = - this.w; return this; } dot( v ) { return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w; } lengthSq() { return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w; } length() { return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w ); } manhattanLength() { return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w ); } normalize() { return this.divideScalar( this.length() || 1 ); } setLength( length ) { return this.normalize().multiplyScalar( length ); } lerp( v, alpha ) { this.x += ( v.x - this.x ) * alpha; this.y += ( v.y - this.y ) * alpha; this.z += ( v.z - this.z ) * alpha; this.w += ( v.w - this.w ) * alpha; return this; } lerpVectors( v1, v2, alpha ) { this.x = v1.x + ( v2.x - v1.x ) * alpha; this.y = v1.y + ( v2.y - v1.y ) * alpha; this.z = v1.z + ( v2.z - v1.z ) * alpha; this.w = v1.w + ( v2.w - v1.w ) * alpha; return this; } equals( v ) { return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) ); } fromArray( array, offset = 0 ) { this.x = array[ offset ]; this.y = array[ offset + 1 ]; this.z = array[ offset + 2 ]; this.w = array[ offset + 3 ]; return this; } toArray( array = [], offset = 0 ) { array[ offset ] = this.x; array[ offset + 1 ] = this.y; array[ offset + 2 ] = this.z; array[ offset + 3 ] = this.w; return array; } fromBufferAttribute( attribute, index ) { this.x = attribute.getX( index ); this.y = attribute.getY( index ); this.z = attribute.getZ( index ); this.w = attribute.getW( index ); return this; } random() { this.x = Math.random(); this.y = Math.random(); this.z = Math.random(); this.w = Math.random(); return this; } *[ Symbol.iterator ]() { yield this.x; yield this.y; yield this.z; yield this.w; } } /* In options, we can specify: * Texture parameters for an auto-generated target texture * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers */ class RenderTarget extends EventDispatcher { constructor( width = 1, height = 1, options = {} ) { super(); this.isRenderTarget = true; this.width = width; this.height = height; this.depth = 1; this.scissor = new Vector4( 0, 0, width, height ); this.scissorTest = false; this.viewport = new Vector4( 0, 0, width, height ); const image = { width: width, height: height, depth: 1 }; if ( options.encoding !== undefined ) { // @deprecated, r152 warnOnce( 'THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace.' ); options.colorSpace = options.encoding === sRGBEncoding ? SRGBColorSpace : NoColorSpace; } options = Object.assign( { generateMipmaps: false, internalFormat: null, minFilter: LinearFilter, depthBuffer: true, stencilBuffer: false, depthTexture: null, samples: 0 }, options ); this.texture = new Texture( image, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.colorSpace ); this.texture.isRenderTargetTexture = true; this.texture.flipY = false; this.texture.generateMipmaps = options.generateMipmaps; this.texture.internalFormat = options.internalFormat; this.depthBuffer = options.depthBuffer; this.stencilBuffer = options.stencilBuffer; this.depthTexture = options.depthTexture; this.samples = options.samples; } setSize( width, height, depth = 1 ) { if ( this.width !== width || this.height !== height || this.depth !== depth ) { this.width = width; this.height = height; this.depth = depth; this.texture.image.width = width; this.texture.image.height = height; this.texture.image.depth = depth; this.dispose(); } this.viewport.set( 0, 0, width, height ); this.scissor.set( 0, 0, width, height ); } clone() { return new this.constructor().copy( this ); } copy( source ) { this.width = source.width; this.height = source.height; this.depth = source.depth; this.scissor.copy( source.scissor ); this.scissorTest = source.scissorTest; this.viewport.copy( source.viewport ); this.texture = source.texture.clone(); this.texture.isRenderTargetTexture = true; // ensure image object is not shared, see #20328 const image = Object.assign( {}, source.texture.image ); this.texture.source = new Source( image ); this.depthBuffer = source.depthBuffer; this.stencilBuffer = source.stencilBuffer; if ( source.depthTexture !== null ) this.depthTexture = source.depthTexture.clone(); this.samples = source.samples; return this; } dispose() { this.dispatchEvent( { type: 'dispose' } ); } } class WebGLRenderTarget extends RenderTarget { constructor( width = 1, height = 1, options = {} ) { super( width, height, options ); this.isWebGLRenderTarget = true; } } class DataArrayTexture extends Texture { constructor( data = null, width = 1, height = 1, depth = 1 ) { super( null ); this.isDataArrayTexture = true; this.image = { data, width, height, depth }; this.magFilter = NearestFilter; this.minFilter = NearestFilter; this.wrapR = ClampToEdgeWrapping; this.generateMipmaps = false; this.flipY = false; this.unpackAlignment = 1; } } class WebGLArrayRenderTarget extends WebGLRenderTarget { constructor( width = 1, height = 1, depth = 1 ) { super( width, height ); this.isWebGLArrayRenderTarget = true; this.depth = depth; this.texture = new DataArrayTexture( null, width, height, depth ); this.texture.isRenderTargetTexture = true; } } class Data3DTexture extends Texture { constructor( data = null, width = 1, height = 1, depth = 1 ) { // We're going to add .setXXX() methods for setting properties later. // Users can still set in DataTexture3D directly. // // const texture = new THREE.DataTexture3D( data, width, height, depth ); // texture.anisotropy = 16; // // See #14839 super( null ); this.isData3DTexture = true; this.image = { data, width, height, depth }; this.magFilter = NearestFilter; this.minFilter = NearestFilter; this.wrapR = ClampToEdgeWrapping; this.generateMipmaps = false; this.flipY = false; this.unpackAlignment = 1; } } class WebGL3DRenderTarget extends WebGLRenderTarget { constructor( width = 1, height = 1, depth = 1 ) { super( width, height ); this.isWebGL3DRenderTarget = true; this.depth = depth; this.texture = new Data3DTexture( null, width, height, depth ); this.texture.isRenderTargetTexture = true; } } class WebGLMultipleRenderTargets extends WebGLRenderTarget { constructor( width = 1, height = 1, count = 1, options = {} ) { super( width, height, options ); this.isWebGLMultipleRenderTargets = true; const texture = this.texture; this.texture = []; for ( let i = 0; i < count; i ++ ) { this.texture[ i ] = texture.clone(); this.texture[ i ].isRenderTargetTexture = true; } } setSize( width, height, depth = 1 ) { if ( this.width !== width || this.height !== height || this.depth !== depth ) { this.width = width; this.height = height; this.depth = depth; for ( let i = 0, il = this.texture.length; i < il; i ++ ) { this.texture[ i ].image.width = width; this.texture[ i ].image.height = height; this.texture[ i ].image.depth = depth; } this.dispose(); } this.viewport.set( 0, 0, width, height ); this.scissor.set( 0, 0, width, height ); } copy( source ) { this.dispose(); this.width = source.width; this.height = source.height; this.depth = source.depth; this.scissor.copy( source.scissor ); this.scissorTest = source.scissorTest; this.viewport.copy( source.viewport ); this.depthBuffer = source.depthBuffer; this.stencilBuffer = source.stencilBuffer; if ( source.depthTexture !== null ) this.depthTexture = source.depthTexture.clone(); this.texture.length = 0; for ( let i = 0, il = source.texture.length; i < il; i ++ ) { this.texture[ i ] = source.texture[ i ].clone(); this.texture[ i ].isRenderTargetTexture = true; } return this; } } class Quaternion { constructor( x = 0, y = 0, z = 0, w = 1 ) { this.isQuaternion = true; this._x = x; this._y = y; this._z = z; this._w = w; } static slerpFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) { // fuzz-free, array-based Quaternion SLERP operation let x0 = src0[ srcOffset0 + 0 ], y0 = src0[ srcOffset0 + 1 ], z0 = src0[ srcOffset0 + 2 ], w0 = src0[ srcOffset0 + 3 ]; const x1 = src1[ srcOffset1 + 0 ], y1 = src1[ srcOffset1 + 1 ], z1 = src1[ srcOffset1 + 2 ], w1 = src1[ srcOffset1 + 3 ]; if ( t === 0 ) { dst[ dstOffset + 0 ] = x0; dst[ dstOffset + 1 ] = y0; dst[ dstOffset + 2 ] = z0; dst[ dstOffset + 3 ] = w0; return; } if ( t === 1 ) { dst[ dstOffset + 0 ] = x1; dst[ dstOffset + 1 ] = y1; dst[ dstOffset + 2 ] = z1; dst[ dstOffset + 3 ] = w1; return; } if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) { let s = 1 - t; const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = ( cos >= 0 ? 1 : - 1 ), sqrSin = 1 - cos * cos; // Skip the Slerp for tiny steps to avoid numeric problems: if ( sqrSin > Number.EPSILON ) { const sin = Math.sqrt( sqrSin ), len = Math.atan2( sin, cos * dir ); s = Math.sin( s * len ) / sin; t = Math.sin( t * len ) / sin; } const tDir = t * dir; x0 = x0 * s + x1 * tDir; y0 = y0 * s + y1 * tDir; z0 = z0 * s + z1 * tDir; w0 = w0 * s + w1 * tDir; // Normalize in case we just did a lerp: if ( s === 1 - t ) { const f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 ); x0 *= f; y0 *= f; z0 *= f; w0 *= f; } } dst[ dstOffset ] = x0; dst[ dstOffset + 1 ] = y0; dst[ dstOffset + 2 ] = z0; dst[ dstOffset + 3 ] = w0; } static multiplyQuaternionsFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1 ) { const x0 = src0[ srcOffset0 ]; const y0 = src0[ srcOffset0 + 1 ]; const z0 = src0[ srcOffset0 + 2 ]; const w0 = src0[ srcOffset0 + 3 ]; const x1 = src1[ srcOffset1 ]; const y1 = src1[ srcOffset1 + 1 ]; const z1 = src1[ srcOffset1 + 2 ]; const w1 = src1[ srcOffset1 + 3 ]; dst[ dstOffset ] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1; dst[ dstOffset + 1 ] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1; dst[ dstOffset + 2 ] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1; dst[ dstOffset + 3 ] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1; return dst; } get x() { return this._x; } set x( value ) { this._x = value; this._onChangeCallback(); } get y() { return this._y; } set y( value ) { this._y = value; this._onChangeCallback(); } get z() { return this._z; } set z( value ) { this._z = value; this._onChangeCallback(); } get w() { return this._w; } set w( value ) { this._w = value; this._onChangeCallback(); } set( x, y, z, w ) { this._x = x; this._y = y; this._z = z; this._w = w; this._onChangeCallback(); return this; } clone() { return new this.constructor( this._x, this._y, this._z, this._w ); } copy( quaternion ) { this._x = quaternion.x; this._y = quaternion.y; this._z = quaternion.z; this._w = quaternion.w; this._onChangeCallback(); return this; } setFromEuler( euler, update ) { const x = euler._x, y = euler._y, z = euler._z, order = euler._order; // http://www.mathworks.com/matlabcentral/fileexchange/ // 20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/ // content/SpinCalc.m const cos = Math.cos; const sin = Math.sin; const c1 = cos( x / 2 ); const c2 = cos( y / 2 ); const c3 = cos( z / 2 ); const s1 = sin( x / 2 ); const s2 = sin( y / 2 ); const s3 = sin( z / 2 ); switch ( order ) { case 'XYZ': this._x = s1 * c2 * c3 + c1 * s2 * s3; this._y = c1 * s2 * c3 - s1 * c2 * s3; this._z = c1 * c2 * s3 + s1 * s2 * c3; this._w = c1 * c2 * c3 - s1 * s2 * s3; break; case 'YXZ': this._x = s1 * c2 * c3 + c1 * s2 * s3; this._y = c1 * s2 * c3 - s1 * c2 * s3; this._z = c1 * c2 * s3 - s1 * s2 * c3; this._w = c1 * c2 * c3 + s1 * s2 * s3; break; case 'ZXY': this._x = s1 * c2 * c3 - c1 * s2 * s3; this._y = c1 * s2 * c3 + s1 * c2 * s3; this._z = c1 * c2 * s3 + s1 * s2 * c3; this._w = c1 * c2 * c3 - s1 * s2 * s3; break; case 'ZYX': this._x = s1 * c2 * c3 - c1 * s2 * s3; this._y = c1 * s2 * c3 + s1 * c2 * s3; this._z = c1 * c2 * s3 - s1 * s2 * c3; this._w = c1 * c2 * c3 + s1 * s2 * s3; break; case 'YZX': this._x = s1 * c2 * c3 + c1 * s2 * s3; this._y = c1 * s2 * c3 + s1 * c2 * s3; this._z = c1 * c2 * s3 - s1 * s2 * c3; this._w = c1 * c2 * c3 - s1 * s2 * s3; break; case 'XZY': this._x = s1 * c2 * c3 - c1 * s2 * s3; this._y = c1 * s2 * c3 - s1 * c2 * s3; this._z = c1 * c2 * s3 + s1 * s2 * c3; this._w = c1 * c2 * c3 + s1 * s2 * s3; break; default: console.warn( 'THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order ); } if ( update !== false ) this._onChangeCallback(); return this; } setFromAxisAngle( axis, angle ) { // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm // assumes axis is normalized const halfAngle = angle / 2, s = Math.sin( halfAngle ); this._x = axis.x * s; this._y = axis.y * s; this._z = axis.z * s; this._w = Math.cos( halfAngle ); this._onChangeCallback(); return this; } setFromRotationMatrix( m ) { // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled) const te = m.elements, m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ], m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ], m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ], trace = m11 + m22 + m33; if ( trace > 0 ) { const s = 0.5 / Math.sqrt( trace + 1.0 ); this._w = 0.25 / s; this._x = ( m32 - m23 ) * s; this._y = ( m13 - m31 ) * s; this._z = ( m21 - m12 ) * s; } else if ( m11 > m22 && m11 > m33 ) { const s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 ); this._w = ( m32 - m23 ) / s; this._x = 0.25 * s; this._y = ( m12 + m21 ) / s; this._z = ( m13 + m31 ) / s; } else if ( m22 > m33 ) { const s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 ); this._w = ( m13 - m31 ) / s; this._x = ( m12 + m21 ) / s; this._y = 0.25 * s; this._z = ( m23 + m32 ) / s; } else { const s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 ); this._w = ( m21 - m12 ) / s; this._x = ( m13 + m31 ) / s; this._y = ( m23 + m32 ) / s; this._z = 0.25 * s; } this._onChangeCallback(); return this; } setFromUnitVectors( vFrom, vTo ) { // assumes direction vectors vFrom and vTo are normalized let r = vFrom.dot( vTo ) + 1; if ( r < Number.EPSILON ) { // vFrom and vTo point in opposite directions r = 0; if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) { this._x = - vFrom.y; this._y = vFrom.x; this._z = 0; this._w = r; } else { this._x = 0; this._y = - vFrom.z; this._z = vFrom.y; this._w = r; } } else { // crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3 this._x = vFrom.y * vTo.z - vFrom.z * vTo.y; this._y = vFrom.z * vTo.x - vFrom.x * vTo.z; this._z = vFrom.x * vTo.y - vFrom.y * vTo.x; this._w = r; } return this.normalize(); } angleTo( q ) { return 2 * Math.acos( Math.abs( clamp( this.dot( q ), - 1, 1 ) ) ); } rotateTowards( q, step ) { const angle = this.angleTo( q ); if ( angle === 0 ) return this; const t = Math.min( 1, step / angle ); this.slerp( q, t ); return this; } identity() { return this.set( 0, 0, 0, 1 ); } invert() { // quaternion is assumed to have unit length return this.conjugate(); } conjugate() { this._x *= - 1; this._y *= - 1; this._z *= - 1; this._onChangeCallback(); return this; } dot( v ) { return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w; } lengthSq() { return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w; } length() { return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w ); } normalize() { let l = this.length(); if ( l === 0 ) { this._x = 0; this._y = 0; this._z = 0; this._w = 1; } else { l = 1 / l; this._x = this._x * l; this._y = this._y * l; this._z = this._z * l; this._w = this._w * l; } this._onChangeCallback(); return this; } multiply( q ) { return this.multiplyQuaternions( this, q ); } premultiply( q ) { return this.multiplyQuaternions( q, this ); } multiplyQuaternions( a, b ) { // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w; const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w; this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby; this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz; this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx; this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz; this._onChangeCallback(); return this; } slerp( qb, t ) { if ( t === 0 ) return this; if ( t === 1 ) return this.copy( qb ); const x = this._x, y = this._y, z = this._z, w = this._w; // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/ let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z; if ( cosHalfTheta < 0 ) { this._w = - qb._w; this._x = - qb._x; this._y = - qb._y; this._z = - qb._z; cosHalfTheta = - cosHalfTheta; } else { this.copy( qb ); } if ( cosHalfTheta >= 1.0 ) { this._w = w; this._x = x; this._y = y; this._z = z; return this; } const sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta; if ( sqrSinHalfTheta"}],"posts":[{"title":"3D-model-001","slug":"3D/3D-model-001","date":"2023-10-14T06:33:00.000Z","updated":"2023-10-14T08:19:46.198Z","comments":true,"path":"/3D/3D-model-001.html","link":"","permalink":"http://19999997.xyz/3D/3D-model-001.html","excerpt":"这是第一个模型","text":"这是第一个模型 展示 { \"imports\": { \"three\": \"../js/three/build/three.module.js\", \"three/addons/\": \"../js/three/jsm/\" } } 如何呈现 设置如下文件结构 12345678910111213├─js│ ├─modelJS #放置模型的js加载文件及配置文件│ └─three│ ├─build #three js 本体│ ├─jsm #插件文件│ │ ├─controls│ │ ├─libs│ │ │ └─draco│ │ ├─loaders│ │ │ └─lwo│ │ └─utils│ └─models #模型文件│ └─001 文章中放入以下代码 12345678910&lt;div id=&quot;webgl&quot; style=&quot;margin-top: 10px; margin-left: 10px;&quot;&gt;&lt;/div&gt;&lt;script type=&quot;importmap&quot;&gt; &#123; &quot;imports&quot;: &#123; &quot;three&quot;: &quot;../js/three/build/three.module.js&quot;, &quot;three/addons/&quot;: &quot;../js/three/jsm/&quot; &#125; &#125;&lt;/script&gt;&lt;script type=&quot;module&quot; src=&quot;../js/modelJS/001.js&quot;&gt;&lt;/script&gt;","categories":[{"name":"3D","slug":"3D","permalink":"http://19999997.xyz/categories/3D/"}],"tags":[{"name":"3D","slug":"3D","permalink":"http://19999997.xyz/tags/3D/"}]},{"title":"dictation-day-003","slug":"dictations/dictation-day-003","date":"2023-10-11T15:00:50.000Z","updated":"2023-10-11T15:08:06.797Z","comments":true,"path":"/dictations/dictation-day-003.html","link":"","permalink":"http://19999997.xyz/dictations/dictation-day-003.html","excerpt":"dictation day 003","text":"dictation day 003 dictation-day-003 dictation day 002|dictation day 004","categories":[{"name":"English","slug":"English","permalink":"http://19999997.xyz/categories/English/"}],"tags":[{"name":"video","slug":"video","permalink":"http://19999997.xyz/tags/video/"},{"name":"English","slug":"English","permalink":"http://19999997.xyz/tags/English/"},{"name":"dictation","slug":"dictation","permalink":"http://19999997.xyz/tags/dictation/"}]},{"title":"dictation-day-002","slug":"dictations/dictation-day-002","date":"2023-10-11T14:47:31.000Z","updated":"2023-10-11T15:08:04.061Z","comments":true,"path":"/dictations/dictation-day-002.html","link":"","permalink":"http://19999997.xyz/dictations/dictation-day-002.html","excerpt":"dictation day 002","text":"dictation day 002 dictation-day-002 dictation day 001|dictation day 003","categories":[{"name":"English","slug":"English","permalink":"http://19999997.xyz/categories/English/"}],"tags":[{"name":"video","slug":"video","permalink":"http://19999997.xyz/tags/video/"},{"name":"English","slug":"English","permalink":"http://19999997.xyz/tags/English/"},{"name":"dictation","slug":"dictation","permalink":"http://19999997.xyz/tags/dictation/"}]},{"title":"dictation-day-001","slug":"dictations/dictation-day-001","date":"2023-09-29T08:35:31.000Z","updated":"2023-10-11T15:08:00.316Z","comments":true,"path":"/dictations/dictation-day-001.html","link":"","permalink":"http://19999997.xyz/dictations/dictation-day-001.html","excerpt":"dictation day 001","text":"dictation day 001 dictation-day-001 dictation day 002","categories":[{"name":"English","slug":"English","permalink":"http://19999997.xyz/categories/English/"}],"tags":[{"name":"video","slug":"video","permalink":"http://19999997.xyz/tags/video/"},{"name":"English","slug":"English","permalink":"http://19999997.xyz/tags/English/"},{"name":"dictation","slug":"dictation","permalink":"http://19999997.xyz/tags/dictation/"}]},{"title":"markdown it plugins","slug":"markdown-it-plugins","date":"2023-09-28T06:25:06.000Z","updated":"2023-10-14T08:56:19.281Z","comments":true,"path":"/markdown-it-plugins.html","link":"","permalink":"http://19999997.xyz/markdown-it-plugins.html","excerpt":"markdown it 插件的使用","text":"markdown it 插件的使用 markdown it plugins hexo-renderer-markdown-it-plus markdown-it-latex2img【额外】 markdown-it-katex【额外】 markdown-it-abbr【默认】 markdown-it-attrs【额外】 markdown-it-deflist【默认】 markdown-it-emoji【默认】 markdown-it-footnote【默认】 markdown-it-ins【默认】 markdown-it-mark【默认】 markdown-it-sub【默认】 markdown-it-sup【默认】 markdown-it-toc【默认】 markdown-it-bracketed-spans markdown-it-spoiler【额外】 启用 12345- plugin: name: markdown-it-spoiler enable: true options: title: &quot;你知道得太多了&quot; 配置 在themes\\purabo\\source\\css\\style.css中添加样式 123456789101112131415161718192021/* spoiler 隐藏文本 start *//* !!balabala!! 鼠标放置时显示内容。 *//* !!balabala!!&#123;.bulr&#125; 鼠标选中时显示内容 */.spoiler:not(.bulr) &#123; background-color: #333; color: var(#333); text-shadow: none; transition: color .3s; padding:0 .1875rem;&#125;.spoiler:hover &#123; color: #FFF;&#125;.spoiler.bulr &#123; text-shadow: rgba(0, 0, 0, .7) 0rem 0rem .625rem; color: transparent;&#125;/* spoiler 隐藏文本 end */ 使用 12!!balabala!! 鼠标放置时显示内容。!!balabala!!&#123;.bulr&#125; 鼠标选中时显示内容 效果","categories":[{"name":"markdown","slug":"markdown","permalink":"http://19999997.xyz/categories/markdown/"}],"tags":[{"name":"plugins","slug":"plugins","permalink":"http://19999997.xyz/tags/plugins/"},{"name":"markdown","slug":"markdown","permalink":"http://19999997.xyz/tags/markdown/"},{"name":"guides","slug":"guides","permalink":"http://19999997.xyz/tags/guides/"}]},{"title":"插件推荐","slug":"guide/插件推荐","date":"2023-09-26T10:04:29.000Z","updated":"2023-10-14T08:54:31.903Z","comments":true,"path":"/guide/hexo-plugin-recommend.html","link":"","permalink":"http://19999997.xyz/guide/hexo-plugin-recommend.html","excerpt":"","text":"必装插件 hexo-wordcount-必装插件 hexo-wordcount 安装 1npm install hexo-wordcount --save 配置 【内置支持】 hexo-generator-index-pin-top 安装 12npm uninstall --save hexo-generator-index #首先卸载 hexo-generator-indexnpm install --save hexo-generator-index-pin-top 配置 【内置支持】 选装插件[配置文件写到站点_config.yml里面] hexo-tag-mmedia 安装 1npm install hexo-tag-mmedia --save 配置文件 123456789101112131415161718192021222324252627282930313233mmedia:# https://dplayer.diygod.dev/zh/guide.html#%E5%8F%82%E6%95%B0 dplayer: cdn: https://cdn.jsdelivr.net/npm/dplayer/dist/DPlayer.min.js style_cdn: https://cdn.jsdelivr.net/npm/dplayer/dist/DPlayer.min.css hls_cdn: https://cdn.jsdelivr.net/npm/hls.j/dist/hls.min.js dash_cdn: https://cdn.jsdelivr.net/npm/dashjs/dist/dash.all.min.js shaka_dash_cdn: https://cdn.jsdelivr.net/npm/shaka-player/dist/shaka-player.compiled.js flv_cdn: https://cdn.jsdelivr.net/npm/flv.js/dist/flv.min.js webtorrent_cdn: https://cdn.jsdelivr.net/npm/webtorrent/webtorrent.min.js default: audio: default: video: default: aplayer: js: https://cdn.jsdelivr.net/npm/aplayer@1/dist/APlayer.min.js css: https://cdn.jsdelivr.net/npm/aplayer@1/dist/APlayer.min.css default: contents: meting: js: https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js api: default: bilibili: default: page: 1 danmaku: true allowfullscreen: allowfullscreen sandbox: allow-top-navigation allow-same-origin allow-forms allow-scripts allow-popups width: 100% max_width: 850px margin: auto hexo-neat 安装 1npm install --save hexo-neat 配置文件 12345678910111213141516# hexo-neatneat_enable: trueneat_html: enable: true exclude: neat_css: enable: true exclude: - &#x27;*.min.css&#x27;neat_js: enable: true mangle: true output: compress: exclude: - &#x27;*.min.js&#x27; hexo-lazyload-image 安装 1npm install hexo-lazyload-image --save 配置文件 1234lazyload: enable: true onlypost: false loadingImg: # eg. ./images/loading.png # 可以配置加载图片 hexo-renderer-markdown-it-plus 安装 123npm uninstall --save hexo-renderer-marked # 卸载 hexo-renderer-markednpm install --save hexo-renderer-markdown-it-plusnpm install --save markdown-it-katex 配置 1234567891011121314151617181920# plugin markdown_it_plusmarkdown_it_plus: highlight: true html: true xhtmlOut: true breaks: true langPrefix: linkify: true typographer: quotes: “”‘’ plugins: # for math formula - plugin: name: markdown-it-katex enable: true - plugin: name: markdown-it-mark enable: falsemathjax: eanble: true hexo-generator-feed 安装 1npm install --save hexo-generator-feed 配置 见官网 hexo-generator-sitemap 安装 1npm install hexo-generator-sitemap --save 配置 见官网 hexo-blog-encrypt 安装 1npm install --save hexo-blog-encrypt 配置 12345678910# Securityencrypt: # hexo-blog-encrypt enable: true #silent: true #是否启用log true为不启用 abstract: 有东西被加密了, 请输入密码查看. message: 您好, 这里需要密码. #tags: [&#123;name: 加密, password: @abo&#125;] theme: xray #加密框的主题 wrong_pass_message: 抱歉, 这个密码看着不太对, 请再试试. wrong_hash_message: 抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容. 详细配置请见官网 hexo-generator-json-content 安装 1npm install --save hexo-generator-json-content 配置 详情请见官网 hexo-statistics-charts 安装 1npm install --save hexo-statistics-charts 配置 【内置支持】 详情请见官网 hexo-baidu-url-submit 安装 1npm install --save hexo-baidu-url-submit 配置 12345# 站点配置文件deploy:- type: s3 ## 这是我原来的deployer ...- type: baidu_url_submitter ## 这是新加的 1234567# 站点配置文件baidu_url_submit: count: 1 ## 提交最新的一个链接 host: 19999997.xyz ## 在百度站长平台中注册的域名 token: your_token ## 请注意这是您的秘钥， 所以请不要把博客源代码发布在公众仓库里! path: baidu_urls.txt ## 文本文档的地址， 新链接会保存在此文本文档里 hexo-dynamic-config【有冲突】 安装 1npm install hexo-dynamic-config --save 1. Hexo-theme-purabo-使用教程 2. Hexo-theme-purabo-快速开始 3. Hexo-theme-purabo-主题及站点配置 4. 插件推荐","categories":[{"name":"guides","slug":"guides","permalink":"http://19999997.xyz/categories/guides/"}],"tags":[{"name":"plugin","slug":"plugin","permalink":"http://19999997.xyz/tags/plugin/"},{"name":"hexo","slug":"hexo","permalink":"http://19999997.xyz/tags/hexo/"},{"name":"guides","slug":"guides","permalink":"http://19999997.xyz/tags/guides/"},{"name":"purabo","slug":"purabo","permalink":"http://19999997.xyz/tags/purabo/"}]},{"title":"Hexo-theme-purabo 主题及站点配置","slug":"guide/Hexo-theme-purabo-主题及站点配置","date":"2023-09-26T10:04:10.000Z","updated":"2023-10-14T08:54:42.856Z","comments":true,"path":"/guide/hexo-theme-purabo-configurations.html","link":"","permalink":"http://19999997.xyz/guide/hexo-theme-purabo-configurations.html","excerpt":"","text":"配置文件 hexo的配置文件有两个 Hexo 根目录下的_config.yml。这是 Hexo 的配置文件，对整个站点生效（无论使用哪个主题）。 purabo 根目录下的 _config.yml。这是 Stun 的配置文件，只对主题生效。 首先我们把 purabo 根目录下的配置文件 _config.yml复制到 Hexo 根目录下并重命名为 _config.purabo.yml。之后改主题配置文件就只改_config.purabo.yml即可。 主题配置 修改_config.purabo.yml中的内容 1. 设置语言 打开_config.purabo.yml，设置language: zh-CN 2. 设置导航菜单 在_config.purabo.yml中： menu:左侧导航菜单 menu_icons:导航菜单图标 想改图标可以看这里 3. 自定义功能设置 3.1 在purabo中，可以选择以下功能是否开启 go_top:一键回顶部 custom_img:自定义图片大小 在图片链接后加 ?widthxheight ?widthx ?xheight ?scale copy_button: 一键复制按钮 about: 关于页面 chart: 博客图表统计 fold_action: 可折叠功能 preloader: 图片预加载功能 3.2 在tag_cloud中可以选择是否开启标签云 3.3 在site中，可以选择以下功能是否开启 copyright: 底部版权信息是否显示 visitor: 底部站点点击数访客数统计 theme_authoer: 是否显示主题作者信息 site_time:建站时间是否显示 date: 建站日期，格式YYYY-MM-DD time: 建站时间, 格式HH:mm:ss frequency: 时间刷新时间，1000为1秒 3.4 fancybox: 是否开启点击图片查看大图功能 fancybox: true 3.5 search: 站内搜索功能 123search: insight: true # you need to install `hexo-generator-json-content` before using Insight Search baidu: false # you need to disable other search engines to use Baidu search 3.6 donate: 赞赏功能 3.7 share: 分享功能 12345# weibo,qq,qzone,wechat,tencent,douban,diandian,facebook,twitter,google,linkedinshare: enable: true # 是否启用分享 sites: weibo,qq,wechat,facebook,twitter # PC端显示的分享图标 mobile_sites: weibo,wechat,qq,qzone # 移动端显示的分享图标 3.8 github: 3.9 pagination 分页功能 123456pagination: # 分页功能 number: false prev: alwayShow: true next: alwayShow: true 4. 评论功能 在comment中： type：启用哪种评论系统 utterances 详情请见 utterances, 及注释 123456utterances: repo: abobot/hexo-blog-comments issue_term: pathname label: 💬comments theme: github-light crossorigin: anonymous disqus youyan 12youyan: uid: 1783844 # enter youyan uid livere 12livere: uid: # enter youyan uid gitment 123456gitment: githubID: repo: ClientID: ClientSecret: lazy: false gitalk 详情请见 gitalk, [评论系统](https://hwame.top/20200520/hello-hexo-configuration.html#5-评论系统及注释 123456gitalk: # gitalk. https://gitalk.github.io/ owner: #必须. GitHub repository 所有者，可以是个人或者组织。 admin: #必须. GitHub repository 的所有者和合作者 (对这个 repository 有写权限的用户)。 repo: #必须. GitHub repository. ClientID: #必须. GitHub Application Client ID. ClientSecret: #必须. GitHub Application Client Secret. valine 详情请见 valine, 及注释 12345678910111213valine: # Valine. https://valine.js.org appid: # your leancloud application appid appkey: # your leancloud application appkey notify: false # mail notifier , https://github.com/xCss/Valine/wiki verify: false # Verification code placeholder: Just go go # comment box placeholder avatar: mm # gravatar style meta: nick,mail,link # custom comment header pageSize: 10 # pagination size visitor: false # Article reading statistic https://valine.js.org/visitor.html enableQQ: true recordIP: true requiredFields: [&#x27;mail&#x27;,] # Nick必填则需3+字符 5. 个人信息profile 根据需要填写 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# profileprofile: enabled: true # Whether to show profile bar avatar: images/avatar.jpg gravatar: # Gravatar email address, if you enable Gravatar, your avatar config will be overriden author: 阿波bot author_title: many things want to learn. author_description: 个人简介。 location: ChangSha, China follow: https://github.com/aboobt # Social Links social: links: github: https://github.com/abobot # weibo: http://weibo.com/ zhihu: https://www.zhihu.com/people/abobot gitee: https://gitee.com/abobot douban: https://www.douban.com/people/abobot/ # twitter: https://twitter.com/ # facebook: / # dribbble: / # behance: https://www.behance.net/ rss: atom.xml link_tooltip: true # enable the social link tooltip, options: true, false # My Skills skills: Git: ☆☆☆☆☆ Gulp: ☆☆☆☆☆ Javascript: ☆☆☆☆☆ HTML+CSS: ☆☆☆☆☆ Bootstrap: ☆☆☆☆☆ ThinkPHP: ☆☆☆☆☆ 平面设计: ☆☆☆☆☆ # My Personal Links links: Github: https://github.com/aboobt Blog: http://abobot.github.io 微博: http://weibo.com/ 豆瓣: https://www.douban.com/people/abobot/ # 花瓣: http://huaban.com/ # Behance: https://www.behance.net/ # My Personal Labels labels: - 前端不会 - 前端开发不会 - 前端重构不会 - Web前端不会 - 网页重构不会 # My Personal Works works: name: link: 1999997.xyz date: 2021 # My Personal Projects projects: abobot/hexo-theme-purabo: https://github.com/abobot/hexo-theme-purable 站点配置 参考 Hexo配置 其他可参考 这个大佬的设置 1. Hexo-theme-purabo-使用教程 2. Hexo-theme-purabo-快速开始 3. Hexo-theme-purabo-主题及站点配置 4. 插件推荐","categories":[{"name":"guides","slug":"guides","permalink":"http://19999997.xyz/categories/guides/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://19999997.xyz/tags/hexo/"},{"name":"guides","slug":"guides","permalink":"http://19999997.xyz/tags/guides/"},{"name":"purabo","slug":"purabo","permalink":"http://19999997.xyz/tags/purabo/"}]},{"title":"Hexo-theme-purabo 快速开始","slug":"guide/Hexo-theme-purabo-快速开始","date":"2023-09-26T10:03:31.000Z","updated":"2023-10-14T08:54:26.789Z","comments":true,"path":"/guide/quickly-start.html","link":"","permalink":"http://19999997.xyz/guide/quickly-start.html","excerpt":"","text":"快速开始 安装步骤 2.1 前期准备 确保安装了 node.js git npm 安装Hexo 安装完整版hexo 1npm install -g hexo-cli 2.2 建站 参考 【官方中文文档】 在合适位置打开cmd，输入 123hexo init &lt;folder&gt;cd &lt;folder&gt;npm install 2.3 启动服务器 123hexo cleanhexo ghexo s “一键三连”之后在http://localhost:4000就可以看到生成的博客了 CTRL + C可以停止服务器 主题 安装purabo主题 在Hexo根目录下，执行命令： 1git clone git@github.com:abobot/hexo-theme-purabo.git themes/purabo 更新 12cd themes/purabogit puull origin master 使用 修改 Hexo 根目录下的 _config.yml 文件： theme: purabo 必装插件 在Hexo根目录下，执行命令 (hexo-wordcount)[https://github.com/willin/hexo-wordcount] npm install hexo-wordcount --save 按照2.3可以看到效果 新建文章 新建页面 默认只开启了，首页和归档，如果你想打开其他页面 分类 hexo new page categories 打开source\\categories\\index.md,在以下位置添加： 1234---type: categorieslayout: categories--- 标签 hexo new page tags 打开source\\tags\\index.md,在以下位置添加： 1234---type: tagslayout: tags--- 项目 hexo new page repository 打开source\\repository\\index.md,在以下位置添加： 1234---type: repositorylayout: repository--- 相册 hexo new page gallery 打开source\\gallery\\index.md,在以下位置添加： 1234---type: gallerylayout: gallery--- 书单 hexo new page books 打开source\\books\\index.md,在以下位置添加： 1234---type: bookslayout: books--- 友链 hexo new page links 打开source\\links\\index.md,在以下位置添加： 1234---type: linkslayout: links--- 关于 hexo new page about 打开source\\about\\index.md,在以下位置添加： 1234---type: aboutlayout: about--- 404 hexo new page about 打开source\\about\\index.md,将内容改为： 1234567---title: 404 Not Found：该页无法显示toc: falsecomments: falsepermalink: /404---&lt;script type=&quot;text/javascript&quot; src=&quot;//www.qq.com/404/search_children.js&quot; charset=&quot;utf-8&quot; homePageUrl=&quot;&lt;%- config.url %&gt;&quot; homePageName=&quot;回到我的主页&quot;&gt;&lt;/script&gt; 部署 参考 部署到github 需要安装插件 npm install hexo-deployer-git --save 1. Hexo-theme-purabo-使用教程 2. Hexo-theme-purabo-快速开始 3. Hexo-theme-purabo-主题及站点配置 4. 插件推荐","categories":[{"name":"guides","slug":"guides","permalink":"http://19999997.xyz/categories/guides/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://19999997.xyz/tags/hexo/"},{"name":"guides","slug":"guides","permalink":"http://19999997.xyz/tags/guides/"},{"name":"purabo","slug":"purabo","permalink":"http://19999997.xyz/tags/purabo/"}]},{"title":"Hexo-theme-purabo-使用教程","slug":"guide/Hexo-theme-purabo-使用教程","date":"2023-09-26T10:02:11.000Z","updated":"2023-10-01T03:13:28.359Z","comments":true,"path":"/guide/hexo-theme-purabo-guides.html","link":"","permalink":"http://19999997.xyz/guide/hexo-theme-purabo-guides.html","excerpt":"","text":"1. Hexo-theme-purabo-使用教程 2. Hexo-theme-purabo-快速开始 3. Hexo-theme-purabo-主题及站点配置 4. 插件推荐","categories":[{"name":"guide","slug":"guide","permalink":"http://19999997.xyz/categories/guide/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://19999997.xyz/tags/hexo/"},{"name":"purabo","slug":"purabo","permalink":"http://19999997.xyz/tags/purabo/"},{"name":"guide","slug":"guide","permalink":"http://19999997.xyz/tags/guide/"}]},{"title":"Function test","slug":"Function-test","date":"2023-09-26T08:32:49.000Z","updated":"2023-09-28T08:25:47.574Z","comments":true,"path":"/function-test.html","link":"","permalink":"http://19999997.xyz/function-test.html","excerpt":"","text":"this is for fold function you can see me. 公式 quotes: “”‘’ “quote” 123for(var i = 0; i &lt; 10; i++)&#123;&#125; inline # The opening $ must have a non-space character immediately to its right, while the closing $ must have a non-space character immediately to its left, and must not be followed immediately by a digit. block quiz spoiler balabala 鼠标放置时显示内容。 balabala 鼠标选中时显示内容 H2O2 x2 😅 # 流汗黄豆 😘 💍 🎶 H20 29th","categories":[],"tags":[{"name":"test","slug":"test","permalink":"http://19999997.xyz/tags/test/"}]},{"title":"Hexo-pure改造计划——添加utterances评论支持","slug":"Hexo-pure改造计划——添加utterances评论支持","date":"2023-09-21T09:52:36.000Z","updated":"2023-10-14T08:56:02.814Z","comments":true,"path":"/hexo-adds-utterances-support.html","link":"","permalink":"http://19999997.xyz/hexo-adds-utterances-support.html","excerpt":"添加utterances评论支持。由于pure主题集成了几个评论系统，所以增加一个还算简单。","text":"添加utterances评论支持。由于pure主题集成了几个评论系统，所以增加一个还算简单。 参考链接 Hexo NexT 使用 utterances 评论区 hexo-fluid添加utterances评论功能(详细图文过程) 新建utterances.ejs 在themes\\pure\\layout\\_script\\_comment\\目录新建utterances.ejs文件，文件内容如下： 1234567891011&lt;% if (typeof(script) !== &#x27;undefined&#x27; &amp;&amp; script) &#123; %&gt; &lt;script src=&quot;https://utteranc.es/client.js&quot; repo=&lt;%= theme.comment.utterances.repo %&gt; issue-term=&lt;%= theme.comment.utterances.issue_term %&gt; label=&lt;%= theme.comment.utterances.label %&gt; theme=&lt;%= theme.comment.utterances.theme %&gt; crossorigin=&lt;%= theme.comment.utterances.crossorigin %&gt; async&gt; &lt;/script&gt;&lt;% &#125; %&gt; 更改comment.ejs文件 注意：comment.ejs文件有两个 一、更改themes\\pure\\layout\\_script\\comment.ejs代码 打开themes\\pure\\layout\\_script\\comment.ejs，在最后添加如下代码： 12345&lt;% &#125; else if (theme.comment.type === &#x27;valine&#x27;) &#123; %&gt; &lt;%- partial(&#x27;_script/_comment/valine&#x27;, &#123; script: true &#125;) %&gt; &lt;% &#125; else if (theme.comment.type === &#x27;utterances&#x27;) &#123; %&gt; &lt;%- partial(&#x27;_script/_comment/utterances&#x27;, &#123; script: true &#125;) %&gt;&lt;% &#125; %&gt; 注意 123&lt;% &#125; else if (theme.comment.type === &#x27;valine&#x27;) &#123; %&gt; &lt;%- partial(&#x27;_script/_comment/valine&#x27;, &#123; script: true &#125;) %&gt; &lt;% &#125; %&gt; 这段代码是原来就有的，也可以插在这个文件其他合适的位置 二、更改themes\\pure\\layout\\_partial\\post\\comment.ejs代码 打开themes\\pure\\layout\\_partial\\post\\comment.ejs,插入如下代码 12345&lt;% &#125; else if (theme.comment.type === &#x27;gitalk&#x27;) &#123; %&gt;&lt;% &#125; else if (theme.comment.type === &#x27;utterances&#x27;) &#123; %&gt; &lt;% &#125; else if (theme.comment.type === &#x27;valine&#x27;) &#123; %&gt; 注意 123&lt;% &#125; else if (theme.comment.type === &#x27;gitalk&#x27;) &#123; %&gt; &lt;% &#125; else if (theme.comment.type === &#x27;valine&#x27;) &#123; %&gt; 这段代码是原来就有的，&lt;% &#125; else if (theme.comment.type === 'utterances') &#123; %&gt;，也可以插在其他合适位置 更改主题配置文件 打开themes\\pure\\_config.yml 找到comment,在对应位置加入： 123456789comment: type: utterances # 启用哪种评论系统 # 20230921 utterances utterances: repo: abobot/hexo-blog-comments issue_term: pathname label: 💬comments theme: github-light crossorigin: anonymous 其中的参数可以去https://utteranc.es/了解 完毕","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://19999997.xyz/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://19999997.xyz/tags/Hexo/"},{"name":"改造","slug":"change","permalink":"http://19999997.xyz/tags/change/"}]},{"title":"Hexo-pure改造计划——添加代码块复制按钮","slug":"Hexo-pure改造计划——添加代码块复制按钮","date":"2023-09-21T02:52:41.000Z","updated":"2023-09-27T13:37:02.058Z","comments":true,"path":"/hexo-adds-codecopy-button.html","link":"","permalink":"http://19999997.xyz/hexo-adds-codecopy-button.html","excerpt":"为代码块添加复制按钮","text":"为代码块添加复制按钮 方法一（弃用）【应该是代码位置没插对】 原因：生成网页之后函数变了。虽然一开始弄的时候是好的，不知道咋回事。 作者说：坑：理论上可以在其他地方添加，但是必须保证代码在jq以及页面dom加载后运行。 正常应该是 12345678910111213141516171819202122232425262728293031323334addLoadEvent(()=&gt;&#123; $(&#x27;.highlight&#x27;).each(function (i, e) &#123; var $wrap = $(&#x27;&lt;div&gt;&#x27;).addClass(&#x27;highlight-wrap&#x27;) $(e).after($wrap) $wrap.append($(&#x27;&lt;button&gt;&#x27;).addClass(&#x27;copy-btn&#x27;).append(&#x27;copy&#x27;).on(&#x27;click&#x27;, function (e) &#123; var code = $(this).parent().find(&quot;.code&quot;)[0].innerText code += &quot;\\n/**\\n* 感谢您复制代码，使用代码请注明引用出处\\n* kajweb @ https://blog.iwwee.com\\n*/&quot; var ta = document.createElement(&#x27;textarea&#x27;) document.body.appendChild(ta) ta.style.position = &#x27;absolute&#x27; ta.style.top = &#x27;0px&#x27; ta.style.left = &#x27;0px&#x27; ta.value = code ta.select() ta.focus() var result = document.execCommand(&#x27;copy&#x27;) document.body.removeChild(ta) if(result)$(this).text(&#x27;copy success&#x27;) else $(this).text(&#x27;copy failed&#x27;) $(this).blur() &#125;)).on(&#x27;mouseleave&#x27;, function (e) &#123; var $b = $(this).find(&#x27;.copy-btn&#x27;) setTimeout(function () &#123; $b.text(&#x27;copy&#x27;) &#125;, 300) &#125;).append(e) &#125;) &#125;) 而我的却是 12345678910111213141516171819202122232425262728293031addLoadEvent(() =&gt;&#123; $(&quot;.highlight&quot;).each(function(t, e) &#123; var n = $(&quot;&lt;div&gt;&quot;).addClass(&quot;highlight-wrap&quot;); $(e).after(n), n.append($(&quot;&lt;button&gt;&quot;).addClass(&quot;copy-btn&quot;).append(&quot;复制&quot;).on(&quot;click&quot;, function(t) &#123; var e = $(this).parent().find(&quot;.code&quot;)[0].innerText, n = document.createElement(&quot;textarea&quot;); document.body.appendChild(n), n.style.position = &quot;absolute&quot;, n.style.top = &quot;0px&quot;, n.style.left = &quot;0px&quot;, n.value = e, n.select(), n.focus(); e = document.execCommand(&quot;copy&quot;); document.body.removeChild(n), e ? $(this).text(&quot;复制成功&quot;) : $(this).text(&quot;复制失败&quot;), $(this).blur() &#125;)).on(&quot;mouseleave&quot;, function(t) &#123; var e = $(this).find(&quot;.copy-btn&quot;); setTimeout(function() &#123; e.text(&quot;复制&quot;) &#125;, 300) &#125;).append(e) &#125;)&#125;) 参考链接 为代码块增加复制按钮 添加全局函数 addLoadEvent 在/themes/pure/source/js目录下打开application.js，在文件最后追加 12345678910111213141516function addLoadEvent(func) &#123; var oldonload = window.onload; if (typeof window.onload != &#x27;function&#x27;) &#123; window.onload = func; &#125; else &#123; window.onload = function() &#123; oldonload(); func(); &#125; &#125;&#125;/*** 感谢您复制代码，使用代码请注明引用出处* kajweb @ https://blog.iwwee.com*/ 新增按钮 pure默认情况下是没有代码复制功能的，此时需要对hexo增加复制代码块功能。 首先在/themes/pure/layout/_partial目录下新增article-copy-code.ejs，增加以下内容： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;% if(theme.codeblock.copy_button.enable)&#123; %&gt; &lt;style&gt; .copy-btn &#123; display: inline-block; padding: 6px 12px; font-size: 13px; font-weight: 700; line-height: 20px; color: #333; white-space: nowrap; vertical-align: middle; cursor: pointer; background-color: #eee; background-image: linear-gradient(#fcfcfc, #eee); border: 1px solid #d5d5d5; border-radius: 3px; user-select: none; outline: 0; &#125; .highlight-wrap .copy-btn &#123; transition: opacity .3s ease-in-out; opacity: 0; padding: 2px 6px; position: absolute; right: 4px; top: 8px; z-index: 2; &#125; .highlight-wrap:hover .copy-btn, .highlight-wrap .copy-btn:focus &#123; opacity: 1 &#125; .highlight-wrap &#123; position: relative; &#125; &lt;/style&gt; &lt;script&gt; addLoadEvent(()=&gt;&#123; $(&#x27;.highlight&#x27;).each(function (i, e) &#123; var $wrap = $(&#x27;&lt;div&gt;&#x27;).addClass(&#x27;highlight-wrap&#x27;) $(e).after($wrap) $wrap.append($(&#x27;&lt;button&gt;&#x27;).addClass(&#x27;copy-btn&#x27;).append(&#x27;&lt;%= __(&quot;codeblock.copy_button&quot;) %&gt;&#x27;).on(&#x27;click&#x27;, function (e) &#123; var code = $(this).parent().find(&quot;.code&quot;)[0].innerText &lt;% if(theme.codeblock.copyright.enable)&#123; %&gt; code += &quot;&lt;%= theme.codeblock.copyright.content %&gt;&quot; &lt;% &#125; %&gt; var ta = document.createElement(&#x27;textarea&#x27;) document.body.appendChild(ta) ta.style.position = &#x27;absolute&#x27; ta.style.top = &#x27;0px&#x27; ta.style.left = &#x27;0px&#x27; ta.value = code ta.select() ta.focus() var result = document.execCommand(&#x27;copy&#x27;) document.body.removeChild(ta) &lt;% if(theme.codeblock.copy_button.result)&#123; %&gt; if(result)$(this).text(&#x27;&lt;%= __(&quot;codeblock.copy_success&quot;) %&gt;&#x27;) else $(this).text(&#x27;&lt;%= __(&quot;codeblock.copy_failure&quot;) %&gt;&#x27;) &lt;% &#125; %&gt; $(this).blur() &#125;)).on(&#x27;mouseleave&#x27;, function (e) &#123; var $b = $(this).find(&#x27;.copy-btn&#x27;) setTimeout(function () &#123; $b.text(&#x27;&lt;%= __(&quot;codeblock.copy_button&quot;) %&gt;&#x27;) &#125;, 300) &#125;).append(e) &#125;) &#125;) &lt;/script&gt;&lt;% &#125; %&gt; 插入到页面 编辑/themes/pure/layout/layout.ejs，在&lt;/body&gt;前面一行增加&lt;%- partial('_partial/article-copy-code')%&gt; 12345678 &lt;%- body %&gt; &lt;%- partial(&#x27;_common/footer&#x27;, null, &#123;cache: !config.relative_link&#125;) %&gt; &lt;%- partial(&#x27;_common/script&#x27;, &#123;post: page&#125;) %&gt; &lt;%- partial(&#x27;_partial/article-copy-code&#x27;) %&gt;&lt;/body&gt;&lt;/html&gt; 理论上可以在其他地方添加，但是必须保证代码在jq以及页面dom加载后运行。 增加语言文件 在/themes/pure/languages目录下选择对应的语言文件，在文件后面增加： 1234codeblock: copy_button: 复制 copy_success: 复制成功 copy_failure: 复制失败 增加主题配置文件 打开themes/pure/_config.yml，在文件末尾添加 1234567codeblock: copy_button: enable: true result: true copyright: enable: true content: 方法二 参考链接 Hexo NexT 代码块复制功能 Hexo NexT 代码块复制功能","categories":[{"name":"hexo","slug":"hexo","permalink":"http://19999997.xyz/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://19999997.xyz/tags/hexo/"}]},{"title":"Hexo 静态博客添加可折叠内容","slug":"Hexo-静态博客添加可折叠内容","date":"2023-09-21T02:13:27.000Z","updated":"2023-09-27T13:34:25.756Z","comments":true,"path":"/add-fold-tag.html","link":"","permalink":"http://19999997.xyz/add-fold-tag.html","excerpt":"想在在博客里面插入 dictation 视频, 然后视频底下可以输入内容，内容可折叠。","text":"想在在博客里面插入 dictation 视频, 然后视频底下可以输入内容，内容可折叠。 参考连接 Hexo静态博客添加可折叠内容 | Bambrow’s Blog 使用方法及效果 代码一： 123&#123;% fold 我是可折叠内容 %&#125;你看到了隐藏起来的我！&#123;% endfold %&#125; 效果 我是可折叠内容 你看到了隐藏起来的我！ 代码二： 123&#123;% fold 我是带有`行内代码块`的可折叠内容 %&#125;你又看到了隐藏起来的我！&#123;% endfold %&#125; 效果 我是带有行内代码块的可折叠内容 你又看到了隐藏起来的我！ 添加自定义标签 首先在themes\\pure\\scripts\\下新建fold_tag.js文件，加入以下代码： 123456789101112/* global hexo */// Usage: &#123;% fold Title %&#125; Something &#123;% endfold %&#125;function fold(args, content) &#123; var text = args.join(&#x27; &#x27;); if(!text) text = &quot;点击显示/隐藏&quot;; return &#x27;&lt;div&gt;&lt;div class=&quot;fold_hider&quot;&gt;&lt;div class=&quot;close hider_title&quot;&gt;&#x27; + hexo.render.renderSync(&#123;text: text, engine: &#x27;markdown&#x27;&#125;).replace(/^&lt;p&gt;/, &#x27;&#x27;).replace(/&lt;\\/p&gt;$/, &#x27;&#x27;) + &#x27;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;fold&quot;&gt;\\n&#x27; + hexo.render.renderSync(&#123;text: content, engine: &#x27;markdown&#x27;&#125;) + &#x27;\\n&lt;/div&gt;&lt;/div&gt;&#x27;;&#125;hexo.extend.tag.register(&#x27;fold&#x27;, fold, &#123;ends: true&#125;); 添加折叠文本代码 新建themes\\pure\\layout\\_partial\\fold_action.ejs文件，加入以下代码 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;% if(theme.fold_action.enable)&#123; %&gt; &lt;style&gt; /* 折叠内容 */ /* toggle hider title */ .hider_title &#123; display: contents; cursor: pointer; background: #05f040c2; font-size:15px; &#125; /* toggle indicators */ .close:before &#123; padding-left: .5em; padding-right: .5em; content: &quot;▼&quot;; &#125; .open:before &#123; padding-left: .5em; padding-right: .5em; content: &quot;▲&quot;; &#125; .fold_hider &#123; background: #eeeeee; &#125; .fold &#123; background: rgb(241, 208, 208); &#125; &lt;/style&gt; &lt;script&gt; $(document).ready(function()&#123; $(document).on(&#x27;click&#x27;, &#x27;.fold_hider&#x27;, function()&#123; $(&#x27;&gt;.fold&#x27;, this.parentNode).slideToggle(); $(&#x27;&gt;:first&#x27;, this).toggleClass(&#x27;open&#x27;); &#125;); //默认情况下折叠 $(&quot;div.fold&quot;).css(&quot;display&quot;, &quot;none&quot;); &#125;); &lt;/script&gt; &lt;% &#125; %&gt; &lt;style&gt;...&lt;\\style&gt; 部分代码可以放到themes\\pure\\source\\css\\style.css文件最后 在themes\\pure\\_config.yml中添加配置 123# 文本折叠按钮fold_action: enable: true 在themes\\pure\\layout\\layout.ejs中添加 12&lt;!-- 文本折叠按钮 --&gt;&lt;%- partial(&#x27;_partial/fold_action&#x27;)%&gt; 添加位置在最后一个&lt;/body&gt;前面 修改样式 找到文件themes\\pure\\source\\css\\style.css中大约5549行，在code后添加,.hider_title code,完整代码为 12345678910code,.hider_title code &#123; text-shadow: 0 1px #fff; padding: 0.2em 0.4em; margin: 0 0.3em; color: #FF4500; background: #F0FFFF; /* 行代码背景颜色 */ border-radius: 3px; font-size: 85%;&#125;","categories":[{"name":"改造","slug":"change","permalink":"http://19999997.xyz/categories/change/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://19999997.xyz/tags/Hexo/"},{"name":"改造","slug":"change","permalink":"http://19999997.xyz/tags/change/"}]},{"title":"Hexo blog insert video","slug":"hexo-blog-insert-video","date":"2023-09-18T05:20:00.000Z","updated":"2023-10-14T08:55:14.501Z","comments":true,"path":"/hexo-blog-insert-video.html","link":"","permalink":"http://19999997.xyz/hexo-blog-insert-video.html","excerpt":"文章描述","text":"文章描述 参考链接 GitHub - MoePlayer/hexo-tag-dplayer: Embed dplayer in Hexo posts/pages 指南 | DPlayer 1. 安装插件 在博客目录使用 --save安装 npm install hexo-tag-dplayer --save 2. 使用 方法一： 123456789101112131415161718&#123;% dplayer&quot;url=/videos/test.mp4&quot;&quot;autoplay=true&quot;&quot;width=50%&quot;&quot;height&quot;=&quot;50%&quot;&quot;theme=#FFFFFF&quot;&quot;hotkey=true&quot;&quot;volume=0.7&quot;&quot;mutex=true&quot;&lt;!-- 水印 --&gt;&quot;logo=/videos/logo.jpg&quot;&lt;!-- 封面 --&gt;&quot;pic=/videos/pic.png&quot;&lt;!-- 缩略图(不好用好像) --&gt;&quot;thumbnails=/videos/thumbnails.jpg&quot;%&#125; 以上能用但不是很好用，找到一个替代hexo-tag-mmedia 3. 更新使用 hexo-tag-mmedia 卸载 hexo-tag-dplayer 1npm uninstall hexo-tag-dplayer 安装hexo-tag-mmedia 1npm install hexo-tag-mmedia --save 配置 参考连接 hexo-tag-mmedia | Easy Hexo 👨‍💻 GitHub - u2sb/hexo-tag-mmedia: hexo插入aplayer、meting、dplayer、bilibili、哔哩哔哩、西瓜视频 标签 hexo-tag-mmedia | 帅比网 Dplayer官方中文教程 var aqJmBAJUAMwqMiHp_options = JSON.parse('{\\\"video\\\":{\\\"url\\\":\\\"/videos/test.mp4\\\",\\\"pic\\\":\\\"/videos/pic.png\\\",\\\"thumbnails\\\":\\\"/video/thumbnails.jpg\\\"},\\\"logo\\\":\\\"/videos/logo.jpg\\\",\\\"listMaxHeight\\\":true,\\\"highlight\\\":[{\\\"time\\\":5,\\\"text\\\":\\\"这是第 5 秒\\\"},{\\\"time\\\":8,\\\"text\\\":\\\"这是 8 秒\\\"}]}'); aqJmBAJUAMwqMiHp_options.container = document.getElementById(\"mmedia-aqJmBAJUAMwqMiHp\"); HEXO_MMEDIA_DATA.js.push(\"https://cdn.jsdelivr.net/npm/dplayer@1/dist/DPlayer.min.js\");HEXO_MMEDIA_DATA.dplayerData.push(aqJmBAJUAMwqMiHp_options); 格式 12345678910111213141516&#123;% mmedias &quot;dplayer&quot; &quot;url:/videos/test.mp4&quot; &quot;pic:/videos/pic.png&quot; &quot;logo:/videos/logo.jpg&quot; &quot;thumbnails:/videos/thumbnails.jpg&quot; %&#125;&#123; highlight: [ &#123; time: 5, text: &#x27;这是第 5 秒&#x27;, &#125;, &#123; time: 8, text: &#x27;这是 8 秒&#x27;, &#125;, ]&#125;&#123;% endmmedias %&#125;","categories":[{"name":"video","slug":"video","permalink":"http://19999997.xyz/categories/video/"}],"tags":[{"name":"dplayer","slug":"dplayer","permalink":"http://19999997.xyz/tags/dplayer/"},{"name":"bilibili","slug":"bilibili","permalink":"http://19999997.xyz/tags/bilibili/"},{"name":"video","slug":"video","permalink":"http://19999997.xyz/tags/video/"},{"name":"改造","slug":"change","permalink":"http://19999997.xyz/tags/change/"},{"name":"plugins","slug":"plugins","permalink":"http://19999997.xyz/tags/plugins/"}]},{"title":"hexo-pure改造计划--github-pages-action-自动部署","slug":"Hexo-pure改造计划——自动部署","date":"2021-09-29T12:56:02.000Z","updated":"2023-09-27T13:40:56.552Z","comments":true,"path":"/hexo-auto-deploy.html","link":"","permalink":"http://19999997.xyz/hexo-auto-deploy.html","excerpt":"","text":"github-pages-action-自动部署。&lt;–!more --&gt;","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://19999997.xyz/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://19999997.xyz/tags/Hexo/"},{"name":"pure","slug":"pure","permalink":"http://19999997.xyz/tags/pure/"}]},{"title":"Hexo-pure改造计划——后期添加域名","slug":"Hexo-pure改造计划——后期添加域名","date":"2021-09-28T16:12:22.000Z","updated":"2023-09-27T13:35:36.642Z","comments":true,"path":"/hexo-adds-a-domain-name.html","link":"","permalink":"http://19999997.xyz/hexo-adds-a-domain-name.html","excerpt":"文章描述","text":"文章描述 Hexo pure改造计划——后期添加域名 购买域名 我的域名为19999997.xyz 获取github pages IP地址 我的pages域名为abobot.github.io 打开cmd ping abobot.github.io 获得IP地址185.199.108.153 新建CNAME文件 在./source文件夹下新建CNAME文件，内容为你的域名 执行hexo的一键三连 123hexo cleanhexo ghexo s 添加DNS解析 我是在腾讯云买的域名，其他地方的不知道 登录DNSPOD 点击侧边栏DNS解析→我的域名 点击域名19999997.xyz 添加记录：主机记录www；记录值pages的公网ip 选择开启 现在就可以访问你自己的域名了 更改配置文件 站点配置文件 改url: http://abobot.github.io为url: http://1999997.xyz 主题配置文件 改Blog: http://abobot.github.io为Blog: http://1999997.xyz （直接在这两个配置文件中搜索.github.io就行，然后选择性更改） 更改leancloud评论环境变量 进入云引擎→设置 改SITE_URL变量值为http://1999997.xyz 在相同界面绑定你自己的域名 重新部署 更改说说相关 更改腾讯云WEB安全域名 添加百度谷歌收录 安装插件 1npm install hexo-baidu-url-submit --save 具体步骤见Hexo插件之百度主动提交链接 参考链接添加搜索引擎收录","categories":[{"name":"改造","slug":"change","permalink":"http://19999997.xyz/categories/change/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://19999997.xyz/tags/Hexo/"},{"name":"pure","slug":"pure","permalink":"http://19999997.xyz/tags/pure/"},{"name":"改造","slug":"change","permalink":"http://19999997.xyz/tags/change/"}]},{"title":"Hexo-pure改造计划——添加标签云","slug":"Hexo-pure改造计划——添加标签云","date":"2021-09-28T16:04:13.000Z","updated":"2023-09-27T13:35:56.754Z","comments":true,"path":"/hexo-adds-tagcloud.html","link":"","permalink":"http://19999997.xyz/hexo-adds-tagcloud.html","excerpt":"","text":"Hexo pure改造计划——添加标签云 安装插件 1npm install hexo-tag-cloud --save 配置插件 将./themes/pure/layout/_widget/tagcloud.ejs修改为 123456789101112&lt;% if (site.tags.length) &#123; %&gt; &lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;/js/tagcloud.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;/js/tagcanvas.js&quot;&gt;&lt;/script&gt; &lt;div class=&quot;widget-wrap&quot;&gt; &lt;h3 class=&quot;widget-title&quot;&gt;&lt;%= __(&#x27;widget.tagcloud&#x27;) %&gt;&lt;/h3&gt; &lt;div id=&quot;myCanvasContainer&quot; class=&quot;widget tagcloud&quot;&gt; &lt;canvas width=&quot;250&quot; height=&quot;250&quot; id=&quot;resCanvas&quot; style=&quot;width=100%&quot;&gt; &lt;%- tagcloud() %&gt; &lt;/canvas&gt; &lt;/div&gt; &lt;/div&gt;&lt;% &#125; %&gt; 站点配置 在_config.yml最后添加： 1234567# hexo-tag-cloudtag_cloud: textFont: Trebuchet MS, Helvetica textColor: &#x27;#333&#x27; textHeight: 25 outlineColor: &#x27;#E2E1D1&#x27; maxSpeed: 0.1 更新 20230918 在站点配置中添加是否启用标签选项 站点配置 在_config.yml最后添加： 12345678tag_cloud: enable: true textFont: Trebuchet MS, Helvetica textColor: &#x27;#333&#x27; textHeight: 25 outlineColor: &#x27;#E2E1D1&#x27; maxSpeed: 0.1 pauseOnSelected: false # true 意味着当选中对应 tag 时,停止转动 配置插件 将./themes/pure/layout/_widget/tagcloud.ejs修改为 123456789101112&lt;% if (site.tags.length &amp;&amp; config.tag_cloud.enable) &#123; %&gt; &lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;/js/tagcloud.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;/js/tagcanvas.js&quot;&gt;&lt;/script&gt; &lt;div class=&quot;widget-wrap&quot;&gt; &lt;h3 class=&quot;widget-title&quot;&gt;&lt;%= __(&#x27;widget.tagcloud&#x27;) %&gt;&lt;/h3&gt; &lt;div id=&quot;myCanvasContainer&quot; class=&quot;widget tagcloud&quot;&gt; &lt;canvas width=&quot;250&quot; height=&quot;250&quot; id=&quot;resCanvas&quot; style=&quot;width=100%&quot;&gt; &lt;%- tagcloud() %&gt; &lt;/canvas&gt; &lt;/div&gt; &lt;/div&gt;&lt;% &#125; %&gt;","categories":[{"name":"改造","slug":"change","permalink":"http://19999997.xyz/categories/change/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://19999997.xyz/tags/Hexo/"},{"name":"pure","slug":"pure","permalink":"http://19999997.xyz/tags/pure/"},{"name":"改造","slug":"change","permalink":"http://19999997.xyz/tags/change/"}]},{"title":"Docker安装Adguard","slug":"Docker安装Adguard","date":"2021-09-27T09:31:32.000Z","updated":"2023-09-27T13:33:16.358Z","comments":true,"path":"/docker-installs-adguard.html","link":"","permalink":"http://19999997.xyz/docker-installs-adguard.html","excerpt":"文章描述","text":"文章描述 Docker安装Adguard服务器 安装镜像 1docker pull adguard/adguardhome 创建并运行容器 1docker run --name adguardhome --restart unless-stopped -v /my/own/workdir:/opt/adguardhome/work -v /my/own/confdir:/opt/adguardhome/conf -p 53:53/tcp -p 53:53/udp -p 67:67/udp -p 68:68/udp -p 80:80/tcp -p 443:443/tcp -p 443:443/udp -p 3000:3000/tcp -p 853:853/tcp -p 784:784/udp -p 853:853/udp -p 8853:8853/udp -p 5443:5443/tcp -p 5443:5443/udp -d adguard/adguardhome 进入后台配置 后台地址 按照图片设置端口 按照提示设置 设置DNS 输入 12345119.29.29.29223.5.5.5117.50.10.10101.226.4.6123.125.81.6 应用 设置封锁清单 添加阻止列表 添加自定义列表 anti-ad-easylist https://anti-ad.net/easylist.txt 如图 检查更新 更多封锁列表 设备设置方法 手机设置服务器本机的ip地址 参考链接 Mac搭建DNS服务器，电脑手机iOS去广告，AdGuardHome本地搭建教程 AdGuard Home - Docker [AdGuard Home - Docker wiki](AdGuard Home - Docker)","categories":[{"name":"docker","slug":"docker","permalink":"http://19999997.xyz/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://19999997.xyz/tags/docker/"},{"name":"adguard","slug":"adguard","permalink":"http://19999997.xyz/tags/adguard/"}]},{"title":"Hexo-pure改造计划——图片懒加载","slug":"Hexo-pure改造计划——图片懒加载","date":"2021-09-27T09:28:43.000Z","updated":"2023-09-27T13:40:36.519Z","comments":true,"path":"/hexo-adds-images-lzayloading.html","link":"","permalink":"http://19999997.xyz/hexo-adds-images-lzayloading.html","excerpt":"图片懒加载","text":"图片懒加载 图片懒加载 参考链接：Hexo-lazyload-image图片懒加载 安装插件 1npm install hexo-lazyload-image --save 修改站点配置文件_config.yml文件 1234lazyload: enable: true onlypost: false loadingImg: # eg. ./images/loading.png PS：这个路径没改成","categories":[{"name":"改造","slug":"change","permalink":"http://19999997.xyz/categories/change/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://19999997.xyz/tags/Hexo/"},{"name":"pure","slug":"pure","permalink":"http://19999997.xyz/tags/pure/"},{"name":"改造","slug":"change","permalink":"http://19999997.xyz/tags/change/"}]},{"title":"Hexo-pure改造计划——添加加载动画","slug":"Hexo-pure改造计划——添加加载动画","date":"2021-09-27T09:25:39.000Z","updated":"2023-09-27T13:37:47.519Z","comments":true,"path":"/hexo-adds-loading-animation.html","link":"","permalink":"http://19999997.xyz/hexo-adds-loading-animation.html","excerpt":"添加加载动画","text":"添加加载动画 添加加载动画 方法一 在./theme/pure/layout/head.ejs中添加 1&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/gh/HCLonely/images@master/others/loading.min.css&quot;&gt; 在./theme/pure/layout/layout.ejs的&lt;body&gt;标签前添加： 12345678910111213&lt;div id=&quot;loading-box&quot;&gt; &lt;div class=&quot;loading-left-bg&quot;&gt;&lt;/div&gt; &lt;div class=&quot;loading-right-bg&quot;&gt;&lt;/div&gt; &lt;div class=&quot;spinner-box&quot;&gt; &lt;div class=&quot;configure-border-1&quot;&gt; &lt;div class=&quot;configure-core&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;configure-border-2&quot;&gt; &lt;div class=&quot;configure-core&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;loading-word&quot;&gt;加载中...&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 在./theme/pure/layout/layout.ejs的&lt;/body&gt;标签前添加： 1234567&lt;script&gt; var endLoading = function () &#123; document.body.style.overflow = &#x27;auto&#x27;; document.getElementById(&#x27;loading-box&#x27;).classList.add(&quot;loaded&quot;); &#125; window.addEventListener(&#x27;load&#x27;,endLoading);&lt;/script&gt; 参考链接 ​ 1.hexo 博客美化 方法二 在./theme/pure/_config.yml中添加配置 123preloader: enable: true layout: gear # gear, spinner-box 两种样式 在./themes/pure/layout/_script中新建loaded.ejs文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;% if (theme.preloader.enable) &#123; %&gt;&lt;div id=&#x27;loader&#x27;&gt; &lt;% if(theme.preloader.layout == &#x27;gear&#x27; ) &#123;%&gt; &lt;div class=&quot;outer_box&quot;&gt; &lt;div class=&#x27;loader_overlay&#x27;&gt;&lt;/div&gt; &lt;div class=&#x27;loader_cogs&#x27;&gt; &lt;div class=&#x27;loader_cogs__top&#x27;&gt; &lt;div class=&#x27;top_part&#x27;&gt;&lt;/div&gt; &lt;div class=&#x27;top_part&#x27;&gt;&lt;/div&gt; &lt;div class=&#x27;top_part&#x27;&gt;&lt;/div&gt; &lt;div class=&#x27;top_hole&#x27;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&#x27;loader_cogs__left&#x27;&gt; &lt;div class=&#x27;left_part&#x27;&gt;&lt;/div&gt; &lt;div class=&#x27;left_part&#x27;&gt;&lt;/div&gt; &lt;div class=&#x27;left_part&#x27;&gt;&lt;/div&gt; &lt;div class=&#x27;left_hole&#x27;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&#x27;loader_cogs__bottom&#x27;&gt; &lt;div class=&#x27;bottom_part&#x27;&gt;&lt;/div&gt; &lt;div class=&#x27;bottom_part&#x27;&gt;&lt;/div&gt; &lt;div class=&#x27;bottom_part&#x27;&gt;&lt;/div&gt; &lt;div class=&#x27;bottom_hole&#x27;&gt;&lt;/div&gt; &lt;/div&gt; &lt;p style=&quot;text-align:center&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;loading...&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;% &#125; else if(theme.preloader.layout == &#x27;spinner-box&#x27;) &#123; %&gt; &lt;div class=&quot;loading-left-bg&quot;&gt;&lt;/div&gt; &lt;div class=&quot;loading-right-bg&quot;&gt;&lt;/div&gt; &lt;div class=&quot;spinner-box&quot;&gt; &lt;div class=&quot;configure-border-1&quot;&gt; &lt;div class=&quot;configure-core&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;configure-border-2&quot;&gt; &lt;div class=&quot;configure-core&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;loading-word&quot;&gt;加载中...&lt;/div&gt; &lt;/div&gt; &lt;% &#125; %&gt;&lt;/div&gt;&lt;script&gt; var endLoading = function () &#123; document.body.style.overflow = &#x27;auto&#x27;; document.getElementById(&#x27;loader&#x27;).classList.add(&quot;loading&quot;); &#125; window.addEventListener(&#x27;load&#x27;,endLoading);&lt;/script&gt;&lt;% &#125; %&gt; 在./theme/pure/layout/_comment/head.ejs中添加样式 spinner-box风格样式 1&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/gh/zyoushuo/Blog@latest/hexo/css/loading_style_1.css&quot; &gt; gear风格样式 &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/gh/zyoushuo/Blog@latest/hexo/css/loading_style_2.css&quot; &gt; 123454. 在`blog\\themes\\pure\\layout\\layout.ejs`的`&lt;body&gt;`标签下引入创建文件的地址：```ejs&lt;%- partial(&#x27;_s/loaded&#x27;) %&gt; 参考链接： ​ 2.hexo中添加预加载动画 ​ 3.hexo中添加预加载动画","categories":[{"name":"改造","slug":"change","permalink":"http://19999997.xyz/categories/change/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://19999997.xyz/tags/Hexo/"},{"name":"pure","slug":"pure","permalink":"http://19999997.xyz/tags/pure/"},{"name":"改造","slug":"change","permalink":"http://19999997.xyz/tags/change/"}]},{"title":"备份hexo本地配置文件至github私有仓库","slug":"备份hexo本地配置文件至github私有仓库","date":"2021-09-27T09:18:34.000Z","updated":"2023-09-27T13:31:22.470Z","comments":true,"path":"/backup-to-github.html","link":"","permalink":"http://19999997.xyz/backup-to-github.html","excerpt":"本地文件git","text":"本地文件git Hexo 项目同步方案 一、本地操作 利用Git解决hexo博客多PC间同步问题 Hexo 多终端同步方案 删除主题目录下的.git 建立本地仓 git init 编辑.gitignore文件 1.DS_StoreThumbs.dbdb.json*.lognode_modules/public/.deploy*/ .deploy_git是hexo默认的.git配置文件夹，不需要同步 public内文件是根据source文件夹内容自动生成，不需要备份，不然每次改动内容太多 二、本地仓连接到私有仓 1234567git remote add origin git@github.com:abobot/hexo-blog.gitgit add .git commit -m &quot;my first blog-private&quot;git push -u origin main 三、Hexo 拉取hexo clone 1git clone git@github.com:abobot/blog-private.git [file name] 部署hexo 管理员权限打开cmd: npm install 下载pakege.json中hexo必备资源包信息 同步到私有仓 1234git statusgit add .git commit -m &quot;log&quot;git push xxx Hexo 仓库更新 1git fetch --all","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://19999997.xyz/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://19999997.xyz/tags/Hexo/"},{"name":"github","slug":"github","permalink":"http://19999997.xyz/tags/github/"}]},{"title":"Hexo-pure改造计划——添加说说页面","slug":"Hexo-pure改造计划——添加说说页面","date":"2021-09-25T07:57:00.000Z","updated":"2023-09-27T13:38:59.478Z","comments":true,"path":"/hexo-adds-shuoshuo-page.html","link":"","permalink":"http://19999997.xyz/hexo-adds-shuoshuo-page.html","excerpt":"hexo pure 主题添加动态说说","text":"hexo pure 主题添加动态说说 添加说说页面 文件（夹）操作 按照这个，添加「相册」页面 给你的Hexo博客添加说说页面 哔哔点啥」微信公众号 2.0 在./theme/pure/shuoshuo/文件夹下添加index.md文件，将下面代码复制过去，更改云函数环境id 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132---title: 说点啥type: shuoshuotoc: falsenoDate: &#x27;true&#x27;comments: &#x27;false&#x27;---&lt;div class=&quot;content&quot;&gt; &lt;div class=&quot;post&quot;&gt; &lt;h2 class=&quot;post-title&quot;&gt;说说&lt;/h2&gt; &lt;div class=&quot;post-content&quot;&gt; &lt;div class=&quot;search-box&quot;&gt; &lt;input type=&quot;text&quot; id=&quot;searchBoxInput&quot; placeholder=&quot;搜搜以前说了啥&quot;&gt; &lt;/div&gt; &lt;style&gt; .timeline ul &#123; margin:0; background-color: #fff;/*背景颜色 */ padding: 10px; min-height: 200px; &#125; .timeline ul li &#123; background:#08f0f8;/*线条*/ list-style-type:none; position:relative; width:3px; margin-left:2em; padding:0.8em 0 2em; &#125; .timeline ul li::after &#123; transform: rotate(45deg); content:&#x27;&#x27;; background-color:#92b3b9;/*棱块*/ display: block; position: absolute; top: 10px; left: -5px; width: 0.8em; height:0.8em; outline: 15px solid #fff; &#125; .timeline ul li div &#123; position:relative; /* background-color: red;整个一条 */ top:-13px; left:3em; width:670px; padding:0px 16px 0px; &#125; .timeline ul li p.datatime&#123; color: #fafafa; font-size: 0.75em; font-style:italic; background-color: #3b3d42;/*时间的背景颜色*/ display: inline-block; padding:0.25em 1em 0.2em 1em; &#125; .timeline ul li p.datacont&#123; white-space: pre-wrap; margin:0.65em 0 0.3em; /* background-color: red;说说的背景颜色 */ &#125; .timeline ul li p.datacont img&#123; display:block; max-height:340px!important; /* background-color: red;图片边框颜色 */ &#125; .timeline ul li p.datacont img[src*=&quot;emotion&quot;] &#123; display:inline-block; width:auto; background-color: red; &#125; .timeline ul li p.datafrom&#123; color: #aaa; font-size: 0.75em !important; font-style:italic; /* background-color: red;发送人的背景颜色 */ &#125; .timeline ul li p &#123; margin:0; font-size:16px; letter-spacing:1px; color:#3b3d42; /* background-color: red;内容和发送人都红了 */ &#125; button&#123; width: auto; border-radius: 5%; background-color: #d4e3e4; &#125; .dark-theme .timeline ul li div p&#123; color:#fafafa; /* background-color: red;没反应 */ &#125; .dark-theme .timeline ul li div p svg&#123; fill:#fafafa; &#125; .dark-theme .timeline ul li p.datafrom&#123; color: #aaa; &#125; .dark-theme .timeline ul li&#123; background:#3b3d42; &#125; .dark-theme .timeline ul li::after&#123; outline: 15px solid #292a2d; &#125; @media(max-width:860px) &#123; .timeline ul li&#123;margin-left:0;&#125; .timeline ul li div&#123;width:calc(100vw- 75px);left:30px;&#125; &#125; &lt;/style&gt; &lt;div id=&quot;bber&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;https://imgcache.qq.com/qcloud/cloudbase-js-sdk/1.4.0/cloudbase.full.js&quot;&gt; &lt;/script&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/gh/buddys/qq-wechat-emotion-parser@master/dist/qq-wechat-emotion-parser.min.js&quot;&gt; &lt;/script&gt; &lt;script&gt; const app = cloudbase.init(&#123; env: &quot;函数的环境id&quot;, &#125;) &lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.jsdelivr.net/gh/lmm214/bber@0.0.6/bber.js&quot;&gt; &lt;/script&gt;&lt;/div&gt; 更改函数的环境id为你自己函数的环境id","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://19999997.xyz/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://19999997.xyz/tags/Hexo/"},{"name":"改造","slug":"change","permalink":"http://19999997.xyz/tags/change/"}]},{"title":"Hexo-pure改造计划","slug":"Hexo-pure改造计划","date":"2021-09-24T15:00:00.000Z","updated":"2023-10-01T03:13:34.991Z","comments":true,"path":"/hexo-optimizations.html","link":"","permalink":"http://19999997.xyz/hexo-optimizations.html","excerpt":"Hexo-pure改造计划汇总","text":"Hexo-pure改造计划汇总 跟着大佬改Hexo-pure博客网站 Hexo博客搭建(1)——建站及部署 1.Hexo博客搭建(1)——建站及部署 Hexo博客搭建(2)——主题配置 1.Hexo博客搭建(2)——主题配置 Hexo博客搭建(3)——优化评论系统 1.Hexo博客搭建(3)——优化评论系统 Hexo博客搭建(4)——常见问题 1.Hexo博客搭建(4)——常见问题 为代码块增加复制按钮 1.为代码块增加复制按钮 Hexo-pure改造计划——添加代码块复制按钮 友链添加 1.友链添加 123456789Name: link: http://example.com avatar: http://example.com/avatar.png desc: &quot;这是一个描述&quot;阿波bot: link: http://abobot.github.io avatar: http://abobot.github.com/images/avatar.jpg desc: &quot;这是一个描述&quot; 说说建立 1.静态说说建立 2.哔哔点啥 评论相关 一些垃圾评论把页面都改了[吐血] 添加AKISMET_KEY(看看效果) Valine 评论之 Valine-admin 配置攻略 书单相关 20230920更新 由于豆瓣API用不了，参考hexo-douban中的接口更改了\\themes\\pure\\layout\\_script\\douban.ejs中的部分代码，原始文件更名为\\themes\\pure\\layout\\_script\\douban.ejs.v0 插入博客其他文章 20230921更新 在引入位置插入&#123;* post_link filename *&#125; 标签插件（Tag Plugins） | Hexo 添加可折叠内容 20230921更新 Hexo-pure改造计划——添加代码块复制按钮 Hexo-pure改造计划——添加utterances评论支持","categories":[{"name":"改造","slug":"change","permalink":"http://19999997.xyz/categories/change/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://19999997.xyz/tags/Hexo/"},{"name":"pure","slug":"pure","permalink":"http://19999997.xyz/tags/pure/"},{"name":"改造","slug":"change","permalink":"http://19999997.xyz/tags/change/"}]},{"title":"hello-world","slug":"hello-world","date":"2021-09-24T12:34:57.000Z","updated":"2023-09-27T13:34:09.860Z","comments":true,"path":"/hello-world.html","link":"","permalink":"http://19999997.xyz/hello-world.html","excerpt":"Hexo首页","text":"Hexo首页 Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1hexo new &quot;My New Post&quot; More info: Writing Run server 1hexo server More info: Server Generate static files 1hexo generate More info: Generating Deploy to remote sites 1hexo deploy More info: Deployment","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://19999997.xyz/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://19999997.xyz/tags/Hexo/"}]},{"title":"本地网站hexo与github pages不一致","slug":"different between hexo and github-pages","date":"2021-09-22T16:15:24.000Z","updated":"2023-09-27T13:32:46.101Z","comments":true,"path":"/different-between-local-hexo-and-github-pages.html","link":"","permalink":"http://19999997.xyz/different-between-local-hexo-and-github-pages.html","excerpt":"","text":"hexo与github pages不一致 一、本地hexo情况 二、github pages情况 三、分析 使用指令hexo s -s只生成静态文件发现本地网站变得与github pages上一致 使用指令 123hexo cleanhexo ghexo d 重新部署之后github pages显示正常 四、others教程 gitee设为图床教程 Picgo图床客户端 livere评论 gitment + gitalk搞了半天，各种错误，放弃了","categories":[{"name":"记录","slug":"record","permalink":"http://19999997.xyz/categories/record/"}],"tags":[{"name":"记录","slug":"record","permalink":"http://19999997.xyz/tags/record/"},{"name":"github","slug":"github","permalink":"http://19999997.xyz/tags/github/"}]},{"title":"Docker安装Typecho","slug":"Docker安装Typecho","date":"2021-09-22T11:18:11.000Z","updated":"2023-09-27T13:33:42.219Z","comments":true,"path":"/docker-installs-typecho.html","link":"","permalink":"http://19999997.xyz/docker-installs-typecho.html","excerpt":"文章描述测试","text":"文章描述测试 Docker安装Typecho 安装镜像 1docker pull 80x86/typecho 实例化 1docker run -d --name=typecho-blog --restart always -e PHP_TZ=Asia/Shanghai -e PHP_MAX_EXECUTION_TIME=600 -p 8081:80 80x86/typecho:latest 8081:80将本地的8081端口映射到容器的80端口 查看ip信息 1docker inspect xx xx为实例id前两位 ip:172.17.0.4 安装nginx 1docker pull nginx 安装mysql 1docker pull mysqlbash 1docker run --name mysql-test -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:latest 在shell中访问mysql 1docker exec -it mysql-test bash 在shell中输入 1mysql -uroot -p -h localhost 密码123456 出现mysql后输入 1create database typecho 教程 教程 选择数据库 1use typecho 新建用户 1create user &#x27;root&#x27;@&#x27;localhost&#x27; identified by &#x27;123456&#x27;; 上面代码没有作用 1create user &#x27;typecho&#x27;@&#x27;%&#x27; identified by &#x27;@typecho&#x27; 设置权限 1grant select,insert,update,delete,create on typecho.* to typecho; 刷新权限 1flush privileges","categories":[{"name":"docker","slug":"docker","permalink":"http://19999997.xyz/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://19999997.xyz/tags/docker/"},{"name":"typecho","slug":"typecho","permalink":"http://19999997.xyz/tags/typecho/"}]}],"categories":[{"name":"3D","slug":"3D","permalink":"http://19999997.xyz/categories/3D/"},{"name":"English","slug":"English","permalink":"http://19999997.xyz/categories/English/"},{"name":"markdown","slug":"markdown","permalink":"http://19999997.xyz/categories/markdown/"},{"name":"guides","slug":"guides","permalink":"http://19999997.xyz/categories/guides/"},{"name":"guide","slug":"guide","permalink":"http://19999997.xyz/categories/guide/"},{"name":"Hexo","slug":"Hexo","permalink":"http://19999997.xyz/categories/Hexo/"},{"name":"hexo","slug":"hexo","permalink":"http://19999997.xyz/categories/hexo/"},{"name":"改造","slug":"change","permalink":"http://19999997.xyz/categories/change/"},{"name":"video","slug":"video","permalink":"http://19999997.xyz/categories/video/"},{"name":"docker","slug":"docker","permalink":"http://19999997.xyz/categories/docker/"},{"name":"记录","slug":"record","permalink":"http://19999997.xyz/categories/record/"}],"tags":[{"name":"3D","slug":"3D","permalink":"http://19999997.xyz/tags/3D/"},{"name":"video","slug":"video","permalink":"http://19999997.xyz/tags/video/"},{"name":"English","slug":"English","permalink":"http://19999997.xyz/tags/English/"},{"name":"dictation","slug":"dictation","permalink":"http://19999997.xyz/tags/dictation/"},{"name":"plugins","slug":"plugins","permalink":"http://19999997.xyz/tags/plugins/"},{"name":"markdown","slug":"markdown","permalink":"http://19999997.xyz/tags/markdown/"},{"name":"guides","slug":"guides","permalink":"http://19999997.xyz/tags/guides/"},{"name":"plugin","slug":"plugin","permalink":"http://19999997.xyz/tags/plugin/"},{"name":"hexo","slug":"hexo","permalink":"http://19999997.xyz/tags/hexo/"},{"name":"purabo","slug":"purabo","permalink":"http://19999997.xyz/tags/purabo/"},{"name":"guide","slug":"guide","permalink":"http://19999997.xyz/tags/guide/"},{"name":"test","slug":"test","permalink":"http://19999997.xyz/tags/test/"},{"name":"Hexo","slug":"Hexo","permalink":"http://19999997.xyz/tags/Hexo/"},{"name":"改造","slug":"change","permalink":"http://19999997.xyz/tags/change/"},{"name":"dplayer","slug":"dplayer","permalink":"http://19999997.xyz/tags/dplayer/"},{"name":"bilibili","slug":"bilibili","permalink":"http://19999997.xyz/tags/bilibili/"},{"name":"pure","slug":"pure","permalink":"http://19999997.xyz/tags/pure/"},{"name":"docker","slug":"docker","permalink":"http://19999997.xyz/tags/docker/"},{"name":"adguard","slug":"adguard","permalink":"http://19999997.xyz/tags/adguard/"},{"name":"github","slug":"github","permalink":"http://19999997.xyz/tags/github/"},{"name":"记录","slug":"record","permalink":"http://19999997.xyz/tags/record/"},{"name":"typecho","slug":"typecho","permalink":"http://19999997.xyz/tags/typecho/"}]}